
# ========================================
# SCHEMA SYSTEM
# ========================================

# Error types for schema validation
variant DecodeError = 
  TypeMismatch String String  # expected_type actual_type
  | MissingField String          # field_name
  | InvalidValue String          # reason
  | NestedError String DecodeError;  # field_name nested_error

variant EncodeError = 
  UnsupportedType String       # type_name
  | SerializationError String;   # reason

# Schema type for validation
type Schema a = Unknown -> Result a DecodeError;

# Primitive schema functions
string_schema = isString |> map_err (fn e => TypeMismatch "String" "Unknown");

float_schema = isNumber |> map_err (fn e => TypeMismatch "Float" "Unknown");

bool_schema = isBool |> map_err (fn e => TypeMismatch "Bool" "Unknown");

# Schema combinators
list_schema = fn element_schema data => 
  match (isList data) (
    Ok list => (
      validated_elements = list_map element_schema list;
      first_error = list_find is_err validated_elements;
      match first_error (
        Some (Err error) => Err (NestedError "list_element" error);
        None => Ok (list_map (fn x => match x (Ok v => v; Err _ => {})) validated_elements)
      )
    );
    Err _ => Err (TypeMismatch "List" "Unknown")
  ) : (Unknown -> Result a DecodeError) -> Unknown -> Result (List a) DecodeError;

# union_schema = fn schemas => fn data => (
#   # Try each schema until one succeeds
#   try_schemas = fn remaining_schemas => match remaining_schemas (
#     [] => Err (InvalidValue "No matching schema found");
#     [schema, ...rest] => (
#       result = schema data;
#       match result (
#         Ok value => Ok value;
#         Err _ => try_schemas rest
#       )
#     )
#   );
#   try_schemas schemas
# );

# literal_schema = fn expected_value => fn data => 
#   if data == expected_value then (
#     Ok data
#   ) else (
#     Err (InvalidValue (concat "Expected literal " (show expected_value)))
#   );

# enum_schema = fn values => fn data => 
#   if (any (fn v => v == data) values) then (
#     Ok data
#   ) else (
#     Err (InvalidValue (concat "Expected one of " (show values)))
#   );

# refine_schema = fn schema predicate message => fn data => (
#   validated = schema data;
#   match validated (
#     Ok value => (
#       if (predicate value) then (
#         Ok value
#       ) else (
#         Err (InvalidValue message)
#       )
#     );
#     Err error => Err error
#   )
# );

# map_schema = fn schema mapper => fn data => (
#   validated = schema data;
#   match validated (
#     Ok value => Ok (mapper value);
#     Err error => Err error
#   )
# );

# # Main decode function, this will be moved to built-ins and be responsible for !ffi erasure
decode = fn schema data => schema data;

list_schema string_schema (forget ["test", "test2"]);

# # Guard function that returns Option instead of Result
# guard = fn schema data => 
#   match (schema data) (
#     Ok value => Some value;
#     Err _ => None
#   );

# # Helper functions for schema construction
# create_list = fn values => values;  # Placeholder - should create proper List value
# create_tuple = fn values => values;  # Placeholder - should create proper Tuple value
# create_record = fn fields => fields;  # Placeholder - should create proper Record value

# # Record utilities implemented using existing functions
# has_field = fn name record => hasKey record name;

# get_field = fn name record => 
#   if (has_field name record) then (
#     # For now, return Unit - proper record access would need more complex implementation
#     Unit
#   ) else (
#     Unit
#   );

# keys = fn record => 
#   # For now, return empty list - proper key extraction would need more complex implementation
#   [];
