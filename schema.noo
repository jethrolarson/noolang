
# ========================================
# SCHEMA SYSTEM
# ========================================

# Error types for schema validation
variant DecodeError = 
  TypeMismatch String String  # expected_type actual_type
  | MissingField String          # field_name
  | InvalidValue String          # reason
  | NestedError String DecodeError;  # field_name nested_error

variant EncodeError = 
  UnsupportedType String       # type_name
  | SerializationError String;   # reason

# Schema type for validation
type Schema a = Unknown -> Result a DecodeError;

# Primitive schema functions
string_schema = fn data => 
  map_err (fn e => NestedError "string" e) (isString data);

float_schema = isNumber |> map_err (fn e => NestedError "float" e);

bool_schema = isBool |> map_err (fn e => NestedError "bool" e);

unit_schema = isUnit |> map_err (fn e => NestedError "unit" e);


# Schema combinators
list_schema = fn element_schema data => 
  match isList data with (
    Ok list => (
      validated_elements = list_map element_schema list;
      first_error = list_find is_err validated_elements;
      match first_error with (
        Some (Err error) => Err (NestedError "list_element" error);
        None => Ok (list_map (fn x => match x with (Ok v => v; Err _ => {})) validated_elements)
      )
    );
    Err _ => Err (TypeMismatch "List" "Unknown")
  ) # : (Unknown -> Result a DecodeError) -> Unknown -> Result (List a) DecodeError;

# tuple_schema = fn schemas => fn data => 
#   match isList data with (
#     Ok list => (
#       if (length list) != (length schemas) then (
#         Err (InvalidValue (concat "Expected " (concat (toString (length schemas)) " elements, got " (toString (length list)))))
#       ) else (
#         # Zip schemas with values and validate
#         zipped = zip schemas list;
#         validated = list_map (fn pair => match pair with ({@1 schema, @2 value} => schema value)) zipped;
#         # Check for errors
#         has_errors = any (fn x => match x with (Ok _ => False; Err _ => True)) validated;
#         if has_errors then (
#           # Find first error
#           first_error = find (fn x => match x with (Ok _ => False; Err _ => True)) validated;
#           match first_error with (
#             Some (Err error) => Err (NestedError "tuple_element" error);
#             _ => Err (InvalidValue "Tuple validation failed")
#           )
#         ) else (
#           # Extract validated values
#           values = list_map (fn x => match x with (Ok v => v; Err _ => Unit)) validated;
#           Ok (create_tuple values)
#         )
#       )
#     );
#     Err _ => Err (TypeMismatch "Tuple" "Unknown")
#   );

# record_schema = fn field_schemas => fn data => 
#   match data with (
#     Record fields => (
#       # Validate each field
#       field_names = keys field_schemas;
#       missing_fields = filter (fn name => not (has_field name fields)) field_names;
#       if (length missing_fields) > 0 then (
#         Err (MissingField (head missing_fields))
#       ) else (
#         # Validate each field value
#         validation_results = list_map (fn name => (
#           field_value = get_field name fields;
#           schema = get_field name field_schemas;
#           result = schema field_value;
#           match result with (
#             Ok value => Ok { @name name, @value value };
#             Err error => Err (NestedError name error)
#           )
#         )) field_names;
#         # Check for errors
#         has_errors = any (fn x => match x with (Ok _ => False; Err _ => True)) validation_results;
#         if has_errors then (
#           # Find first error
#           first_error = find (fn x => match x with (Ok _ => False; Err _ => True)) validation_results;
#           match first_error with (
#             Some (Err error) => Err error;
#             _ => Err (InvalidValue "Record validation failed")
#           )
#         ) else (
#           # Build validated record
#           validated_fields = list_map (fn x => match x with (Ok field => field; Err _ => { @name "", @value Unit })) validation_results;
#           record_fields = reduce (fn acc field => set_field field.name field.value acc) (create_record []) validated_fields;
#           Ok record_fields
#         )
#       )
#     );
#     _ => Err (TypeMismatch "Record" "Unknown")
#   );

# union_schema = fn schemas => fn data => (
#   # Try each schema until one succeeds
#   try_schemas = fn remaining_schemas => match remaining_schemas with (
#     [] => Err (InvalidValue "No matching schema found");
#     [schema, ...rest] => (
#       result = schema data;
#       match result with (
#         Ok value => Ok value;
#         Err _ => try_schemas rest
#       )
#     )
#   );
#   try_schemas schemas
# );

# literal_schema = fn expected_value => fn data => 
#   if data == expected_value then (
#     Ok data
#   ) else (
#     Err (InvalidValue (concat "Expected literal " (show expected_value)))
#   );

# enum_schema = fn values => fn data => 
#   if (any (fn v => v == data) values) then (
#     Ok data
#   ) else (
#     Err (InvalidValue (concat "Expected one of " (show values)))
#   );

# refine_schema = fn schema predicate message => fn data => (
#   validated = schema data;
#   match validated with (
#     Ok value => (
#       if (predicate value) then (
#         Ok value
#       ) else (
#         Err (InvalidValue message)
#       )
#     );
#     Err error => Err error
#   )
# );

# map_schema = fn schema mapper => fn data => (
#   validated = schema data;
#   match validated with (
#     Ok value => Ok (mapper value);
#     Err error => Err error
#   )
# );

# # Main decode function, this will be moved to built-ins and be responsible for !ffi erasure
decode = fn schema data => schema data;
string_schema
#list_schema string_schema (forget ["test", "test2"]);

# # Guard function that returns Option instead of Result
# guard = fn schema data => 
#   match (schema data) with (
#     Ok value => Some value;
#     Err _ => None
#   );

# # Helper functions for schema construction
# create_list = fn values => values;  # Placeholder - should create proper List value
# create_tuple = fn values => values;  # Placeholder - should create proper Tuple value
# create_record = fn fields => fields;  # Placeholder - should create proper Record value

# # Record utilities implemented using existing functions
# has_field = fn name record => hasKey record name;

# get_field = fn name record => 
#   if (has_field name record) then (
#     # For now, return Unit - proper record access would need more complex implementation
#     Unit
#   ) else (
#     Unit
#   );

# set_field = fn name value record => 
#   # For now, return the record unchanged - proper mutation would need more complex implementation
#   record;

# keys = fn record => 
#   # For now, return empty list - proper key extraction would need more complex implementation
#   [];

# # List utilities implemented using existing functions
# any = fn predicate list => 
#   reduce (fn acc x => 
#     if acc then True else (
#       result = predicate x;
#       if (isBool result) then result else False
#     )
#   ) False list;

# find = fn predicate list => 
#   reduce (fn acc x => 
#     if acc == None then (
#       result = predicate x;
#       if (isBool result) and result then Some x else None
#     ) else (
#       acc
#     )
#   ) None list;

# zip = fn list1 list2 => 
#   # This is more complex - would need to track indices
#   # For now, return empty list as placeholder
#   [];
