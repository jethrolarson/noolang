# Larger performance test with many ADT definitions and functions

# Define multiple ADTs
type Color = Red | Green | Blue | Yellow | Purple | Orange;
type Shape a = Circle a | Rectangle a a | Triangle a a a | Square a | Pentagon a | Hexagon a;
type Point a = Point a a;
type Vector a = Vector a a a;
type Direction = North | South | East | West | NorthEast | NorthWest | SouthEast | SouthWest;
type Result a b = Ok a | Error b;
type Option a = Some a | None;
type Tree a = Leaf a | Branch (Tree a) (Tree a);
type Either a b = Left a | Right b;

# Define many simple functions
add = fn x y => x + y;
subtract = fn x y => x - y;
multiply = fn x y => x * y;
divide = fn x y => x / y;
square = fn x => x * x;
cube = fn x => x * x * x;
double = fn x => x + x;
triple = fn x => x + x + x;
increment = fn x => x + 1;
decrement = fn x => x - 1;
negate = fn x => 0 - x;
absolute = fn x => if x < 0 then negate x else x;

# Functions for ADTs
color_to_number = fn color => match color with (
  Red => 1;
  Green => 2;
  Blue => 3;
  Yellow => 4;
  Purple => 5;
  Orange => 6
);

number_to_color = fn n => match n with (
  1 => Red;
  2 => Green;
  3 => Blue;
  4 => Yellow;
  5 => Purple;
  6 => Orange
);

calculate_area = fn shape => match shape with (
  Circle radius => radius * radius * 3;
  Rectangle width height => width * height;
  Triangle a b c => (a * b) / 2;
  Square side => side * side;
  Pentagon side => side * side * 2;
  Hexagon side => side * side * 3
);

calculate_perimeter = fn shape => match shape with (
  Circle radius => radius * 2 * 3;
  Rectangle width height => (width + height) * 2;
  Triangle a b c => a + b + c;
  Square side => side * 4;
  Pentagon side => side * 5;
  Hexagon side => side * 6
);

get_x = fn point => match point with (Point x y => x);
get_y = fn point => match point with (Point x y => y);

distance_squared = fn p1 p2 => 
  (get_x p1 - get_x p2) * (get_x p1 - get_x p2) + (get_y p1 - get_y p2) * (get_y p1 - get_y p2);

# Option functions
is_some = fn opt => match opt with (Some x => 1; None => 0);
is_none = fn opt => match opt with (Some x => 0; None => 1);
unwrap_or = fn default opt => match opt with (Some x => x; None => default);

# Result functions
is_ok = fn result => match result with (Ok x => 1; Error e => 0);
is_error = fn result => match result with (Ok x => 0; Error e => 1);

# Either functions
is_left = fn either => match either with (Left x => 1; Right y => 0);
is_right = fn either => match either with (Left x => 0; Right y => 1);

# Tree functions
tree_depth = fn tree => match tree with (
  Leaf x => 1;
  Branch left right => 1 + (if tree_depth left > tree_depth right then tree_depth left else tree_depth right)
);

tree_count = fn tree => match tree with (
  Leaf x => 1;
  Branch left right => tree_count left + tree_count right
);

# Direction functions
opposite_direction = fn dir => match dir with (
  North => South;
  South => North;
  East => West;
  West => East;
  NorthEast => SouthWest;
  NorthWest => SouthEast;
  SouthEast => NorthWest;
  SouthWest => NorthEast
);

# More complex pattern matching functions
complex_shape_analysis = fn shape => match shape with (
  Circle radius => if radius > 5 then "Large Circle" else "Small Circle";
  Rectangle width height => if width * height > 20 then "Large Rectangle" else "Small Rectangle";
  Triangle a b c => if a + b + c > 10 then "Large Triangle" else "Small Triangle";
  Square side => if side > 4 then "Large Square" else "Small Square";
  Pentagon side => if side > 3 then "Large Pentagon" else "Small Pentagon";
  Hexagon side => if side > 2 then "Large Hexagon" else "Small Hexagon"
);

color_brightness = fn color => match color with (
  Red => 8;
  Green => 6;
  Blue => 4;
  Yellow => 9;
  Purple => 5;
  Orange => 7
);

direction_angle = fn dir => match dir with (
  North => 0;
  South => 180;
  East => 90;
  West => 270;
  NorthEast => 45;
  NorthWest => 315;
  SouthEast => 135;
  SouthWest => 225
);

# Create test data with many values
colors = [Red, Green, Blue, Yellow, Purple, Orange, Red, Green, Blue, Yellow, Purple, Orange];
color_numbers = map color_to_number colors;
color_brightnesses = map color_brightness colors;

shapes = [
  Circle 3, Rectangle 5 4, Triangle 2 3 4, Square 5,
  Pentagon 6, Hexagon 7, Circle 2, Rectangle 3 6,
  Triangle 1 2 3, Square 3, Pentagon 4, Hexagon 5,
  Circle 6, Rectangle 7 8, Triangle 4 5 6, Square 7
];
areas = map calculate_area shapes;
perimeters = map calculate_perimeter shapes;
shape_analyses = map complex_shape_analysis shapes;

points = [
  Point 0 0, Point 1 2, Point 3 4, Point 5 6,
  Point 7 8, Point 9 10, Point 11 12, Point 13 14,
  Point 15 16, Point 17 18, Point 19 20, Point 21 22
];
x_coords = map get_x points;
y_coords = map get_y points;

# Create some trees
tree1 = Branch (Leaf 1) (Leaf 2);
tree2 = Branch tree1 (Leaf 3);
tree3 = Branch tree2 (Branch (Leaf 4) (Leaf 5));
tree4 = Branch tree3 (Branch (Branch (Leaf 6) (Leaf 7)) (Leaf 8));

tree_depths = [tree_depth tree1, tree_depth tree2, tree_depth tree3, tree_depth tree4];
tree_counts = [tree_count tree1, tree_count tree2, tree_count tree3, tree_count tree4];

# Direction testing
directions = [North, South, East, West, NorthEast, NorthWest, SouthEast, SouthWest];
opposite_dirs = map opposite_direction directions;
direction_angles = map direction_angle directions;

# Mathematical operations on collections
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];
squares = map square numbers;
cubes = map cube numbers;
doubled = map double numbers;
tripled = map triple numbers;
incremented = map increment numbers;
decremented = map decrement numbers;
negated = map negate numbers;
absolutes = map absolute numbers;

# Final result with many computed values
{
  @colors color_numbers,
  @color_brightnesses color_brightnesses,
  @areas areas,
  @perimeters perimeters,
  @shape_analyses shape_analyses,
  @x_coords x_coords,
  @y_coords y_coords,
  @tree_depths tree_depths,
  @tree_counts tree_counts,
  @opposite_dirs opposite_dirs,
  @direction_angles direction_angles,
  @squares squares,
  @cubes cubes,
  @doubled doubled,
  @tripled tripled,
  @incremented incremented,
  @decremented decremented,
  @negated negated,
  @absolutes absolutes
}