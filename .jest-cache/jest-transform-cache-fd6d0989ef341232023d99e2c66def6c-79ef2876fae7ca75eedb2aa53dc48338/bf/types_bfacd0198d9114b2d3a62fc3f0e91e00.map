{"version":3,"sources":["/workspace/src/typer/types.ts"],"sourcesContent":["import type { Constraint, Type, Effect } from \"../ast\";\n\n// ADT registry for tracking defined algebraic data types\nexport type ADTRegistry = Map<\n\tstring,\n\t{\n\t\ttypeParams: string[];\n\t\tconstructors: Map<string, Type[]>; // constructor name -> arg types\n\t}\n>;\n\n// Constraint system types for trait support\nexport type ConstraintSignature = {\n\tname: string;\n\ttypeParam: string;\n\tfunctions: Map<string, Type>; // function name -> type signature\n};\n\nexport type ConstraintImplementation = {\n\tfunctions: Map<string, TypeScheme>; // function name -> implementation\n};\n\nexport type ConstraintRegistry = Map<string, {\n\tsignature: ConstraintSignature;\n\timplementations: Map<string, ConstraintImplementation>; // type name -> implementation\n}>;\n\n// Type scheme for let-polymorphism\nexport type TypeScheme = {\n\ttype: Type;\n\tquantifiedVars: string[];\n\teffects?: Set<Effect>; // Effects for values that have effects\n};\n\nexport type TypeEnvironment = Map<string, TypeScheme> & {\n\tconstraints?: ConstraintRegistry;\n};\n\n// Functional state for type inference\nexport type TypeState = {\n\tenvironment: TypeEnvironment;\n\tsubstitution: Map<string, Type>;\n\tcounter: number;\n\tconstraints: Constraint[]; // Track constraints during inference\n\tadtRegistry: ADTRegistry; // Track ADT definitions\n\taccessorCache: Map<string, Type>; // Cache accessor types by field name\n\tconstraintRegistry: ConstraintRegistry; // Track constraint definitions and implementations\n};\n\n// Type inference result with separated effects\nexport type TypeResult = {\n\ttype: Type;\n\teffects: Set<Effect>;\n\tstate: TypeState;\n};\n\n// Effect manipulation helpers\nexport const emptyEffects = (): Set<Effect> => new Set();\n\nexport const singleEffect = (effect: Effect): Set<Effect> => new Set([effect]);\n\nexport const unionEffects = (...effectSets: Set<Effect>[]): Set<Effect> => {\n\tconst result = new Set<Effect>();\n\tfor (const effects of effectSets) {\n\t\tfor (const effect of effects) {\n\t\t\tresult.add(effect);\n\t\t}\n\t}\n\treturn result;\n};\n\nexport const createTypeResult = (type: Type, effects: Set<Effect>, state: TypeState): TypeResult => ({\n\ttype,\n\teffects,\n\tstate,\n});\n\nexport const createPureTypeResult = (type: Type, state: TypeState): TypeResult => ({\n\ttype,\n\teffects: emptyEffects(),\n\tstate,\n});\n\n// Constraint registry helpers\nexport const createConstraintRegistry = (): ConstraintRegistry => new Map();\n\nexport const addConstraintDefinition = (\n\tregistry: ConstraintRegistry,\n\tname: string,\n\tsignature: ConstraintSignature\n): void => {\n\tregistry.set(name, {\n\t\tsignature,\n\t\timplementations: new Map()\n\t});\n};\n\nexport const addConstraintImplementation = (\n\tregistry: ConstraintRegistry,\n\tconstraintName: string,\n\ttypeName: string,\n\timplementation: ConstraintImplementation\n): boolean => {\n\tconst constraint = registry.get(constraintName);\n\tif (!constraint) {\n\t\treturn false; // Constraint not defined\n\t}\n\tconstraint.implementations.set(typeName, implementation);\n\treturn true;\n};\n\nexport const resolveConstraintFunction = (\n\tregistry: ConstraintRegistry,\n\tconstraintName: string,\n\tfunctionName: string,\n\tconcreteType: Type\n): TypeScheme | null => {\n\tconst constraint = registry.get(constraintName);\n\tif (!constraint) {\n\t\treturn null;\n\t}\n\t\n\t// Convert type to string for lookup\n\tconst typeName = typeToString(concreteType);\n\tconst impl = constraint.implementations.get(typeName);\n\treturn impl?.functions.get(functionName) || null;\n};\n\n// Helper to get constraint signature\nexport const getConstraintSignature = (\n\tregistry: ConstraintRegistry,\n\tconstraintName: string\n): ConstraintSignature | null => {\n\treturn registry.get(constraintName)?.signature || null;\n};\n\n// Helper function to convert Type to string for registry keys\nconst typeToString = (type: Type): string => {\n\tswitch (type.kind) {\n\t\tcase \"primitive\":\n\t\t\treturn type.name;\n\t\tcase \"variable\":\n\t\t\treturn type.name;\n\t\tcase \"list\":\n\t\t\treturn `List ${typeToString(type.element)}`;\n\t\tcase \"tuple\":\n\t\t\treturn `{${type.elements.map(typeToString).join(\", \")}}`;\n\t\tcase \"record\":\n\t\t\tconst fields = Object.entries(type.fields)\n\t\t\t\t.map(([k, v]) => `${k}: ${typeToString(v)}`)\n\t\t\t\t.join(\", \");\n\t\t\treturn `{${fields}}`;\n\t\tcase \"function\":\n\t\t\tconst params = type.params.map(typeToString).join(\" -> \");\n\t\t\treturn `${params} -> ${typeToString(type.return)}`;\n\t\tcase \"union\":\n\t\t\treturn type.types.map(typeToString).join(\" | \");\n\t\tcase \"variant\":\n\t\t\treturn type.args.length > 0 \n\t\t\t\t? `${type.name} ${type.args.map(typeToString).join(\" \")}`\n\t\t\t\t: type.name;\n\t\tcase \"adt\":\n\t\t\treturn type.name;\n\t\tcase \"unit\":\n\t\t\treturn \"Unit\";\n\t\tcase \"unknown\":\n\t\t\treturn \"?\";\n\t\tdefault:\n\t\t\treturn \"Unknown\";\n\t}\n};\n"],"names":["addConstraintDefinition","addConstraintImplementation","createConstraintRegistry","createPureTypeResult","createTypeResult","emptyEffects","getConstraintSignature","resolveConstraintFunction","singleEffect","unionEffects","Set","effect","effectSets","result","effects","add","type","state","Map","registry","name","signature","set","implementations","constraintName","typeName","implementation","constraint","get","functionName","concreteType","typeToString","impl","functions","kind","element","elements","map","join","fields","Object","entries","k","v","params","return","types","args","length"],"mappings":";;;;;;;;;;;QAsFaA;eAAAA;;QAWAC;eAAAA;;QAbAC;eAAAA;;QAPAC;eAAAA;;QANAC;eAAAA;;QAdAC;eAAAA;;QAwEAC;eAAAA;;QAlBAC;eAAAA;;QApDAC;eAAAA;;QAEAC;eAAAA;;;AAJN,MAAMJ,eAAe,IAAmB,IAAIK;AAE5C,MAAMF,eAAe,CAACG,SAAgC,IAAID,IAAI;QAACC;KAAO;AAEtE,MAAMF,eAAe,CAAC,GAAGG;IAC/B,MAAMC,SAAS,IAAIH;IACnB,KAAK,MAAMI,WAAWF,WAAY;QACjC,KAAK,MAAMD,UAAUG,QAAS;YAC7BD,OAAOE,GAAG,CAACJ;QACZ;IACD;IACA,OAAOE;AACR;AAEO,MAAMT,mBAAmB,CAACY,MAAYF,SAAsBG,QAAkC,CAAA;QACpGD;QACAF;QACAG;IACD,CAAA;AAEO,MAAMd,uBAAuB,CAACa,MAAYC,QAAkC,CAAA;QAClFD;QACAF,SAAST;QACTY;IACD,CAAA;AAGO,MAAMf,2BAA2B,IAA0B,IAAIgB;AAE/D,MAAMlB,0BAA0B,CACtCmB,UACAC,MACAC;IAEAF,SAASG,GAAG,CAACF,MAAM;QAClBC;QACAE,iBAAiB,IAAIL;IACtB;AACD;AAEO,MAAMjB,8BAA8B,CAC1CkB,UACAK,gBACAC,UACAC;IAEA,MAAMC,aAAaR,SAASS,GAAG,CAACJ;IAChC,IAAI,CAACG,YAAY;QAChB,OAAO,OAAO,yBAAyB;IACxC;IACAA,WAAWJ,eAAe,CAACD,GAAG,CAACG,UAAUC;IACzC,OAAO;AACR;AAEO,MAAMnB,4BAA4B,CACxCY,UACAK,gBACAK,cACAC;IAEA,MAAMH,aAAaR,SAASS,GAAG,CAACJ;IAChC,IAAI,CAACG,YAAY;QAChB,OAAO;IACR;IAEA,oCAAoC;IACpC,MAAMF,WAAWM,aAAaD;IAC9B,MAAME,OAAOL,WAAWJ,eAAe,CAACK,GAAG,CAACH;IAC5C,OAAOO,MAAMC,UAAUL,IAAIC,iBAAiB;AAC7C;AAGO,MAAMvB,yBAAyB,CACrCa,UACAK;IAEA,OAAOL,SAASS,GAAG,CAACJ,iBAAiBH,aAAa;AACnD;AAEA,8DAA8D;AAC9D,MAAMU,eAAe,CAACf;IACrB,OAAQA,KAAKkB,IAAI;QAChB,KAAK;YACJ,OAAOlB,KAAKI,IAAI;QACjB,KAAK;YACJ,OAAOJ,KAAKI,IAAI;QACjB,KAAK;YACJ,OAAO,CAAC,KAAK,EAAEW,aAAaf,KAAKmB,OAAO,GAAG;QAC5C,KAAK;YACJ,OAAO,CAAC,CAAC,EAAEnB,KAAKoB,QAAQ,CAACC,GAAG,CAACN,cAAcO,IAAI,CAAC,MAAM,CAAC,CAAC;QACzD,KAAK;YACJ,MAAMC,SAASC,OAAOC,OAAO,CAACzB,KAAKuB,MAAM,EACvCF,GAAG,CAAC,CAAC,CAACK,GAAGC,EAAE,GAAK,GAAGD,EAAE,EAAE,EAAEX,aAAaY,IAAI,EAC1CL,IAAI,CAAC;YACP,OAAO,CAAC,CAAC,EAAEC,OAAO,CAAC,CAAC;QACrB,KAAK;YACJ,MAAMK,SAAS5B,KAAK4B,MAAM,CAACP,GAAG,CAACN,cAAcO,IAAI,CAAC;YAClD,OAAO,GAAGM,OAAO,IAAI,EAAEb,aAAaf,KAAK6B,MAAM,GAAG;QACnD,KAAK;YACJ,OAAO7B,KAAK8B,KAAK,CAACT,GAAG,CAACN,cAAcO,IAAI,CAAC;QAC1C,KAAK;YACJ,OAAOtB,KAAK+B,IAAI,CAACC,MAAM,GAAG,IACvB,GAAGhC,KAAKI,IAAI,CAAC,CAAC,EAAEJ,KAAK+B,IAAI,CAACV,GAAG,CAACN,cAAcO,IAAI,CAAC,MAAM,GACvDtB,KAAKI,IAAI;QACb,KAAK;YACJ,OAAOJ,KAAKI,IAAI;QACjB,KAAK;YACJ,OAAO;QACR,KAAK;YACJ,OAAO;QACR;YACC,OAAO;IACT;AACD"}