40f7627ef6577d367c22aca7adbf6c23
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _lexer = require("../../lexer");
const _parser = require("../parser");
// Helper functions for type-safe testing
function assertLiteralExpression(expr) {
    if (expr.kind !== "literal") {
        throw new Error(`Expected literal expression, got ${expr.kind}`);
    }
    return expr;
}
function assertVariableExpression(expr) {
    if (expr.kind !== "variable") {
        throw new Error(`Expected variable expression, got ${expr.kind}`);
    }
    return expr;
}
function assertFunctionExpression(expr) {
    if (expr.kind !== "function") {
        throw new Error(`Expected function expression, got ${expr.kind}`);
    }
    return expr;
}
function assertApplicationExpression(expr) {
    if (expr.kind !== "application") {
        throw new Error(`Expected application expression, got ${expr.kind}`);
    }
    return expr;
}
function assertBinaryExpression(expr) {
    if (expr.kind !== "binary") {
        throw new Error(`Expected binary expression, got ${expr.kind}`);
    }
    return expr;
}
function assertIfExpression(expr) {
    if (expr.kind !== "if") {
        throw new Error(`Expected if expression, got ${expr.kind}`);
    }
    return expr;
}
function assertRecordExpression(expr) {
    if (expr.kind !== "record") {
        throw new Error(`Expected record expression, got ${expr.kind}`);
    }
    return expr;
}
function assertAccessorExpression(expr) {
    if (expr.kind !== "accessor") {
        throw new Error(`Expected accessor expression, got ${expr.kind}`);
    }
    return expr;
}
function assertUnitExpression(expr) {
    if (expr.kind !== "unit") {
        throw new Error(`Expected unit expression, got ${expr.kind}`);
    }
    return expr;
}
function assertTypeDefinitionExpression(expr) {
    if (expr.kind !== "type-definition") {
        throw new Error(`Expected type definition expression, got ${expr.kind}`);
    }
    return expr;
}
function assertWhereExpression(expr) {
    if (expr.kind !== "where") {
        throw new Error(`Expected where expression, got ${expr.kind}`);
    }
    return expr;
}
function assertMutableDefinitionExpression(expr) {
    if (expr.kind !== "mutable-definition") {
        throw new Error(`Expected mutable definition expression, got ${expr.kind}`);
    }
    return expr;
}
function assertMutationExpression(expr) {
    if (expr.kind !== "mutation") {
        throw new Error(`Expected mutation expression, got ${expr.kind}`);
    }
    return expr;
}
function assertConstraintDefinitionExpression(expr) {
    if (expr.kind !== "constraint-definition") {
        throw new Error(`Expected constraint definition expression, got ${expr.kind}`);
    }
    return expr;
}
function assertImplementDefinitionExpression(expr) {
    if (expr.kind !== "implement-definition") {
        throw new Error(`Expected implement definition expression, got ${expr.kind}`);
    }
    return expr;
}
function assertConstrainedExpression(expr) {
    if (expr.kind !== "constrained") {
        throw new Error(`Expected constrained expression, got ${expr.kind}`);
    }
    return expr;
}
function assertRecordType(type) {
    if (type.kind !== "record") {
        throw new Error(`Expected record type, got ${type.kind}`);
    }
}
function assertTupleType(type) {
    if (type.kind !== "tuple") {
        throw new Error(`Expected tuple type, got ${type.kind}`);
    }
}
function assertListType(type) {
    if (type.kind !== "list") {
        throw new Error(`Expected list type, got ${type.kind}`);
    }
}
function assertFunctionType(type) {
    if (type.kind !== "function") {
        throw new Error(`Expected function type, got ${type.kind}`);
    }
}
function assertVariableType(type) {
    if (type.kind !== "variable") {
        throw new Error(`Expected variable type, got ${type.kind}`);
    }
}
function assertDefinitionExpression(expr) {
    if (expr.kind !== "definition") {
        throw new Error(`Expected definition expression, got ${expr.kind}`);
    }
    return expr;
}
function assertTypedExpression(expr) {
    if (expr.kind !== "typed") {
        throw new Error(`Expected typed expression, got ${expr.kind}`);
    }
    return expr;
}
function assertMatchExpression(expr) {
    if (expr.kind !== "match") {
        throw new Error(`Expected match expression, got ${expr.kind}`);
    }
    return expr;
}
function assertParseSuccess(result) {
    if (!result.success) {
        throw new Error(`Expected parse success, got ${result.error}`);
    }
}
function assertParseError(result) {
    if (result.success) {
        throw new Error(`Expected parse error, got success: (${JSON.stringify(result)})`);
    }
}
describe("Parser", ()=>{
    test("should parse simple literals", ()=>{
        const lexer = new _lexer.Lexer("42");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const literal = assertLiteralExpression(program.statements[0]);
        expect(literal.value).toBe(42);
    });
    test("should parse string literals", ()=>{
        const lexer = new _lexer.Lexer('"hello"');
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const literal = assertLiteralExpression(program.statements[0]);
        expect(literal.value).toBe("hello");
    });
    test("should parse boolean literals", ()=>{
        const lexer = new _lexer.Lexer("True");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("variable");
        expect(program.statements[0].name).toBe("True");
    });
    test("should parse variable references", ()=>{
        const lexer = new _lexer.Lexer("x");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const variable = assertVariableExpression(program.statements[0]);
        expect(variable.name).toBe("x");
    });
    test("should parse function definitions", ()=>{
        const lexer = new _lexer.Lexer("fn x => x + 1");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const func = assertFunctionExpression(program.statements[0]);
        expect(func.params).toEqual([
            "x"
        ]);
        expect(func.body.kind).toBe("binary");
    });
    test("should parse function applications", ()=>{
        const lexer = new _lexer.Lexer("(fn x => x + 1) 2");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const app = assertApplicationExpression(program.statements[0]);
        expect(app.func.kind).toBe("function");
        expect(app.args).toHaveLength(1);
        const arg = assertLiteralExpression(app.args[0]);
        expect(arg.value).toBe(2);
    });
    test("should parse binary expressions", ()=>{
        const lexer = new _lexer.Lexer("2 + 3");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const binary = assertBinaryExpression(program.statements[0]);
        expect(binary.operator).toBe("+");
    });
    test("should parse lists", ()=>{
        const lexer = new _lexer.Lexer("[1, 2, 3]");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("list");
        const elements = program.statements[0].elements;
        expect(Array.isArray(elements)).toBe(true);
        expect(elements).toHaveLength(3);
        expect(elements[0].kind).toBe("literal");
        expect(elements[0].value).toBe(1);
        expect(elements[1].kind).toBe("literal");
        expect(elements[1].value).toBe(2);
        expect(elements[2].kind).toBe("literal");
        expect(elements[2].value).toBe(3);
    });
    test("should parse if expressions", ()=>{
        const lexer = new _lexer.Lexer("if True then 1 else 2");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("if");
        const ifExpr = program.statements[0];
        expect(ifExpr.condition.name).toBe("True");
        expect(ifExpr.then.value).toBe(1);
        expect(ifExpr.else.value).toBe(2);
    });
    test("should parse pipeline expressions", ()=>{
        const lexer = new _lexer.Lexer("[1, 2, 3] |> map");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const pipeline = program.statements[0];
        expect(pipeline.kind).toBe("pipeline");
        expect(pipeline.steps[0].kind).toBe("list");
        expect(pipeline.steps[1].kind).toBe("variable");
    });
    test("should parse single-field record", ()=>{
        const lexer = new _lexer.Lexer('{ @name "Alice", @age 30 }');
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("record");
        const record = program.statements[0];
        expect(record.fields).toHaveLength(2);
        expect(record.fields[0].name).toBe("name");
        expect(record.fields[0].value.value).toBe("Alice");
        expect(record.fields[1].name).toBe("age");
        expect(record.fields[1].value.value).toBe(30);
    });
    test("should parse multi-field record (semicolon separated)", ()=>{
        const lexer = new _lexer.Lexer('{ @name "Alice", @age 30 }');
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("record");
        const record = program.statements[0];
        expect(record.fields).toHaveLength(2);
        expect(record.fields[0].name).toBe("name");
        expect(record.fields[0].value.value).toBe("Alice");
        expect(record.fields[1].name).toBe("age");
        expect(record.fields[1].value.value).toBe(30);
    });
    test("should parse multi-field record (semicolon separated)", ()=>{
        const lexer = new _lexer.Lexer('{ @name "Alice", @age 30 }');
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("record");
        const record = program.statements[0];
        expect(record.fields).toHaveLength(2);
        expect(record.fields[0].name).toBe("name");
        expect(record.fields[0].value.value).toBe("Alice");
        expect(record.fields[1].name).toBe("age");
        expect(record.fields[1].value.value).toBe(30);
    });
    test("should parse accessor", ()=>{
        const lexer = new _lexer.Lexer("@name");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("accessor");
        const accessor = program.statements[0];
        expect(accessor.field).toBe("name");
    });
    test("should parse function with unit parameter", ()=>{
        const lexer = new _lexer.Lexer("fn {} => 42");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const func = assertFunctionExpression(program.statements[0]);
        expect(func.params).toEqual([
            "_unit"
        ]); // Unit parameter
        expect(func.body.kind).toBe("literal");
        expect(func.body.value).toBe(42);
    });
    test("should parse deeply nested tuples in records", ()=>{
        const lexer = new _lexer.Lexer("{ @key [1, {{{1}}}] }");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        // Check the outermost record
        expect(program.statements).toHaveLength(1);
        const outer = program.statements[0];
        expect(outer.kind).toBe("record");
        const keyField = outer.fields[0];
        expect(keyField.name).toBe("key");
        // Check that keyField.value is a list with two elements
        expect(keyField.value.kind).toBe("list");
        expect(keyField.value.elements).toHaveLength(2);
        // First element should be a literal
        expect(keyField.value.elements[0].kind).toBe("literal");
        expect(keyField.value.elements[0].value).toBe(1);
        // Second element should be a nested tuple structure
        let nestedTuple = keyField.value.elements[1];
        expect(nestedTuple.kind).toBe("tuple");
        // Check the nested structure: tuple -> tuple -> tuple -> literal
        for(let i = 0; i < 3; i++){
            expect(nestedTuple.kind).toBe("tuple");
            expect(nestedTuple.elements).toHaveLength(1);
            nestedTuple = nestedTuple.elements[0];
        }
        expect(nestedTuple.kind).toBe("literal");
        expect(nestedTuple.value).toBe(1);
    });
    test("should parse records with nested lists and records", ()=>{
        const lexer = new _lexer.Lexer("{ @key [1, { @inner [2, 3] }] }");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const outer = program.statements[0];
        expect(outer.kind).toBe("record");
        const keyField = outer.fields[0];
        expect(keyField.name).toBe("key");
        const list = keyField.value;
        expect(list.kind).toBe("list");
        expect(list.elements[0].kind).toBe("literal");
        expect(list.elements[0].value).toBe(1);
        const nestedRecord = list.elements[1];
        expect(nestedRecord.kind).toBe("record");
        const innerField = nestedRecord.fields[0];
        expect(innerField.name).toBe("inner");
        const innerList = innerField.value;
        expect(innerList.kind).toBe("list");
        expect(innerList.elements.map((e)=>e.value)).toEqual([
            2,
            3
        ]);
    });
    test("should parse lists of records", ()=>{
        const lexer = new _lexer.Lexer("[{ @a 1 }, { @b 2 }]");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const list = program.statements[0];
        expect(list.kind).toBe("list");
        expect(list.elements[0].kind).toBe("record");
        expect(list.elements[1].kind).toBe("record");
        expect(list.elements[0].fields[0].name).toBe("a");
        expect(list.elements[0].fields[0].value.value).toBe(1);
        expect(list.elements[1].fields[0].name).toBe("b");
        expect(list.elements[1].fields[0].value.value).toBe(2);
    });
    test("should parse a single tuple", ()=>{
        const lexer = new _lexer.Lexer("{1}");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const tuple = program.statements[0];
        expect(tuple.kind).toBe("tuple");
        expect(tuple.elements[0].kind).toBe("literal");
        expect(tuple.elements[0].value).toBe(1);
    });
    test("should parse a single record", ()=>{
        const lexer = new _lexer.Lexer("{ @foo 1 }");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const record = program.statements[0];
        expect(record.kind).toBe("record");
        expect(record.fields[0].name).toBe("foo");
        expect(record.fields[0].value.value).toBe(1);
    });
    test("should parse a list of literals", ()=>{
        const lexer = new _lexer.Lexer("[1, 2]");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const list = program.statements[0];
        expect(list.kind).toBe("list");
        expect(list.elements[0].kind).toBe("literal");
        expect(list.elements[0].value).toBe(1);
        expect(list.elements[1].kind).toBe("literal");
        expect(list.elements[1].value).toBe(2);
    });
    test("should parse a list of tuples", ()=>{
        const lexer = new _lexer.Lexer("[{1}, {2}]");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const list = program.statements[0];
        expect(list.kind).toBe("list");
        expect(list.elements[0].kind).toBe("tuple");
        expect(list.elements[0].elements[0].value).toBe(1);
        expect(list.elements[1].kind).toBe("tuple");
        expect(list.elements[1].elements[0].value).toBe(2);
    });
    test("should parse a list of records", ()=>{
        const lexer = new _lexer.Lexer("[{ @foo 1 }, { @bar 2 }]");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const list = program.statements[0];
        expect(list.kind).toBe("list");
        expect(list.elements[0].kind).toBe("record");
        expect(list.elements[0].fields[0].name).toBe("foo");
        expect(list.elements[0].fields[0].value.value).toBe(1);
        expect(list.elements[1].kind).toBe("record");
        expect(list.elements[1].fields[0].name).toBe("bar");
        expect(list.elements[1].fields[0].value.value).toBe(2);
    });
    test("should parse thrush operator", ()=>{
        const lexer = new _lexer.Lexer("10 | (fn x => x + 1)");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const thrush = program.statements[0];
        expect(thrush.kind).toBe("binary");
        expect(thrush.operator).toBe("|");
        expect(thrush.left.kind).toBe("literal");
        expect(thrush.right.kind).toBe("function");
    });
    test("should parse chained thrush operators as left-associative", ()=>{
        const lexer = new _lexer.Lexer("a | b | c");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const chain = program.statements[0];
        expect(chain.kind).toBe("binary");
        expect(chain.operator).toBe("|");
        expect(chain.left.kind).toBe("binary");
        expect(chain.left.operator).toBe("|");
        expect(chain.left.left.kind).toBe("variable");
        expect(chain.left.left.name).toBe("a");
        expect(chain.left.right.kind).toBe("variable");
        expect(chain.left.right.name).toBe("b");
        expect(chain.right.kind).toBe("variable");
        expect(chain.right.name).toBe("c");
    });
    test("should parse thrush operator after record", ()=>{
        const lexer = new _lexer.Lexer("{@key 1, @key2 False} | @key");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        // Verify it's a binary expression with thrush operator
        const expr = program.statements[0];
        expect(expr.kind).toBe("binary");
        expect(expr.operator).toBe("|");
        expect(expr.left.kind).toBe("record");
        expect(expr.right.kind).toBe("accessor");
    });
    // Add tests for empty unit expression
    test("should parse empty braces as unit", ()=>{
        const lexer = new _lexer.Lexer("{}");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const unit = assertUnitExpression(program.statements[0]);
        expect(unit.kind).toBe("unit");
    });
    // Add tests for function with empty parentheses
    test("should parse function with empty parentheses", ()=>{
        const lexer = new _lexer.Lexer("fn () => 42");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const func = assertFunctionExpression(program.statements[0]);
        expect(func.params).toEqual([]);
        expect(func.body.kind).toBe("literal");
    });
    // Add tests for function with multiple parameters
    test("should parse function with multiple parameters", ()=>{
        const lexer = new _lexer.Lexer("fn x y z => x + y + z");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const func = assertFunctionExpression(program.statements[0]);
        expect(func.params).toEqual([
            "x",
            "y",
            "z"
        ]);
        expect(func.body.kind).toBe("binary");
    });
    // Add tests for empty lists
    test("should parse empty list", ()=>{
        const lexer = new _lexer.Lexer("[]");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("list");
        const list = program.statements[0];
        expect(list.elements).toHaveLength(0);
    });
    // Add tests for lists with trailing commas
    test("should parse list with trailing comma", ()=>{
        const lexer = new _lexer.Lexer("[1, 2, 3,]");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("list");
        const list = program.statements[0];
        expect(list.elements).toHaveLength(3);
    });
    // Add tests for records with trailing commas
    test("should parse record with trailing comma", ()=>{
        const lexer = new _lexer.Lexer("{ @name \"Alice\", @age 30, }");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("record");
        const record = program.statements[0];
        expect(record.fields).toHaveLength(2);
    });
    // Add tests for unary minus (adjacent)
    test("should parse unary minus (adjacent)", ()=>{
        const lexer = new _lexer.Lexer("-42");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("binary");
        const binary = program.statements[0];
        expect(binary.operator).toBe("*");
        expect(binary.left.kind).toBe("literal");
        expect(binary.left.value).toBe(-1);
        expect(binary.right.kind).toBe("literal");
        expect(binary.right.value).toBe(42);
    });
    // Add tests for minus operator (non-adjacent)
    test("should parse minus operator (non-adjacent)", ()=>{
        const lexer = new _lexer.Lexer("10 - 5");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("binary");
        const binary = program.statements[0];
        expect(binary.operator).toBe("-");
        expect(binary.left.kind).toBe("literal");
        expect(binary.left.value).toBe(10);
        expect(binary.right.kind).toBe("literal");
        expect(binary.right.value).toBe(5);
    });
});
// Add new test suite for Type Definitions (ADTs)
describe("Type Definitions (ADTs)", ()=>{
    test("should parse simple type definition", ()=>{
        const lexer = new _lexer.Lexer("type Bool = True | False");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const typeDef = assertTypeDefinitionExpression(program.statements[0]);
        expect(typeDef.name).toBe("Bool");
        expect(typeDef.typeParams).toEqual([]);
        expect(typeDef.constructors).toHaveLength(2);
        expect(typeDef.constructors[0].name).toBe("True");
        expect(typeDef.constructors[0].args).toEqual([]);
        expect(typeDef.constructors[1].name).toBe("False");
        expect(typeDef.constructors[1].args).toEqual([]);
    });
    test("should parse type definition with parameters", ()=>{
        const lexer = new _lexer.Lexer("type Option a = None | Some a");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const typeDef = assertTypeDefinitionExpression(program.statements[0]);
        expect(typeDef.name).toBe("Option");
        expect(typeDef.typeParams).toEqual([
            "a"
        ]);
        expect(typeDef.constructors).toHaveLength(2);
        expect(typeDef.constructors[0].name).toBe("None");
        expect(typeDef.constructors[0].args).toEqual([]);
        expect(typeDef.constructors[1].name).toBe("Some");
        expect(typeDef.constructors[1].args).toHaveLength(1);
    });
    test("should parse type definition with complex constructors", ()=>{
        const lexer = new _lexer.Lexer("type Either a b = Left a | Right b");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const typeDef = assertTypeDefinitionExpression(program.statements[0]);
        expect(typeDef.name).toBe("Either");
        expect(typeDef.typeParams).toEqual([
            "a",
            "b"
        ]);
        expect(typeDef.constructors).toHaveLength(2);
        expect(typeDef.constructors[0].name).toBe("Left");
        expect(typeDef.constructors[1].name).toBe("Right");
    });
    test("should parse type definition with multiple constructor arguments", ()=>{
        const lexer = new _lexer.Lexer("type Person = Person String Number");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const typeDef = assertTypeDefinitionExpression(program.statements[0]);
        expect(typeDef.name).toBe("Person");
        expect(typeDef.constructors).toHaveLength(1);
        expect(typeDef.constructors[0].name).toBe("Person");
        expect(typeDef.constructors[0].args).toHaveLength(2);
    });
});
// Add new test suite for Pattern Matching
describe("Pattern Matching", ()=>{
    test("should parse simple match expression", ()=>{
        const lexer = new _lexer.Lexer("match x with ( True => 1; False => 0 )");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const matchExpr = assertMatchExpression(program.statements[0]);
        expect(matchExpr.expression.kind).toBe("variable");
        expect(matchExpr.cases).toHaveLength(2);
        expect(matchExpr.cases[0].pattern.kind).toBe("constructor");
        expect(matchExpr.cases[0].pattern.name).toBe("True");
        expect(matchExpr.cases[0].expression.kind).toBe("literal");
        expect(matchExpr.cases[0].expression.value).toBe(1);
    });
    test("should parse match with variable patterns", ()=>{
        const lexer = new _lexer.Lexer("match x with ( Some y => y; None => 0 )");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const matchExpr = assertMatchExpression(program.statements[0]);
        expect(matchExpr.cases).toHaveLength(2);
        expect(matchExpr.cases[0].pattern.kind).toBe("constructor");
        expect(matchExpr.cases[0].pattern.name).toBe("Some");
        expect(matchExpr.cases[0].pattern.args).toHaveLength(1);
        expect(matchExpr.cases[0].pattern.args[0].kind).toBe("variable");
    });
    test("should parse match with wildcard patterns", ()=>{
        const lexer = new _lexer.Lexer("match x with ( Some _ => 1; _ => 0 )");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const matchExpr = assertMatchExpression(program.statements[0]);
        expect(matchExpr.cases).toHaveLength(2);
        expect(matchExpr.cases[0].pattern.kind).toBe("constructor");
        // Note: _ is parsed as a variable pattern because it's an identifier in the lexer
        expect(matchExpr.cases[1].pattern.kind).toBe("variable");
        expect(matchExpr.cases[1].pattern.name).toBe("_");
    });
    test.skip("should parse match with literal patterns", ()=>{
        // TODO: This test is skipped due to parser precedence issues with top-level match expressions.
        // The parser choice ordering causes parseMatchExpression to conflict with other parsers
        // when parsing at the top level. This needs parser architecture improvements to resolve.
        const lexer = new _lexer.Lexer('match x with ( 1 => "one"; "hello" => "world"; _ => "other" )');
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const matchExpr = assertMatchExpression(program.statements[0]);
        expect(matchExpr.cases).toHaveLength(3);
        expect(matchExpr.cases[0].pattern.kind).toBe("literal");
        expect(matchExpr.cases[0].pattern.value).toBe(1);
        expect(matchExpr.cases[1].pattern.kind).toBe("literal");
        expect(matchExpr.cases[1].pattern.value).toBe("hello");
    });
    test("should parse match with nested constructor patterns", ()=>{
        const lexer = new _lexer.Lexer("match x with ( Wrap (Value n) => n; _ => 0 )");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const matchExpr = assertMatchExpression(program.statements[0]);
        expect(matchExpr.cases).toHaveLength(2);
        expect(matchExpr.cases[0].pattern.kind).toBe("constructor");
        expect(matchExpr.cases[0].pattern.name).toBe("Wrap");
        expect(matchExpr.cases[0].pattern.args).toHaveLength(1);
        const nestedPattern = matchExpr.cases[0].pattern.args[0];
        expect(nestedPattern.kind).toBe("constructor");
        expect(nestedPattern.name).toBe("Value");
    });
});
// Add new test suite for Where Expressions
describe("Where Expressions", ()=>{
    test("should parse where expression with single definition", ()=>{
        const lexer = new _lexer.Lexer("x + y where ( x = 1 )");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const whereExpr = assertWhereExpression(program.statements[0]);
        expect(whereExpr.main.kind).toBe("binary");
        expect(whereExpr.definitions).toHaveLength(1);
        expect(whereExpr.definitions[0].kind).toBe("definition");
        expect(whereExpr.definitions[0].name).toBe("x");
    });
    test("should parse where expression with multiple definitions", ()=>{
        const lexer = new _lexer.Lexer("x + y where ( x = 1; y = 2 )");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const whereExpr = assertWhereExpression(program.statements[0]);
        expect(whereExpr.definitions).toHaveLength(2);
        expect(whereExpr.definitions[0].name).toBe("x");
        expect(whereExpr.definitions[1].name).toBe("y");
    });
    test("should parse where expression with mutable definition", ()=>{
        const lexer = new _lexer.Lexer("x + y where ( mut x = 1; y = 2 )");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const whereExpr = assertWhereExpression(program.statements[0]);
        expect(whereExpr.definitions).toHaveLength(2);
        expect(whereExpr.definitions[0].kind).toBe("mutable-definition");
        expect(whereExpr.definitions[1].kind).toBe("definition");
    });
});
// Add new test suite for Mutable Definitions and Mutations
describe("Mutable Definitions and Mutations", ()=>{
    test("should parse mutable definition", ()=>{
        const lexer = new _lexer.Lexer("mut x = 42");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const mutDef = assertMutableDefinitionExpression(program.statements[0]);
        expect(mutDef.name).toBe("x");
        expect(mutDef.value.kind).toBe("literal");
        expect(mutDef.value.value).toBe(42);
    });
    test("should parse mutation", ()=>{
        const lexer = new _lexer.Lexer("mut! x = 100");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const mutation = assertMutationExpression(program.statements[0]);
        expect(mutation.target).toBe("x");
        expect(mutation.value.kind).toBe("literal");
        expect(mutation.value.value).toBe(100);
    });
    test("should parse mutable definition with complex expression", ()=>{
        const lexer = new _lexer.Lexer("mut result = fn x => x * 2");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const mutDef = assertMutableDefinitionExpression(program.statements[0]);
        expect(mutDef.name).toBe("result");
        expect(mutDef.value.kind).toBe("function");
    });
});
// Add new test suite for Constraint Definitions and Implementations
describe("Constraint Definitions and Implementations", ()=>{
    test.skip("should parse constraint definition", ()=>{
        // TODO: This test is skipped due to parser precedence issues with top-level constraint definitions.
        // The parser choice ordering causes parseConstraintDefinition to conflict with other parsers
        // when parsing at the top level. This needs parser architecture improvements to resolve.
        const lexer = new _lexer.Lexer("constraint Monad m ( return a : a -> m a; bind a b : m a -> (a -> m b) -> m b )");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const constraintDef = assertConstraintDefinitionExpression(program.statements[0]);
        expect(constraintDef.name).toBe("Monad");
        expect(constraintDef.typeParam).toBe("m");
        expect(constraintDef.functions).toHaveLength(2);
        expect(constraintDef.functions[0].name).toBe("return");
        expect(constraintDef.functions[1].name).toBe("bind");
    });
    test("should parse implement definition", ()=>{
        const lexer = new _lexer.Lexer("implement Monad Option ( return = Some; bind = fn opt f => match opt with ( Some x => f x; None => None ) )");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const implDef = assertImplementDefinitionExpression(program.statements[0]);
        expect(implDef.constraintName).toBe("Monad");
        expect(implDef.typeName).toBe("Option");
        expect(implDef.implementations).toHaveLength(2);
        expect(implDef.implementations[0].name).toBe("return");
        expect(implDef.implementations[1].name).toBe("bind");
    });
    test("should parse constraint with simple functions", ()=>{
        const lexer = new _lexer.Lexer("constraint Eq a ( eq a : a -> a -> Bool )");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const constraintDef = assertConstraintDefinitionExpression(program.statements[0]);
        expect(constraintDef.name).toBe("Eq");
        expect(constraintDef.typeParam).toBe("a");
        expect(constraintDef.functions).toHaveLength(1);
        expect(constraintDef.functions[0].name).toBe("eq");
        expect(constraintDef.functions[0].typeParams).toEqual([
            "a"
        ]);
    });
});
// Add new test suite for Advanced Type Expressions
describe("Advanced Type Expressions", ()=>{
    test("should parse Tuple type constructor", ()=>{
        const lexer = new _lexer.Lexer("Tuple Int String Bool");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseSuccess(result);
        expect(result.value.kind).toBe("tuple");
        const tupleConstructor = result.value;
        expect(tupleConstructor.elements).toHaveLength(3);
    });
    test("should parse parenthesized type expression", ()=>{
        const lexer = new _lexer.Lexer("(Int -> String)");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseSuccess(result);
        assertFunctionType(result.value);
    });
    test("should parse List type with generic parameter", ()=>{
        const lexer = new _lexer.Lexer("List");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseSuccess(result);
        assertListType(result.value);
        const listType = result.value;
        expect(listType.element.kind).toBe("variable");
        expect(listType.element.name).toBe("a");
    });
    test("should parse variant type with args", ()=>{
        const lexer = new _lexer.Lexer("Maybe String");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseSuccess(result);
        expect(result.value.kind).toBe("variant");
        const variantType = result.value;
        expect(variantType.name).toBe("Maybe");
        expect(variantType.args).toHaveLength(1);
    });
});
// Add new test suite for Constraint Expressions
describe("Constraint Expressions", ()=>{
    test("should parse simple constraint expression", ()=>{
        const lexer = new _lexer.Lexer("x : Int given a is Eq");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const constrained = assertConstrainedExpression(program.statements[0]);
        expect(constrained.expression.kind).toBe("variable");
        expect(constrained.type.kind).toBe("primitive");
        expect(constrained.constraint.kind).toBe("is");
        expect(constrained.constraint.typeVar).toBe("a");
        expect(constrained.constraint.constraint).toBe("Eq");
    });
    test("should parse constraint with and operator", ()=>{
        const lexer = new _lexer.Lexer("x : a given a is Eq and a is Ord");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const constrained = assertConstrainedExpression(program.statements[0]);
        expect(constrained.constraint.kind).toBe("and");
        const andConstraint = constrained.constraint;
        expect(andConstraint.left.kind).toBe("is");
        expect(andConstraint.right.kind).toBe("is");
    });
    test("should parse constraint with or operator", ()=>{
        const lexer = new _lexer.Lexer("x : a given a is Eq or a is Ord");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const constrained = assertConstrainedExpression(program.statements[0]);
        expect(constrained.constraint.kind).toBe("or");
    });
    test.skip("should parse constraint with hasField", ()=>{
        // TODO: This test is skipped due to parser precedence issues with top-level constrained expressions.
        // The parser choice ordering causes constraint parsing to conflict with other parsers
        // when parsing at the top level. This needs parser architecture improvements to resolve.
        const lexer = new _lexer.Lexer('x : a given a has field "name" of type String');
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const constrained = assertConstrainedExpression(program.statements[0]);
        expect(constrained.constraint.kind).toBe("hasField");
        const hasFieldConstraint = constrained.constraint;
        expect(hasFieldConstraint.typeVar).toBe("a");
        expect(hasFieldConstraint.field).toBe("name");
        expect(hasFieldConstraint.fieldType.kind).toBe("primitive");
    });
    test("should parse constraint with implements", ()=>{
        const lexer = new _lexer.Lexer("x : a given a implements Iterable");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const constrained = assertConstrainedExpression(program.statements[0]);
        expect(constrained.constraint.kind).toBe("implements");
        const implementsConstraint = constrained.constraint;
        expect(implementsConstraint.typeVar).toBe("a");
        expect(implementsConstraint.interfaceName).toBe("Iterable");
    });
    test("should parse parenthesized constraint", ()=>{
        const lexer = new _lexer.Lexer("x : a given (a is Eq and a is Ord) or a is Show");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const constrained = assertConstrainedExpression(program.statements[0]);
        expect(constrained.constraint.kind).toBe("or");
        const orConstraint = constrained.constraint;
        expect(orConstraint.left.kind).toBe("paren");
        expect(orConstraint.right.kind).toBe("is");
    });
});
// Add new test suite for Error Conditions
describe("Error Conditions", ()=>{
    test("should throw error for unexpected token after expression", ()=>{
        const lexer = new _lexer.Lexer("1 + +"); // Invalid double operator
        const tokens = lexer.tokenize();
        expect(()=>(0, _parser.parse)(tokens)).toThrow("Parse error");
    });
    test("should throw error for parse error with line information", ()=>{
        const lexer = new _lexer.Lexer("fn ==> 42"); // invalid double arrow
        const tokens = lexer.tokenize();
        expect(()=>(0, _parser.parse)(tokens)).toThrow("Parse error");
    });
    test("should handle empty input", ()=>{
        const lexer = new _lexer.Lexer("");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(0);
    });
    test("should handle only semicolons", ()=>{
        const lexer = new _lexer.Lexer(";;;;");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(0);
    });
    test("should handle mixed named and positional fields error", ()=>{
        expect(()=>{
            const lexer = new _lexer.Lexer("{ @name \"Alice\", 30 }"); // mixed named and positional
            const tokens = lexer.tokenize();
            (0, _parser.parse)(tokens);
        }).toThrow("Parse error");
    });
    test("should handle invalid field after comma in record", ()=>{
        expect(()=>{
            const lexer = new _lexer.Lexer("{ @name \"Alice\", }"); // trailing comma with no field
            const tokens = lexer.tokenize();
            (0, _parser.parse)(tokens);
        }).not.toThrow(); // should handle trailing comma gracefully
    });
    test("should handle invalid element after comma in list", ()=>{
        expect(()=>{
            const lexer = new _lexer.Lexer("[1, 2, ]"); // trailing comma with no element
            const tokens = lexer.tokenize();
            (0, _parser.parse)(tokens);
        }).not.toThrow(); // should handle trailing comma gracefully
    });
});
// Add new test suite for Operator Precedence
describe("Operator Precedence", ()=>{
    test("should parse operators with correct precedence", ()=>{
        const lexer = new _lexer.Lexer("a + b * c");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const expr = assertBinaryExpression(program.statements[0]);
        expect(expr.operator).toBe("+");
        expect(expr.left.kind).toBe("variable");
        expect(expr.right.kind).toBe("binary");
        const rightExpr = assertBinaryExpression(expr.right);
        expect(rightExpr.operator).toBe("*");
    });
    test("should parse comparison operators", ()=>{
        const lexer = new _lexer.Lexer("a < b == c > d");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        // Due to left associativity, this parses as (((a < b) == c) > d)
        const expr = assertBinaryExpression(program.statements[0]);
        expect(expr.operator).toBe(">");
    });
    test("should parse composition operators", ()=>{
        const lexer = new _lexer.Lexer("f |> g |> h");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const pipeline = program.statements[0];
        expect(pipeline.kind).toBe("pipeline");
        expect(pipeline.steps).toHaveLength(3);
    });
    test("should parse dollar operator", ()=>{
        const lexer = new _lexer.Lexer("f $ g $ h");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const expr = assertBinaryExpression(program.statements[0]);
        expect(expr.operator).toBe("$");
    });
});
describe("Top-level sequence parsing", ()=>{
    test("multiple definitions and final expression", ()=>{
        const lexer = new _lexer.Lexer("a = 1; b = 2; a + b");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const seq = program.statements[0];
        expect(seq.kind).toBe("binary"); // semicolon sequence
    });
    test("multiple definitions and final record", ()=>{
        const code = `
      add = fn x y => x + y;
      sub = fn x y => x - y;
      math = { @add add, @sub sub };
      math
    `;
        const lexer = new _lexer.Lexer(code);
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const seq = program.statements[0];
        expect(seq.kind).toBe("binary");
    });
    test("sequence with trailing semicolon", ()=>{
        const lexer = new _lexer.Lexer("a = 1; b = 2; a + b;");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const seq = program.statements[0];
        expect(seq.kind).toBe("binary");
    });
});
describe("Type annotation parsing", ()=>{
    function parseType(typeSrc) {
        const lexer = new _lexer.Lexer(typeSrc);
        const tokens = lexer.tokenize();
        return (0, _parser.parseTypeExpression)(tokens);
    }
    test("parses record type annotation", ()=>{
        const result = parseType("{ name: String, age: Number }");
        assertParseSuccess(result);
        assertRecordType(result.value);
        expect(result.value.kind).toBe("record");
        expect(result.value.fields).toHaveProperty("name");
        expect(result.value.fields).toHaveProperty("age");
        expect(result.value.fields.name.kind).toBe("primitive");
        expect(result.value.fields.age.kind).toBe("primitive");
    });
    test("parses tuple type annotation", ()=>{
        const result = parseType("{ Number, String }");
        assertParseSuccess(result);
        assertTupleType(result.value);
        expect(result.value.elements[0].kind).toBe("primitive");
        expect(result.value.elements[1].kind).toBe("primitive");
    });
    test("parses list type annotation", ()=>{
        const result = parseType("List Number");
        assertParseSuccess(result);
        assertListType(result.value);
        expect(result.value.element.kind).toBe("primitive");
    });
    test("parses function type annotation", ()=>{
        const result = parseType("Number -> Number");
        assertParseSuccess(result);
        assertFunctionType(result.value);
        const funcType = result.value;
        expect(funcType.params[0].kind).toBe("primitive");
        expect(funcType.return.kind).toBe("primitive");
    });
    test("parses type variable", ()=>{
        const result = parseType("a");
        assertParseSuccess(result);
        assertVariableType(result.value);
        expect(result.value.kind).toBe("variable");
        expect(result.value.name).toBe("a");
    });
    // Add comprehensive tests for type constructor application
    test("parses simple type constructor application", ()=>{
        const result = parseType("Option Int");
        assertParseSuccess(result);
        expect(result.value.kind).toBe("variant");
        const variantType = result.value;
        expect(variantType.name).toBe("Option");
        expect(variantType.args).toHaveLength(1);
        expect(variantType.args[0].kind).toBe("primitive");
        expect(variantType.args[0].name).toBe("Int");
    });
    test("parses type constructor with type variable", ()=>{
        const result = parseType("Option a");
        assertParseSuccess(result);
        expect(result.value.kind).toBe("variant");
        const variantType = result.value;
        expect(variantType.name).toBe("Option");
        expect(variantType.args).toHaveLength(1);
        expect(variantType.args[0].kind).toBe("variable");
        expect(variantType.args[0].name).toBe("a");
    });
    test("parses type constructor with multiple arguments", ()=>{
        const result = parseType("Either String Int");
        assertParseSuccess(result);
        expect(result.value.kind).toBe("variant");
        const variantType = result.value;
        expect(variantType.name).toBe("Either");
        expect(variantType.args).toHaveLength(2);
        expect(variantType.args[0].kind).toBe("primitive");
        expect(variantType.args[0].name).toBe("String");
        expect(variantType.args[1].kind).toBe("primitive");
        expect(variantType.args[1].name).toBe("Int");
    });
    test("parses type constructor with mixed type arguments", ()=>{
        const result = parseType("Map String a");
        assertParseSuccess(result);
        expect(result.value.kind).toBe("variant");
        const variantType = result.value;
        expect(variantType.name).toBe("Map");
        expect(variantType.args).toHaveLength(2);
        expect(variantType.args[0].kind).toBe("primitive");
        expect(variantType.args[0].name).toBe("String");
        expect(variantType.args[1].kind).toBe("variable");
        expect(variantType.args[1].name).toBe("a");
    });
    test("parses nested type constructor application", ()=>{
        const result = parseType("Option (Either String Int)");
        assertParseSuccess(result);
        expect(result.value.kind).toBe("variant");
        const variantType = result.value;
        expect(variantType.name).toBe("Option");
        expect(variantType.args).toHaveLength(1);
        expect(variantType.args[0].kind).toBe("variant");
        expect(variantType.args[0].name).toBe("Either");
        expect(variantType.args[0].args).toHaveLength(2);
    });
    test("parses single letter type constructor for constraints", ()=>{
        // While the advanced `m a` syntax isn't currently supported,
        // we should still be able to parse simple type variables for constraints
        const result = parseType("m");
        assertParseSuccess(result);
        expect(result.value.kind).toBe("variable");
        const varType = result.value;
        expect(varType.name).toBe("m");
    // TODO: In the future, we should support `m a` syntax:
    // const advancedResult = parseType("m a");
    // expect(advancedResult.value.kind).toBe("variant");
    // expect(advancedResult.value.name).toBe("m");
    // expect(advancedResult.value.args).toHaveLength(1);
    });
    test("parses type constructor in function type", ()=>{
        const result = parseType("Option a -> Bool");
        assertParseSuccess(result);
        expect(result.value.kind).toBe("function");
        const funcType = result.value;
        expect(funcType.params[0].kind).toBe("variant");
        expect(funcType.params[0].name).toBe("Option");
        expect(funcType.params[0].args).toHaveLength(1);
        expect(funcType.return.kind).toBe("variant");
        expect(funcType.return.name).toBe("Bool");
    });
    test("parses constraint function types", ()=>{
        // Test simple constraint function
        const result = parseType("a -> a");
        assertParseSuccess(result);
        expect(result.value.kind).toBe("function");
        const funcType = result.value;
        expect(funcType.params[0].kind).toBe("variable");
        expect(funcType.params[0].name).toBe("a");
        expect(funcType.return.kind).toBe("variable");
        expect(funcType.return.name).toBe("a");
    // TODO: In the future, we should support more complex constraint functions:
    // const complexResult = parseType("m a -> (a -> m b) -> m b");
    // expect(complexResult.value.kind).toBe("function");
    // This would be the monadic bind signature
    });
    test("parses nested record type", ()=>{
        const result = parseType("{ person: { name: String, age: Number }, active: Bool }");
        assertParseSuccess(result);
        assertRecordType(result.value);
        expect(result.value.fields).toHaveProperty("person");
        expect(result.value.fields).toHaveProperty("active");
        expect(result.value.fields.person.kind).toBe("record");
        expect(result.value.fields.active.kind).toBe("variant");
    });
});
describe("Top-level definitions with type annotations", ()=>{
    function parseDefinition(defSrc) {
        const lexer = new _lexer.Lexer(defSrc);
        const tokens = lexer.tokenize();
        return (0, _parser.parse)(tokens);
    }
    test("parses definition with function type annotation", ()=>{
        const result = parseDefinition("add = fn x y => x + y : Number -> Number -> Number;");
        expect(result.statements).toHaveLength(1);
        expect(result.statements[0].kind).toBe("definition");
        const def = assertDefinitionExpression(result.statements[0]);
        expect(def.name).toBe("add");
        expect(def.value.kind).toBe("function");
    // Function expressions with type annotations may not wrap in "typed" nodes
    // The type information might be stored directly on the function
    });
    test("parses definition with primitive type annotation", ()=>{
        const result = parseDefinition("answer = 42 : Number;");
        expect(result.statements).toHaveLength(1);
        expect(result.statements[0].kind).toBe("definition");
        const def = assertDefinitionExpression(result.statements[0]);
        expect(def.name).toBe("answer");
        const typed = assertTypedExpression(def.value);
        expect(typed.expression.kind).toBe("literal");
        expect(typed.type.kind).toBe("primitive");
    });
    test("parses definition with list type annotation", ()=>{
        const result = parseDefinition("numbers = [1, 2, 3] : List Number;");
        expect(result.statements).toHaveLength(1);
        const def = assertDefinitionExpression(result.statements[0]);
        expect(def.name).toBe("numbers");
        const typed = assertTypedExpression(def.value);
        expect(typed.expression.kind).toBe("list");
        expect(typed.type.kind).toBe("list"); // List types have kind "list"
        expect(typed.type.element.kind).toBe("primitive"); // Number is a primitive type  
        expect(typed.type.element.name).toBe("Int"); // Number maps to Int internally
    });
    test("parses multiple definitions with type annotations", ()=>{
        const result = parseDefinition(`
      add = fn x y => x + y : Number -> Number -> Number;
      answer = 42 : Number;
      numbers = [1, 2, 3] : List Number;
    `);
        expect(result.statements).toHaveLength(1);
        const seq = assertBinaryExpression(result.statements[0]);
        expect(seq.kind).toBe("binary"); // semicolon sequence
        expect(seq.operator).toBe(";");
    });
    // Phase 1: Effect parsing tests
    describe("Effect parsing", ()=>{
        test("should parse function type with single effect", ()=>{
            const lexer = new _lexer.Lexer("Int -> Int !write");
            const tokens = lexer.tokenize();
            const result = (0, _parser.parseTypeExpression)(tokens);
            assertParseSuccess(result);
            assertFunctionType(result.value);
            const funcType = result.value;
            expect([
                ...funcType.effects
            ]).toEqual([
                "write"
            ]);
            expect(funcType.params).toHaveLength(1);
            expect(funcType.params[0].kind).toBe("primitive");
            expect(funcType.return.kind).toBe("primitive");
        });
        test("should parse function type with multiple effects", ()=>{
            const lexer = new _lexer.Lexer("Int -> String !write !log");
            const tokens = lexer.tokenize();
            const result = (0, _parser.parseTypeExpression)(tokens);
            assertParseSuccess(result);
            assertFunctionType(result.value);
            const funcType = result.value;
            expect([
                ...funcType.effects
            ].sort()).toEqual([
                "log",
                "write"
            ]);
        });
        test("should parse function type with all valid effects", ()=>{
            const lexer = new _lexer.Lexer("Int -> Int !log !read !write !state !time !rand !ffi !async");
            const tokens = lexer.tokenize();
            const result = (0, _parser.parseTypeExpression)(tokens);
            assertParseSuccess(result);
            assertFunctionType(result.value);
            const funcType = result.value;
            expect([
                ...funcType.effects
            ].sort()).toEqual([
                "async",
                "ffi",
                "log",
                "rand",
                "read",
                "state",
                "time",
                "write"
            ]);
        });
        test("should parse function type with no effects", ()=>{
            const lexer = new _lexer.Lexer("Int -> Int");
            const tokens = lexer.tokenize();
            const result = (0, _parser.parseTypeExpression)(tokens);
            assertParseSuccess(result);
            assertFunctionType(result.value);
            const funcType = result.value;
            expect([
                ...funcType.effects
            ]).toEqual([]);
        });
        test("should parse multi-parameter function with effects", ()=>{
            const lexer = new _lexer.Lexer("Int -> String -> Bool !read");
            const tokens = lexer.tokenize();
            const result = (0, _parser.parseTypeExpression)(tokens);
            assertParseSuccess(result);
            assertFunctionType(result.value);
            const funcType = result.value;
            expect([
                ...funcType.effects
            ]).toEqual([
                "read"
            ]);
            expect(funcType.params).toHaveLength(1);
            expect(funcType.return.kind).toBe("function");
        });
        test("should reject invalid effect names", ()=>{
            const lexer = new _lexer.Lexer("Int -> Int !invalid");
            const tokens = lexer.tokenize();
            const result = (0, _parser.parseTypeExpression)(tokens);
            assertParseError(result);
            expect(result.error).toContain("Invalid effect: invalid");
        });
        test("should require effect name after exclamation mark", ()=>{
            const lexer = new _lexer.Lexer("Int -> Int !");
            const tokens = lexer.tokenize();
            const result = (0, _parser.parseTypeExpression)(tokens);
            assertParseError(result);
            expect(result.error).toContain("Expected effect name after !");
        });
        test("should parse typed expression with effects", ()=>{
            const result = parseDefinition("x : Int -> Int !state");
            expect(result.statements).toHaveLength(1);
            const typed = assertTypedExpression(result.statements[0]);
            assertFunctionType(typed.type);
            const funcType = typed.type;
            expect([
                ...funcType.effects
            ]).toEqual([
                "state"
            ]);
        });
        test("should parse function definition with effect annotation", ()=>{
            const result = parseDefinition("fn x => x : Int -> Int !log");
            expect(result.statements).toHaveLength(1);
            const func = assertFunctionExpression(result.statements[0]);
            const typed = assertTypedExpression(func.body);
            assertFunctionType(typed.type);
            const funcType = typed.type;
            expect([
                ...funcType.effects
            ]).toEqual([
                "log"
            ]);
        });
        test("should automatically deduplicate effects", ()=>{
            const lexer = new _lexer.Lexer("Int -> Int !write !log !write");
            const tokens = lexer.tokenize();
            const result = (0, _parser.parseTypeExpression)(tokens);
            assertParseSuccess(result);
            assertFunctionType(result.value);
            const funcType = result.value;
            // Set automatically deduplicates, so !write !log !write becomes {log, write}
            expect([
                ...funcType.effects
            ].sort()).toEqual([
                "log",
                "write"
            ]);
            expect(funcType.effects.size).toBe(2);
        });
    });
});
// Add new test suite for Edge Cases and Error Conditions to improve coverage
describe("Edge Cases and Error Conditions", ()=>{
    test("should handle empty input for type expressions", ()=>{
        const tokens = [];
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseError(result);
        expect(result.error).toContain("Expected type expression");
    });
    test("should handle invalid tokens for type expressions", ()=>{
        const lexer = new _lexer.Lexer("@invalid");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseError(result);
        expect(result.error).toContain("Expected type expression");
    });
    test("should parse Unit type correctly", ()=>{
        const lexer = new _lexer.Lexer("Unit");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseSuccess(result);
        expect(result.value.kind).toBe("unit");
    });
    test("should parse Number type correctly", ()=>{
        const lexer = new _lexer.Lexer("Number");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseSuccess(result);
        expect(result.value.kind).toBe("primitive");
        expect(result.value.name).toBe("Int");
    });
    test("should handle incomplete function type", ()=>{
        const lexer = new _lexer.Lexer("Int ->");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseError(result);
    });
    test("should handle invalid effect name", ()=>{
        const lexer = new _lexer.Lexer("Int -> Int !invalideffect");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseError(result);
        expect(result.error).toContain("Invalid effect: invalideffect");
    });
    test("should handle missing effect name after exclamation", ()=>{
        const lexer = new _lexer.Lexer("Int -> Int !");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseError(result);
        expect(result.error).toContain("Expected effect name after !");
    });
    test("should handle generic List type", ()=>{
        const lexer = new _lexer.Lexer("List");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseSuccess(result);
        assertListType(result.value);
        expect(result.value.element.kind).toBe("variable");
        expect(result.value.element.name).toBe("a");
    });
    test("should handle List type with argument", ()=>{
        const lexer = new _lexer.Lexer("List String");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseSuccess(result);
        assertListType(result.value);
        expect(result.value.element.kind).toBe("primitive");
    });
    test("should handle empty record fields", ()=>{
        const lexer = new _lexer.Lexer("{ }");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const unit = assertUnitExpression(program.statements[0]);
        expect(unit.kind).toBe("unit");
    });
    test.skip("should handle record field parsing edge cases", ()=>{
        // TODO: This test is skipped because the input "{ @name @value }" is actually valid syntax
        // that parses as a record with positional fields. Need to find a truly invalid syntax
        // to test error conditions, or adjust the test expectation.
        const lexer = new _lexer.Lexer("{ @name @value }"); // Invalid syntax - two accessors
        const tokens = lexer.tokenize();
        expect(()=>(0, _parser.parse)(tokens)).toThrow("Parse error");
    });
    test("should handle empty list elements", ()=>{
        const lexer = new _lexer.Lexer("[]");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("list");
        const list = program.statements[0];
        expect(list.elements).toHaveLength(0);
    });
    test("should handle adjacent minus for unary operator", ()=>{
        const lexer = new _lexer.Lexer("-123");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("binary");
        const binary = program.statements[0];
        expect(binary.operator).toBe("*");
        expect(binary.left.value).toBe(-1);
        expect(binary.right.value).toBe(123);
    });
    test("should handle non-adjacent minus for binary operator", ()=>{
        const lexer = new _lexer.Lexer("a - b");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        expect(program.statements[0].kind).toBe("binary");
        const binary = program.statements[0];
        expect(binary.operator).toBe("-");
    });
    test("should handle function type without effects fallback", ()=>{
        const lexer = new _lexer.Lexer("String -> Int");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseSuccess(result);
        assertFunctionType(result.value);
        expect([
            ...result.value.effects
        ]).toEqual([]);
    });
    test("should handle lowercase type variable", ()=>{
        const lexer = new _lexer.Lexer("a");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseSuccess(result);
        assertVariableType(result.value);
        expect(result.value.name).toBe("a");
    });
    test("should handle record type edge case", ()=>{
        const lexer = new _lexer.Lexer("{ name: String }");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseSuccess(result);
        assertRecordType(result.value);
        expect(result.value.fields).toHaveProperty("name");
    });
    test("should handle tuple type edge case", ()=>{
        const lexer = new _lexer.Lexer("{ String, Int }");
        const tokens = lexer.tokenize();
        const result = (0, _parser.parseTypeExpression)(tokens);
        assertParseSuccess(result);
        assertTupleType(result.value);
        expect(result.value.elements).toHaveLength(2);
    });
    test.skip("should handle debug logging when enabled", ()=>{
        // Set debug environment variable
        const originalDebug = process.env.NOO_DEBUG_PARSE;
        process.env.NOO_DEBUG_PARSE = "1";
        const lexer = new _lexer.Lexer("42");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        // Restore original environment
        if (originalDebug) {
            process.env.NOO_DEBUG_PARSE = originalDebug;
        } else {
            delete process.env.NOO_DEBUG_PARSE;
        }
    });
    test("should handle unexpected token types in primary parser", ()=>{
        // Create a mock token with an unexpected type
        const tokens = [
            {
                type: "COMMENT",
                value: "# comment",
                location: {
                    start: {
                        line: 1,
                        column: 1
                    },
                    end: {
                        line: 1,
                        column: 9
                    }
                }
            }
        ];
        expect(()=>(0, _parser.parse)(tokens)).toThrow("Parse error");
    });
    test("should handle various punctuation cases", ()=>{
        const testCases = [
            "(",
            "[",
            "{"
        ];
        for (const testCase of testCases){
            const lexer = new _lexer.Lexer(testCase);
            const tokens = lexer.tokenize();
            expect(()=>(0, _parser.parse)(tokens)).toThrow("Parse error");
        }
    });
    test("should handle type atom parsing edge cases", ()=>{
        // Test various edge cases that might not be covered
        const testCases = [
            "(Int -> String)",
            "Maybe Int",
            "Either String Int"
        ];
        for (const testCase of testCases){
            const lexer = new _lexer.Lexer(testCase);
            const tokens = lexer.tokenize();
            const result = (0, _parser.parseTypeExpression)(tokens);
            assertParseSuccess(result);
        }
    });
    test("should handle constraint expression edge cases", ()=>{
        const lexer = new _lexer.Lexer("x : a given (a is Eq)");
        const tokens = lexer.tokenize();
        const program = (0, _parser.parse)(tokens);
        expect(program.statements).toHaveLength(1);
        const constrained = assertConstrainedExpression(program.statements[0]);
        expect(constrained.constraint.kind).toBe("paren");
    });
    test("should handle complex parsing edge cases for coverage", ()=>{
        // Test some complex parsing scenarios
        const testCases = [
            "fn x y z => x + y + z",
            "(fn x => x) 42",
            "[1, 2, 3] |> map |> filter",
            "{ @a 1, @b 2, @c 3 }",
            "match x with ( Some y => y + 1; None => 0 )"
        ];
        for (const testCase of testCases){
            const lexer = new _lexer.Lexer(testCase);
            const tokens = lexer.tokenize();
            const program = (0, _parser.parse)(tokens);
            expect(program.statements).toHaveLength(1);
        }
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Uvc3JjL3BhcnNlci9fX3Rlc3RzX18vcGFyc2VyLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi4vLi4vbGV4ZXJcIjtcbmltcG9ydCB7IHBhcnNlLCBwYXJzZVR5cGVFeHByZXNzaW9uIH0gZnJvbSBcIi4uL3BhcnNlclwiO1xuaW1wb3J0IHR5cGUge1xuXHRFeHByZXNzaW9uLFxuXHRMaXRlcmFsRXhwcmVzc2lvbixcblx0VmFyaWFibGVFeHByZXNzaW9uLFxuXHRGdW5jdGlvbkV4cHJlc3Npb24sXG5cdEFwcGxpY2F0aW9uRXhwcmVzc2lvbixcblx0QmluYXJ5RXhwcmVzc2lvbixcblx0SWZFeHByZXNzaW9uLFxuXHRSZWNvcmRFeHByZXNzaW9uLFxuXHRBY2Nlc3NvckV4cHJlc3Npb24sXG5cdFR5cGUsXG5cdFJlY29yZFR5cGUsXG5cdFR1cGxlVHlwZSxcblx0TGlzdFR5cGUsXG5cdEZ1bmN0aW9uVHlwZSxcblx0VmFyaWFibGVUeXBlLFxuXHREZWZpbml0aW9uRXhwcmVzc2lvbixcblx0VHlwZWRFeHByZXNzaW9uLFxuXHRNYXRjaEV4cHJlc3Npb24sXG5cdFR5cGVEZWZpbml0aW9uRXhwcmVzc2lvbixcblx0V2hlcmVFeHByZXNzaW9uLFxuXHRNdXRhYmxlRGVmaW5pdGlvbkV4cHJlc3Npb24sXG5cdE11dGF0aW9uRXhwcmVzc2lvbixcblx0Q29uc3RyYWludERlZmluaXRpb25FeHByZXNzaW9uLFxuXHRJbXBsZW1lbnREZWZpbml0aW9uRXhwcmVzc2lvbixcblx0VW5pdEV4cHJlc3Npb24sXG5cdENvbnN0cmFpbmVkRXhwcmVzc2lvbixcbn0gZnJvbSBcIi4uLy4uL2FzdFwiO1xuaW1wb3J0IHR5cGUgeyBQYXJzZUVycm9yLCBQYXJzZVJlc3VsdCwgUGFyc2VTdWNjZXNzIH0gZnJvbSBcIi4uL2NvbWJpbmF0b3JzXCI7XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHR5cGUtc2FmZSB0ZXN0aW5nXG5mdW5jdGlvbiBhc3NlcnRMaXRlcmFsRXhwcmVzc2lvbihleHByOiBFeHByZXNzaW9uKTogTGl0ZXJhbEV4cHJlc3Npb24ge1xuXHRpZiAoZXhwci5raW5kICE9PSBcImxpdGVyYWxcIikge1xuXHRcdHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgbGl0ZXJhbCBleHByZXNzaW9uLCBnb3QgJHtleHByLmtpbmR9YCk7XG5cdH1cblx0cmV0dXJuIGV4cHI7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFZhcmlhYmxlRXhwcmVzc2lvbihleHByOiBFeHByZXNzaW9uKTogVmFyaWFibGVFeHByZXNzaW9uIHtcblx0aWYgKGV4cHIua2luZCAhPT0gXCJ2YXJpYWJsZVwiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB2YXJpYWJsZSBleHByZXNzaW9uLCBnb3QgJHtleHByLmtpbmR9YCk7XG5cdH1cblx0cmV0dXJuIGV4cHI7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uRXhwcmVzc2lvbihleHByOiBFeHByZXNzaW9uKTogRnVuY3Rpb25FeHByZXNzaW9uIHtcblx0aWYgKGV4cHIua2luZCAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBmdW5jdGlvbiBleHByZXNzaW9uLCBnb3QgJHtleHByLmtpbmR9YCk7XG5cdH1cblx0cmV0dXJuIGV4cHI7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFwcGxpY2F0aW9uRXhwcmVzc2lvbihleHByOiBFeHByZXNzaW9uKTogQXBwbGljYXRpb25FeHByZXNzaW9uIHtcblx0aWYgKGV4cHIua2luZCAhPT0gXCJhcHBsaWNhdGlvblwiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhcHBsaWNhdGlvbiBleHByZXNzaW9uLCBnb3QgJHtleHByLmtpbmR9YCk7XG5cdH1cblx0cmV0dXJuIGV4cHI7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEJpbmFyeUV4cHJlc3Npb24oZXhwcjogRXhwcmVzc2lvbik6IEJpbmFyeUV4cHJlc3Npb24ge1xuXHRpZiAoZXhwci5raW5kICE9PSBcImJpbmFyeVwiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBiaW5hcnkgZXhwcmVzc2lvbiwgZ290ICR7ZXhwci5raW5kfWApO1xuXHR9XG5cdHJldHVybiBleHByO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJZkV4cHJlc3Npb24oZXhwcjogRXhwcmVzc2lvbik6IElmRXhwcmVzc2lvbiB7XG5cdGlmIChleHByLmtpbmQgIT09IFwiaWZcIikge1xuXHRcdHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgaWYgZXhwcmVzc2lvbiwgZ290ICR7ZXhwci5raW5kfWApO1xuXHR9XG5cdHJldHVybiBleHByO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWNvcmRFeHByZXNzaW9uKGV4cHI6IEV4cHJlc3Npb24pOiBSZWNvcmRFeHByZXNzaW9uIHtcblx0aWYgKGV4cHIua2luZCAhPT0gXCJyZWNvcmRcIikge1xuXHRcdHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgcmVjb3JkIGV4cHJlc3Npb24sIGdvdCAke2V4cHIua2luZH1gKTtcblx0fVxuXHRyZXR1cm4gZXhwcjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QWNjZXNzb3JFeHByZXNzaW9uKGV4cHI6IEV4cHJlc3Npb24pOiBBY2Nlc3NvckV4cHJlc3Npb24ge1xuXHRpZiAoZXhwci5raW5kICE9PSBcImFjY2Vzc29yXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFjY2Vzc29yIGV4cHJlc3Npb24sIGdvdCAke2V4cHIua2luZH1gKTtcblx0fVxuXHRyZXR1cm4gZXhwcjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VW5pdEV4cHJlc3Npb24oZXhwcjogRXhwcmVzc2lvbik6IFVuaXRFeHByZXNzaW9uIHtcblx0aWYgKGV4cHIua2luZCAhPT0gXCJ1bml0XCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHVuaXQgZXhwcmVzc2lvbiwgZ290ICR7ZXhwci5raW5kfWApO1xuXHR9XG5cdHJldHVybiBleHByO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUeXBlRGVmaW5pdGlvbkV4cHJlc3Npb24oZXhwcjogRXhwcmVzc2lvbik6IFR5cGVEZWZpbml0aW9uRXhwcmVzc2lvbiB7XG5cdGlmIChleHByLmtpbmQgIT09IFwidHlwZS1kZWZpbml0aW9uXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHR5cGUgZGVmaW5pdGlvbiBleHByZXNzaW9uLCBnb3QgJHtleHByLmtpbmR9YCk7XG5cdH1cblx0cmV0dXJuIGV4cHI7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFdoZXJlRXhwcmVzc2lvbihleHByOiBFeHByZXNzaW9uKTogV2hlcmVFeHByZXNzaW9uIHtcblx0aWYgKGV4cHIua2luZCAhPT0gXCJ3aGVyZVwiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB3aGVyZSBleHByZXNzaW9uLCBnb3QgJHtleHByLmtpbmR9YCk7XG5cdH1cblx0cmV0dXJuIGV4cHI7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE11dGFibGVEZWZpbml0aW9uRXhwcmVzc2lvbihleHByOiBFeHByZXNzaW9uKTogTXV0YWJsZURlZmluaXRpb25FeHByZXNzaW9uIHtcblx0aWYgKGV4cHIua2luZCAhPT0gXCJtdXRhYmxlLWRlZmluaXRpb25cIikge1xuXHRcdHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgbXV0YWJsZSBkZWZpbml0aW9uIGV4cHJlc3Npb24sIGdvdCAke2V4cHIua2luZH1gKTtcblx0fVxuXHRyZXR1cm4gZXhwcjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TXV0YXRpb25FeHByZXNzaW9uKGV4cHI6IEV4cHJlc3Npb24pOiBNdXRhdGlvbkV4cHJlc3Npb24ge1xuXHRpZiAoZXhwci5raW5kICE9PSBcIm11dGF0aW9uXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIG11dGF0aW9uIGV4cHJlc3Npb24sIGdvdCAke2V4cHIua2luZH1gKTtcblx0fVxuXHRyZXR1cm4gZXhwcjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q29uc3RyYWludERlZmluaXRpb25FeHByZXNzaW9uKGV4cHI6IEV4cHJlc3Npb24pOiBDb25zdHJhaW50RGVmaW5pdGlvbkV4cHJlc3Npb24ge1xuXHRpZiAoZXhwci5raW5kICE9PSBcImNvbnN0cmFpbnQtZGVmaW5pdGlvblwiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBjb25zdHJhaW50IGRlZmluaXRpb24gZXhwcmVzc2lvbiwgZ290ICR7ZXhwci5raW5kfWApO1xuXHR9XG5cdHJldHVybiBleHByO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJbXBsZW1lbnREZWZpbml0aW9uRXhwcmVzc2lvbihleHByOiBFeHByZXNzaW9uKTogSW1wbGVtZW50RGVmaW5pdGlvbkV4cHJlc3Npb24ge1xuXHRpZiAoZXhwci5raW5kICE9PSBcImltcGxlbWVudC1kZWZpbml0aW9uXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGltcGxlbWVudCBkZWZpbml0aW9uIGV4cHJlc3Npb24sIGdvdCAke2V4cHIua2luZH1gKTtcblx0fVxuXHRyZXR1cm4gZXhwcjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q29uc3RyYWluZWRFeHByZXNzaW9uKGV4cHI6IEV4cHJlc3Npb24pOiBDb25zdHJhaW5lZEV4cHJlc3Npb24ge1xuXHRpZiAoZXhwci5raW5kICE9PSBcImNvbnN0cmFpbmVkXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGNvbnN0cmFpbmVkIGV4cHJlc3Npb24sIGdvdCAke2V4cHIua2luZH1gKTtcblx0fVxuXHRyZXR1cm4gZXhwcjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVjb3JkVHlwZSh0eXBlOiBUeXBlKTogYXNzZXJ0cyB0eXBlIGlzIFJlY29yZFR5cGUge1xuXHRpZiAodHlwZS5raW5kICE9PSBcInJlY29yZFwiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCByZWNvcmQgdHlwZSwgZ290ICR7dHlwZS5raW5kfWApO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFR1cGxlVHlwZSh0eXBlOiBUeXBlKTogYXNzZXJ0cyB0eXBlIGlzIFR1cGxlVHlwZSB7XG5cdGlmICh0eXBlLmtpbmQgIT09IFwidHVwbGVcIikge1xuXHRcdHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdHVwbGUgdHlwZSwgZ290ICR7dHlwZS5raW5kfWApO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFzc2VydExpc3RUeXBlKHR5cGU6IFR5cGUpOiBhc3NlcnRzIHR5cGUgaXMgTGlzdFR5cGUge1xuXHRpZiAodHlwZS5raW5kICE9PSBcImxpc3RcIikge1xuXHRcdHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgbGlzdCB0eXBlLCBnb3QgJHt0eXBlLmtpbmR9YCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb25UeXBlKHR5cGU6IFR5cGUpOiBhc3NlcnRzIHR5cGUgaXMgRnVuY3Rpb25UeXBlIHtcblx0aWYgKHR5cGUua2luZCAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBmdW5jdGlvbiB0eXBlLCBnb3QgJHt0eXBlLmtpbmR9YCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFyaWFibGVUeXBlKHR5cGU6IFR5cGUpOiBhc3NlcnRzIHR5cGUgaXMgVmFyaWFibGVUeXBlIHtcblx0aWYgKHR5cGUua2luZCAhPT0gXCJ2YXJpYWJsZVwiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB2YXJpYWJsZSB0eXBlLCBnb3QgJHt0eXBlLmtpbmR9YCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVmaW5pdGlvbkV4cHJlc3Npb24oZXhwcjogRXhwcmVzc2lvbik6IERlZmluaXRpb25FeHByZXNzaW9uIHtcblx0aWYgKGV4cHIua2luZCAhPT0gXCJkZWZpbml0aW9uXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGRlZmluaXRpb24gZXhwcmVzc2lvbiwgZ290ICR7ZXhwci5raW5kfWApO1xuXHR9XG5cdHJldHVybiBleHByO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUeXBlZEV4cHJlc3Npb24oZXhwcjogRXhwcmVzc2lvbik6IFR5cGVkRXhwcmVzc2lvbiB7XG5cdGlmIChleHByLmtpbmQgIT09IFwidHlwZWRcIikge1xuXHRcdHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdHlwZWQgZXhwcmVzc2lvbiwgZ290ICR7ZXhwci5raW5kfWApO1xuXHR9XG5cdHJldHVybiBleHByO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRNYXRjaEV4cHJlc3Npb24oZXhwcjogRXhwcmVzc2lvbik6IE1hdGNoRXhwcmVzc2lvbiB7XG5cdGlmIChleHByLmtpbmQgIT09IFwibWF0Y2hcIikge1xuXHRcdHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgbWF0Y2ggZXhwcmVzc2lvbiwgZ290ICR7ZXhwci5raW5kfWApO1xuXHR9XG5cdHJldHVybiBleHByO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQYXJzZVN1Y2Nlc3M8VD4oXG5cdHJlc3VsdDogUGFyc2VSZXN1bHQ8VD4sXG4pOiBhc3NlcnRzIHJlc3VsdCBpcyBQYXJzZVN1Y2Nlc3M8VD4ge1xuXHRpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBwYXJzZSBzdWNjZXNzLCBnb3QgJHtyZXN1bHQuZXJyb3J9YCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UGFyc2VFcnJvcjxUPihcblx0cmVzdWx0OiBQYXJzZVJlc3VsdDxUPixcbik6IGFzc2VydHMgcmVzdWx0IGlzIFBhcnNlRXJyb3Ige1xuXHRpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRgRXhwZWN0ZWQgcGFyc2UgZXJyb3IsIGdvdCBzdWNjZXNzOiAoJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfSlgLFxuXHRcdCk7XG5cdH1cbn1cblxuZGVzY3JpYmUoXCJQYXJzZXJcIiwgKCkgPT4ge1xuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIHNpbXBsZSBsaXRlcmFsc1wiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCI0MlwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IGxpdGVyYWwgPSBhc3NlcnRMaXRlcmFsRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChsaXRlcmFsLnZhbHVlKS50b0JlKDQyKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSBzdHJpbmcgbGl0ZXJhbHNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKCdcImhlbGxvXCInKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IGxpdGVyYWwgPSBhc3NlcnRMaXRlcmFsRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChsaXRlcmFsLnZhbHVlKS50b0JlKFwiaGVsbG9cIik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgYm9vbGVhbiBsaXRlcmFsc1wiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJUcnVlXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50c1swXS5raW5kKS50b0JlKFwidmFyaWFibGVcIik7XG5cdFx0ZXhwZWN0KChwcm9ncmFtLnN0YXRlbWVudHNbMF0gYXMgYW55KS5uYW1lKS50b0JlKFwiVHJ1ZVwiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSB2YXJpYWJsZSByZWZlcmVuY2VzXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcInhcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblxuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCB2YXJpYWJsZSA9IGFzc2VydFZhcmlhYmxlRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdCh2YXJpYWJsZS5uYW1lKS50b0JlKFwieFwiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSBmdW5jdGlvbiBkZWZpbml0aW9uc1wiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJmbiB4ID0+IHggKyAxXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0Y29uc3QgZnVuYyA9IGFzc2VydEZ1bmN0aW9uRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChmdW5jLnBhcmFtcykudG9FcXVhbChbXCJ4XCJdKTtcblx0XHRleHBlY3QoZnVuYy5ib2R5LmtpbmQpLnRvQmUoXCJiaW5hcnlcIik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgZnVuY3Rpb24gYXBwbGljYXRpb25zXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIihmbiB4ID0+IHggKyAxKSAyXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0Y29uc3QgYXBwID0gYXNzZXJ0QXBwbGljYXRpb25FeHByZXNzaW9uKHByb2dyYW0uc3RhdGVtZW50c1swXSk7XG5cdFx0ZXhwZWN0KGFwcC5mdW5jLmtpbmQpLnRvQmUoXCJmdW5jdGlvblwiKTtcblx0XHRleHBlY3QoYXBwLmFyZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBhcmcgPSBhc3NlcnRMaXRlcmFsRXhwcmVzc2lvbihhcHAuYXJnc1swXSk7XG5cdFx0ZXhwZWN0KGFyZy52YWx1ZSkudG9CZSgyKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSBiaW5hcnkgZXhwcmVzc2lvbnNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiMiArIDNcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblxuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBiaW5hcnkgPSBhc3NlcnRCaW5hcnlFeHByZXNzaW9uKHByb2dyYW0uc3RhdGVtZW50c1swXSk7XG5cdFx0ZXhwZWN0KGJpbmFyeS5vcGVyYXRvcikudG9CZShcIitcIik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgbGlzdHNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiWzEsIDIsIDNdXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50c1swXS5raW5kKS50b0JlKFwibGlzdFwiKTtcblx0XHRjb25zdCBlbGVtZW50cyA9IChwcm9ncmFtLnN0YXRlbWVudHNbMF0gYXMgYW55KS5lbGVtZW50cztcblx0XHRleHBlY3QoQXJyYXkuaXNBcnJheShlbGVtZW50cykpLnRvQmUodHJ1ZSk7XG5cdFx0ZXhwZWN0KGVsZW1lbnRzKS50b0hhdmVMZW5ndGgoMyk7XG5cdFx0ZXhwZWN0KGVsZW1lbnRzWzBdLmtpbmQpLnRvQmUoXCJsaXRlcmFsXCIpO1xuXHRcdGV4cGVjdChlbGVtZW50c1swXS52YWx1ZSkudG9CZSgxKTtcblx0XHRleHBlY3QoZWxlbWVudHNbMV0ua2luZCkudG9CZShcImxpdGVyYWxcIik7XG5cdFx0ZXhwZWN0KGVsZW1lbnRzWzFdLnZhbHVlKS50b0JlKDIpO1xuXHRcdGV4cGVjdChlbGVtZW50c1syXS5raW5kKS50b0JlKFwibGl0ZXJhbFwiKTtcblx0XHRleHBlY3QoZWxlbWVudHNbMl0udmFsdWUpLnRvQmUoMyk7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgaWYgZXhwcmVzc2lvbnNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiaWYgVHJ1ZSB0aGVuIDEgZWxzZSAyXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50c1swXS5raW5kKS50b0JlKFwiaWZcIik7XG5cdFx0Y29uc3QgaWZFeHByID0gcHJvZ3JhbS5zdGF0ZW1lbnRzWzBdIGFzIGFueTtcblx0XHRleHBlY3QoaWZFeHByLmNvbmRpdGlvbi5uYW1lKS50b0JlKFwiVHJ1ZVwiKTtcblx0XHRleHBlY3QoaWZFeHByLnRoZW4udmFsdWUpLnRvQmUoMSk7XG5cdFx0ZXhwZWN0KGlmRXhwci5lbHNlLnZhbHVlKS50b0JlKDIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIHBpcGVsaW5lIGV4cHJlc3Npb25zXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIlsxLCAyLCAzXSB8PiBtYXBcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0Y29uc3QgcGlwZWxpbmUgPSBwcm9ncmFtLnN0YXRlbWVudHNbMF0gYXMgYW55O1xuXHRcdGV4cGVjdChwaXBlbGluZS5raW5kKS50b0JlKFwicGlwZWxpbmVcIik7XG5cdFx0ZXhwZWN0KHBpcGVsaW5lLnN0ZXBzWzBdLmtpbmQpLnRvQmUoXCJsaXN0XCIpO1xuXHRcdGV4cGVjdChwaXBlbGluZS5zdGVwc1sxXS5raW5kKS50b0JlKFwidmFyaWFibGVcIik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2Ugc2luZ2xlLWZpZWxkIHJlY29yZFwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoJ3sgQG5hbWUgXCJBbGljZVwiLCBAYWdlIDMwIH0nKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdLmtpbmQpLnRvQmUoXCJyZWNvcmRcIik7XG5cdFx0Y29uc3QgcmVjb3JkID0gcHJvZ3JhbS5zdGF0ZW1lbnRzWzBdIGFzIGFueTtcblx0XHRleHBlY3QocmVjb3JkLmZpZWxkcykudG9IYXZlTGVuZ3RoKDIpO1xuXHRcdGV4cGVjdChyZWNvcmQuZmllbGRzWzBdLm5hbWUpLnRvQmUoXCJuYW1lXCIpO1xuXHRcdGV4cGVjdChyZWNvcmQuZmllbGRzWzBdLnZhbHVlLnZhbHVlKS50b0JlKFwiQWxpY2VcIik7XG5cdFx0ZXhwZWN0KHJlY29yZC5maWVsZHNbMV0ubmFtZSkudG9CZShcImFnZVwiKTtcblx0XHRleHBlY3QocmVjb3JkLmZpZWxkc1sxXS52YWx1ZS52YWx1ZSkudG9CZSgzMCk7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgbXVsdGktZmllbGQgcmVjb3JkIChzZW1pY29sb24gc2VwYXJhdGVkKVwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoJ3sgQG5hbWUgXCJBbGljZVwiLCBAYWdlIDMwIH0nKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdLmtpbmQpLnRvQmUoXCJyZWNvcmRcIik7XG5cdFx0Y29uc3QgcmVjb3JkID0gcHJvZ3JhbS5zdGF0ZW1lbnRzWzBdIGFzIGFueTtcblx0XHRleHBlY3QocmVjb3JkLmZpZWxkcykudG9IYXZlTGVuZ3RoKDIpO1xuXHRcdGV4cGVjdChyZWNvcmQuZmllbGRzWzBdLm5hbWUpLnRvQmUoXCJuYW1lXCIpO1xuXHRcdGV4cGVjdChyZWNvcmQuZmllbGRzWzBdLnZhbHVlLnZhbHVlKS50b0JlKFwiQWxpY2VcIik7XG5cdFx0ZXhwZWN0KHJlY29yZC5maWVsZHNbMV0ubmFtZSkudG9CZShcImFnZVwiKTtcblx0XHRleHBlY3QocmVjb3JkLmZpZWxkc1sxXS52YWx1ZS52YWx1ZSkudG9CZSgzMCk7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgbXVsdGktZmllbGQgcmVjb3JkIChzZW1pY29sb24gc2VwYXJhdGVkKVwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoJ3sgQG5hbWUgXCJBbGljZVwiLCBAYWdlIDMwIH0nKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdLmtpbmQpLnRvQmUoXCJyZWNvcmRcIik7XG5cdFx0Y29uc3QgcmVjb3JkID0gcHJvZ3JhbS5zdGF0ZW1lbnRzWzBdIGFzIGFueTtcblx0XHRleHBlY3QocmVjb3JkLmZpZWxkcykudG9IYXZlTGVuZ3RoKDIpO1xuXHRcdGV4cGVjdChyZWNvcmQuZmllbGRzWzBdLm5hbWUpLnRvQmUoXCJuYW1lXCIpO1xuXHRcdGV4cGVjdChyZWNvcmQuZmllbGRzWzBdLnZhbHVlLnZhbHVlKS50b0JlKFwiQWxpY2VcIik7XG5cdFx0ZXhwZWN0KHJlY29yZC5maWVsZHNbMV0ubmFtZSkudG9CZShcImFnZVwiKTtcblx0XHRleHBlY3QocmVjb3JkLmZpZWxkc1sxXS52YWx1ZS52YWx1ZSkudG9CZSgzMCk7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgYWNjZXNzb3JcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiQG5hbWVcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50c1swXS5raW5kKS50b0JlKFwiYWNjZXNzb3JcIik7XG5cdFx0Y29uc3QgYWNjZXNzb3IgPSBwcm9ncmFtLnN0YXRlbWVudHNbMF0gYXMgYW55O1xuXHRcdGV4cGVjdChhY2Nlc3Nvci5maWVsZCkudG9CZShcIm5hbWVcIik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgZnVuY3Rpb24gd2l0aCB1bml0IHBhcmFtZXRlclwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJmbiB7fSA9PiA0MlwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBmdW5jID0gYXNzZXJ0RnVuY3Rpb25FeHByZXNzaW9uKHByb2dyYW0uc3RhdGVtZW50c1swXSk7XG5cdFx0ZXhwZWN0KGZ1bmMucGFyYW1zKS50b0VxdWFsKFtcIl91bml0XCJdKTsgLy8gVW5pdCBwYXJhbWV0ZXJcblx0XHRleHBlY3QoZnVuYy5ib2R5LmtpbmQpLnRvQmUoXCJsaXRlcmFsXCIpO1xuXHRcdGV4cGVjdCgoZnVuYy5ib2R5IGFzIExpdGVyYWxFeHByZXNzaW9uKS52YWx1ZSkudG9CZSg0Mik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgZGVlcGx5IG5lc3RlZCB0dXBsZXMgaW4gcmVjb3Jkc1wiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJ7IEBrZXkgWzEsIHt7ezF9fX1dIH1cIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHQvLyBDaGVjayB0aGUgb3V0ZXJtb3N0IHJlY29yZFxuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBvdXRlciA9IHByb2dyYW0uc3RhdGVtZW50c1swXTtcblx0XHRleHBlY3Qob3V0ZXIua2luZCkudG9CZShcInJlY29yZFwiKTtcblx0XHRjb25zdCBrZXlGaWVsZCA9IChvdXRlciBhcyBhbnkpLmZpZWxkc1swXTtcblx0XHRleHBlY3Qoa2V5RmllbGQubmFtZSkudG9CZShcImtleVwiKTtcblx0XHQvLyBDaGVjayB0aGF0IGtleUZpZWxkLnZhbHVlIGlzIGEgbGlzdCB3aXRoIHR3byBlbGVtZW50c1xuXHRcdGV4cGVjdChrZXlGaWVsZC52YWx1ZS5raW5kKS50b0JlKFwibGlzdFwiKTtcblx0XHRleHBlY3Qoa2V5RmllbGQudmFsdWUuZWxlbWVudHMpLnRvSGF2ZUxlbmd0aCgyKTtcblx0XHQvLyBGaXJzdCBlbGVtZW50IHNob3VsZCBiZSBhIGxpdGVyYWxcblx0XHRleHBlY3Qoa2V5RmllbGQudmFsdWUuZWxlbWVudHNbMF0ua2luZCkudG9CZShcImxpdGVyYWxcIik7XG5cdFx0ZXhwZWN0KGtleUZpZWxkLnZhbHVlLmVsZW1lbnRzWzBdLnZhbHVlKS50b0JlKDEpO1xuXHRcdC8vIFNlY29uZCBlbGVtZW50IHNob3VsZCBiZSBhIG5lc3RlZCB0dXBsZSBzdHJ1Y3R1cmVcblx0XHRsZXQgbmVzdGVkVHVwbGUgPSBrZXlGaWVsZC52YWx1ZS5lbGVtZW50c1sxXTtcblx0XHRleHBlY3QobmVzdGVkVHVwbGUua2luZCkudG9CZShcInR1cGxlXCIpO1xuXHRcdC8vIENoZWNrIHRoZSBuZXN0ZWQgc3RydWN0dXJlOiB0dXBsZSAtPiB0dXBsZSAtPiB0dXBsZSAtPiBsaXRlcmFsXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdGV4cGVjdChuZXN0ZWRUdXBsZS5raW5kKS50b0JlKFwidHVwbGVcIik7XG5cdFx0XHRleHBlY3QobmVzdGVkVHVwbGUuZWxlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRcdG5lc3RlZFR1cGxlID0gbmVzdGVkVHVwbGUuZWxlbWVudHNbMF07XG5cdFx0fVxuXHRcdGV4cGVjdChuZXN0ZWRUdXBsZS5raW5kKS50b0JlKFwibGl0ZXJhbFwiKTtcblx0XHRleHBlY3QobmVzdGVkVHVwbGUudmFsdWUpLnRvQmUoMSk7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgcmVjb3JkcyB3aXRoIG5lc3RlZCBsaXN0cyBhbmQgcmVjb3Jkc1wiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJ7IEBrZXkgWzEsIHsgQGlubmVyIFsyLCAzXSB9XSB9XCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IG91dGVyID0gcHJvZ3JhbS5zdGF0ZW1lbnRzWzBdO1xuXHRcdGV4cGVjdChvdXRlci5raW5kKS50b0JlKFwicmVjb3JkXCIpO1xuXHRcdGNvbnN0IGtleUZpZWxkID0gKG91dGVyIGFzIGFueSkuZmllbGRzWzBdO1xuXHRcdGV4cGVjdChrZXlGaWVsZC5uYW1lKS50b0JlKFwia2V5XCIpO1xuXHRcdGNvbnN0IGxpc3QgPSBrZXlGaWVsZC52YWx1ZSBhcyBhbnk7XG5cdFx0ZXhwZWN0KGxpc3Qua2luZCkudG9CZShcImxpc3RcIik7XG5cdFx0ZXhwZWN0KGxpc3QuZWxlbWVudHNbMF0ua2luZCkudG9CZShcImxpdGVyYWxcIik7XG5cdFx0ZXhwZWN0KGxpc3QuZWxlbWVudHNbMF0udmFsdWUpLnRvQmUoMSk7XG5cdFx0Y29uc3QgbmVzdGVkUmVjb3JkID0gbGlzdC5lbGVtZW50c1sxXTtcblx0XHRleHBlY3QobmVzdGVkUmVjb3JkLmtpbmQpLnRvQmUoXCJyZWNvcmRcIik7XG5cdFx0Y29uc3QgaW5uZXJGaWVsZCA9IG5lc3RlZFJlY29yZC5maWVsZHNbMF07XG5cdFx0ZXhwZWN0KGlubmVyRmllbGQubmFtZSkudG9CZShcImlubmVyXCIpO1xuXHRcdGNvbnN0IGlubmVyTGlzdCA9IGlubmVyRmllbGQudmFsdWUgYXMgYW55O1xuXHRcdGV4cGVjdChpbm5lckxpc3Qua2luZCkudG9CZShcImxpc3RcIik7XG5cdFx0ZXhwZWN0KGlubmVyTGlzdC5lbGVtZW50cy5tYXAoKGU6IGFueSkgPT4gZS52YWx1ZSkpLnRvRXF1YWwoWzIsIDNdKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSBsaXN0cyBvZiByZWNvcmRzXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIlt7IEBhIDEgfSwgeyBAYiAyIH1dXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IGxpc3QgPSBwcm9ncmFtLnN0YXRlbWVudHNbMF0gYXMgYW55O1xuXHRcdGV4cGVjdChsaXN0LmtpbmQpLnRvQmUoXCJsaXN0XCIpO1xuXHRcdGV4cGVjdChsaXN0LmVsZW1lbnRzWzBdLmtpbmQpLnRvQmUoXCJyZWNvcmRcIik7XG5cdFx0ZXhwZWN0KGxpc3QuZWxlbWVudHNbMV0ua2luZCkudG9CZShcInJlY29yZFwiKTtcblx0XHRleHBlY3QobGlzdC5lbGVtZW50c1swXS5maWVsZHNbMF0ubmFtZSkudG9CZShcImFcIik7XG5cdFx0ZXhwZWN0KGxpc3QuZWxlbWVudHNbMF0uZmllbGRzWzBdLnZhbHVlLnZhbHVlKS50b0JlKDEpO1xuXHRcdGV4cGVjdChsaXN0LmVsZW1lbnRzWzFdLmZpZWxkc1swXS5uYW1lKS50b0JlKFwiYlwiKTtcblx0XHRleHBlY3QobGlzdC5lbGVtZW50c1sxXS5maWVsZHNbMF0udmFsdWUudmFsdWUpLnRvQmUoMik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgYSBzaW5nbGUgdHVwbGVcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiezF9XCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IHR1cGxlID0gcHJvZ3JhbS5zdGF0ZW1lbnRzWzBdIGFzIGFueTtcblx0XHRleHBlY3QodHVwbGUua2luZCkudG9CZShcInR1cGxlXCIpO1xuXHRcdGV4cGVjdCh0dXBsZS5lbGVtZW50c1swXS5raW5kKS50b0JlKFwibGl0ZXJhbFwiKTtcblx0XHRleHBlY3QodHVwbGUuZWxlbWVudHNbMF0udmFsdWUpLnRvQmUoMSk7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgYSBzaW5nbGUgcmVjb3JkXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcInsgQGZvbyAxIH1cIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0Y29uc3QgcmVjb3JkID0gcHJvZ3JhbS5zdGF0ZW1lbnRzWzBdIGFzIGFueTtcblx0XHRleHBlY3QocmVjb3JkLmtpbmQpLnRvQmUoXCJyZWNvcmRcIik7XG5cdFx0ZXhwZWN0KHJlY29yZC5maWVsZHNbMF0ubmFtZSkudG9CZShcImZvb1wiKTtcblx0XHRleHBlY3QocmVjb3JkLmZpZWxkc1swXS52YWx1ZS52YWx1ZSkudG9CZSgxKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSBhIGxpc3Qgb2YgbGl0ZXJhbHNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiWzEsIDJdXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IGxpc3QgPSBwcm9ncmFtLnN0YXRlbWVudHNbMF0gYXMgYW55O1xuXHRcdGV4cGVjdChsaXN0LmtpbmQpLnRvQmUoXCJsaXN0XCIpO1xuXHRcdGV4cGVjdChsaXN0LmVsZW1lbnRzWzBdLmtpbmQpLnRvQmUoXCJsaXRlcmFsXCIpO1xuXHRcdGV4cGVjdChsaXN0LmVsZW1lbnRzWzBdLnZhbHVlKS50b0JlKDEpO1xuXHRcdGV4cGVjdChsaXN0LmVsZW1lbnRzWzFdLmtpbmQpLnRvQmUoXCJsaXRlcmFsXCIpO1xuXHRcdGV4cGVjdChsaXN0LmVsZW1lbnRzWzFdLnZhbHVlKS50b0JlKDIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIGEgbGlzdCBvZiB0dXBsZXNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiW3sxfSwgezJ9XVwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBsaXN0ID0gcHJvZ3JhbS5zdGF0ZW1lbnRzWzBdIGFzIGFueTtcblx0XHRleHBlY3QobGlzdC5raW5kKS50b0JlKFwibGlzdFwiKTtcblx0XHRleHBlY3QobGlzdC5lbGVtZW50c1swXS5raW5kKS50b0JlKFwidHVwbGVcIik7XG5cdFx0ZXhwZWN0KGxpc3QuZWxlbWVudHNbMF0uZWxlbWVudHNbMF0udmFsdWUpLnRvQmUoMSk7XG5cdFx0ZXhwZWN0KGxpc3QuZWxlbWVudHNbMV0ua2luZCkudG9CZShcInR1cGxlXCIpO1xuXHRcdGV4cGVjdChsaXN0LmVsZW1lbnRzWzFdLmVsZW1lbnRzWzBdLnZhbHVlKS50b0JlKDIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIGEgbGlzdCBvZiByZWNvcmRzXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIlt7IEBmb28gMSB9LCB7IEBiYXIgMiB9XVwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBsaXN0ID0gcHJvZ3JhbS5zdGF0ZW1lbnRzWzBdIGFzIGFueTtcblx0XHRleHBlY3QobGlzdC5raW5kKS50b0JlKFwibGlzdFwiKTtcblx0XHRleHBlY3QobGlzdC5lbGVtZW50c1swXS5raW5kKS50b0JlKFwicmVjb3JkXCIpO1xuXHRcdGV4cGVjdChsaXN0LmVsZW1lbnRzWzBdLmZpZWxkc1swXS5uYW1lKS50b0JlKFwiZm9vXCIpO1xuXHRcdGV4cGVjdChsaXN0LmVsZW1lbnRzWzBdLmZpZWxkc1swXS52YWx1ZS52YWx1ZSkudG9CZSgxKTtcblx0XHRleHBlY3QobGlzdC5lbGVtZW50c1sxXS5raW5kKS50b0JlKFwicmVjb3JkXCIpO1xuXHRcdGV4cGVjdChsaXN0LmVsZW1lbnRzWzFdLmZpZWxkc1swXS5uYW1lKS50b0JlKFwiYmFyXCIpO1xuXHRcdGV4cGVjdChsaXN0LmVsZW1lbnRzWzFdLmZpZWxkc1swXS52YWx1ZS52YWx1ZSkudG9CZSgyKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSB0aHJ1c2ggb3BlcmF0b3JcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiMTAgfCAoZm4geCA9PiB4ICsgMSlcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0Y29uc3QgdGhydXNoID0gcHJvZ3JhbS5zdGF0ZW1lbnRzWzBdIGFzIGFueTtcblx0XHRleHBlY3QodGhydXNoLmtpbmQpLnRvQmUoXCJiaW5hcnlcIik7XG5cdFx0ZXhwZWN0KHRocnVzaC5vcGVyYXRvcikudG9CZShcInxcIik7XG5cdFx0ZXhwZWN0KHRocnVzaC5sZWZ0LmtpbmQpLnRvQmUoXCJsaXRlcmFsXCIpO1xuXHRcdGV4cGVjdCh0aHJ1c2gucmlnaHQua2luZCkudG9CZShcImZ1bmN0aW9uXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIGNoYWluZWQgdGhydXNoIG9wZXJhdG9ycyBhcyBsZWZ0LWFzc29jaWF0aXZlXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcImEgfCBiIHwgY1wiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBjaGFpbiA9IHByb2dyYW0uc3RhdGVtZW50c1swXSBhcyBhbnk7XG5cdFx0ZXhwZWN0KGNoYWluLmtpbmQpLnRvQmUoXCJiaW5hcnlcIik7XG5cdFx0ZXhwZWN0KGNoYWluLm9wZXJhdG9yKS50b0JlKFwifFwiKTtcblx0XHRleHBlY3QoY2hhaW4ubGVmdC5raW5kKS50b0JlKFwiYmluYXJ5XCIpO1xuXHRcdGV4cGVjdChjaGFpbi5sZWZ0Lm9wZXJhdG9yKS50b0JlKFwifFwiKTtcblx0XHRleHBlY3QoY2hhaW4ubGVmdC5sZWZ0LmtpbmQpLnRvQmUoXCJ2YXJpYWJsZVwiKTtcblx0XHRleHBlY3QoY2hhaW4ubGVmdC5sZWZ0Lm5hbWUpLnRvQmUoXCJhXCIpO1xuXHRcdGV4cGVjdChjaGFpbi5sZWZ0LnJpZ2h0LmtpbmQpLnRvQmUoXCJ2YXJpYWJsZVwiKTtcblx0XHRleHBlY3QoY2hhaW4ubGVmdC5yaWdodC5uYW1lKS50b0JlKFwiYlwiKTtcblx0XHRleHBlY3QoY2hhaW4ucmlnaHQua2luZCkudG9CZShcInZhcmlhYmxlXCIpO1xuXHRcdGV4cGVjdChjaGFpbi5yaWdodC5uYW1lKS50b0JlKFwiY1wiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSB0aHJ1c2ggb3BlcmF0b3IgYWZ0ZXIgcmVjb3JkXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIntAa2V5IDEsIEBrZXkyIEZhbHNlfSB8IEBrZXlcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cblx0XHQvLyBWZXJpZnkgaXQncyBhIGJpbmFyeSBleHByZXNzaW9uIHdpdGggdGhydXNoIG9wZXJhdG9yXG5cdFx0Y29uc3QgZXhwciA9IHByb2dyYW0uc3RhdGVtZW50c1swXSBhcyBCaW5hcnlFeHByZXNzaW9uO1xuXHRcdGV4cGVjdChleHByLmtpbmQpLnRvQmUoXCJiaW5hcnlcIik7XG5cdFx0ZXhwZWN0KGV4cHIub3BlcmF0b3IpLnRvQmUoXCJ8XCIpO1xuXHRcdGV4cGVjdChleHByLmxlZnQua2luZCkudG9CZShcInJlY29yZFwiKTtcblx0XHRleHBlY3QoZXhwci5yaWdodC5raW5kKS50b0JlKFwiYWNjZXNzb3JcIik7XG5cdH0pO1xuXG5cdC8vIEFkZCB0ZXN0cyBmb3IgZW1wdHkgdW5pdCBleHByZXNzaW9uXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgZW1wdHkgYnJhY2VzIGFzIHVuaXRcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwie31cIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0Y29uc3QgdW5pdCA9IGFzc2VydFVuaXRFeHByZXNzaW9uKHByb2dyYW0uc3RhdGVtZW50c1swXSk7XG5cdFx0ZXhwZWN0KHVuaXQua2luZCkudG9CZShcInVuaXRcIik7XG5cdH0pO1xuXG5cdC8vIEFkZCB0ZXN0cyBmb3IgZnVuY3Rpb24gd2l0aCBlbXB0eSBwYXJlbnRoZXNlc1xuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIGZ1bmN0aW9uIHdpdGggZW1wdHkgcGFyZW50aGVzZXNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiZm4gKCkgPT4gNDJcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0Y29uc3QgZnVuYyA9IGFzc2VydEZ1bmN0aW9uRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChmdW5jLnBhcmFtcykudG9FcXVhbChbXSk7XG5cdFx0ZXhwZWN0KGZ1bmMuYm9keS5raW5kKS50b0JlKFwibGl0ZXJhbFwiKTtcblx0fSk7XG5cblx0Ly8gQWRkIHRlc3RzIGZvciBmdW5jdGlvbiB3aXRoIG11bHRpcGxlIHBhcmFtZXRlcnNcblx0dGVzdChcInNob3VsZCBwYXJzZSBmdW5jdGlvbiB3aXRoIG11bHRpcGxlIHBhcmFtZXRlcnNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiZm4geCB5IHogPT4geCArIHkgKyB6XCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IGZ1bmMgPSBhc3NlcnRGdW5jdGlvbkV4cHJlc3Npb24ocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdKTtcblx0XHRleHBlY3QoZnVuYy5wYXJhbXMpLnRvRXF1YWwoW1wieFwiLCBcInlcIiwgXCJ6XCJdKTtcblx0XHRleHBlY3QoZnVuYy5ib2R5LmtpbmQpLnRvQmUoXCJiaW5hcnlcIik7XG5cdH0pO1xuXG5cdC8vIEFkZCB0ZXN0cyBmb3IgZW1wdHkgbGlzdHNcblx0dGVzdChcInNob3VsZCBwYXJzZSBlbXB0eSBsaXN0XCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIltdXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHNbMF0ua2luZCkudG9CZShcImxpc3RcIik7XG5cdFx0Y29uc3QgbGlzdCA9IHByb2dyYW0uc3RhdGVtZW50c1swXSBhcyBhbnk7XG5cdFx0ZXhwZWN0KGxpc3QuZWxlbWVudHMpLnRvSGF2ZUxlbmd0aCgwKTtcblx0fSk7XG5cblx0Ly8gQWRkIHRlc3RzIGZvciBsaXN0cyB3aXRoIHRyYWlsaW5nIGNvbW1hc1xuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIGxpc3Qgd2l0aCB0cmFpbGluZyBjb21tYVwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJbMSwgMiwgMyxdXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHNbMF0ua2luZCkudG9CZShcImxpc3RcIik7XG5cdFx0Y29uc3QgbGlzdCA9IHByb2dyYW0uc3RhdGVtZW50c1swXSBhcyBhbnk7XG5cdFx0ZXhwZWN0KGxpc3QuZWxlbWVudHMpLnRvSGF2ZUxlbmd0aCgzKTtcblx0fSk7XG5cblx0Ly8gQWRkIHRlc3RzIGZvciByZWNvcmRzIHdpdGggdHJhaWxpbmcgY29tbWFzXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgcmVjb3JkIHdpdGggdHJhaWxpbmcgY29tbWFcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwieyBAbmFtZSBcXFwiQWxpY2VcXFwiLCBAYWdlIDMwLCB9XCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHNbMF0ua2luZCkudG9CZShcInJlY29yZFwiKTtcblx0XHRjb25zdCByZWNvcmQgPSBwcm9ncmFtLnN0YXRlbWVudHNbMF0gYXMgYW55O1xuXHRcdGV4cGVjdChyZWNvcmQuZmllbGRzKS50b0hhdmVMZW5ndGgoMik7XG5cdH0pO1xuXG5cdC8vIEFkZCB0ZXN0cyBmb3IgdW5hcnkgbWludXMgKGFkamFjZW50KVxuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIHVuYXJ5IG1pbnVzIChhZGphY2VudClcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiLTQyXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHNbMF0ua2luZCkudG9CZShcImJpbmFyeVwiKTtcblx0XHRjb25zdCBiaW5hcnkgPSBwcm9ncmFtLnN0YXRlbWVudHNbMF0gYXMgYW55O1xuXHRcdGV4cGVjdChiaW5hcnkub3BlcmF0b3IpLnRvQmUoXCIqXCIpO1xuXHRcdGV4cGVjdChiaW5hcnkubGVmdC5raW5kKS50b0JlKFwibGl0ZXJhbFwiKTtcblx0XHRleHBlY3QoYmluYXJ5LmxlZnQudmFsdWUpLnRvQmUoLTEpO1xuXHRcdGV4cGVjdChiaW5hcnkucmlnaHQua2luZCkudG9CZShcImxpdGVyYWxcIik7XG5cdFx0ZXhwZWN0KGJpbmFyeS5yaWdodC52YWx1ZSkudG9CZSg0Mik7XG5cdH0pO1xuXG5cdC8vIEFkZCB0ZXN0cyBmb3IgbWludXMgb3BlcmF0b3IgKG5vbi1hZGphY2VudClcblx0dGVzdChcInNob3VsZCBwYXJzZSBtaW51cyBvcGVyYXRvciAobm9uLWFkamFjZW50KVwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCIxMCAtIDVcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50c1swXS5raW5kKS50b0JlKFwiYmluYXJ5XCIpO1xuXHRcdGNvbnN0IGJpbmFyeSA9IHByb2dyYW0uc3RhdGVtZW50c1swXSBhcyBhbnk7XG5cdFx0ZXhwZWN0KGJpbmFyeS5vcGVyYXRvcikudG9CZShcIi1cIik7XG5cdFx0ZXhwZWN0KGJpbmFyeS5sZWZ0LmtpbmQpLnRvQmUoXCJsaXRlcmFsXCIpO1xuXHRcdGV4cGVjdChiaW5hcnkubGVmdC52YWx1ZSkudG9CZSgxMCk7XG5cdFx0ZXhwZWN0KGJpbmFyeS5yaWdodC5raW5kKS50b0JlKFwibGl0ZXJhbFwiKTtcblx0XHRleHBlY3QoYmluYXJ5LnJpZ2h0LnZhbHVlKS50b0JlKDUpO1xuXHR9KTtcbn0pO1xuXG4vLyBBZGQgbmV3IHRlc3Qgc3VpdGUgZm9yIFR5cGUgRGVmaW5pdGlvbnMgKEFEVHMpXG5kZXNjcmliZShcIlR5cGUgRGVmaW5pdGlvbnMgKEFEVHMpXCIsICgpID0+IHtcblx0dGVzdChcInNob3VsZCBwYXJzZSBzaW1wbGUgdHlwZSBkZWZpbml0aW9uXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcInR5cGUgQm9vbCA9IFRydWUgfCBGYWxzZVwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCB0eXBlRGVmID0gYXNzZXJ0VHlwZURlZmluaXRpb25FeHByZXNzaW9uKHByb2dyYW0uc3RhdGVtZW50c1swXSk7XG5cdFx0ZXhwZWN0KHR5cGVEZWYubmFtZSkudG9CZShcIkJvb2xcIik7XG5cdFx0ZXhwZWN0KHR5cGVEZWYudHlwZVBhcmFtcykudG9FcXVhbChbXSk7XG5cdFx0ZXhwZWN0KHR5cGVEZWYuY29uc3RydWN0b3JzKS50b0hhdmVMZW5ndGgoMik7XG5cdFx0ZXhwZWN0KHR5cGVEZWYuY29uc3RydWN0b3JzWzBdLm5hbWUpLnRvQmUoXCJUcnVlXCIpO1xuXHRcdGV4cGVjdCh0eXBlRGVmLmNvbnN0cnVjdG9yc1swXS5hcmdzKS50b0VxdWFsKFtdKTtcblx0XHRleHBlY3QodHlwZURlZi5jb25zdHJ1Y3RvcnNbMV0ubmFtZSkudG9CZShcIkZhbHNlXCIpO1xuXHRcdGV4cGVjdCh0eXBlRGVmLmNvbnN0cnVjdG9yc1sxXS5hcmdzKS50b0VxdWFsKFtdKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSB0eXBlIGRlZmluaXRpb24gd2l0aCBwYXJhbWV0ZXJzXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcInR5cGUgT3B0aW9uIGEgPSBOb25lIHwgU29tZSBhXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IHR5cGVEZWYgPSBhc3NlcnRUeXBlRGVmaW5pdGlvbkV4cHJlc3Npb24ocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdKTtcblx0XHRleHBlY3QodHlwZURlZi5uYW1lKS50b0JlKFwiT3B0aW9uXCIpO1xuXHRcdGV4cGVjdCh0eXBlRGVmLnR5cGVQYXJhbXMpLnRvRXF1YWwoW1wiYVwiXSk7XG5cdFx0ZXhwZWN0KHR5cGVEZWYuY29uc3RydWN0b3JzKS50b0hhdmVMZW5ndGgoMik7XG5cdFx0ZXhwZWN0KHR5cGVEZWYuY29uc3RydWN0b3JzWzBdLm5hbWUpLnRvQmUoXCJOb25lXCIpO1xuXHRcdGV4cGVjdCh0eXBlRGVmLmNvbnN0cnVjdG9yc1swXS5hcmdzKS50b0VxdWFsKFtdKTtcblx0XHRleHBlY3QodHlwZURlZi5jb25zdHJ1Y3RvcnNbMV0ubmFtZSkudG9CZShcIlNvbWVcIik7XG5cdFx0ZXhwZWN0KHR5cGVEZWYuY29uc3RydWN0b3JzWzFdLmFyZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSB0eXBlIGRlZmluaXRpb24gd2l0aCBjb21wbGV4IGNvbnN0cnVjdG9yc1wiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJ0eXBlIEVpdGhlciBhIGIgPSBMZWZ0IGEgfCBSaWdodCBiXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IHR5cGVEZWYgPSBhc3NlcnRUeXBlRGVmaW5pdGlvbkV4cHJlc3Npb24ocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdKTtcblx0XHRleHBlY3QodHlwZURlZi5uYW1lKS50b0JlKFwiRWl0aGVyXCIpO1xuXHRcdGV4cGVjdCh0eXBlRGVmLnR5cGVQYXJhbXMpLnRvRXF1YWwoW1wiYVwiLCBcImJcIl0pO1xuXHRcdGV4cGVjdCh0eXBlRGVmLmNvbnN0cnVjdG9ycykudG9IYXZlTGVuZ3RoKDIpO1xuXHRcdGV4cGVjdCh0eXBlRGVmLmNvbnN0cnVjdG9yc1swXS5uYW1lKS50b0JlKFwiTGVmdFwiKTtcblx0XHRleHBlY3QodHlwZURlZi5jb25zdHJ1Y3RvcnNbMV0ubmFtZSkudG9CZShcIlJpZ2h0XCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIHR5cGUgZGVmaW5pdGlvbiB3aXRoIG11bHRpcGxlIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1wiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJ0eXBlIFBlcnNvbiA9IFBlcnNvbiBTdHJpbmcgTnVtYmVyXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IHR5cGVEZWYgPSBhc3NlcnRUeXBlRGVmaW5pdGlvbkV4cHJlc3Npb24ocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdKTtcblx0XHRleHBlY3QodHlwZURlZi5uYW1lKS50b0JlKFwiUGVyc29uXCIpO1xuXHRcdGV4cGVjdCh0eXBlRGVmLmNvbnN0cnVjdG9ycykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGV4cGVjdCh0eXBlRGVmLmNvbnN0cnVjdG9yc1swXS5uYW1lKS50b0JlKFwiUGVyc29uXCIpO1xuXHRcdGV4cGVjdCh0eXBlRGVmLmNvbnN0cnVjdG9yc1swXS5hcmdzKS50b0hhdmVMZW5ndGgoMik7XG5cdH0pO1xufSk7XG5cbi8vIEFkZCBuZXcgdGVzdCBzdWl0ZSBmb3IgUGF0dGVybiBNYXRjaGluZ1xuZGVzY3JpYmUoXCJQYXR0ZXJuIE1hdGNoaW5nXCIsICgpID0+IHtcblx0dGVzdChcInNob3VsZCBwYXJzZSBzaW1wbGUgbWF0Y2ggZXhwcmVzc2lvblwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJtYXRjaCB4IHdpdGggKCBUcnVlID0+IDE7IEZhbHNlID0+IDAgKVwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBtYXRjaEV4cHIgPSBhc3NlcnRNYXRjaEV4cHJlc3Npb24ocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdKTtcblx0XHRleHBlY3QobWF0Y2hFeHByLmV4cHJlc3Npb24ua2luZCkudG9CZShcInZhcmlhYmxlXCIpO1xuXHRcdGV4cGVjdChtYXRjaEV4cHIuY2FzZXMpLnRvSGF2ZUxlbmd0aCgyKTtcblx0XHRleHBlY3QobWF0Y2hFeHByLmNhc2VzWzBdLnBhdHRlcm4ua2luZCkudG9CZShcImNvbnN0cnVjdG9yXCIpO1xuXHRcdGV4cGVjdCgobWF0Y2hFeHByLmNhc2VzWzBdLnBhdHRlcm4gYXMgYW55KS5uYW1lKS50b0JlKFwiVHJ1ZVwiKTtcblx0XHRleHBlY3QobWF0Y2hFeHByLmNhc2VzWzBdLmV4cHJlc3Npb24ua2luZCkudG9CZShcImxpdGVyYWxcIik7XG5cdFx0ZXhwZWN0KChtYXRjaEV4cHIuY2FzZXNbMF0uZXhwcmVzc2lvbiBhcyBhbnkpLnZhbHVlKS50b0JlKDEpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIG1hdGNoIHdpdGggdmFyaWFibGUgcGF0dGVybnNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwibWF0Y2ggeCB3aXRoICggU29tZSB5ID0+IHk7IE5vbmUgPT4gMCApXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IG1hdGNoRXhwciA9IGFzc2VydE1hdGNoRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChtYXRjaEV4cHIuY2FzZXMpLnRvSGF2ZUxlbmd0aCgyKTtcblx0XHRleHBlY3QobWF0Y2hFeHByLmNhc2VzWzBdLnBhdHRlcm4ua2luZCkudG9CZShcImNvbnN0cnVjdG9yXCIpO1xuXHRcdGV4cGVjdCgobWF0Y2hFeHByLmNhc2VzWzBdLnBhdHRlcm4gYXMgYW55KS5uYW1lKS50b0JlKFwiU29tZVwiKTtcblx0XHRleHBlY3QoKG1hdGNoRXhwci5jYXNlc1swXS5wYXR0ZXJuIGFzIGFueSkuYXJncykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGV4cGVjdCgobWF0Y2hFeHByLmNhc2VzWzBdLnBhdHRlcm4gYXMgYW55KS5hcmdzWzBdLmtpbmQpLnRvQmUoXCJ2YXJpYWJsZVwiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSBtYXRjaCB3aXRoIHdpbGRjYXJkIHBhdHRlcm5zXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIm1hdGNoIHggd2l0aCAoIFNvbWUgXyA9PiAxOyBfID0+IDAgKVwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBtYXRjaEV4cHIgPSBhc3NlcnRNYXRjaEV4cHJlc3Npb24ocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdKTtcblx0XHRleHBlY3QobWF0Y2hFeHByLmNhc2VzKS50b0hhdmVMZW5ndGgoMik7XG5cdFx0ZXhwZWN0KG1hdGNoRXhwci5jYXNlc1swXS5wYXR0ZXJuLmtpbmQpLnRvQmUoXCJjb25zdHJ1Y3RvclwiKTtcblx0XHQvLyBOb3RlOiBfIGlzIHBhcnNlZCBhcyBhIHZhcmlhYmxlIHBhdHRlcm4gYmVjYXVzZSBpdCdzIGFuIGlkZW50aWZpZXIgaW4gdGhlIGxleGVyXG5cdFx0ZXhwZWN0KG1hdGNoRXhwci5jYXNlc1sxXS5wYXR0ZXJuLmtpbmQpLnRvQmUoXCJ2YXJpYWJsZVwiKTtcblx0XHRleHBlY3QoKG1hdGNoRXhwci5jYXNlc1sxXS5wYXR0ZXJuIGFzIGFueSkubmFtZSkudG9CZShcIl9cIik7XG5cdH0pO1xuXG5cdHRlc3Quc2tpcChcInNob3VsZCBwYXJzZSBtYXRjaCB3aXRoIGxpdGVyYWwgcGF0dGVybnNcIiwgKCkgPT4ge1xuXHRcdC8vIFRPRE86IFRoaXMgdGVzdCBpcyBza2lwcGVkIGR1ZSB0byBwYXJzZXIgcHJlY2VkZW5jZSBpc3N1ZXMgd2l0aCB0b3AtbGV2ZWwgbWF0Y2ggZXhwcmVzc2lvbnMuXG5cdFx0Ly8gVGhlIHBhcnNlciBjaG9pY2Ugb3JkZXJpbmcgY2F1c2VzIHBhcnNlTWF0Y2hFeHByZXNzaW9uIHRvIGNvbmZsaWN0IHdpdGggb3RoZXIgcGFyc2Vyc1xuXHRcdC8vIHdoZW4gcGFyc2luZyBhdCB0aGUgdG9wIGxldmVsLiBUaGlzIG5lZWRzIHBhcnNlciBhcmNoaXRlY3R1cmUgaW1wcm92ZW1lbnRzIHRvIHJlc29sdmUuXG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoJ21hdGNoIHggd2l0aCAoIDEgPT4gXCJvbmVcIjsgXCJoZWxsb1wiID0+IFwid29ybGRcIjsgXyA9PiBcIm90aGVyXCIgKScpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IG1hdGNoRXhwciA9IGFzc2VydE1hdGNoRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChtYXRjaEV4cHIuY2FzZXMpLnRvSGF2ZUxlbmd0aCgzKTtcblx0XHRleHBlY3QobWF0Y2hFeHByLmNhc2VzWzBdLnBhdHRlcm4ua2luZCkudG9CZShcImxpdGVyYWxcIik7XG5cdFx0ZXhwZWN0KChtYXRjaEV4cHIuY2FzZXNbMF0ucGF0dGVybiBhcyBhbnkpLnZhbHVlKS50b0JlKDEpO1xuXHRcdGV4cGVjdChtYXRjaEV4cHIuY2FzZXNbMV0ucGF0dGVybi5raW5kKS50b0JlKFwibGl0ZXJhbFwiKTtcblx0XHRleHBlY3QoKG1hdGNoRXhwci5jYXNlc1sxXS5wYXR0ZXJuIGFzIGFueSkudmFsdWUpLnRvQmUoXCJoZWxsb1wiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSBtYXRjaCB3aXRoIG5lc3RlZCBjb25zdHJ1Y3RvciBwYXR0ZXJuc1wiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJtYXRjaCB4IHdpdGggKCBXcmFwIChWYWx1ZSBuKSA9PiBuOyBfID0+IDAgKVwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBtYXRjaEV4cHIgPSBhc3NlcnRNYXRjaEV4cHJlc3Npb24ocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdKTtcblx0XHRleHBlY3QobWF0Y2hFeHByLmNhc2VzKS50b0hhdmVMZW5ndGgoMik7XG5cdFx0ZXhwZWN0KG1hdGNoRXhwci5jYXNlc1swXS5wYXR0ZXJuLmtpbmQpLnRvQmUoXCJjb25zdHJ1Y3RvclwiKTtcblx0XHRleHBlY3QoKG1hdGNoRXhwci5jYXNlc1swXS5wYXR0ZXJuIGFzIGFueSkubmFtZSkudG9CZShcIldyYXBcIik7XG5cdFx0ZXhwZWN0KChtYXRjaEV4cHIuY2FzZXNbMF0ucGF0dGVybiBhcyBhbnkpLmFyZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBuZXN0ZWRQYXR0ZXJuID0gKG1hdGNoRXhwci5jYXNlc1swXS5wYXR0ZXJuIGFzIGFueSkuYXJnc1swXTtcblx0XHRleHBlY3QobmVzdGVkUGF0dGVybi5raW5kKS50b0JlKFwiY29uc3RydWN0b3JcIik7XG5cdFx0ZXhwZWN0KG5lc3RlZFBhdHRlcm4ubmFtZSkudG9CZShcIlZhbHVlXCIpO1xuXHR9KTtcbn0pO1xuXG4vLyBBZGQgbmV3IHRlc3Qgc3VpdGUgZm9yIFdoZXJlIEV4cHJlc3Npb25zXG5kZXNjcmliZShcIldoZXJlIEV4cHJlc3Npb25zXCIsICgpID0+IHtcblx0dGVzdChcInNob3VsZCBwYXJzZSB3aGVyZSBleHByZXNzaW9uIHdpdGggc2luZ2xlIGRlZmluaXRpb25cIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwieCArIHkgd2hlcmUgKCB4ID0gMSApXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IHdoZXJlRXhwciA9IGFzc2VydFdoZXJlRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdCh3aGVyZUV4cHIubWFpbi5raW5kKS50b0JlKFwiYmluYXJ5XCIpO1xuXHRcdGV4cGVjdCh3aGVyZUV4cHIuZGVmaW5pdGlvbnMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRleHBlY3Qod2hlcmVFeHByLmRlZmluaXRpb25zWzBdLmtpbmQpLnRvQmUoXCJkZWZpbml0aW9uXCIpO1xuXHRcdGV4cGVjdCgod2hlcmVFeHByLmRlZmluaXRpb25zWzBdIGFzIGFueSkubmFtZSkudG9CZShcInhcIik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2Ugd2hlcmUgZXhwcmVzc2lvbiB3aXRoIG11bHRpcGxlIGRlZmluaXRpb25zXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcInggKyB5IHdoZXJlICggeCA9IDE7IHkgPSAyIClcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0Y29uc3Qgd2hlcmVFeHByID0gYXNzZXJ0V2hlcmVFeHByZXNzaW9uKHByb2dyYW0uc3RhdGVtZW50c1swXSk7XG5cdFx0ZXhwZWN0KHdoZXJlRXhwci5kZWZpbml0aW9ucykudG9IYXZlTGVuZ3RoKDIpO1xuXHRcdGV4cGVjdCgod2hlcmVFeHByLmRlZmluaXRpb25zWzBdIGFzIGFueSkubmFtZSkudG9CZShcInhcIik7XG5cdFx0ZXhwZWN0KCh3aGVyZUV4cHIuZGVmaW5pdGlvbnNbMV0gYXMgYW55KS5uYW1lKS50b0JlKFwieVwiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSB3aGVyZSBleHByZXNzaW9uIHdpdGggbXV0YWJsZSBkZWZpbml0aW9uXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcInggKyB5IHdoZXJlICggbXV0IHggPSAxOyB5ID0gMiApXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IHdoZXJlRXhwciA9IGFzc2VydFdoZXJlRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdCh3aGVyZUV4cHIuZGVmaW5pdGlvbnMpLnRvSGF2ZUxlbmd0aCgyKTtcblx0XHRleHBlY3Qod2hlcmVFeHByLmRlZmluaXRpb25zWzBdLmtpbmQpLnRvQmUoXCJtdXRhYmxlLWRlZmluaXRpb25cIik7XG5cdFx0ZXhwZWN0KHdoZXJlRXhwci5kZWZpbml0aW9uc1sxXS5raW5kKS50b0JlKFwiZGVmaW5pdGlvblwiKTtcblx0fSk7XG59KTtcblxuLy8gQWRkIG5ldyB0ZXN0IHN1aXRlIGZvciBNdXRhYmxlIERlZmluaXRpb25zIGFuZCBNdXRhdGlvbnNcbmRlc2NyaWJlKFwiTXV0YWJsZSBEZWZpbml0aW9ucyBhbmQgTXV0YXRpb25zXCIsICgpID0+IHtcblx0dGVzdChcInNob3VsZCBwYXJzZSBtdXRhYmxlIGRlZmluaXRpb25cIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwibXV0IHggPSA0MlwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBtdXREZWYgPSBhc3NlcnRNdXRhYmxlRGVmaW5pdGlvbkV4cHJlc3Npb24ocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdKTtcblx0XHRleHBlY3QobXV0RGVmLm5hbWUpLnRvQmUoXCJ4XCIpO1xuXHRcdGV4cGVjdChtdXREZWYudmFsdWUua2luZCkudG9CZShcImxpdGVyYWxcIik7XG5cdFx0ZXhwZWN0KChtdXREZWYudmFsdWUgYXMgYW55KS52YWx1ZSkudG9CZSg0Mik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgbXV0YXRpb25cIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwibXV0ISB4ID0gMTAwXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IG11dGF0aW9uID0gYXNzZXJ0TXV0YXRpb25FeHByZXNzaW9uKHByb2dyYW0uc3RhdGVtZW50c1swXSk7XG5cdFx0ZXhwZWN0KG11dGF0aW9uLnRhcmdldCkudG9CZShcInhcIik7XG5cdFx0ZXhwZWN0KG11dGF0aW9uLnZhbHVlLmtpbmQpLnRvQmUoXCJsaXRlcmFsXCIpO1xuXHRcdGV4cGVjdCgobXV0YXRpb24udmFsdWUgYXMgYW55KS52YWx1ZSkudG9CZSgxMDApO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIG11dGFibGUgZGVmaW5pdGlvbiB3aXRoIGNvbXBsZXggZXhwcmVzc2lvblwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJtdXQgcmVzdWx0ID0gZm4geCA9PiB4ICogMlwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBtdXREZWYgPSBhc3NlcnRNdXRhYmxlRGVmaW5pdGlvbkV4cHJlc3Npb24ocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdKTtcblx0XHRleHBlY3QobXV0RGVmLm5hbWUpLnRvQmUoXCJyZXN1bHRcIik7XG5cdFx0ZXhwZWN0KG11dERlZi52YWx1ZS5raW5kKS50b0JlKFwiZnVuY3Rpb25cIik7XG5cdH0pO1xufSk7XG5cbi8vIEFkZCBuZXcgdGVzdCBzdWl0ZSBmb3IgQ29uc3RyYWludCBEZWZpbml0aW9ucyBhbmQgSW1wbGVtZW50YXRpb25zXG5kZXNjcmliZShcIkNvbnN0cmFpbnQgRGVmaW5pdGlvbnMgYW5kIEltcGxlbWVudGF0aW9uc1wiLCAoKSA9PiB7XG5cdHRlc3Quc2tpcChcInNob3VsZCBwYXJzZSBjb25zdHJhaW50IGRlZmluaXRpb25cIiwgKCkgPT4ge1xuXHRcdC8vIFRPRE86IFRoaXMgdGVzdCBpcyBza2lwcGVkIGR1ZSB0byBwYXJzZXIgcHJlY2VkZW5jZSBpc3N1ZXMgd2l0aCB0b3AtbGV2ZWwgY29uc3RyYWludCBkZWZpbml0aW9ucy5cblx0XHQvLyBUaGUgcGFyc2VyIGNob2ljZSBvcmRlcmluZyBjYXVzZXMgcGFyc2VDb25zdHJhaW50RGVmaW5pdGlvbiB0byBjb25mbGljdCB3aXRoIG90aGVyIHBhcnNlcnNcblx0XHQvLyB3aGVuIHBhcnNpbmcgYXQgdGhlIHRvcCBsZXZlbC4gVGhpcyBuZWVkcyBwYXJzZXIgYXJjaGl0ZWN0dXJlIGltcHJvdmVtZW50cyB0byByZXNvbHZlLlxuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiY29uc3RyYWludCBNb25hZCBtICggcmV0dXJuIGEgOiBhIC0+IG0gYTsgYmluZCBhIGIgOiBtIGEgLT4gKGEgLT4gbSBiKSAtPiBtIGIgKVwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBjb25zdHJhaW50RGVmID0gYXNzZXJ0Q29uc3RyYWludERlZmluaXRpb25FeHByZXNzaW9uKHByb2dyYW0uc3RhdGVtZW50c1swXSk7XG5cdFx0ZXhwZWN0KGNvbnN0cmFpbnREZWYubmFtZSkudG9CZShcIk1vbmFkXCIpO1xuXHRcdGV4cGVjdChjb25zdHJhaW50RGVmLnR5cGVQYXJhbSkudG9CZShcIm1cIik7XG5cdFx0ZXhwZWN0KGNvbnN0cmFpbnREZWYuZnVuY3Rpb25zKS50b0hhdmVMZW5ndGgoMik7XG5cdFx0ZXhwZWN0KGNvbnN0cmFpbnREZWYuZnVuY3Rpb25zWzBdLm5hbWUpLnRvQmUoXCJyZXR1cm5cIik7XG5cdFx0ZXhwZWN0KGNvbnN0cmFpbnREZWYuZnVuY3Rpb25zWzFdLm5hbWUpLnRvQmUoXCJiaW5kXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIGltcGxlbWVudCBkZWZpbml0aW9uXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcImltcGxlbWVudCBNb25hZCBPcHRpb24gKCByZXR1cm4gPSBTb21lOyBiaW5kID0gZm4gb3B0IGYgPT4gbWF0Y2ggb3B0IHdpdGggKCBTb21lIHggPT4gZiB4OyBOb25lID0+IE5vbmUgKSApXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IGltcGxEZWYgPSBhc3NlcnRJbXBsZW1lbnREZWZpbml0aW9uRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChpbXBsRGVmLmNvbnN0cmFpbnROYW1lKS50b0JlKFwiTW9uYWRcIik7XG5cdFx0ZXhwZWN0KGltcGxEZWYudHlwZU5hbWUpLnRvQmUoXCJPcHRpb25cIik7XG5cdFx0ZXhwZWN0KGltcGxEZWYuaW1wbGVtZW50YXRpb25zKS50b0hhdmVMZW5ndGgoMik7XG5cdFx0ZXhwZWN0KGltcGxEZWYuaW1wbGVtZW50YXRpb25zWzBdLm5hbWUpLnRvQmUoXCJyZXR1cm5cIik7XG5cdFx0ZXhwZWN0KGltcGxEZWYuaW1wbGVtZW50YXRpb25zWzFdLm5hbWUpLnRvQmUoXCJiaW5kXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIGNvbnN0cmFpbnQgd2l0aCBzaW1wbGUgZnVuY3Rpb25zXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcImNvbnN0cmFpbnQgRXEgYSAoIGVxIGEgOiBhIC0+IGEgLT4gQm9vbCApXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IGNvbnN0cmFpbnREZWYgPSBhc3NlcnRDb25zdHJhaW50RGVmaW5pdGlvbkV4cHJlc3Npb24ocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdKTtcblx0XHRleHBlY3QoY29uc3RyYWludERlZi5uYW1lKS50b0JlKFwiRXFcIik7XG5cdFx0ZXhwZWN0KGNvbnN0cmFpbnREZWYudHlwZVBhcmFtKS50b0JlKFwiYVwiKTtcblx0XHRleHBlY3QoY29uc3RyYWludERlZi5mdW5jdGlvbnMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRleHBlY3QoY29uc3RyYWludERlZi5mdW5jdGlvbnNbMF0ubmFtZSkudG9CZShcImVxXCIpO1xuXHRcdGV4cGVjdChjb25zdHJhaW50RGVmLmZ1bmN0aW9uc1swXS50eXBlUGFyYW1zKS50b0VxdWFsKFtcImFcIl0pO1xuXHR9KTtcbn0pO1xuXG4vLyBBZGQgbmV3IHRlc3Qgc3VpdGUgZm9yIEFkdmFuY2VkIFR5cGUgRXhwcmVzc2lvbnNcbmRlc2NyaWJlKFwiQWR2YW5jZWQgVHlwZSBFeHByZXNzaW9uc1wiLCAoKSA9PiB7XG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgVHVwbGUgdHlwZSBjb25zdHJ1Y3RvclwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJUdXBsZSBJbnQgU3RyaW5nIEJvb2xcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCByZXN1bHQgPSBwYXJzZVR5cGVFeHByZXNzaW9uKHRva2Vucyk7XG5cdFx0YXNzZXJ0UGFyc2VTdWNjZXNzKHJlc3VsdCk7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5raW5kKS50b0JlKFwidHVwbGVcIik7XG5cdFx0Y29uc3QgdHVwbGVDb25zdHJ1Y3RvciA9IHJlc3VsdC52YWx1ZSBhcyBhbnk7XG5cdFx0ZXhwZWN0KHR1cGxlQ29uc3RydWN0b3IuZWxlbWVudHMpLnRvSGF2ZUxlbmd0aCgzKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSBwYXJlbnRoZXNpemVkIHR5cGUgZXhwcmVzc2lvblwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCIoSW50IC0+IFN0cmluZylcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCByZXN1bHQgPSBwYXJzZVR5cGVFeHByZXNzaW9uKHRva2Vucyk7XG5cdFx0YXNzZXJ0UGFyc2VTdWNjZXNzKHJlc3VsdCk7XG5cdFx0YXNzZXJ0RnVuY3Rpb25UeXBlKHJlc3VsdC52YWx1ZSk7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgTGlzdCB0eXBlIHdpdGggZ2VuZXJpYyBwYXJhbWV0ZXJcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiTGlzdFwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZUV4cHJlc3Npb24odG9rZW5zKTtcblx0XHRhc3NlcnRQYXJzZVN1Y2Nlc3MocmVzdWx0KTtcblx0XHRhc3NlcnRMaXN0VHlwZShyZXN1bHQudmFsdWUpO1xuXHRcdGNvbnN0IGxpc3RUeXBlID0gcmVzdWx0LnZhbHVlO1xuXHRcdGV4cGVjdChsaXN0VHlwZS5lbGVtZW50LmtpbmQpLnRvQmUoXCJ2YXJpYWJsZVwiKTtcblx0XHRleHBlY3QoKGxpc3RUeXBlLmVsZW1lbnQgYXMgYW55KS5uYW1lKS50b0JlKFwiYVwiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSB2YXJpYW50IHR5cGUgd2l0aCBhcmdzXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIk1heWJlIFN0cmluZ1wiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZUV4cHJlc3Npb24odG9rZW5zKTtcblx0XHRhc3NlcnRQYXJzZVN1Y2Nlc3MocmVzdWx0KTtcblx0XHRleHBlY3QocmVzdWx0LnZhbHVlLmtpbmQpLnRvQmUoXCJ2YXJpYW50XCIpO1xuXHRcdGNvbnN0IHZhcmlhbnRUeXBlID0gcmVzdWx0LnZhbHVlIGFzIGFueTtcblx0XHRleHBlY3QodmFyaWFudFR5cGUubmFtZSkudG9CZShcIk1heWJlXCIpO1xuXHRcdGV4cGVjdCh2YXJpYW50VHlwZS5hcmdzKS50b0hhdmVMZW5ndGgoMSk7XG5cdH0pO1xufSk7XG5cbi8vIEFkZCBuZXcgdGVzdCBzdWl0ZSBmb3IgQ29uc3RyYWludCBFeHByZXNzaW9uc1xuZGVzY3JpYmUoXCJDb25zdHJhaW50IEV4cHJlc3Npb25zXCIsICgpID0+IHtcblx0dGVzdChcInNob3VsZCBwYXJzZSBzaW1wbGUgY29uc3RyYWludCBleHByZXNzaW9uXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcInggOiBJbnQgZ2l2ZW4gYSBpcyBFcVwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBjb25zdHJhaW5lZCA9IGFzc2VydENvbnN0cmFpbmVkRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChjb25zdHJhaW5lZC5leHByZXNzaW9uLmtpbmQpLnRvQmUoXCJ2YXJpYWJsZVwiKTtcblx0XHRleHBlY3QoY29uc3RyYWluZWQudHlwZS5raW5kKS50b0JlKFwicHJpbWl0aXZlXCIpO1xuXHRcdGV4cGVjdChjb25zdHJhaW5lZC5jb25zdHJhaW50LmtpbmQpLnRvQmUoXCJpc1wiKTtcblx0XHRleHBlY3QoKGNvbnN0cmFpbmVkLmNvbnN0cmFpbnQgYXMgYW55KS50eXBlVmFyKS50b0JlKFwiYVwiKTtcblx0XHRleHBlY3QoKGNvbnN0cmFpbmVkLmNvbnN0cmFpbnQgYXMgYW55KS5jb25zdHJhaW50KS50b0JlKFwiRXFcIik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgY29uc3RyYWludCB3aXRoIGFuZCBvcGVyYXRvclwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJ4IDogYSBnaXZlbiBhIGlzIEVxIGFuZCBhIGlzIE9yZFwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBjb25zdHJhaW5lZCA9IGFzc2VydENvbnN0cmFpbmVkRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChjb25zdHJhaW5lZC5jb25zdHJhaW50LmtpbmQpLnRvQmUoXCJhbmRcIik7XG5cdFx0Y29uc3QgYW5kQ29uc3RyYWludCA9IGNvbnN0cmFpbmVkLmNvbnN0cmFpbnQgYXMgYW55O1xuXHRcdGV4cGVjdChhbmRDb25zdHJhaW50LmxlZnQua2luZCkudG9CZShcImlzXCIpO1xuXHRcdGV4cGVjdChhbmRDb25zdHJhaW50LnJpZ2h0LmtpbmQpLnRvQmUoXCJpc1wiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSBjb25zdHJhaW50IHdpdGggb3Igb3BlcmF0b3JcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwieCA6IGEgZ2l2ZW4gYSBpcyBFcSBvciBhIGlzIE9yZFwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBjb25zdHJhaW5lZCA9IGFzc2VydENvbnN0cmFpbmVkRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChjb25zdHJhaW5lZC5jb25zdHJhaW50LmtpbmQpLnRvQmUoXCJvclwiKTtcblx0fSk7XG5cblx0dGVzdC5za2lwKFwic2hvdWxkIHBhcnNlIGNvbnN0cmFpbnQgd2l0aCBoYXNGaWVsZFwiLCAoKSA9PiB7XG5cdFx0Ly8gVE9ETzogVGhpcyB0ZXN0IGlzIHNraXBwZWQgZHVlIHRvIHBhcnNlciBwcmVjZWRlbmNlIGlzc3VlcyB3aXRoIHRvcC1sZXZlbCBjb25zdHJhaW5lZCBleHByZXNzaW9ucy5cblx0XHQvLyBUaGUgcGFyc2VyIGNob2ljZSBvcmRlcmluZyBjYXVzZXMgY29uc3RyYWludCBwYXJzaW5nIHRvIGNvbmZsaWN0IHdpdGggb3RoZXIgcGFyc2Vyc1xuXHRcdC8vIHdoZW4gcGFyc2luZyBhdCB0aGUgdG9wIGxldmVsLiBUaGlzIG5lZWRzIHBhcnNlciBhcmNoaXRlY3R1cmUgaW1wcm92ZW1lbnRzIHRvIHJlc29sdmUuXG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoJ3ggOiBhIGdpdmVuIGEgaGFzIGZpZWxkIFwibmFtZVwiIG9mIHR5cGUgU3RyaW5nJyk7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0Y29uc3QgY29uc3RyYWluZWQgPSBhc3NlcnRDb25zdHJhaW5lZEV4cHJlc3Npb24ocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdKTtcblx0XHRleHBlY3QoY29uc3RyYWluZWQuY29uc3RyYWludC5raW5kKS50b0JlKFwiaGFzRmllbGRcIik7XG5cdFx0Y29uc3QgaGFzRmllbGRDb25zdHJhaW50ID0gY29uc3RyYWluZWQuY29uc3RyYWludCBhcyBhbnk7XG5cdFx0ZXhwZWN0KGhhc0ZpZWxkQ29uc3RyYWludC50eXBlVmFyKS50b0JlKFwiYVwiKTtcblx0XHRleHBlY3QoaGFzRmllbGRDb25zdHJhaW50LmZpZWxkKS50b0JlKFwibmFtZVwiKTtcblx0XHRleHBlY3QoaGFzRmllbGRDb25zdHJhaW50LmZpZWxkVHlwZS5raW5kKS50b0JlKFwicHJpbWl0aXZlXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIHBhcnNlIGNvbnN0cmFpbnQgd2l0aCBpbXBsZW1lbnRzXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcInggOiBhIGdpdmVuIGEgaW1wbGVtZW50cyBJdGVyYWJsZVwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBjb25zdHJhaW5lZCA9IGFzc2VydENvbnN0cmFpbmVkRXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChjb25zdHJhaW5lZC5jb25zdHJhaW50LmtpbmQpLnRvQmUoXCJpbXBsZW1lbnRzXCIpO1xuXHRcdGNvbnN0IGltcGxlbWVudHNDb25zdHJhaW50ID0gY29uc3RyYWluZWQuY29uc3RyYWludCBhcyBhbnk7XG5cdFx0ZXhwZWN0KGltcGxlbWVudHNDb25zdHJhaW50LnR5cGVWYXIpLnRvQmUoXCJhXCIpO1xuXHRcdGV4cGVjdChpbXBsZW1lbnRzQ29uc3RyYWludC5pbnRlcmZhY2VOYW1lKS50b0JlKFwiSXRlcmFibGVcIik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgcGFyZW50aGVzaXplZCBjb25zdHJhaW50XCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcInggOiBhIGdpdmVuIChhIGlzIEVxIGFuZCBhIGlzIE9yZCkgb3IgYSBpcyBTaG93XCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IGNvbnN0cmFpbmVkID0gYXNzZXJ0Q29uc3RyYWluZWRFeHByZXNzaW9uKHByb2dyYW0uc3RhdGVtZW50c1swXSk7XG5cdFx0ZXhwZWN0KGNvbnN0cmFpbmVkLmNvbnN0cmFpbnQua2luZCkudG9CZShcIm9yXCIpO1xuXHRcdGNvbnN0IG9yQ29uc3RyYWludCA9IGNvbnN0cmFpbmVkLmNvbnN0cmFpbnQgYXMgYW55O1xuXHRcdGV4cGVjdChvckNvbnN0cmFpbnQubGVmdC5raW5kKS50b0JlKFwicGFyZW5cIik7XG5cdFx0ZXhwZWN0KG9yQ29uc3RyYWludC5yaWdodC5raW5kKS50b0JlKFwiaXNcIik7XG5cdH0pO1xufSk7XG5cbi8vIEFkZCBuZXcgdGVzdCBzdWl0ZSBmb3IgRXJyb3IgQ29uZGl0aW9uc1xuZGVzY3JpYmUoXCJFcnJvciBDb25kaXRpb25zXCIsICgpID0+IHtcblx0dGVzdChcInNob3VsZCB0aHJvdyBlcnJvciBmb3IgdW5leHBlY3RlZCB0b2tlbiBhZnRlciBleHByZXNzaW9uXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIjEgKyArXCIpOyAvLyBJbnZhbGlkIGRvdWJsZSBvcGVyYXRvclxuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0ZXhwZWN0KCgpID0+IHBhcnNlKHRva2VucykpLnRvVGhyb3coXCJQYXJzZSBlcnJvclwiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCB0aHJvdyBlcnJvciBmb3IgcGFyc2UgZXJyb3Igd2l0aCBsaW5lIGluZm9ybWF0aW9uXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcImZuID09PiA0MlwiKTsgLy8gaW52YWxpZCBkb3VibGUgYXJyb3dcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGV4cGVjdCgoKSA9PiBwYXJzZSh0b2tlbnMpKS50b1Rocm93KFwiUGFyc2UgZXJyb3JcIik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgaGFuZGxlIGVtcHR5IGlucHV0XCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIlwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgwKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBoYW5kbGUgb25seSBzZW1pY29sb25zXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIjs7OztcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMCk7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgaGFuZGxlIG1peGVkIG5hbWVkIGFuZCBwb3NpdGlvbmFsIGZpZWxkcyBlcnJvclwiLCAoKSA9PiB7XG5cdFx0ZXhwZWN0KCgpID0+IHtcblx0XHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwieyBAbmFtZSBcXFwiQWxpY2VcXFwiLCAzMCB9XCIpOyAvLyBtaXhlZCBuYW1lZCBhbmQgcG9zaXRpb25hbFxuXHRcdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRcdHBhcnNlKHRva2Vucyk7XG5cdFx0fSkudG9UaHJvdyhcIlBhcnNlIGVycm9yXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIGhhbmRsZSBpbnZhbGlkIGZpZWxkIGFmdGVyIGNvbW1hIGluIHJlY29yZFwiLCAoKSA9PiB7XG5cdFx0ZXhwZWN0KCgpID0+IHtcblx0XHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwieyBAbmFtZSBcXFwiQWxpY2VcXFwiLCB9XCIpOyAvLyB0cmFpbGluZyBjb21tYSB3aXRoIG5vIGZpZWxkXG5cdFx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdFx0cGFyc2UodG9rZW5zKTtcblx0XHR9KS5ub3QudG9UaHJvdygpOyAvLyBzaG91bGQgaGFuZGxlIHRyYWlsaW5nIGNvbW1hIGdyYWNlZnVsbHlcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBoYW5kbGUgaW52YWxpZCBlbGVtZW50IGFmdGVyIGNvbW1hIGluIGxpc3RcIiwgKCkgPT4ge1xuXHRcdGV4cGVjdCgoKSA9PiB7XG5cdFx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIlsxLCAyLCBdXCIpOyAvLyB0cmFpbGluZyBjb21tYSB3aXRoIG5vIGVsZW1lbnRcblx0XHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0XHRwYXJzZSh0b2tlbnMpO1xuXHRcdH0pLm5vdC50b1Rocm93KCk7IC8vIHNob3VsZCBoYW5kbGUgdHJhaWxpbmcgY29tbWEgZ3JhY2VmdWxseVxuXHR9KTtcbn0pO1xuXG4vLyBBZGQgbmV3IHRlc3Qgc3VpdGUgZm9yIE9wZXJhdG9yIFByZWNlZGVuY2VcbmRlc2NyaWJlKFwiT3BlcmF0b3IgUHJlY2VkZW5jZVwiLCAoKSA9PiB7XG5cdHRlc3QoXCJzaG91bGQgcGFyc2Ugb3BlcmF0b3JzIHdpdGggY29ycmVjdCBwcmVjZWRlbmNlXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcImEgKyBiICogY1wiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBleHByID0gYXNzZXJ0QmluYXJ5RXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChleHByLm9wZXJhdG9yKS50b0JlKFwiK1wiKTtcblx0XHRleHBlY3QoZXhwci5sZWZ0LmtpbmQpLnRvQmUoXCJ2YXJpYWJsZVwiKTtcblx0XHRleHBlY3QoZXhwci5yaWdodC5raW5kKS50b0JlKFwiYmluYXJ5XCIpO1xuXHRcdGNvbnN0IHJpZ2h0RXhwciA9IGFzc2VydEJpbmFyeUV4cHJlc3Npb24oZXhwci5yaWdodCk7XG5cdFx0ZXhwZWN0KHJpZ2h0RXhwci5vcGVyYXRvcikudG9CZShcIipcIik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgY29tcGFyaXNvbiBvcGVyYXRvcnNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiYSA8IGIgPT0gYyA+IGRcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0Ly8gRHVlIHRvIGxlZnQgYXNzb2NpYXRpdml0eSwgdGhpcyBwYXJzZXMgYXMgKCgoYSA8IGIpID09IGMpID4gZClcblx0XHRjb25zdCBleHByID0gYXNzZXJ0QmluYXJ5RXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChleHByLm9wZXJhdG9yKS50b0JlKFwiPlwiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSBjb21wb3NpdGlvbiBvcGVyYXRvcnNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiZiB8PiBnIHw+IGhcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0Y29uc3QgcGlwZWxpbmUgPSBwcm9ncmFtLnN0YXRlbWVudHNbMF0gYXMgYW55O1xuXHRcdGV4cGVjdChwaXBlbGluZS5raW5kKS50b0JlKFwicGlwZWxpbmVcIik7XG5cdFx0ZXhwZWN0KHBpcGVsaW5lLnN0ZXBzKS50b0hhdmVMZW5ndGgoMyk7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgcGFyc2UgZG9sbGFyIG9wZXJhdG9yXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcImYgJCBnICQgaFwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBleHByID0gYXNzZXJ0QmluYXJ5RXhwcmVzc2lvbihwcm9ncmFtLnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChleHByLm9wZXJhdG9yKS50b0JlKFwiJFwiKTtcblx0fSk7XG59KTtcblxuZGVzY3JpYmUoXCJUb3AtbGV2ZWwgc2VxdWVuY2UgcGFyc2luZ1wiLCAoKSA9PiB7XG5cdHRlc3QoXCJtdWx0aXBsZSBkZWZpbml0aW9ucyBhbmQgZmluYWwgZXhwcmVzc2lvblwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJhID0gMTsgYiA9IDI7IGEgKyBiXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IHNlcSA9IHByb2dyYW0uc3RhdGVtZW50c1swXTtcblx0XHRleHBlY3Qoc2VxLmtpbmQpLnRvQmUoXCJiaW5hcnlcIik7IC8vIHNlbWljb2xvbiBzZXF1ZW5jZVxuXHR9KTtcblxuXHR0ZXN0KFwibXVsdGlwbGUgZGVmaW5pdGlvbnMgYW5kIGZpbmFsIHJlY29yZFwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgY29kZSA9IGBcbiAgICAgIGFkZCA9IGZuIHggeSA9PiB4ICsgeTtcbiAgICAgIHN1YiA9IGZuIHggeSA9PiB4IC0geTtcbiAgICAgIG1hdGggPSB7IEBhZGQgYWRkLCBAc3ViIHN1YiB9O1xuICAgICAgbWF0aFxuICAgIGA7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoY29kZSk7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0Y29uc3Qgc2VxID0gcHJvZ3JhbS5zdGF0ZW1lbnRzWzBdO1xuXHRcdGV4cGVjdChzZXEua2luZCkudG9CZShcImJpbmFyeVwiKTtcblx0fSk7XG5cblx0dGVzdChcInNlcXVlbmNlIHdpdGggdHJhaWxpbmcgc2VtaWNvbG9uXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcImEgPSAxOyBiID0gMjsgYSArIGI7XCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IHNlcSA9IHByb2dyYW0uc3RhdGVtZW50c1swXTtcblx0XHRleHBlY3Qoc2VxLmtpbmQpLnRvQmUoXCJiaW5hcnlcIik7XG5cdH0pO1xufSk7XG5cbmRlc2NyaWJlKFwiVHlwZSBhbm5vdGF0aW9uIHBhcnNpbmdcIiwgKCkgPT4ge1xuXHRmdW5jdGlvbiBwYXJzZVR5cGUodHlwZVNyYzogc3RyaW5nKSB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIodHlwZVNyYyk7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRyZXR1cm4gcGFyc2VUeXBlRXhwcmVzc2lvbih0b2tlbnMpO1xuXHR9XG5cblx0dGVzdChcInBhcnNlcyByZWNvcmQgdHlwZSBhbm5vdGF0aW9uXCIsICgpID0+IHtcblx0XHRjb25zdCByZXN1bHQgPSBwYXJzZVR5cGUoXCJ7IG5hbWU6IFN0cmluZywgYWdlOiBOdW1iZXIgfVwiKTtcblx0XHRhc3NlcnRQYXJzZVN1Y2Nlc3MocmVzdWx0KTtcblx0XHRhc3NlcnRSZWNvcmRUeXBlKHJlc3VsdC52YWx1ZSk7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5raW5kKS50b0JlKFwicmVjb3JkXCIpO1xuXHRcdGV4cGVjdChyZXN1bHQudmFsdWUuZmllbGRzKS50b0hhdmVQcm9wZXJ0eShcIm5hbWVcIik7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5maWVsZHMpLnRvSGF2ZVByb3BlcnR5KFwiYWdlXCIpO1xuXHRcdGV4cGVjdChyZXN1bHQudmFsdWUuZmllbGRzLm5hbWUua2luZCkudG9CZShcInByaW1pdGl2ZVwiKTtcblx0XHRleHBlY3QocmVzdWx0LnZhbHVlLmZpZWxkcy5hZ2Uua2luZCkudG9CZShcInByaW1pdGl2ZVwiKTtcblx0fSk7XG5cblx0dGVzdChcInBhcnNlcyB0dXBsZSB0eXBlIGFubm90YXRpb25cIiwgKCkgPT4ge1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZShcInsgTnVtYmVyLCBTdHJpbmcgfVwiKTtcblx0XHRhc3NlcnRQYXJzZVN1Y2Nlc3MocmVzdWx0KTtcblx0XHRhc3NlcnRUdXBsZVR5cGUocmVzdWx0LnZhbHVlKTtcblx0XHRleHBlY3QocmVzdWx0LnZhbHVlLmVsZW1lbnRzWzBdLmtpbmQpLnRvQmUoXCJwcmltaXRpdmVcIik7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5lbGVtZW50c1sxXS5raW5kKS50b0JlKFwicHJpbWl0aXZlXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwicGFyc2VzIGxpc3QgdHlwZSBhbm5vdGF0aW9uXCIsICgpID0+IHtcblx0XHRjb25zdCByZXN1bHQgPSBwYXJzZVR5cGUoXCJMaXN0IE51bWJlclwiKTtcblx0XHRhc3NlcnRQYXJzZVN1Y2Nlc3MocmVzdWx0KTtcblx0XHRhc3NlcnRMaXN0VHlwZShyZXN1bHQudmFsdWUpO1xuXHRcdGV4cGVjdChyZXN1bHQudmFsdWUuZWxlbWVudC5raW5kKS50b0JlKFwicHJpbWl0aXZlXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwicGFyc2VzIGZ1bmN0aW9uIHR5cGUgYW5ub3RhdGlvblwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VUeXBlKFwiTnVtYmVyIC0+IE51bWJlclwiKTtcblx0XHRhc3NlcnRQYXJzZVN1Y2Nlc3MocmVzdWx0KTtcblx0XHRhc3NlcnRGdW5jdGlvblR5cGUocmVzdWx0LnZhbHVlKTtcblx0XHRjb25zdCBmdW5jVHlwZSA9IHJlc3VsdC52YWx1ZTtcblx0XHRleHBlY3QoZnVuY1R5cGUucGFyYW1zWzBdLmtpbmQpLnRvQmUoXCJwcmltaXRpdmVcIik7XG5cdFx0ZXhwZWN0KGZ1bmNUeXBlLnJldHVybi5raW5kKS50b0JlKFwicHJpbWl0aXZlXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwicGFyc2VzIHR5cGUgdmFyaWFibGVcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZShcImFcIik7XG5cdFx0YXNzZXJ0UGFyc2VTdWNjZXNzKHJlc3VsdCk7XG5cdFx0YXNzZXJ0VmFyaWFibGVUeXBlKHJlc3VsdC52YWx1ZSk7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5raW5kKS50b0JlKFwidmFyaWFibGVcIik7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5uYW1lKS50b0JlKFwiYVwiKTtcblx0fSk7XG5cblx0Ly8gQWRkIGNvbXByZWhlbnNpdmUgdGVzdHMgZm9yIHR5cGUgY29uc3RydWN0b3IgYXBwbGljYXRpb25cblx0dGVzdChcInBhcnNlcyBzaW1wbGUgdHlwZSBjb25zdHJ1Y3RvciBhcHBsaWNhdGlvblwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VUeXBlKFwiT3B0aW9uIEludFwiKTtcblx0XHRhc3NlcnRQYXJzZVN1Y2Nlc3MocmVzdWx0KTtcblx0XHRleHBlY3QocmVzdWx0LnZhbHVlLmtpbmQpLnRvQmUoXCJ2YXJpYW50XCIpO1xuXHRcdGNvbnN0IHZhcmlhbnRUeXBlID0gcmVzdWx0LnZhbHVlIGFzIGFueTtcblx0XHRleHBlY3QodmFyaWFudFR5cGUubmFtZSkudG9CZShcIk9wdGlvblwiKTtcblx0XHRleHBlY3QodmFyaWFudFR5cGUuYXJncykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGV4cGVjdCh2YXJpYW50VHlwZS5hcmdzWzBdLmtpbmQpLnRvQmUoXCJwcmltaXRpdmVcIik7XG5cdFx0ZXhwZWN0KHZhcmlhbnRUeXBlLmFyZ3NbMF0ubmFtZSkudG9CZShcIkludFwiKTtcblx0fSk7XG5cblx0dGVzdChcInBhcnNlcyB0eXBlIGNvbnN0cnVjdG9yIHdpdGggdHlwZSB2YXJpYWJsZVwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VUeXBlKFwiT3B0aW9uIGFcIik7XG5cdFx0YXNzZXJ0UGFyc2VTdWNjZXNzKHJlc3VsdCk7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5raW5kKS50b0JlKFwidmFyaWFudFwiKTtcblx0XHRjb25zdCB2YXJpYW50VHlwZSA9IHJlc3VsdC52YWx1ZSBhcyBhbnk7XG5cdFx0ZXhwZWN0KHZhcmlhbnRUeXBlLm5hbWUpLnRvQmUoXCJPcHRpb25cIik7XG5cdFx0ZXhwZWN0KHZhcmlhbnRUeXBlLmFyZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRleHBlY3QodmFyaWFudFR5cGUuYXJnc1swXS5raW5kKS50b0JlKFwidmFyaWFibGVcIik7XG5cdFx0ZXhwZWN0KHZhcmlhbnRUeXBlLmFyZ3NbMF0ubmFtZSkudG9CZShcImFcIik7XG5cdH0pO1xuXG5cdHRlc3QoXCJwYXJzZXMgdHlwZSBjb25zdHJ1Y3RvciB3aXRoIG11bHRpcGxlIGFyZ3VtZW50c1wiLCAoKSA9PiB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VUeXBlKFwiRWl0aGVyIFN0cmluZyBJbnRcIik7XG5cdFx0YXNzZXJ0UGFyc2VTdWNjZXNzKHJlc3VsdCk7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5raW5kKS50b0JlKFwidmFyaWFudFwiKTtcblx0XHRjb25zdCB2YXJpYW50VHlwZSA9IHJlc3VsdC52YWx1ZSBhcyBhbnk7XG5cdFx0ZXhwZWN0KHZhcmlhbnRUeXBlLm5hbWUpLnRvQmUoXCJFaXRoZXJcIik7XG5cdFx0ZXhwZWN0KHZhcmlhbnRUeXBlLmFyZ3MpLnRvSGF2ZUxlbmd0aCgyKTtcblx0XHRleHBlY3QodmFyaWFudFR5cGUuYXJnc1swXS5raW5kKS50b0JlKFwicHJpbWl0aXZlXCIpO1xuXHRcdGV4cGVjdCh2YXJpYW50VHlwZS5hcmdzWzBdLm5hbWUpLnRvQmUoXCJTdHJpbmdcIik7XG5cdFx0ZXhwZWN0KHZhcmlhbnRUeXBlLmFyZ3NbMV0ua2luZCkudG9CZShcInByaW1pdGl2ZVwiKTtcblx0XHRleHBlY3QodmFyaWFudFR5cGUuYXJnc1sxXS5uYW1lKS50b0JlKFwiSW50XCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwicGFyc2VzIHR5cGUgY29uc3RydWN0b3Igd2l0aCBtaXhlZCB0eXBlIGFyZ3VtZW50c1wiLCAoKSA9PiB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VUeXBlKFwiTWFwIFN0cmluZyBhXCIpO1xuXHRcdGFzc2VydFBhcnNlU3VjY2VzcyhyZXN1bHQpO1xuXHRcdGV4cGVjdChyZXN1bHQudmFsdWUua2luZCkudG9CZShcInZhcmlhbnRcIik7XG5cdFx0Y29uc3QgdmFyaWFudFR5cGUgPSByZXN1bHQudmFsdWUgYXMgYW55O1xuXHRcdGV4cGVjdCh2YXJpYW50VHlwZS5uYW1lKS50b0JlKFwiTWFwXCIpO1xuXHRcdGV4cGVjdCh2YXJpYW50VHlwZS5hcmdzKS50b0hhdmVMZW5ndGgoMik7XG5cdFx0ZXhwZWN0KHZhcmlhbnRUeXBlLmFyZ3NbMF0ua2luZCkudG9CZShcInByaW1pdGl2ZVwiKTtcblx0XHRleHBlY3QodmFyaWFudFR5cGUuYXJnc1swXS5uYW1lKS50b0JlKFwiU3RyaW5nXCIpO1xuXHRcdGV4cGVjdCh2YXJpYW50VHlwZS5hcmdzWzFdLmtpbmQpLnRvQmUoXCJ2YXJpYWJsZVwiKTtcblx0XHRleHBlY3QodmFyaWFudFR5cGUuYXJnc1sxXS5uYW1lKS50b0JlKFwiYVwiKTtcblx0fSk7XG5cblx0dGVzdChcInBhcnNlcyBuZXN0ZWQgdHlwZSBjb25zdHJ1Y3RvciBhcHBsaWNhdGlvblwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VUeXBlKFwiT3B0aW9uIChFaXRoZXIgU3RyaW5nIEludClcIik7XG5cdFx0YXNzZXJ0UGFyc2VTdWNjZXNzKHJlc3VsdCk7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5raW5kKS50b0JlKFwidmFyaWFudFwiKTtcblx0XHRjb25zdCB2YXJpYW50VHlwZSA9IHJlc3VsdC52YWx1ZSBhcyBhbnk7XG5cdFx0ZXhwZWN0KHZhcmlhbnRUeXBlLm5hbWUpLnRvQmUoXCJPcHRpb25cIik7XG5cdFx0ZXhwZWN0KHZhcmlhbnRUeXBlLmFyZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRleHBlY3QodmFyaWFudFR5cGUuYXJnc1swXS5raW5kKS50b0JlKFwidmFyaWFudFwiKTtcblx0XHRleHBlY3QodmFyaWFudFR5cGUuYXJnc1swXS5uYW1lKS50b0JlKFwiRWl0aGVyXCIpO1xuXHRcdGV4cGVjdCh2YXJpYW50VHlwZS5hcmdzWzBdLmFyZ3MpLnRvSGF2ZUxlbmd0aCgyKTtcblx0fSk7XG5cblx0dGVzdChcInBhcnNlcyBzaW5nbGUgbGV0dGVyIHR5cGUgY29uc3RydWN0b3IgZm9yIGNvbnN0cmFpbnRzXCIsICgpID0+IHtcblx0XHQvLyBXaGlsZSB0aGUgYWR2YW5jZWQgYG0gYWAgc3ludGF4IGlzbid0IGN1cnJlbnRseSBzdXBwb3J0ZWQsXG5cdFx0Ly8gd2Ugc2hvdWxkIHN0aWxsIGJlIGFibGUgdG8gcGFyc2Ugc2ltcGxlIHR5cGUgdmFyaWFibGVzIGZvciBjb25zdHJhaW50c1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZShcIm1cIik7XG5cdFx0YXNzZXJ0UGFyc2VTdWNjZXNzKHJlc3VsdCk7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5raW5kKS50b0JlKFwidmFyaWFibGVcIik7XG5cdFx0Y29uc3QgdmFyVHlwZSA9IHJlc3VsdC52YWx1ZSBhcyBhbnk7XG5cdFx0ZXhwZWN0KHZhclR5cGUubmFtZSkudG9CZShcIm1cIik7XG5cdFx0XG5cdFx0Ly8gVE9ETzogSW4gdGhlIGZ1dHVyZSwgd2Ugc2hvdWxkIHN1cHBvcnQgYG0gYWAgc3ludGF4OlxuXHRcdC8vIGNvbnN0IGFkdmFuY2VkUmVzdWx0ID0gcGFyc2VUeXBlKFwibSBhXCIpO1xuXHRcdC8vIGV4cGVjdChhZHZhbmNlZFJlc3VsdC52YWx1ZS5raW5kKS50b0JlKFwidmFyaWFudFwiKTtcblx0XHQvLyBleHBlY3QoYWR2YW5jZWRSZXN1bHQudmFsdWUubmFtZSkudG9CZShcIm1cIik7XG5cdFx0Ly8gZXhwZWN0KGFkdmFuY2VkUmVzdWx0LnZhbHVlLmFyZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcblx0fSk7XG5cblx0dGVzdChcInBhcnNlcyB0eXBlIGNvbnN0cnVjdG9yIGluIGZ1bmN0aW9uIHR5cGVcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZShcIk9wdGlvbiBhIC0+IEJvb2xcIik7XG5cdFx0YXNzZXJ0UGFyc2VTdWNjZXNzKHJlc3VsdCk7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5raW5kKS50b0JlKFwiZnVuY3Rpb25cIik7XG5cdFx0Y29uc3QgZnVuY1R5cGUgPSByZXN1bHQudmFsdWUgYXMgYW55O1xuXHRcdGV4cGVjdChmdW5jVHlwZS5wYXJhbXNbMF0ua2luZCkudG9CZShcInZhcmlhbnRcIik7XG5cdFx0ZXhwZWN0KGZ1bmNUeXBlLnBhcmFtc1swXS5uYW1lKS50b0JlKFwiT3B0aW9uXCIpO1xuXHRcdGV4cGVjdChmdW5jVHlwZS5wYXJhbXNbMF0uYXJncykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGV4cGVjdChmdW5jVHlwZS5yZXR1cm4ua2luZCkudG9CZShcInZhcmlhbnRcIik7XG5cdFx0ZXhwZWN0KGZ1bmNUeXBlLnJldHVybi5uYW1lKS50b0JlKFwiQm9vbFwiKTtcblx0fSk7XG5cblx0dGVzdChcInBhcnNlcyBjb25zdHJhaW50IGZ1bmN0aW9uIHR5cGVzXCIsICgpID0+IHtcblx0XHQvLyBUZXN0IHNpbXBsZSBjb25zdHJhaW50IGZ1bmN0aW9uXG5cdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VUeXBlKFwiYSAtPiBhXCIpO1xuXHRcdGFzc2VydFBhcnNlU3VjY2VzcyhyZXN1bHQpO1xuXHRcdGV4cGVjdChyZXN1bHQudmFsdWUua2luZCkudG9CZShcImZ1bmN0aW9uXCIpO1xuXHRcdGNvbnN0IGZ1bmNUeXBlID0gcmVzdWx0LnZhbHVlIGFzIGFueTtcblx0XHRleHBlY3QoZnVuY1R5cGUucGFyYW1zWzBdLmtpbmQpLnRvQmUoXCJ2YXJpYWJsZVwiKTtcblx0XHRleHBlY3QoZnVuY1R5cGUucGFyYW1zWzBdLm5hbWUpLnRvQmUoXCJhXCIpO1xuXHRcdGV4cGVjdChmdW5jVHlwZS5yZXR1cm4ua2luZCkudG9CZShcInZhcmlhYmxlXCIpO1xuXHRcdGV4cGVjdChmdW5jVHlwZS5yZXR1cm4ubmFtZSkudG9CZShcImFcIik7XG5cdFx0XG5cdFx0Ly8gVE9ETzogSW4gdGhlIGZ1dHVyZSwgd2Ugc2hvdWxkIHN1cHBvcnQgbW9yZSBjb21wbGV4IGNvbnN0cmFpbnQgZnVuY3Rpb25zOlxuXHRcdC8vIGNvbnN0IGNvbXBsZXhSZXN1bHQgPSBwYXJzZVR5cGUoXCJtIGEgLT4gKGEgLT4gbSBiKSAtPiBtIGJcIik7XG5cdFx0Ly8gZXhwZWN0KGNvbXBsZXhSZXN1bHQudmFsdWUua2luZCkudG9CZShcImZ1bmN0aW9uXCIpO1xuXHRcdC8vIFRoaXMgd291bGQgYmUgdGhlIG1vbmFkaWMgYmluZCBzaWduYXR1cmVcblx0fSk7XG5cblx0dGVzdChcInBhcnNlcyBuZXN0ZWQgcmVjb3JkIHR5cGVcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZShcblx0XHRcdFwieyBwZXJzb246IHsgbmFtZTogU3RyaW5nLCBhZ2U6IE51bWJlciB9LCBhY3RpdmU6IEJvb2wgfVwiLFxuXHRcdCk7XG5cdFx0YXNzZXJ0UGFyc2VTdWNjZXNzKHJlc3VsdCk7XG5cdFx0YXNzZXJ0UmVjb3JkVHlwZShyZXN1bHQudmFsdWUpO1xuXHRcdGV4cGVjdChyZXN1bHQudmFsdWUuZmllbGRzKS50b0hhdmVQcm9wZXJ0eShcInBlcnNvblwiKTtcblx0XHRleHBlY3QocmVzdWx0LnZhbHVlLmZpZWxkcykudG9IYXZlUHJvcGVydHkoXCJhY3RpdmVcIik7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5maWVsZHMucGVyc29uLmtpbmQpLnRvQmUoXCJyZWNvcmRcIik7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5maWVsZHMuYWN0aXZlLmtpbmQpLnRvQmUoXCJ2YXJpYW50XCIpO1xuXHR9KTtcbn0pO1xuXG5kZXNjcmliZShcIlRvcC1sZXZlbCBkZWZpbml0aW9ucyB3aXRoIHR5cGUgYW5ub3RhdGlvbnNcIiwgKCkgPT4ge1xuXHRmdW5jdGlvbiBwYXJzZURlZmluaXRpb24oZGVmU3JjOiBzdHJpbmcpIHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihkZWZTcmMpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0cmV0dXJuIHBhcnNlKHRva2Vucyk7XG5cdH1cblxuXHR0ZXN0KFwicGFyc2VzIGRlZmluaXRpb24gd2l0aCBmdW5jdGlvbiB0eXBlIGFubm90YXRpb25cIiwgKCkgPT4ge1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlRGVmaW5pdGlvbihcblx0XHRcdFwiYWRkID0gZm4geCB5ID0+IHggKyB5IDogTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXI7XCIsXG5cdFx0KTtcblx0XHRleHBlY3QocmVzdWx0LnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRleHBlY3QocmVzdWx0LnN0YXRlbWVudHNbMF0ua2luZCkudG9CZShcImRlZmluaXRpb25cIik7XG5cdFx0Y29uc3QgZGVmID0gYXNzZXJ0RGVmaW5pdGlvbkV4cHJlc3Npb24ocmVzdWx0LnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChkZWYubmFtZSkudG9CZShcImFkZFwiKTtcblx0XHRleHBlY3QoZGVmLnZhbHVlLmtpbmQpLnRvQmUoXCJmdW5jdGlvblwiKTtcblx0XHQvLyBGdW5jdGlvbiBleHByZXNzaW9ucyB3aXRoIHR5cGUgYW5ub3RhdGlvbnMgbWF5IG5vdCB3cmFwIGluIFwidHlwZWRcIiBub2Rlc1xuXHRcdC8vIFRoZSB0eXBlIGluZm9ybWF0aW9uIG1pZ2h0IGJlIHN0b3JlZCBkaXJlY3RseSBvbiB0aGUgZnVuY3Rpb25cblx0fSk7XG5cblx0dGVzdChcInBhcnNlcyBkZWZpbml0aW9uIHdpdGggcHJpbWl0aXZlIHR5cGUgYW5ub3RhdGlvblwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VEZWZpbml0aW9uKFwiYW5zd2VyID0gNDIgOiBOdW1iZXI7XCIpO1xuXHRcdGV4cGVjdChyZXN1bHQuc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGV4cGVjdChyZXN1bHQuc3RhdGVtZW50c1swXS5raW5kKS50b0JlKFwiZGVmaW5pdGlvblwiKTtcblx0XHRjb25zdCBkZWYgPSBhc3NlcnREZWZpbml0aW9uRXhwcmVzc2lvbihyZXN1bHQuc3RhdGVtZW50c1swXSk7XG5cdFx0ZXhwZWN0KGRlZi5uYW1lKS50b0JlKFwiYW5zd2VyXCIpO1xuXHRcdGNvbnN0IHR5cGVkID0gYXNzZXJ0VHlwZWRFeHByZXNzaW9uKGRlZi52YWx1ZSk7XG5cdFx0ZXhwZWN0KHR5cGVkLmV4cHJlc3Npb24ua2luZCkudG9CZShcImxpdGVyYWxcIik7XG5cdFx0ZXhwZWN0KHR5cGVkLnR5cGUua2luZCkudG9CZShcInByaW1pdGl2ZVwiKTtcblx0fSk7XG5cblx0dGVzdChcInBhcnNlcyBkZWZpbml0aW9uIHdpdGggbGlzdCB0eXBlIGFubm90YXRpb25cIiwgKCkgPT4ge1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlRGVmaW5pdGlvbihcIm51bWJlcnMgPSBbMSwgMiwgM10gOiBMaXN0IE51bWJlcjtcIik7XG5cdFx0ZXhwZWN0KHJlc3VsdC5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0Y29uc3QgZGVmID0gYXNzZXJ0RGVmaW5pdGlvbkV4cHJlc3Npb24ocmVzdWx0LnN0YXRlbWVudHNbMF0pO1xuXHRcdGV4cGVjdChkZWYubmFtZSkudG9CZShcIm51bWJlcnNcIik7XG5cdFx0Y29uc3QgdHlwZWQgPSBhc3NlcnRUeXBlZEV4cHJlc3Npb24oZGVmLnZhbHVlKTtcblx0XHRleHBlY3QodHlwZWQuZXhwcmVzc2lvbi5raW5kKS50b0JlKFwibGlzdFwiKTtcblx0XHRleHBlY3QodHlwZWQudHlwZS5raW5kKS50b0JlKFwibGlzdFwiKTsgLy8gTGlzdCB0eXBlcyBoYXZlIGtpbmQgXCJsaXN0XCJcblx0XHRleHBlY3QoKHR5cGVkLnR5cGUgYXMgYW55KS5lbGVtZW50LmtpbmQpLnRvQmUoXCJwcmltaXRpdmVcIik7IC8vIE51bWJlciBpcyBhIHByaW1pdGl2ZSB0eXBlICBcblx0XHRleHBlY3QoKHR5cGVkLnR5cGUgYXMgYW55KS5lbGVtZW50Lm5hbWUpLnRvQmUoXCJJbnRcIik7IC8vIE51bWJlciBtYXBzIHRvIEludCBpbnRlcm5hbGx5XG5cdH0pO1xuXG5cdHRlc3QoXCJwYXJzZXMgbXVsdGlwbGUgZGVmaW5pdGlvbnMgd2l0aCB0eXBlIGFubm90YXRpb25zXCIsICgpID0+IHtcblx0XHRjb25zdCByZXN1bHQgPSBwYXJzZURlZmluaXRpb24oYFxuICAgICAgYWRkID0gZm4geCB5ID0+IHggKyB5IDogTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXI7XG4gICAgICBhbnN3ZXIgPSA0MiA6IE51bWJlcjtcbiAgICAgIG51bWJlcnMgPSBbMSwgMiwgM10gOiBMaXN0IE51bWJlcjtcbiAgICBgKTtcblx0XHRleHBlY3QocmVzdWx0LnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCBzZXEgPSBhc3NlcnRCaW5hcnlFeHByZXNzaW9uKHJlc3VsdC5zdGF0ZW1lbnRzWzBdKTtcblx0XHRleHBlY3Qoc2VxLmtpbmQpLnRvQmUoXCJiaW5hcnlcIik7IC8vIHNlbWljb2xvbiBzZXF1ZW5jZVxuXHRcdGV4cGVjdChzZXEub3BlcmF0b3IpLnRvQmUoXCI7XCIpO1xuXHR9KTtcblxuXHQvLyBQaGFzZSAxOiBFZmZlY3QgcGFyc2luZyB0ZXN0c1xuXHRkZXNjcmliZShcIkVmZmVjdCBwYXJzaW5nXCIsICgpID0+IHtcblx0XHR0ZXN0KFwic2hvdWxkIHBhcnNlIGZ1bmN0aW9uIHR5cGUgd2l0aCBzaW5nbGUgZWZmZWN0XCIsICgpID0+IHtcblx0XHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiSW50IC0+IEludCAhd3JpdGVcIik7XG5cdFx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VUeXBlRXhwcmVzc2lvbih0b2tlbnMpO1xuXHRcdFx0XG5cdFx0XHRhc3NlcnRQYXJzZVN1Y2Nlc3MocmVzdWx0KTtcblx0XHRcdGFzc2VydEZ1bmN0aW9uVHlwZShyZXN1bHQudmFsdWUpO1xuXHRcdGNvbnN0IGZ1bmNUeXBlID0gcmVzdWx0LnZhbHVlO1xuXHRcdFx0ZXhwZWN0KFsuLi5mdW5jVHlwZS5lZmZlY3RzXSkudG9FcXVhbChbXCJ3cml0ZVwiXSk7XG5cdFx0XHRleHBlY3QoZnVuY1R5cGUucGFyYW1zKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0XHRleHBlY3QoZnVuY1R5cGUucGFyYW1zWzBdLmtpbmQpLnRvQmUoXCJwcmltaXRpdmVcIik7XG5cdFx0XHRleHBlY3QoZnVuY1R5cGUucmV0dXJuLmtpbmQpLnRvQmUoXCJwcmltaXRpdmVcIik7XG5cdFx0fSk7XG5cblx0XHR0ZXN0KFwic2hvdWxkIHBhcnNlIGZ1bmN0aW9uIHR5cGUgd2l0aCBtdWx0aXBsZSBlZmZlY3RzXCIsICgpID0+IHtcblx0XHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiSW50IC0+IFN0cmluZyAhd3JpdGUgIWxvZ1wiKTtcblx0XHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBwYXJzZVR5cGVFeHByZXNzaW9uKHRva2Vucyk7XG5cdFx0XHRcblx0XHRcdGFzc2VydFBhcnNlU3VjY2VzcyhyZXN1bHQpO1xuXHRcdFx0YXNzZXJ0RnVuY3Rpb25UeXBlKHJlc3VsdC52YWx1ZSk7XG5cdFx0Y29uc3QgZnVuY1R5cGUgPSByZXN1bHQudmFsdWU7XG5cdFx0XHRleHBlY3QoWy4uLmZ1bmNUeXBlLmVmZmVjdHNdLnNvcnQoKSkudG9FcXVhbChbXCJsb2dcIiwgXCJ3cml0ZVwiXSk7XG5cdFx0fSk7XG5cblx0XHR0ZXN0KFwic2hvdWxkIHBhcnNlIGZ1bmN0aW9uIHR5cGUgd2l0aCBhbGwgdmFsaWQgZWZmZWN0c1wiLCAoKSA9PiB7XG5cdFx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIkludCAtPiBJbnQgIWxvZyAhcmVhZCAhd3JpdGUgIXN0YXRlICF0aW1lICFyYW5kICFmZmkgIWFzeW5jXCIpO1xuXHRcdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZUV4cHJlc3Npb24odG9rZW5zKTtcblx0XHRcdFxuXHRcdFx0YXNzZXJ0UGFyc2VTdWNjZXNzKHJlc3VsdCk7XG5cdFx0XHRhc3NlcnRGdW5jdGlvblR5cGUocmVzdWx0LnZhbHVlKTtcblx0XHRjb25zdCBmdW5jVHlwZSA9IHJlc3VsdC52YWx1ZTtcblx0XHRcdGV4cGVjdChbLi4uZnVuY1R5cGUuZWZmZWN0c10uc29ydCgpKS50b0VxdWFsKFtcImFzeW5jXCIsIFwiZmZpXCIsIFwibG9nXCIsIFwicmFuZFwiLCBcInJlYWRcIiwgXCJzdGF0ZVwiLCBcInRpbWVcIiwgXCJ3cml0ZVwiXSk7XG5cdFx0fSk7XG5cblx0XHR0ZXN0KFwic2hvdWxkIHBhcnNlIGZ1bmN0aW9uIHR5cGUgd2l0aCBubyBlZmZlY3RzXCIsICgpID0+IHtcblx0XHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiSW50IC0+IEludFwiKTtcblx0XHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBwYXJzZVR5cGVFeHByZXNzaW9uKHRva2Vucyk7XG5cdFx0XHRcblx0XHRcdGFzc2VydFBhcnNlU3VjY2VzcyhyZXN1bHQpO1xuXHRcdFx0YXNzZXJ0RnVuY3Rpb25UeXBlKHJlc3VsdC52YWx1ZSk7XG5cdFx0Y29uc3QgZnVuY1R5cGUgPSByZXN1bHQudmFsdWU7XG5cdFx0XHRleHBlY3QoWy4uLmZ1bmNUeXBlLmVmZmVjdHNdKS50b0VxdWFsKFtdKTtcblx0XHR9KTtcblxuXHRcdHRlc3QoXCJzaG91bGQgcGFyc2UgbXVsdGktcGFyYW1ldGVyIGZ1bmN0aW9uIHdpdGggZWZmZWN0c1wiLCAoKSA9PiB7XG5cdFx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIkludCAtPiBTdHJpbmcgLT4gQm9vbCAhcmVhZFwiKTtcblx0XHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBwYXJzZVR5cGVFeHByZXNzaW9uKHRva2Vucyk7XG5cdFx0XHRcblx0XHRcdGFzc2VydFBhcnNlU3VjY2VzcyhyZXN1bHQpO1xuXHRcdFx0YXNzZXJ0RnVuY3Rpb25UeXBlKHJlc3VsdC52YWx1ZSk7XG5cdFx0Y29uc3QgZnVuY1R5cGUgPSByZXN1bHQudmFsdWU7XG5cdFx0XHRleHBlY3QoWy4uLmZ1bmNUeXBlLmVmZmVjdHNdKS50b0VxdWFsKFtcInJlYWRcIl0pO1xuXHRcdFx0ZXhwZWN0KGZ1bmNUeXBlLnBhcmFtcykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdFx0ZXhwZWN0KGZ1bmNUeXBlLnJldHVybi5raW5kKS50b0JlKFwiZnVuY3Rpb25cIik7XG5cdFx0fSk7XG5cblx0XHR0ZXN0KFwic2hvdWxkIHJlamVjdCBpbnZhbGlkIGVmZmVjdCBuYW1lc1wiLCAoKSA9PiB7XG5cdFx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIkludCAtPiBJbnQgIWludmFsaWRcIik7XG5cdFx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VUeXBlRXhwcmVzc2lvbih0b2tlbnMpO1xuXHRcdFx0XG5cdFx0XHRhc3NlcnRQYXJzZUVycm9yKHJlc3VsdCk7XG5cdFx0XHRleHBlY3QocmVzdWx0LmVycm9yKS50b0NvbnRhaW4oXCJJbnZhbGlkIGVmZmVjdDogaW52YWxpZFwiKTtcblx0XHR9KTtcblxuXHRcdHRlc3QoXCJzaG91bGQgcmVxdWlyZSBlZmZlY3QgbmFtZSBhZnRlciBleGNsYW1hdGlvbiBtYXJrXCIsICgpID0+IHtcblx0XHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiSW50IC0+IEludCAhXCIpO1xuXHRcdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZUV4cHJlc3Npb24odG9rZW5zKTtcblx0XHRcdFxuXHRcdFx0YXNzZXJ0UGFyc2VFcnJvcihyZXN1bHQpO1xuXHRcdFx0ZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKFwiRXhwZWN0ZWQgZWZmZWN0IG5hbWUgYWZ0ZXIgIVwiKTtcblx0XHR9KTtcblxuXHRcdHRlc3QoXCJzaG91bGQgcGFyc2UgdHlwZWQgZXhwcmVzc2lvbiB3aXRoIGVmZmVjdHNcIiwgKCkgPT4ge1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VEZWZpbml0aW9uKFwieCA6IEludCAtPiBJbnQgIXN0YXRlXCIpO1xuXHRcdFx0ZXhwZWN0KHJlc3VsdC5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0XHRjb25zdCB0eXBlZCA9IGFzc2VydFR5cGVkRXhwcmVzc2lvbihyZXN1bHQuc3RhdGVtZW50c1swXSk7XG5cdFx0XHRhc3NlcnRGdW5jdGlvblR5cGUodHlwZWQudHlwZSk7XG5cdFx0Y29uc3QgZnVuY1R5cGUgPSB0eXBlZC50eXBlO1xuXHRcdFx0ZXhwZWN0KFsuLi5mdW5jVHlwZS5lZmZlY3RzXSkudG9FcXVhbChbXCJzdGF0ZVwiXSk7XG5cdFx0fSk7XG5cblx0XHR0ZXN0KFwic2hvdWxkIHBhcnNlIGZ1bmN0aW9uIGRlZmluaXRpb24gd2l0aCBlZmZlY3QgYW5ub3RhdGlvblwiLCAoKSA9PiB7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBwYXJzZURlZmluaXRpb24oXCJmbiB4ID0+IHggOiBJbnQgLT4gSW50ICFsb2dcIik7XG5cdFx0XHRleHBlY3QocmVzdWx0LnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRcdGNvbnN0IGZ1bmMgPSBhc3NlcnRGdW5jdGlvbkV4cHJlc3Npb24ocmVzdWx0LnN0YXRlbWVudHNbMF0pO1xuXHRcdFx0Y29uc3QgdHlwZWQgPSBhc3NlcnRUeXBlZEV4cHJlc3Npb24oZnVuYy5ib2R5KTtcblx0XHRcdGFzc2VydEZ1bmN0aW9uVHlwZSh0eXBlZC50eXBlKTtcblx0XHRjb25zdCBmdW5jVHlwZSA9IHR5cGVkLnR5cGU7XG5cdFx0XHRleHBlY3QoWy4uLmZ1bmNUeXBlLmVmZmVjdHNdKS50b0VxdWFsKFtcImxvZ1wiXSk7XG5cdFx0fSk7XG5cblx0XHR0ZXN0KFwic2hvdWxkIGF1dG9tYXRpY2FsbHkgZGVkdXBsaWNhdGUgZWZmZWN0c1wiLCAoKSA9PiB7XG5cdFx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIkludCAtPiBJbnQgIXdyaXRlICFsb2cgIXdyaXRlXCIpO1xuXHRcdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZUV4cHJlc3Npb24odG9rZW5zKTtcblx0XHRcdFxuXHRcdFx0YXNzZXJ0UGFyc2VTdWNjZXNzKHJlc3VsdCk7XG5cdFx0XHRhc3NlcnRGdW5jdGlvblR5cGUocmVzdWx0LnZhbHVlKTtcblx0XHRjb25zdCBmdW5jVHlwZSA9IHJlc3VsdC52YWx1ZTtcblx0XHRcdC8vIFNldCBhdXRvbWF0aWNhbGx5IGRlZHVwbGljYXRlcywgc28gIXdyaXRlICFsb2cgIXdyaXRlIGJlY29tZXMge2xvZywgd3JpdGV9XG5cdFx0XHRleHBlY3QoWy4uLmZ1bmNUeXBlLmVmZmVjdHNdLnNvcnQoKSkudG9FcXVhbChbXCJsb2dcIiwgXCJ3cml0ZVwiXSk7XG5cdFx0XHRleHBlY3QoZnVuY1R5cGUuZWZmZWN0cy5zaXplKS50b0JlKDIpO1xuXHRcdH0pO1xuXHR9KTtcbn0pO1xuXG4vLyBBZGQgbmV3IHRlc3Qgc3VpdGUgZm9yIEVkZ2UgQ2FzZXMgYW5kIEVycm9yIENvbmRpdGlvbnMgdG8gaW1wcm92ZSBjb3ZlcmFnZVxuZGVzY3JpYmUoXCJFZGdlIENhc2VzIGFuZCBFcnJvciBDb25kaXRpb25zXCIsICgpID0+IHtcblx0dGVzdChcInNob3VsZCBoYW5kbGUgZW1wdHkgaW5wdXQgZm9yIHR5cGUgZXhwcmVzc2lvbnNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IHRva2VuczogYW55W10gPSBbXTtcblx0XHRjb25zdCByZXN1bHQgPSBwYXJzZVR5cGVFeHByZXNzaW9uKHRva2Vucyk7XG5cdFx0YXNzZXJ0UGFyc2VFcnJvcihyZXN1bHQpO1xuXHRcdGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbihcIkV4cGVjdGVkIHR5cGUgZXhwcmVzc2lvblwiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBoYW5kbGUgaW52YWxpZCB0b2tlbnMgZm9yIHR5cGUgZXhwcmVzc2lvbnNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiQGludmFsaWRcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCByZXN1bHQgPSBwYXJzZVR5cGVFeHByZXNzaW9uKHRva2Vucyk7XG5cdFx0YXNzZXJ0UGFyc2VFcnJvcihyZXN1bHQpO1xuXHRcdGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbihcIkV4cGVjdGVkIHR5cGUgZXhwcmVzc2lvblwiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSBVbml0IHR5cGUgY29ycmVjdGx5XCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIlVuaXRcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCByZXN1bHQgPSBwYXJzZVR5cGVFeHByZXNzaW9uKHRva2Vucyk7XG5cdFx0YXNzZXJ0UGFyc2VTdWNjZXNzKHJlc3VsdCk7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5raW5kKS50b0JlKFwidW5pdFwiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBwYXJzZSBOdW1iZXIgdHlwZSBjb3JyZWN0bHlcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiTnVtYmVyXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VUeXBlRXhwcmVzc2lvbih0b2tlbnMpO1xuXHRcdGFzc2VydFBhcnNlU3VjY2VzcyhyZXN1bHQpO1xuXHRcdGV4cGVjdChyZXN1bHQudmFsdWUua2luZCkudG9CZShcInByaW1pdGl2ZVwiKTtcblx0XHRleHBlY3QoKHJlc3VsdC52YWx1ZSBhcyBhbnkpLm5hbWUpLnRvQmUoXCJJbnRcIik7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgaGFuZGxlIGluY29tcGxldGUgZnVuY3Rpb24gdHlwZVwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJJbnQgLT5cIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCByZXN1bHQgPSBwYXJzZVR5cGVFeHByZXNzaW9uKHRva2Vucyk7XG5cdFx0YXNzZXJ0UGFyc2VFcnJvcihyZXN1bHQpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIGhhbmRsZSBpbnZhbGlkIGVmZmVjdCBuYW1lXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIkludCAtPiBJbnQgIWludmFsaWRlZmZlY3RcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCByZXN1bHQgPSBwYXJzZVR5cGVFeHByZXNzaW9uKHRva2Vucyk7XG5cdFx0YXNzZXJ0UGFyc2VFcnJvcihyZXN1bHQpO1xuXHRcdGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbihcIkludmFsaWQgZWZmZWN0OiBpbnZhbGlkZWZmZWN0XCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIGhhbmRsZSBtaXNzaW5nIGVmZmVjdCBuYW1lIGFmdGVyIGV4Y2xhbWF0aW9uXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIkludCAtPiBJbnQgIVwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZUV4cHJlc3Npb24odG9rZW5zKTtcblx0XHRhc3NlcnRQYXJzZUVycm9yKHJlc3VsdCk7XG5cdFx0ZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKFwiRXhwZWN0ZWQgZWZmZWN0IG5hbWUgYWZ0ZXIgIVwiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBoYW5kbGUgZ2VuZXJpYyBMaXN0IHR5cGVcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiTGlzdFwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZUV4cHJlc3Npb24odG9rZW5zKTtcblx0XHRhc3NlcnRQYXJzZVN1Y2Nlc3MocmVzdWx0KTtcblx0XHRhc3NlcnRMaXN0VHlwZShyZXN1bHQudmFsdWUpO1xuXHRcdGV4cGVjdChyZXN1bHQudmFsdWUuZWxlbWVudC5raW5kKS50b0JlKFwidmFyaWFibGVcIik7XG5cdFx0ZXhwZWN0KChyZXN1bHQudmFsdWUuZWxlbWVudCBhcyBhbnkpLm5hbWUpLnRvQmUoXCJhXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIGhhbmRsZSBMaXN0IHR5cGUgd2l0aCBhcmd1bWVudFwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJMaXN0IFN0cmluZ1wiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZUV4cHJlc3Npb24odG9rZW5zKTtcblx0XHRhc3NlcnRQYXJzZVN1Y2Nlc3MocmVzdWx0KTtcblx0XHRhc3NlcnRMaXN0VHlwZShyZXN1bHQudmFsdWUpO1xuXHRcdGV4cGVjdChyZXN1bHQudmFsdWUuZWxlbWVudC5raW5kKS50b0JlKFwicHJpbWl0aXZlXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIGhhbmRsZSBlbXB0eSByZWNvcmQgZmllbGRzXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcInsgfVwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHMpLnRvSGF2ZUxlbmd0aCgxKTtcblx0XHRjb25zdCB1bml0ID0gYXNzZXJ0VW5pdEV4cHJlc3Npb24ocHJvZ3JhbS5zdGF0ZW1lbnRzWzBdKTtcblx0XHRleHBlY3QodW5pdC5raW5kKS50b0JlKFwidW5pdFwiKTtcblx0fSk7XG5cblx0dGVzdC5za2lwKFwic2hvdWxkIGhhbmRsZSByZWNvcmQgZmllbGQgcGFyc2luZyBlZGdlIGNhc2VzXCIsICgpID0+IHtcblx0XHQvLyBUT0RPOiBUaGlzIHRlc3QgaXMgc2tpcHBlZCBiZWNhdXNlIHRoZSBpbnB1dCBcInsgQG5hbWUgQHZhbHVlIH1cIiBpcyBhY3R1YWxseSB2YWxpZCBzeW50YXhcblx0XHQvLyB0aGF0IHBhcnNlcyBhcyBhIHJlY29yZCB3aXRoIHBvc2l0aW9uYWwgZmllbGRzLiBOZWVkIHRvIGZpbmQgYSB0cnVseSBpbnZhbGlkIHN5bnRheFxuXHRcdC8vIHRvIHRlc3QgZXJyb3IgY29uZGl0aW9ucywgb3IgYWRqdXN0IHRoZSB0ZXN0IGV4cGVjdGF0aW9uLlxuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwieyBAbmFtZSBAdmFsdWUgfVwiKTsgLy8gSW52YWxpZCBzeW50YXggLSB0d28gYWNjZXNzb3JzXG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRleHBlY3QoKCkgPT4gcGFyc2UodG9rZW5zKSkudG9UaHJvdyhcIlBhcnNlIGVycm9yXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIGhhbmRsZSBlbXB0eSBsaXN0IGVsZW1lbnRzXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIltdXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHNbMF0ua2luZCkudG9CZShcImxpc3RcIik7XG5cdFx0Y29uc3QgbGlzdCA9IHByb2dyYW0uc3RhdGVtZW50c1swXSBhcyBhbnk7XG5cdFx0ZXhwZWN0KGxpc3QuZWxlbWVudHMpLnRvSGF2ZUxlbmd0aCgwKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBoYW5kbGUgYWRqYWNlbnQgbWludXMgZm9yIHVuYXJ5IG9wZXJhdG9yXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIi0xMjNcIik7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblx0XHRleHBlY3QocHJvZ3JhbS5zdGF0ZW1lbnRzKS50b0hhdmVMZW5ndGgoMSk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50c1swXS5raW5kKS50b0JlKFwiYmluYXJ5XCIpO1xuXHRcdGNvbnN0IGJpbmFyeSA9IHByb2dyYW0uc3RhdGVtZW50c1swXSBhcyBhbnk7XG5cdFx0ZXhwZWN0KGJpbmFyeS5vcGVyYXRvcikudG9CZShcIipcIik7XG5cdFx0ZXhwZWN0KGJpbmFyeS5sZWZ0LnZhbHVlKS50b0JlKC0xKTtcblx0XHRleHBlY3QoYmluYXJ5LnJpZ2h0LnZhbHVlKS50b0JlKDEyMyk7XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgaGFuZGxlIG5vbi1hZGphY2VudCBtaW51cyBmb3IgYmluYXJ5IG9wZXJhdG9yXCIsICgpID0+IHtcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcImEgLSBiXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGV4cGVjdChwcm9ncmFtLnN0YXRlbWVudHNbMF0ua2luZCkudG9CZShcImJpbmFyeVwiKTtcblx0XHRjb25zdCBiaW5hcnkgPSBwcm9ncmFtLnN0YXRlbWVudHNbMF0gYXMgYW55O1xuXHRcdGV4cGVjdChiaW5hcnkub3BlcmF0b3IpLnRvQmUoXCItXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIGhhbmRsZSBmdW5jdGlvbiB0eXBlIHdpdGhvdXQgZWZmZWN0cyBmYWxsYmFja1wiLCAoKSA9PiB7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJTdHJpbmcgLT4gSW50XCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VUeXBlRXhwcmVzc2lvbih0b2tlbnMpO1xuXHRcdGFzc2VydFBhcnNlU3VjY2VzcyhyZXN1bHQpO1xuXHRcdGFzc2VydEZ1bmN0aW9uVHlwZShyZXN1bHQudmFsdWUpO1xuXHRcdGV4cGVjdChbLi4ucmVzdWx0LnZhbHVlLmVmZmVjdHNdKS50b0VxdWFsKFtdKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBoYW5kbGUgbG93ZXJjYXNlIHR5cGUgdmFyaWFibGVcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiYVwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZUV4cHJlc3Npb24odG9rZW5zKTtcblx0XHRhc3NlcnRQYXJzZVN1Y2Nlc3MocmVzdWx0KTtcblx0XHRhc3NlcnRWYXJpYWJsZVR5cGUocmVzdWx0LnZhbHVlKTtcblx0XHRleHBlY3QocmVzdWx0LnZhbHVlLm5hbWUpLnRvQmUoXCJhXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIGhhbmRsZSByZWNvcmQgdHlwZSBlZGdlIGNhc2VcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwieyBuYW1lOiBTdHJpbmcgfVwiKTtcblx0XHRjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuXHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZUV4cHJlc3Npb24odG9rZW5zKTtcblx0XHRhc3NlcnRQYXJzZVN1Y2Nlc3MocmVzdWx0KTtcblx0XHRhc3NlcnRSZWNvcmRUeXBlKHJlc3VsdC52YWx1ZSk7XG5cdFx0ZXhwZWN0KHJlc3VsdC52YWx1ZS5maWVsZHMpLnRvSGF2ZVByb3BlcnR5KFwibmFtZVwiKTtcblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBoYW5kbGUgdHVwbGUgdHlwZSBlZGdlIGNhc2VcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwieyBTdHJpbmcsIEludCB9XCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VUeXBlRXhwcmVzc2lvbih0b2tlbnMpO1xuXHRcdGFzc2VydFBhcnNlU3VjY2VzcyhyZXN1bHQpO1xuXHRcdGFzc2VydFR1cGxlVHlwZShyZXN1bHQudmFsdWUpO1xuXHRcdGV4cGVjdChyZXN1bHQudmFsdWUuZWxlbWVudHMpLnRvSGF2ZUxlbmd0aCgyKTtcblx0fSk7XG5cblx0dGVzdC5za2lwKFwic2hvdWxkIGhhbmRsZSBkZWJ1ZyBsb2dnaW5nIHdoZW4gZW5hYmxlZFwiLCAoKSA9PiB7XG5cdFx0Ly8gU2V0IGRlYnVnIGVudmlyb25tZW50IHZhcmlhYmxlXG5cdFx0Y29uc3Qgb3JpZ2luYWxEZWJ1ZyA9IHByb2Nlc3MuZW52Lk5PT19ERUJVR19QQVJTRTtcblx0XHRwcm9jZXNzLmVudi5OT09fREVCVUdfUEFSU0UgPSBcIjFcIjtcblx0XHRcblx0XHRjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIjQyXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdFxuXHRcdC8vIFJlc3RvcmUgb3JpZ2luYWwgZW52aXJvbm1lbnRcblx0XHRpZiAob3JpZ2luYWxEZWJ1Zykge1xuXHRcdFx0cHJvY2Vzcy5lbnYuTk9PX0RFQlVHX1BBUlNFID0gb3JpZ2luYWxEZWJ1Zztcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIHByb2Nlc3MuZW52Lk5PT19ERUJVR19QQVJTRTtcblx0XHR9XG5cdH0pO1xuXG5cdHRlc3QoXCJzaG91bGQgaGFuZGxlIHVuZXhwZWN0ZWQgdG9rZW4gdHlwZXMgaW4gcHJpbWFyeSBwYXJzZXJcIiwgKCkgPT4ge1xuXHRcdC8vIENyZWF0ZSBhIG1vY2sgdG9rZW4gd2l0aCBhbiB1bmV4cGVjdGVkIHR5cGVcblx0XHRjb25zdCB0b2tlbnMgPSBbe1xuXHRcdFx0dHlwZTogXCJDT01NRU5UXCIgYXMgYW55LFxuXHRcdFx0dmFsdWU6IFwiIyBjb21tZW50XCIsXG5cdFx0XHRsb2NhdGlvbjogeyBzdGFydDogeyBsaW5lOiAxLCBjb2x1bW46IDEgfSwgZW5kOiB7IGxpbmU6IDEsIGNvbHVtbjogOSB9IH1cblx0XHR9XTtcblx0XHRleHBlY3QoKCkgPT4gcGFyc2UodG9rZW5zKSkudG9UaHJvdyhcIlBhcnNlIGVycm9yXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIGhhbmRsZSB2YXJpb3VzIHB1bmN0dWF0aW9uIGNhc2VzXCIsICgpID0+IHtcblx0XHRjb25zdCB0ZXN0Q2FzZXMgPSBbXG5cdFx0XHRcIihcIixcblx0XHRcdFwiW1wiLFxuXHRcdFx0XCJ7XCIsXG5cdFx0XTtcblx0XHRcblx0XHRmb3IgKGNvbnN0IHRlc3RDYXNlIG9mIHRlc3RDYXNlcykge1xuXHRcdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIodGVzdENhc2UpO1xuXHRcdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRcdGV4cGVjdCgoKSA9PiBwYXJzZSh0b2tlbnMpKS50b1Rocm93KFwiUGFyc2UgZXJyb3JcIik7XG5cdFx0fVxuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIGhhbmRsZSB0eXBlIGF0b20gcGFyc2luZyBlZGdlIGNhc2VzXCIsICgpID0+IHtcblx0XHQvLyBUZXN0IHZhcmlvdXMgZWRnZSBjYXNlcyB0aGF0IG1pZ2h0IG5vdCBiZSBjb3ZlcmVkXG5cdFx0Y29uc3QgdGVzdENhc2VzID0gW1xuXHRcdFx0XCIoSW50IC0+IFN0cmluZylcIixcblx0XHRcdFwiTWF5YmUgSW50XCIsXG5cdFx0XHRcIkVpdGhlciBTdHJpbmcgSW50XCIsXG5cdFx0XTtcblx0XHRcblx0XHRmb3IgKGNvbnN0IHRlc3RDYXNlIG9mIHRlc3RDYXNlcykge1xuXHRcdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIodGVzdENhc2UpO1xuXHRcdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IHBhcnNlVHlwZUV4cHJlc3Npb24odG9rZW5zKTtcblx0XHRcdGFzc2VydFBhcnNlU3VjY2VzcyhyZXN1bHQpO1xuXHRcdH1cblx0fSk7XG5cblx0dGVzdChcInNob3VsZCBoYW5kbGUgY29uc3RyYWludCBleHByZXNzaW9uIGVkZ2UgY2FzZXNcIiwgKCkgPT4ge1xuXHRcdGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwieCA6IGEgZ2l2ZW4gKGEgaXMgRXEpXCIpO1xuXHRcdGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG5cdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdGNvbnN0IGNvbnN0cmFpbmVkID0gYXNzZXJ0Q29uc3RyYWluZWRFeHByZXNzaW9uKHByb2dyYW0uc3RhdGVtZW50c1swXSk7XG5cdFx0ZXhwZWN0KGNvbnN0cmFpbmVkLmNvbnN0cmFpbnQua2luZCkudG9CZShcInBhcmVuXCIpO1xuXHR9KTtcblxuXHR0ZXN0KFwic2hvdWxkIGhhbmRsZSBjb21wbGV4IHBhcnNpbmcgZWRnZSBjYXNlcyBmb3IgY292ZXJhZ2VcIiwgKCkgPT4ge1xuXHRcdC8vIFRlc3Qgc29tZSBjb21wbGV4IHBhcnNpbmcgc2NlbmFyaW9zXG5cdFx0Y29uc3QgdGVzdENhc2VzID0gW1xuXHRcdFx0XCJmbiB4IHkgeiA9PiB4ICsgeSArIHpcIixcblx0XHRcdFwiKGZuIHggPT4geCkgNDJcIixcblx0XHRcdFwiWzEsIDIsIDNdIHw+IG1hcCB8PiBmaWx0ZXJcIixcblx0XHRcdFwieyBAYSAxLCBAYiAyLCBAYyAzIH1cIixcblx0XHRcdFwibWF0Y2ggeCB3aXRoICggU29tZSB5ID0+IHkgKyAxOyBOb25lID0+IDAgKVwiLFxuXHRcdF07XG5cblx0XHRmb3IgKGNvbnN0IHRlc3RDYXNlIG9mIHRlc3RDYXNlcykge1xuXHRcdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIodGVzdENhc2UpO1xuXHRcdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZSh0b2tlbnMpO1xuXHRcdFx0ZXhwZWN0KHByb2dyYW0uc3RhdGVtZW50cykudG9IYXZlTGVuZ3RoKDEpO1xuXHRcdH1cblx0fSk7XG59KTtcbiJdLCJuYW1lcyI6WyJhc3NlcnRMaXRlcmFsRXhwcmVzc2lvbiIsImV4cHIiLCJraW5kIiwiRXJyb3IiLCJhc3NlcnRWYXJpYWJsZUV4cHJlc3Npb24iLCJhc3NlcnRGdW5jdGlvbkV4cHJlc3Npb24iLCJhc3NlcnRBcHBsaWNhdGlvbkV4cHJlc3Npb24iLCJhc3NlcnRCaW5hcnlFeHByZXNzaW9uIiwiYXNzZXJ0SWZFeHByZXNzaW9uIiwiYXNzZXJ0UmVjb3JkRXhwcmVzc2lvbiIsImFzc2VydEFjY2Vzc29yRXhwcmVzc2lvbiIsImFzc2VydFVuaXRFeHByZXNzaW9uIiwiYXNzZXJ0VHlwZURlZmluaXRpb25FeHByZXNzaW9uIiwiYXNzZXJ0V2hlcmVFeHByZXNzaW9uIiwiYXNzZXJ0TXV0YWJsZURlZmluaXRpb25FeHByZXNzaW9uIiwiYXNzZXJ0TXV0YXRpb25FeHByZXNzaW9uIiwiYXNzZXJ0Q29uc3RyYWludERlZmluaXRpb25FeHByZXNzaW9uIiwiYXNzZXJ0SW1wbGVtZW50RGVmaW5pdGlvbkV4cHJlc3Npb24iLCJhc3NlcnRDb25zdHJhaW5lZEV4cHJlc3Npb24iLCJhc3NlcnRSZWNvcmRUeXBlIiwidHlwZSIsImFzc2VydFR1cGxlVHlwZSIsImFzc2VydExpc3RUeXBlIiwiYXNzZXJ0RnVuY3Rpb25UeXBlIiwiYXNzZXJ0VmFyaWFibGVUeXBlIiwiYXNzZXJ0RGVmaW5pdGlvbkV4cHJlc3Npb24iLCJhc3NlcnRUeXBlZEV4cHJlc3Npb24iLCJhc3NlcnRNYXRjaEV4cHJlc3Npb24iLCJhc3NlcnRQYXJzZVN1Y2Nlc3MiLCJyZXN1bHQiLCJzdWNjZXNzIiwiZXJyb3IiLCJhc3NlcnRQYXJzZUVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImRlc2NyaWJlIiwidGVzdCIsImxleGVyIiwiTGV4ZXIiLCJ0b2tlbnMiLCJ0b2tlbml6ZSIsInByb2dyYW0iLCJwYXJzZSIsImV4cGVjdCIsInN0YXRlbWVudHMiLCJ0b0hhdmVMZW5ndGgiLCJsaXRlcmFsIiwidmFsdWUiLCJ0b0JlIiwibmFtZSIsInZhcmlhYmxlIiwiZnVuYyIsInBhcmFtcyIsInRvRXF1YWwiLCJib2R5IiwiYXBwIiwiYXJncyIsImFyZyIsImJpbmFyeSIsIm9wZXJhdG9yIiwiZWxlbWVudHMiLCJBcnJheSIsImlzQXJyYXkiLCJpZkV4cHIiLCJjb25kaXRpb24iLCJ0aGVuIiwiZWxzZSIsInBpcGVsaW5lIiwic3RlcHMiLCJyZWNvcmQiLCJmaWVsZHMiLCJhY2Nlc3NvciIsImZpZWxkIiwib3V0ZXIiLCJrZXlGaWVsZCIsIm5lc3RlZFR1cGxlIiwiaSIsImxpc3QiLCJuZXN0ZWRSZWNvcmQiLCJpbm5lckZpZWxkIiwiaW5uZXJMaXN0IiwibWFwIiwiZSIsInR1cGxlIiwidGhydXNoIiwibGVmdCIsInJpZ2h0IiwiY2hhaW4iLCJ1bml0IiwidHlwZURlZiIsInR5cGVQYXJhbXMiLCJjb25zdHJ1Y3RvcnMiLCJtYXRjaEV4cHIiLCJleHByZXNzaW9uIiwiY2FzZXMiLCJwYXR0ZXJuIiwic2tpcCIsIm5lc3RlZFBhdHRlcm4iLCJ3aGVyZUV4cHIiLCJtYWluIiwiZGVmaW5pdGlvbnMiLCJtdXREZWYiLCJtdXRhdGlvbiIsInRhcmdldCIsImNvbnN0cmFpbnREZWYiLCJ0eXBlUGFyYW0iLCJmdW5jdGlvbnMiLCJpbXBsRGVmIiwiY29uc3RyYWludE5hbWUiLCJ0eXBlTmFtZSIsImltcGxlbWVudGF0aW9ucyIsInBhcnNlVHlwZUV4cHJlc3Npb24iLCJ0dXBsZUNvbnN0cnVjdG9yIiwibGlzdFR5cGUiLCJlbGVtZW50IiwidmFyaWFudFR5cGUiLCJjb25zdHJhaW5lZCIsImNvbnN0cmFpbnQiLCJ0eXBlVmFyIiwiYW5kQ29uc3RyYWludCIsImhhc0ZpZWxkQ29uc3RyYWludCIsImZpZWxkVHlwZSIsImltcGxlbWVudHNDb25zdHJhaW50IiwiaW50ZXJmYWNlTmFtZSIsIm9yQ29uc3RyYWludCIsInRvVGhyb3ciLCJub3QiLCJyaWdodEV4cHIiLCJzZXEiLCJjb2RlIiwicGFyc2VUeXBlIiwidHlwZVNyYyIsInRvSGF2ZVByb3BlcnR5IiwiYWdlIiwiZnVuY1R5cGUiLCJyZXR1cm4iLCJ2YXJUeXBlIiwicGVyc29uIiwiYWN0aXZlIiwicGFyc2VEZWZpbml0aW9uIiwiZGVmU3JjIiwiZGVmIiwidHlwZWQiLCJlZmZlY3RzIiwic29ydCIsInRvQ29udGFpbiIsInNpemUiLCJvcmlnaW5hbERlYnVnIiwicHJvY2VzcyIsImVudiIsIk5PT19ERUJVR19QQVJTRSIsImxvY2F0aW9u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