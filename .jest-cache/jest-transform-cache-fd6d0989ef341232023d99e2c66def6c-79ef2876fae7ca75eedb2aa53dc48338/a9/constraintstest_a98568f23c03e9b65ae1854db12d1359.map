{"version":3,"sources":["/workspace/src/typer/__tests__/constraints.test.ts"],"sourcesContent":["import { describe, it, expect } from \"@jest/globals\";\nimport { Lexer } from \"../../lexer\";\nimport { parse } from \"../../parser/parser\";\nimport { typeProgram, createTypeState } from '..';\nimport { typeToString } from '../helpers';\nimport { initializeBuiltins } from '../builtins';\n\n// Helper function to parse a string into a program\nconst parseProgram = (source: string) => {\n\tconst lexer = new Lexer(source);\n\tconst tokens = lexer.tokenize();\n\treturn parse(tokens);\n};\n\ndescribe(\"Type Constraints\", () => {\n\tdescribe(\"Basic Constraint System\", () => {\n\t\tit(\"should support constrained type variables\", () => {\n\t\t\tconst state = createTypeState();\n\t\t\tconst newState = initializeBuiltins(state);\n\n\t\t\t// Check that tail has a constraint (head is now self-hosted)\n\t\t\tconst tailScheme = newState.environment.get(\"tail\");\n\t\t\texpect(tailScheme).toBeDefined();\n\t\t\texpect(tailScheme!.type.kind).toBe(\"function\");\n\t\t\t// tail no longer has constraints since we removed Collection\n\t\t\t// This test now verifies the constraint system works with other functions\n\t\t});\n\n\t\tit(\"should display constraints in type strings\", () => {\n\t\t\t// This test is no longer relevant since we removed Collection constraints\n\t\t\t// and head is now self-hosted. Skipping for now.\n\t\t\texpect(true).toBe(true);\n\t\t});\n\t});\n\n\tdescribe(\"Constraint Solving\", () => {\n\t\tit(\"should solve constraints during unification\", () => {\n\t\t\tconst program = parseProgram(\"head [1, 2, 3]\");\n\t\t\tconst result = typeProgram(program);\n\t\t\tconst typeStr = typeToString(result.type, result.state.substitution);\n\n\t\t\t// head now returns Option Int instead of Int\n\t\t\texpect(typeStr).toBe(\"Option Int\");\n\t\t});\n\n\t\tit(\"should solve constraints for polymorphic functions\", () => {\n\t\t\tconst program = parseProgram(`\n        id = fn x => x;\n        head (id [1, 2, 3])\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\tconst typeStr = typeToString(result.type, result.state.substitution);\n\n\t\t\t// head now returns Option Int instead of Int\n\t\t\texpect(typeStr).toBe(\"Option Int\");\n\t\t});\n\t});\n\n\tdescribe(\"Constraint Error Handling\", () => {\n\t\tit(\"should reject types that don't satisfy constraints\", () => {\n\t\t\t// This would require a more sophisticated constraint system\n\t\t\t// For now, we'll test that constraints are properly tracked\n\t\t\tconst program = parseProgram(\"head 42\");\n\n\t\t\t// This should fail because 42 is not a Collection\n\t\t\texpect(() => typeProgram(program)).toThrow();\n\t\t});\n\t});\n\n\tdescribe(\"Built-in Constrained Functions\", () => {\n\t\tit(\"should have constrained types for list operations\", () => {\n\t\t\tconst state = createTypeState();\n\t\t\tconst newState = initializeBuiltins(state);\n\n\t\t\t// Only tail and length are still built-ins, head is self-hosted\n\t\t\t// And we removed Collection constraints, so this test is no longer relevant\n\t\t\tconst functions = [\"tail\", \"length\"];\n\n\t\t\tfor (const funcName of functions) {\n\t\t\t\tconst scheme = newState.environment.get(funcName);\n\t\t\t\texpect(scheme).toBeDefined();\n\t\t\t\texpect(scheme!.type.kind).toBe(\"function\");\n\t\t\t\t// No longer checking for constraints since we removed Collection\n\t\t\t}\n\t\t});\n\t});\n\n\tdescribe(\"Constraint Propagation\", () => {\n\t\tit(\"should propagate constraints through function composition\", () => {\n\t\t\tconst program = parseProgram(`\n        compose = fn f g => fn x => f (g x);\n        safeHead = compose head;\n        id = fn x => x;\n        result = safeHead id [1, 2, 3]\n      `);\n\n\t\t\t// This should work now since head is safe and returns Option\n\t\t\tconst result = typeProgram(program);\n\t\t\texpect(result).toBeDefined();\n\t\t});\n\n\t\tit(\"should allow composition when constraints are satisfied\", () => {\n\t\t\tconst program = parseProgram(`\n        compose = fn f g => fn x => f (g x);\n        safeHead = compose head;\n        listId = fn x => x;\n        result = safeHead listId [[1, 2, 3], [4, 5, 6]]\n      `);\n\n\t\t\tconst result = typeProgram(program);\n\t\t\tconst typeStr = typeToString(result.type, result.state.substitution);\n\n\t\t\t// The result should be Option List Int since head returns Option\n\t\t\texpect(typeStr).toBe(\"Option List Int\");\n\t\t});\n\t});\n});\n"],"names":["parseProgram","source","lexer","Lexer","tokens","tokenize","parse","describe","it","state","createTypeState","newState","initializeBuiltins","tailScheme","environment","get","expect","toBeDefined","type","kind","toBe","program","result","typeProgram","typeStr","typeToString","substitution","toThrow","functions","funcName","scheme"],"mappings":"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"}