{"version":3,"sources":["/workspace/src/typer/type-errors.ts"],"sourcesContent":["import type { Expression, Type } from \"../ast\";\nimport { createError, type NoolangError, type ErrorLocation } from \"../errors\";\nimport { formatEffectsString } from \"./helpers\";\n\nexport interface TypeErrorContext {\n\texpression?: Expression;\n\texpectedType?: Type;\n\tactualType?: Type;\n\tfunctionName?: string;\n\tparameterIndex?: number;\n\toperator?: string;\n\tvariableName?: string;\n\tsuggestion?: string;\n\tcodeSnippet?: string;\n}\n\nexport function createTypeError(\n\tmessage: string,\n\tcontext?: TypeErrorContext,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tlet enhancedMessage = message;\n\tlet suggestion = context?.suggestion;\n\n\t// Enhance message based on context\n\tif (context?.expectedType && context?.actualType) {\n\t\tenhancedMessage += `\\n  Expected: ${typeToString(context.expectedType)}`;\n\t\tenhancedMessage += `\\n  Got:      ${typeToString(context.actualType)}`;\n\t}\n\n\t// Add function-specific context\n\tif (context?.functionName) {\n\t\tenhancedMessage += `\\n  Function: ${context.functionName}`;\n\t}\n\n\t// Add parameter-specific context\n\tif (context?.parameterIndex !== undefined) {\n\t\tenhancedMessage += `\\n  Parameter ${context.parameterIndex + 1}`;\n\t}\n\n\t// Add operator context\n\tif (context?.operator) {\n\t\tenhancedMessage += `\\n  Operator: ${context.operator}`;\n\t}\n\n\t// Add variable context\n\tif (context?.variableName) {\n\t\tenhancedMessage += `\\n  Variable: ${context.variableName}`;\n\t}\n\n\t// Generate suggestions if not provided\n\tif (!suggestion) {\n\t\tsuggestion = generateSuggestion(context);\n\t}\n\n\treturn createError(\n\t\t\"TypeError\",\n\t\tenhancedMessage,\n\t\tlocation,\n\t\tcontext?.codeSnippet,\n\t\tsuggestion,\n\t);\n}\n\nfunction generateSuggestion(context?: TypeErrorContext): string {\n\tif (!context) return \"\";\n\n\t// Function application errors\n\tif (context.functionName && context.expectedType && context.actualType) {\n\t\tif (context.parameterIndex !== undefined) {\n\t\t\treturn `Check that argument ${context.parameterIndex + 1} matches the expected type. Consider adding a type annotation or using a different value.`;\n\t\t}\n\t\treturn `Check that all arguments match the function's expected parameter types.`;\n\t}\n\n\t// Variable errors\n\tif (context.variableName) {\n\t\treturn `Make sure '${context.variableName}' is defined before use. Check for typos or missing definitions.`;\n\t}\n\n\t// Operator errors\n\tif (context.operator) {\n\t\treturn `The ${context.operator} operator expects specific types. Check that both operands are compatible.`;\n\t}\n\n\t// General type mismatch\n\tif (context.expectedType && context.actualType) {\n\t\treturn `Consider adding a type annotation or using a value of the expected type.`;\n\t}\n\n\treturn \"Review the expression and ensure all types are compatible.\";\n}\n\n// Enhanced error messages for common type errors\nexport function functionApplicationError(\n\tfuncType: Type,\n\targType: Type,\n\tparameterIndex: number,\n\tfunctionName?: string,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Type mismatch in function application`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType: funcType,\n\t\t\tactualType: argType,\n\t\t\tfunctionName,\n\t\t\tparameterIndex,\n\t\t\tsuggestion: `Argument ${parameterIndex + 1} has type ${typeToString(argType)} but the function expects ${typeToString(funcType)}. Consider using a different value or adding a type conversion.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function undefinedVariableError(\n\tvariableName: string,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Undefined variable`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\tvariableName,\n\t\t\tsuggestion: `Define '${variableName}' before using it: ${variableName} = value`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function nonFunctionApplicationError(\n\ttype: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Cannot apply non-function type`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\tactualType: type,\n\t\t\tsuggestion: `Only functions can be applied to arguments. Make sure you're calling a function, not a value.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function operatorTypeError(\n\toperator: string,\n\texpectedType: Type,\n\tactualType: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Operator type mismatch`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\toperator,\n\t\t\texpectedType,\n\t\t\tactualType,\n\t\t\tsuggestion: `The ${operator} operator expects ${typeToString(expectedType)} but got ${typeToString(actualType)}. Check your operand types.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function conditionTypeError(\n\tactualType: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Condition must be boolean`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\tactualType,\n\t\t\tsuggestion: `Use a boolean expression (True/False) or a comparison that returns a boolean.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function ifBranchTypeError(\n\tthenType: Type,\n\telseType: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `If branches must have the same type`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType: thenType,\n\t\t\tactualType: elseType,\n\t\t\tsuggestion: `Both branches of an if expression must return the same type. Consider adding type annotations or using compatible expressions.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function typeAnnotationError(\n\texpectedType: Type,\n\tinferredType: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Type annotation mismatch`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType,\n\t\t\tactualType: inferredType,\n\t\t\tsuggestion: `The explicit type annotation doesn't match the inferred type. Either adjust the annotation or modify the expression.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function listElementTypeError(\n\texpectedType: Type,\n\tactualType: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `List elements must have the same type`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType,\n\t\t\tactualType,\n\t\t\tsuggestion: `All elements in a list must have the same type. Consider using a tuple for mixed types or ensuring all elements are compatible.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function pipelineCompositionError(\n\toutputType: Type,\n\tinputType: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Pipeline composition type mismatch`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType: inputType,\n\t\t\tactualType: outputType,\n\t\t\tsuggestion: `The output type of the first function must match the input type of the second function in a pipeline.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function mutationTypeError(\n\ttargetType: Type,\n\tvalueType: Type,\n\tvariableName: string,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Type mismatch in mutation`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType: targetType,\n\t\t\tactualType: valueType,\n\t\t\tvariableName,\n\t\t\tsuggestion: `The new value must have the same type as the mutable variable '${variableName}'.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function unificationError(\n\ttype1: Type,\n\ttype2: Type,\n\tcontext: {\n\t\treason?: string;\n\t\toperation?: string;\n\t\texpression?: Expression;\n\t\thint?: string;\n\t},\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tlet message = `Cannot unify types`;\n\tlet suggestion = `Review the expression and ensure all types are compatible.`;\n\n\t// Add specific context based on the reason\n\tif (context.reason) {\n\t\tswitch (context.reason) {\n\t\t\tcase \"constructor_application\":\n\t\t\t\tmessage = `Constructor type mismatch`;\n\t\t\t\tsuggestion = `This constructor expects different argument types. Check the ADT definition.`;\n\t\t\t\tbreak;\n\t\t\tcase \"function_application\":\n\t\t\t\tmessage = `Function application type mismatch`;\n\t\t\t\tsuggestion = `The function parameters don't match the provided arguments.`;\n\t\t\t\tbreak;\n\t\t\tcase \"operator_application\":\n\t\t\t\tmessage = `Operator type mismatch`;\n\t\t\t\tsuggestion = `The operator expects specific types. Check that both operands are compatible.`;\n\t\t\t\tbreak;\n\t\t\tcase \"if_branches\":\n\t\t\t\tmessage = `If branch type mismatch`;\n\t\t\t\tsuggestion = `Both branches of an if expression must return the same type.`;\n\t\t\t\tbreak;\n\t\t\tcase \"pattern_matching\":\n\t\t\t\tmessage = `Pattern matching type mismatch`;\n\t\t\t\tsuggestion = `The pattern doesn't match the expected type. Check the pattern structure.`;\n\t\t\t\tbreak;\n\t\t\tcase \"concrete_vs_variable\":\n\t\t\t\tmessage = `Concrete type vs type variable conflict`;\n\t\t\t\tsuggestion = `Trying to unify a concrete type with a type variable that's already constrained. This often happens with ADT constructors - check if you're using concrete types where type variables are expected.`;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (context.operation) {\n\t\tmessage += ` in ${context.operation}`;\n\t}\n\n\tif (context.hint) {\n\t\tsuggestion = context.hint;\n\t}\n\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType: type1,\n\t\t\tactualType: type2,\n\t\t\tsuggestion,\n\t\t},\n\t\tlocation,\n\t);\n}\n\n// Helper function to convert types to strings (simplified version)\nfunction typeToString(type: Type): string {\n\tswitch (type.kind) {\n\t\tcase \"primitive\":\n\t\t\treturn type.name;\n\t\tcase \"variable\":\n\t\t\treturn type.name;\n\t\tcase \"function\":\n\t\t\tconst paramStr = type.params.map(typeToString).join(\" \");\n\t\t\tconst effectStr =\n\t\t\t\tformatEffectsString(type.effects);\n\t\t\treturn `(${paramStr}) -> ${typeToString(type.return)}${effectStr}`;\n\t\tcase \"list\":\n\t\t\treturn `List ${typeToString(type.element)}`;\n\t\tcase \"tuple\":\n\t\t\treturn `(${type.elements.map(typeToString).join(\" \")})`;\n\t\tcase \"record\":\n\t\t\treturn `{ ${Object.entries(type.fields)\n\t\t\t\t.map(([name, fieldType]) => `${name}: ${typeToString(fieldType)}`)\n\t\t\t\t.join(\" \")} }`;\n\t\tcase \"variant\":\n\t\t\tif (type.args.length === 0) {\n\t\t\t\treturn type.name;\n\t\t\t} else {\n\t\t\t\treturn `${type.name} ${type.args.map(typeToString).join(\" \")}`;\n\t\t\t}\n\t\tcase \"unit\":\n\t\t\treturn \"unit\";\n\t\tcase \"unknown\":\n\t\t\treturn \"?\";\n\t\tdefault:\n\t\t\treturn \"unknown\";\n\t}\n}\n\n// Enhanced error formatting for better readability\nexport function formatTypeError(error: NoolangError): string {\n\tlet result = `\\n${error.type}: ${error.message}`;\n\n\tif (error.location) {\n\t\tresult += `\\n  at line ${error.location.line}, column ${error.location.column}`;\n\t}\n\n\tif (error.context) {\n\t\tresult += `\\n\\nCode:\\n  ${error.context}`;\n\t}\n\n\tif (error.suggestion) {\n\t\tresult += `\\n\\nðŸ’¡ ${error.suggestion}`;\n\t}\n\n\treturn result;\n}\n"],"names":["conditionTypeError","createTypeError","formatTypeError","functionApplicationError","ifBranchTypeError","listElementTypeError","mutationTypeError","nonFunctionApplicationError","operatorTypeError","pipelineCompositionError","typeAnnotationError","undefinedVariableError","unificationError","message","context","location","enhancedMessage","suggestion","expectedType","actualType","typeToString","functionName","parameterIndex","undefined","operator","variableName","generateSuggestion","createError","codeSnippet","funcType","argType","type","thenType","elseType","inferredType","outputType","inputType","targetType","valueType","type1","type2","reason","operation","hint","kind","name","paramStr","params","map","join","effectStr","formatEffectsString","effects","return","element","elements","Object","entries","fields","fieldType","args","length","error","result","line","column"],"mappings":"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"}