c22802c1c77c741f86f06e839ef9cc8b
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _lexer = require("../src/lexer");
describe("Lexer", ()=>{
    // Helper function to create lexer and get all tokens
    const tokenize = (input)=>new _lexer.Lexer(input).tokenize();
    // Helper function to get token values without location info
    const getTokenValues = (input)=>tokenize(input).map((token)=>({
                type: token.type,
                value: token.value
            }));
    describe("Numbers", ()=>{
        test("should tokenize integers", ()=>{
            const tokens = getTokenValues("123");
            expect(tokens).toEqual([
                {
                    type: "NUMBER",
                    value: "123"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should tokenize floating point numbers", ()=>{
            const tokens = getTokenValues("123.456");
            expect(tokens).toEqual([
                {
                    type: "NUMBER",
                    value: "123.456"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should tokenize number followed by non-digit", ()=>{
            const tokens = getTokenValues("123abc");
            expect(tokens).toEqual([
                {
                    type: "NUMBER",
                    value: "123"
                },
                {
                    type: "IDENTIFIER",
                    value: "abc"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should not tokenize dot without following digit as float", ()=>{
            const tokens = getTokenValues("123.");
            expect(tokens).toEqual([
                {
                    type: "NUMBER",
                    value: "123"
                },
                {
                    type: "PUNCTUATION",
                    value: "."
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
    });
    describe("Strings", ()=>{
        test("should tokenize double-quoted strings", ()=>{
            const tokens = getTokenValues('"hello world"');
            expect(tokens).toEqual([
                {
                    type: "STRING",
                    value: "hello world"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should tokenize single-quoted strings", ()=>{
            const tokens = getTokenValues("'hello world'");
            expect(tokens).toEqual([
                {
                    type: "STRING",
                    value: "hello world"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle escaped characters in strings", ()=>{
            const tokens = getTokenValues('"hello \\"world\\""');
            expect(tokens).toEqual([
                {
                    type: "STRING",
                    value: 'hello "world"'
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle unclosed strings", ()=>{
            const tokens = getTokenValues('"hello');
            expect(tokens).toEqual([
                {
                    type: "STRING",
                    value: "hello"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle escaped backslash at end of string", ()=>{
            const tokens = getTokenValues('"hello\\\\"');
            expect(tokens).toEqual([
                {
                    type: "STRING",
                    value: "hello\\"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle escape sequence at end of input", ()=>{
            const tokens = getTokenValues('"hello\\');
            expect(tokens).toEqual([
                {
                    type: "STRING",
                    value: "hello"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
    });
    describe("Identifiers and Keywords", ()=>{
        test("should tokenize basic identifiers", ()=>{
            const tokens = getTokenValues("variable");
            expect(tokens).toEqual([
                {
                    type: "IDENTIFIER",
                    value: "variable"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should tokenize identifiers with underscores and numbers", ()=>{
            const tokens = getTokenValues("var_123");
            expect(tokens).toEqual([
                {
                    type: "IDENTIFIER",
                    value: "var_123"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should recognize keywords", ()=>{
            const keywords = [
                "if",
                "then",
                "else",
                "let",
                "in",
                "fn",
                "import",
                "mut",
                "where",
                "type",
                "match",
                "with",
                "given",
                "is",
                "and",
                "or",
                "implements",
                "constraint",
                "implement"
            ];
            for (const keyword of keywords){
                const tokens = getTokenValues(keyword);
                expect(tokens).toEqual([
                    {
                        type: "KEYWORD",
                        value: keyword
                    },
                    {
                        type: "EOF",
                        value: ""
                    }
                ]);
            }
        });
        test("should recognize primitive type keywords", ()=>{
            const primitives = [
                "Int",
                "Number",
                "String",
                "Unit",
                "List"
            ];
            for (const primitive of primitives){
                const tokens = getTokenValues(primitive);
                expect(tokens).toEqual([
                    {
                        type: "KEYWORD",
                        value: primitive
                    },
                    {
                        type: "EOF",
                        value: ""
                    }
                ]);
            }
        });
        test("should handle mut! special case", ()=>{
            const tokens = getTokenValues("mut!");
            expect(tokens).toEqual([
                {
                    type: "KEYWORD",
                    value: "mut!"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle mut without exclamation", ()=>{
            const tokens = getTokenValues("mut");
            expect(tokens).toEqual([
                {
                    type: "KEYWORD",
                    value: "mut"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle identifiers starting with underscore", ()=>{
            const tokens = getTokenValues("_private");
            expect(tokens).toEqual([
                {
                    type: "IDENTIFIER",
                    value: "_private"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
    });
    describe("Operators", ()=>{
        test("should tokenize multi-character operators", ()=>{
            const multiCharOps = [
                "|>",
                "<|",
                "==",
                "!=",
                "<=",
                ">=",
                "=>",
                "->"
            ];
            for (const op of multiCharOps){
                const tokens = getTokenValues(op);
                expect(tokens).toEqual([
                    {
                        type: "OPERATOR",
                        value: op
                    },
                    {
                        type: "EOF",
                        value: ""
                    }
                ]);
            }
        });
        test("should tokenize single-character operators", ()=>{
            const singleCharOps = [
                "+",
                "-",
                "*",
                "/",
                "<",
                ">",
                "=",
                "|",
                "$"
            ];
            for (const op of singleCharOps){
                const tokens = getTokenValues(op);
                expect(tokens).toEqual([
                    {
                        type: "OPERATOR",
                        value: op
                    },
                    {
                        type: "EOF",
                        value: ""
                    }
                ]);
            }
        });
        test("should prefer multi-character operators over single", ()=>{
            const tokens = getTokenValues("==");
            expect(tokens).toEqual([
                {
                    type: "OPERATOR",
                    value: "=="
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle operators in sequence", ()=>{
            const tokens = getTokenValues("+-*/");
            expect(tokens).toEqual([
                {
                    type: "OPERATOR",
                    value: "+"
                },
                {
                    type: "OPERATOR",
                    value: "-"
                },
                {
                    type: "OPERATOR",
                    value: "*"
                },
                {
                    type: "OPERATOR",
                    value: "/"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle single character operator fallback", ()=>{
            // Test the fallback case where no multi-character operator matches
            // This specifically tests line 224 by using "!" which matches the regex but isn't in the multi-char list
            const tokens = getTokenValues("!");
            expect(tokens).toEqual([
                {
                    type: "OPERATOR",
                    value: "!"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
    });
    describe("Punctuation", ()=>{
        test("should tokenize punctuation characters", ()=>{
            const punctuation = [
                "(",
                ")",
                ",",
                ";",
                ":",
                "[",
                "]",
                "{",
                "}"
            ];
            for (const punct of punctuation){
                const tokens = getTokenValues(punct);
                expect(tokens).toEqual([
                    {
                        type: "PUNCTUATION",
                        value: punct
                    },
                    {
                        type: "EOF",
                        value: ""
                    }
                ]);
            }
        });
        test("should handle period as punctuation", ()=>{
            const tokens = getTokenValues(".");
            expect(tokens).toEqual([
                {
                    type: "PUNCTUATION",
                    value: "."
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
    });
    describe("Accessors", ()=>{
        test("should tokenize basic accessor", ()=>{
            const tokens = getTokenValues("@field");
            expect(tokens).toEqual([
                {
                    type: "ACCESSOR",
                    value: "field"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should tokenize accessor with numbers and underscores", ()=>{
            const tokens = getTokenValues("@field_123");
            expect(tokens).toEqual([
                {
                    type: "ACCESSOR",
                    value: "field_123"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle @ without following identifier", ()=>{
            const tokens = getTokenValues("@");
            expect(tokens).toEqual([
                {
                    type: "ACCESSOR",
                    value: ""
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle @ followed by non-identifier", ()=>{
            const tokens = getTokenValues("@(");
            expect(tokens).toEqual([
                {
                    type: "ACCESSOR",
                    value: ""
                },
                {
                    type: "PUNCTUATION",
                    value: "("
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
    });
    describe("Comments", ()=>{
        test("should skip single-line comments", ()=>{
            const codeWithComments = `
        # this is a comment
        x = 5 # inline comment
        y = 10
        # another comment
        x + y # trailing comment
      `;
            const codeWithoutComments = `
        x = 5
        y = 10
        x + y
      `;
            const tokensWithComments = new _lexer.Lexer(codeWithComments).tokenize();
            const tokensWithoutComments = new _lexer.Lexer(codeWithoutComments).tokenize();
            // Remove location info for comparison
            const stripLoc = (t)=>({
                    type: t.type,
                    value: t.value
                });
            expect(tokensWithComments.map(stripLoc)).toEqual(tokensWithoutComments.map(stripLoc));
            // Ensure no COMMENT tokens are present
            expect(tokensWithComments.some((t)=>t.type === "COMMENT")).toBe(false);
        });
        test("should handle comment at end of file", ()=>{
            const tokens = getTokenValues("x # comment");
            expect(tokens).toEqual([
                {
                    type: "IDENTIFIER",
                    value: "x"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle multiple comments", ()=>{
            const tokens = getTokenValues("# comment1\n# comment2\nx");
            expect(tokens).toEqual([
                {
                    type: "IDENTIFIER",
                    value: "x"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle comment encountered in nextToken", ()=>{
            // This tests the comment handling path in nextToken (lines 317-319)
            const lexer = new _lexer.Lexer("# comment\n");
            const token = lexer.nextToken();
            expect(token.type).toBe("EOF");
        });
    });
    describe("Whitespace handling", ()=>{
        test("should skip whitespace", ()=>{
            const tokens = getTokenValues("  \t  x  \n  y  ");
            expect(tokens).toEqual([
                {
                    type: "IDENTIFIER",
                    value: "x"
                },
                {
                    type: "IDENTIFIER",
                    value: "y"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle empty input", ()=>{
            const tokens = getTokenValues("");
            expect(tokens).toEqual([
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle whitespace only", ()=>{
            const tokens = getTokenValues("   \t\n  ");
            expect(tokens).toEqual([
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
    });
    describe("Unknown characters", ()=>{
        test("should handle unknown characters as punctuation", ()=>{
            const tokens = getTokenValues("~");
            expect(tokens).toEqual([
                {
                    type: "PUNCTUATION",
                    value: "~"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle unknown characters that are whitespace", ()=>{
            // Test with a Unicode whitespace character
            const tokens = getTokenValues("x\u00A0y"); // Non-breaking space
            expect(tokens).toEqual([
                {
                    type: "IDENTIFIER",
                    value: "x"
                },
                {
                    type: "IDENTIFIER",
                    value: "y"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle unknown whitespace characters in nextToken path", ()=>{
            // This tests line 327 - when unknown character is whitespace and triggers recursive nextToken
            const lexer = new _lexer.Lexer("\u00A0"); // Non-breaking space as unknown character
            const token = lexer.nextToken();
            expect(token.type).toBe("EOF");
        });
    });
    describe("Edge cases for 100% coverage", ()=>{
        test("should handle comment in nextToken path (lines 317-319)", ()=>{
            // This is tricky - we need a scenario where skipWhitespace doesn't handle the comment
            // Let's create a scenario where the lexer position is at a comment after other processing
            const lexer = new _lexer.Lexer("x#comment");
            // Get first token (x)
            const firstToken = lexer.nextToken();
            expect(firstToken.type).toBe("IDENTIFIER");
            // Now position should be at the comment, and nextToken should handle it
            const secondToken = lexer.nextToken();
            expect(secondToken.type).toBe("EOF");
        });
        test("should handle whitespace in unknown character path (line 327)", ()=>{
            // Create a test where an unknown character becomes whitespace after advance()
            // This happens when we have a character that doesn't match any category initially
            // but when advanced and checked again, is whitespace
            // Use a Unicode character that might be treated as unknown initially
            const lexer = new _lexer.Lexer("\u2000"); // EN QUAD - Unicode space
            const token = lexer.nextToken();
            expect(token.type).toBe("EOF");
        });
        test("should handle form feed as potential unknown whitespace", ()=>{
            // Form feed (\f) might trigger the unknown character path in some cases
            const lexer = new _lexer.Lexer("\fx");
            const token = lexer.nextToken();
            expect(token.type).toBe("IDENTIFIER");
            expect(token.value).toBe("x");
        });
        test("should handle zero-width space as unknown character", ()=>{
            // Zero-width characters are treated as punctuation, not whitespace by the lexer
            const lexer = new _lexer.Lexer("\u200B\u200C\u200Dx"); // Various zero-width characters
            const token = lexer.nextToken();
            expect(token.type).toBe("PUNCTUATION");
            expect(token.value).toBe("\u200B");
        });
        test("should handle tab character in unknown path (line 327)", ()=>{
            // This test specifically targets line 327 - unknown character that becomes whitespace
            // We need a character that doesn't match initial patterns but is whitespace
            // Let's try a form feed character or vertical tab that might slip through
            const lexer = new _lexer.Lexer("\v\fx"); // vertical tab and form feed
            const tokens = tokenize("\v\fx");
            expect(tokens[0].type).toBe("IDENTIFIER");
            expect(tokens[0].value).toBe("x");
        });
        test("should handle specific Unicode whitespace that might be unknown initially", ()=>{
            // Test with various Unicode whitespace characters that might not match initial \s
            const characters = [
                "\u00A0",
                "\u1680",
                "\u2000",
                "\u2001",
                "\u2002",
                "\u2003",
                "\u2004",
                "\u2005",
                "\u2006",
                "\u2007",
                "\u2008",
                "\u2009",
                "\u200A",
                "\u202F",
                "\u205F",
                "\u3000"
            ];
            for (const char of characters){
                const lexer = new _lexer.Lexer(char + "x");
                const token = lexer.nextToken();
                expect(token.type).toBe("IDENTIFIER");
                expect(token.value).toBe("x");
            }
        });
        test("should trigger comment fallback in nextToken (lines 317-319)", ()=>{
            // Try to create a scenario where skipWhitespace doesn't handle the comment
            // This is a very specific edge case - create a lexer where we manually position
            // it so that skipWhitespace has already been called but a comment appears
            const input = "a\t#comment";
            const lexer = new _lexer.Lexer(input);
            // Get the 'a' token
            const firstToken = lexer.nextToken();
            expect(firstToken.type).toBe("IDENTIFIER");
            expect(firstToken.value).toBe("a");
            // The next token should skip the tab and handle the comment
            const secondToken = lexer.nextToken();
            expect(secondToken.type).toBe("EOF");
        });
        test("should trigger unknown whitespace path (line 327) with non-breaking space", ()=>{
            // Use a non-breaking space which might not be caught by initial whitespace checks
            const input = "\u00A0x"; // Non-breaking space followed by identifier
            const tokens = tokenize(input);
            expect(tokens[0].type).toBe("IDENTIFIER");
            expect(tokens[0].value).toBe("x");
        });
        test("should trigger unknown whitespace path (line 327) with exotic whitespace", ()=>{
            // Try other Unicode whitespace characters that might not match initial /\s/
            const input = "\u2000\u2001\u2002x"; // En quad, Em quad, En space
            const tokens = tokenize(input);
            expect(tokens[0].type).toBe("IDENTIFIER");
            expect(tokens[0].value).toBe("x");
        });
        test("should trigger exact uncovered paths with null character edge case", ()=>{
            // Try a null character that might behave unexpectedly
            const input = "\0x";
            const tokens = tokenize(input);
            // This should either handle the null as punctuation or skip it
            expect(tokens.length).toBeGreaterThan(0);
        });
        test("should handle character that looks like operator but isn't", ()=>{
            // Try to trigger the single character operator fallback (line 224)
            // Use a character that matches operator regex but isn't multi-char
            const input = "!x"; // ! is in the operator regex and not multi-char in this context
            const tokens = tokenize(input);
            expect(tokens[0].type).toBe("OPERATOR");
            expect(tokens[0].value).toBe("!");
            expect(tokens[1].type).toBe("IDENTIFIER");
            expect(tokens[1].value).toBe("x");
        });
        test("should handle comment immediately after EOF check", ()=>{
            // Try to create a scenario where comment handling hits the nextToken path
            const input = "#";
            const tokens = tokenize(input);
            expect(tokens[0].type).toBe("EOF");
        });
        test("should handle edge case for exact line coverage - carriage return before comment", ()=>{
            // Try using carriage return which might not be handled the same as other whitespace
            const input = "\r#comment\nx";
            const tokens = tokenize(input);
            expect(tokens[0].type).toBe("IDENTIFIER");
            expect(tokens[0].value).toBe("x");
        });
        test("should handle zero-width joiner that might not match \\s regex", ()=>{
            // Zero-width joiner (U+200D) might not match \\s but could be whitespace-like
            const input = "\u200Dx";
            const tokens = tokenize(input);
            // This should either skip the ZWJJ or treat it as punctuation
            if (tokens[0].type === "IDENTIFIER") {
                expect(tokens[0].value).toBe("x");
            } else {
                expect(tokens[0].type).toBe("PUNCTUATION");
            }
        });
    });
    describe("Line and column tracking", ()=>{
        test("should track line and column positions", ()=>{
            const lexer = new _lexer.Lexer("x\ny");
            const tokens = lexer.tokenize();
            expect(tokens[0].location.start.line).toBe(1);
            expect(tokens[0].location.start.column).toBe(1);
            expect(tokens[0].location.end.line).toBe(1);
            expect(tokens[0].location.end.column).toBe(2);
            expect(tokens[1].location.start.line).toBe(2);
            expect(tokens[1].location.start.column).toBe(1);
            expect(tokens[1].location.end.line).toBe(2);
            expect(tokens[1].location.end.column).toBe(2);
        });
        test("should handle column advancement", ()=>{
            const lexer = new _lexer.Lexer("abc");
            const tokens = lexer.tokenize();
            expect(tokens[0].location.start.line).toBe(1);
            expect(tokens[0].location.start.column).toBe(1);
            expect(tokens[0].location.end.line).toBe(1);
            expect(tokens[0].location.end.column).toBe(4);
        });
    });
    describe("Complex expressions", ()=>{
        test("should tokenize complex expression", ()=>{
            const tokens = getTokenValues('fn add(x, y) -> x + y\nlet result = add(1, 2)');
            expect(tokens).toEqual([
                {
                    type: "KEYWORD",
                    value: "fn"
                },
                {
                    type: "IDENTIFIER",
                    value: "add"
                },
                {
                    type: "PUNCTUATION",
                    value: "("
                },
                {
                    type: "IDENTIFIER",
                    value: "x"
                },
                {
                    type: "PUNCTUATION",
                    value: ","
                },
                {
                    type: "IDENTIFIER",
                    value: "y"
                },
                {
                    type: "PUNCTUATION",
                    value: ")"
                },
                {
                    type: "OPERATOR",
                    value: "->"
                },
                {
                    type: "IDENTIFIER",
                    value: "x"
                },
                {
                    type: "OPERATOR",
                    value: "+"
                },
                {
                    type: "IDENTIFIER",
                    value: "y"
                },
                {
                    type: "KEYWORD",
                    value: "let"
                },
                {
                    type: "IDENTIFIER",
                    value: "result"
                },
                {
                    type: "OPERATOR",
                    value: "="
                },
                {
                    type: "IDENTIFIER",
                    value: "add"
                },
                {
                    type: "PUNCTUATION",
                    value: "("
                },
                {
                    type: "NUMBER",
                    value: "1"
                },
                {
                    type: "PUNCTUATION",
                    value: ","
                },
                {
                    type: "NUMBER",
                    value: "2"
                },
                {
                    type: "PUNCTUATION",
                    value: ")"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle mixed operators and punctuation", ()=>{
            const tokens = getTokenValues("(x == y) && z");
            expect(tokens).toEqual([
                {
                    type: "PUNCTUATION",
                    value: "("
                },
                {
                    type: "IDENTIFIER",
                    value: "x"
                },
                {
                    type: "OPERATOR",
                    value: "=="
                },
                {
                    type: "IDENTIFIER",
                    value: "y"
                },
                {
                    type: "PUNCTUATION",
                    value: ")"
                },
                {
                    type: "PUNCTUATION",
                    value: "&"
                },
                {
                    type: "PUNCTUATION",
                    value: "&"
                },
                {
                    type: "IDENTIFIER",
                    value: "z"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
    });
    describe("Edge cases", ()=>{
        test("should handle EOF conditions", ()=>{
            const lexer = new _lexer.Lexer("");
            const token = lexer.nextToken();
            expect(token.type).toBe("EOF");
            expect(token.value).toBe("");
        });
        test("should handle sequential whitespace and comments", ()=>{
            const tokens = getTokenValues("  # comment\n  \t# another\n x");
            expect(tokens).toEqual([
                {
                    type: "IDENTIFIER",
                    value: "x"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
        test("should handle operators at end of input", ()=>{
            const tokens = getTokenValues("x +");
            expect(tokens).toEqual([
                {
                    type: "IDENTIFIER",
                    value: "x"
                },
                {
                    type: "OPERATOR",
                    value: "+"
                },
                {
                    type: "EOF",
                    value: ""
                }
            ]);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2UvdGVzdC9sZXhlci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uL3NyYy9sZXhlclwiO1xuXG5kZXNjcmliZShcIkxleGVyXCIsICgpID0+IHtcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBsZXhlciBhbmQgZ2V0IGFsbCB0b2tlbnNcbiAgY29uc3QgdG9rZW5pemUgPSAoaW5wdXQ6IHN0cmluZykgPT4gbmV3IExleGVyKGlucHV0KS50b2tlbml6ZSgpO1xuICBcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0b2tlbiB2YWx1ZXMgd2l0aG91dCBsb2NhdGlvbiBpbmZvXG4gIGNvbnN0IGdldFRva2VuVmFsdWVzID0gKGlucHV0OiBzdHJpbmcpID0+IFxuICAgIHRva2VuaXplKGlucHV0KS5tYXAodG9rZW4gPT4gKHsgdHlwZTogdG9rZW4udHlwZSwgdmFsdWU6IHRva2VuLnZhbHVlIH0pKTtcblxuICBkZXNjcmliZShcIk51bWJlcnNcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGQgdG9rZW5pemUgaW50ZWdlcnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gZ2V0VG9rZW5WYWx1ZXMoXCIxMjNcIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIk5VTUJFUlwiLCB2YWx1ZTogXCIxMjNcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCB0b2tlbml6ZSBmbG9hdGluZyBwb2ludCBudW1iZXJzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuVmFsdWVzKFwiMTIzLjQ1NlwiKTtcbiAgICAgIGV4cGVjdCh0b2tlbnMpLnRvRXF1YWwoW1xuICAgICAgICB7IHR5cGU6IFwiTlVNQkVSXCIsIHZhbHVlOiBcIjEyMy40NTZcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCB0b2tlbml6ZSBudW1iZXIgZm9sbG93ZWQgYnkgbm9uLWRpZ2l0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuVmFsdWVzKFwiMTIzYWJjXCIpO1xuICAgICAgZXhwZWN0KHRva2VucykudG9FcXVhbChbXG4gICAgICAgIHsgdHlwZTogXCJOVU1CRVJcIiwgdmFsdWU6IFwiMTIzXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIklERU5USUZJRVJcIiwgdmFsdWU6IFwiYWJjXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgbm90IHRva2VuaXplIGRvdCB3aXRob3V0IGZvbGxvd2luZyBkaWdpdCBhcyBmbG9hdFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhcIjEyMy5cIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIk5VTUJFUlwiLCB2YWx1ZTogXCIxMjNcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiUFVOQ1RVQVRJT05cIiwgdmFsdWU6IFwiLlwiIH0sXG4gICAgICAgIHsgdHlwZTogXCJFT0ZcIiwgdmFsdWU6IFwiXCIgfVxuICAgICAgXSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiU3RyaW5nc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCB0b2tlbml6ZSBkb3VibGUtcXVvdGVkIHN0cmluZ3NcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gZ2V0VG9rZW5WYWx1ZXMoJ1wiaGVsbG8gd29ybGRcIicpO1xuICAgICAgZXhwZWN0KHRva2VucykudG9FcXVhbChbXG4gICAgICAgIHsgdHlwZTogXCJTVFJJTkdcIiwgdmFsdWU6IFwiaGVsbG8gd29ybGRcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCB0b2tlbml6ZSBzaW5nbGUtcXVvdGVkIHN0cmluZ3NcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gZ2V0VG9rZW5WYWx1ZXMoXCInaGVsbG8gd29ybGQnXCIpO1xuICAgICAgZXhwZWN0KHRva2VucykudG9FcXVhbChbXG4gICAgICAgIHsgdHlwZTogXCJTVFJJTkdcIiwgdmFsdWU6IFwiaGVsbG8gd29ybGRcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgZXNjYXBlZCBjaGFyYWN0ZXJzIGluIHN0cmluZ3NcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gZ2V0VG9rZW5WYWx1ZXMoJ1wiaGVsbG8gXFxcXFwid29ybGRcXFxcXCJcIicpO1xuICAgICAgZXhwZWN0KHRva2VucykudG9FcXVhbChbXG4gICAgICAgIHsgdHlwZTogXCJTVFJJTkdcIiwgdmFsdWU6ICdoZWxsbyBcIndvcmxkXCInIH0sXG4gICAgICAgIHsgdHlwZTogXCJFT0ZcIiwgdmFsdWU6IFwiXCIgfVxuICAgICAgXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSB1bmNsb3NlZCBzdHJpbmdzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuVmFsdWVzKCdcImhlbGxvJyk7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIlNUUklOR1wiLCB2YWx1ZTogXCJoZWxsb1wiIH0sXG4gICAgICAgIHsgdHlwZTogXCJFT0ZcIiwgdmFsdWU6IFwiXCIgfVxuICAgICAgXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSBlc2NhcGVkIGJhY2tzbGFzaCBhdCBlbmQgb2Ygc3RyaW5nXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuVmFsdWVzKCdcImhlbGxvXFxcXFxcXFxcIicpO1xuICAgICAgZXhwZWN0KHRva2VucykudG9FcXVhbChbXG4gICAgICAgIHsgdHlwZTogXCJTVFJJTkdcIiwgdmFsdWU6IFwiaGVsbG9cXFxcXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIGVzY2FwZSBzZXF1ZW5jZSBhdCBlbmQgb2YgaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gZ2V0VG9rZW5WYWx1ZXMoJ1wiaGVsbG9cXFxcJyk7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIlNUUklOR1wiLCB2YWx1ZTogXCJoZWxsb1wiIH0sXG4gICAgICAgIHsgdHlwZTogXCJFT0ZcIiwgdmFsdWU6IFwiXCIgfVxuICAgICAgXSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiSWRlbnRpZmllcnMgYW5kIEtleXdvcmRzXCIsICgpID0+IHtcbiAgICB0ZXN0KFwic2hvdWxkIHRva2VuaXplIGJhc2ljIGlkZW50aWZpZXJzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuVmFsdWVzKFwidmFyaWFibGVcIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIklERU5USUZJRVJcIiwgdmFsdWU6IFwidmFyaWFibGVcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCB0b2tlbml6ZSBpZGVudGlmaWVycyB3aXRoIHVuZGVyc2NvcmVzIGFuZCBudW1iZXJzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuVmFsdWVzKFwidmFyXzEyM1wiKTtcbiAgICAgIGV4cGVjdCh0b2tlbnMpLnRvRXF1YWwoW1xuICAgICAgICB7IHR5cGU6IFwiSURFTlRJRklFUlwiLCB2YWx1ZTogXCJ2YXJfMTIzXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcmVjb2duaXplIGtleXdvcmRzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGtleXdvcmRzID0gW1wiaWZcIiwgXCJ0aGVuXCIsIFwiZWxzZVwiLCBcImxldFwiLCBcImluXCIsIFwiZm5cIiwgXCJpbXBvcnRcIiwgXCJtdXRcIiwgXCJ3aGVyZVwiLCBcInR5cGVcIiwgXCJtYXRjaFwiLCBcIndpdGhcIiwgXCJnaXZlblwiLCBcImlzXCIsIFwiYW5kXCIsIFwib3JcIiwgXCJpbXBsZW1lbnRzXCIsIFwiY29uc3RyYWludFwiLCBcImltcGxlbWVudFwiXTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBrZXl3b3JkIG9mIGtleXdvcmRzKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuVmFsdWVzKGtleXdvcmQpO1xuICAgICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgICB7IHR5cGU6IFwiS0VZV09SRFwiLCB2YWx1ZToga2V5d29yZCB9LFxuICAgICAgICAgIHsgdHlwZTogXCJFT0ZcIiwgdmFsdWU6IFwiXCIgfVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcmVjb2duaXplIHByaW1pdGl2ZSB0eXBlIGtleXdvcmRzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHByaW1pdGl2ZXMgPSBbXCJJbnRcIiwgXCJOdW1iZXJcIiwgXCJTdHJpbmdcIiwgXCJVbml0XCIsIFwiTGlzdFwiXTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlcykge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhwcmltaXRpdmUpO1xuICAgICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgICB7IHR5cGU6IFwiS0VZV09SRFwiLCB2YWx1ZTogcHJpbWl0aXZlIH0sXG4gICAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgbXV0ISBzcGVjaWFsIGNhc2VcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gZ2V0VG9rZW5WYWx1ZXMoXCJtdXQhXCIpO1xuICAgICAgZXhwZWN0KHRva2VucykudG9FcXVhbChbXG4gICAgICAgIHsgdHlwZTogXCJLRVlXT1JEXCIsIHZhbHVlOiBcIm11dCFcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgbXV0IHdpdGhvdXQgZXhjbGFtYXRpb25cIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gZ2V0VG9rZW5WYWx1ZXMoXCJtdXRcIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIktFWVdPUkRcIiwgdmFsdWU6IFwibXV0XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIGlkZW50aWZpZXJzIHN0YXJ0aW5nIHdpdGggdW5kZXJzY29yZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhcIl9wcml2YXRlXCIpO1xuICAgICAgZXhwZWN0KHRva2VucykudG9FcXVhbChbXG4gICAgICAgIHsgdHlwZTogXCJJREVOVElGSUVSXCIsIHZhbHVlOiBcIl9wcml2YXRlXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJPcGVyYXRvcnNcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGQgdG9rZW5pemUgbXVsdGktY2hhcmFjdGVyIG9wZXJhdG9yc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtdWx0aUNoYXJPcHMgPSBbXCJ8PlwiLCBcIjx8XCIsIFwiPT1cIiwgXCIhPVwiLCBcIjw9XCIsIFwiPj1cIiwgXCI9PlwiLCBcIi0+XCJdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IG9wIG9mIG11bHRpQ2hhck9wcykge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhvcCk7XG4gICAgICAgIGV4cGVjdCh0b2tlbnMpLnRvRXF1YWwoW1xuICAgICAgICAgIHsgdHlwZTogXCJPUEVSQVRPUlwiLCB2YWx1ZTogb3AgfSxcbiAgICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHRva2VuaXplIHNpbmdsZS1jaGFyYWN0ZXIgb3BlcmF0b3JzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNpbmdsZUNoYXJPcHMgPSBbXCIrXCIsIFwiLVwiLCBcIipcIiwgXCIvXCIsIFwiPFwiLCBcIj5cIiwgXCI9XCIsIFwifFwiLCBcIiRcIl07XG4gICAgICBcbiAgICAgIGZvciAoY29uc3Qgb3Agb2Ygc2luZ2xlQ2hhck9wcykge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhvcCk7XG4gICAgICAgIGV4cGVjdCh0b2tlbnMpLnRvRXF1YWwoW1xuICAgICAgICAgIHsgdHlwZTogXCJPUEVSQVRPUlwiLCB2YWx1ZTogb3AgfSxcbiAgICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHByZWZlciBtdWx0aS1jaGFyYWN0ZXIgb3BlcmF0b3JzIG92ZXIgc2luZ2xlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuVmFsdWVzKFwiPT1cIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIk9QRVJBVE9SXCIsIHZhbHVlOiBcIj09XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIG9wZXJhdG9ycyBpbiBzZXF1ZW5jZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhcIistKi9cIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIk9QRVJBVE9SXCIsIHZhbHVlOiBcIitcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiT1BFUkFUT1JcIiwgdmFsdWU6IFwiLVwiIH0sXG4gICAgICAgIHsgdHlwZTogXCJPUEVSQVRPUlwiLCB2YWx1ZTogXCIqXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIk9QRVJBVE9SXCIsIHZhbHVlOiBcIi9cIiB9LFxuICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgc2luZ2xlIGNoYXJhY3RlciBvcGVyYXRvciBmYWxsYmFja1wiLCAoKSA9PiB7XG4gICAgICAvLyBUZXN0IHRoZSBmYWxsYmFjayBjYXNlIHdoZXJlIG5vIG11bHRpLWNoYXJhY3RlciBvcGVyYXRvciBtYXRjaGVzXG4gICAgICAvLyBUaGlzIHNwZWNpZmljYWxseSB0ZXN0cyBsaW5lIDIyNCBieSB1c2luZyBcIiFcIiB3aGljaCBtYXRjaGVzIHRoZSByZWdleCBidXQgaXNuJ3QgaW4gdGhlIG11bHRpLWNoYXIgbGlzdFxuICAgICAgY29uc3QgdG9rZW5zID0gZ2V0VG9rZW5WYWx1ZXMoXCIhXCIpO1xuICAgICAgZXhwZWN0KHRva2VucykudG9FcXVhbChbXG4gICAgICAgIHsgdHlwZTogXCJPUEVSQVRPUlwiLCB2YWx1ZTogXCIhXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJQdW5jdHVhdGlvblwiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCB0b2tlbml6ZSBwdW5jdHVhdGlvbiBjaGFyYWN0ZXJzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHB1bmN0dWF0aW9uID0gW1wiKFwiLCBcIilcIiwgXCIsXCIsIFwiO1wiLCBcIjpcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCJdO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHB1bmN0IG9mIHB1bmN0dWF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuVmFsdWVzKHB1bmN0KTtcbiAgICAgICAgZXhwZWN0KHRva2VucykudG9FcXVhbChbXG4gICAgICAgICAgeyB0eXBlOiBcIlBVTkNUVUFUSU9OXCIsIHZhbHVlOiBwdW5jdCB9LFxuICAgICAgICAgIHsgdHlwZTogXCJFT0ZcIiwgdmFsdWU6IFwiXCIgfVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIHBlcmlvZCBhcyBwdW5jdHVhdGlvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhcIi5cIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIlBVTkNUVUFUSU9OXCIsIHZhbHVlOiBcIi5cIiB9LFxuICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkFjY2Vzc29yc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCB0b2tlbml6ZSBiYXNpYyBhY2Nlc3NvclwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhcIkBmaWVsZFwiKTtcbiAgICAgIGV4cGVjdCh0b2tlbnMpLnRvRXF1YWwoW1xuICAgICAgICB7IHR5cGU6IFwiQUNDRVNTT1JcIiwgdmFsdWU6IFwiZmllbGRcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCB0b2tlbml6ZSBhY2Nlc3NvciB3aXRoIG51bWJlcnMgYW5kIHVuZGVyc2NvcmVzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuVmFsdWVzKFwiQGZpZWxkXzEyM1wiKTtcbiAgICAgIGV4cGVjdCh0b2tlbnMpLnRvRXF1YWwoW1xuICAgICAgICB7IHR5cGU6IFwiQUNDRVNTT1JcIiwgdmFsdWU6IFwiZmllbGRfMTIzXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIEAgd2l0aG91dCBmb2xsb3dpbmcgaWRlbnRpZmllclwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhcIkBcIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIkFDQ0VTU09SXCIsIHZhbHVlOiBcIlwiIH0sXG4gICAgICAgIHsgdHlwZTogXCJFT0ZcIiwgdmFsdWU6IFwiXCIgfVxuICAgICAgXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSBAIGZvbGxvd2VkIGJ5IG5vbi1pZGVudGlmaWVyXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuVmFsdWVzKFwiQChcIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIkFDQ0VTU09SXCIsIHZhbHVlOiBcIlwiIH0sXG4gICAgICAgIHsgdHlwZTogXCJQVU5DVFVBVElPTlwiLCB2YWx1ZTogXCIoXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJDb21tZW50c1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCBza2lwIHNpbmdsZS1saW5lIGNvbW1lbnRzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvZGVXaXRoQ29tbWVudHMgPSBgXG4gICAgICAgICMgdGhpcyBpcyBhIGNvbW1lbnRcbiAgICAgICAgeCA9IDUgIyBpbmxpbmUgY29tbWVudFxuICAgICAgICB5ID0gMTBcbiAgICAgICAgIyBhbm90aGVyIGNvbW1lbnRcbiAgICAgICAgeCArIHkgIyB0cmFpbGluZyBjb21tZW50XG4gICAgICBgO1xuICAgICAgY29uc3QgY29kZVdpdGhvdXRDb21tZW50cyA9IGBcbiAgICAgICAgeCA9IDVcbiAgICAgICAgeSA9IDEwXG4gICAgICAgIHggKyB5XG4gICAgICBgO1xuICAgICAgY29uc3QgdG9rZW5zV2l0aENvbW1lbnRzID0gbmV3IExleGVyKGNvZGVXaXRoQ29tbWVudHMpLnRva2VuaXplKCk7XG4gICAgICBjb25zdCB0b2tlbnNXaXRob3V0Q29tbWVudHMgPSBuZXcgTGV4ZXIoY29kZVdpdGhvdXRDb21tZW50cykudG9rZW5pemUoKTtcbiAgICAgIC8vIFJlbW92ZSBsb2NhdGlvbiBpbmZvIGZvciBjb21wYXJpc29uXG4gICAgICBjb25zdCBzdHJpcExvYyA9ICh0OiBhbnkpID0+ICh7IHR5cGU6IHQudHlwZSwgdmFsdWU6IHQudmFsdWUgfSk7XG4gICAgICBleHBlY3QodG9rZW5zV2l0aENvbW1lbnRzLm1hcChzdHJpcExvYykpLnRvRXF1YWwoXG4gICAgICAgIHRva2Vuc1dpdGhvdXRDb21tZW50cy5tYXAoc3RyaXBMb2MpLFxuICAgICAgKTtcbiAgICAgIC8vIEVuc3VyZSBubyBDT01NRU5UIHRva2VucyBhcmUgcHJlc2VudFxuICAgICAgZXhwZWN0KHRva2Vuc1dpdGhDb21tZW50cy5zb21lKCh0KSA9PiB0LnR5cGUgPT09IFwiQ09NTUVOVFwiKSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSBjb21tZW50IGF0IGVuZCBvZiBmaWxlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuVmFsdWVzKFwieCAjIGNvbW1lbnRcIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIklERU5USUZJRVJcIiwgdmFsdWU6IFwieFwiIH0sXG4gICAgICAgIHsgdHlwZTogXCJFT0ZcIiwgdmFsdWU6IFwiXCIgfVxuICAgICAgXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSBtdWx0aXBsZSBjb21tZW50c1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhcIiMgY29tbWVudDFcXG4jIGNvbW1lbnQyXFxueFwiKTtcbiAgICAgIGV4cGVjdCh0b2tlbnMpLnRvRXF1YWwoW1xuICAgICAgICB7IHR5cGU6IFwiSURFTlRJRklFUlwiLCB2YWx1ZTogXCJ4XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIGNvbW1lbnQgZW5jb3VudGVyZWQgaW4gbmV4dFRva2VuXCIsICgpID0+IHtcbiAgICAgIC8vIFRoaXMgdGVzdHMgdGhlIGNvbW1lbnQgaGFuZGxpbmcgcGF0aCBpbiBuZXh0VG9rZW4gKGxpbmVzIDMxNy0zMTkpXG4gICAgICBjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIiMgY29tbWVudFxcblwiKTtcbiAgICAgIGNvbnN0IHRva2VuID0gbGV4ZXIubmV4dFRva2VuKCk7XG4gICAgICBleHBlY3QodG9rZW4udHlwZSkudG9CZShcIkVPRlwiKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJXaGl0ZXNwYWNlIGhhbmRsaW5nXCIsICgpID0+IHtcbiAgICB0ZXN0KFwic2hvdWxkIHNraXAgd2hpdGVzcGFjZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhcIiAgXFx0ICB4ICBcXG4gIHkgIFwiKTtcbiAgICAgIGV4cGVjdCh0b2tlbnMpLnRvRXF1YWwoW1xuICAgICAgICB7IHR5cGU6IFwiSURFTlRJRklFUlwiLCB2YWx1ZTogXCJ4XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIklERU5USUZJRVJcIiwgdmFsdWU6IFwieVwiIH0sXG4gICAgICAgIHsgdHlwZTogXCJFT0ZcIiwgdmFsdWU6IFwiXCIgfVxuICAgICAgXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSBlbXB0eSBpbnB1dFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhcIlwiKTtcbiAgICAgIGV4cGVjdCh0b2tlbnMpLnRvRXF1YWwoW1xuICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgd2hpdGVzcGFjZSBvbmx5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGdldFRva2VuVmFsdWVzKFwiICAgXFx0XFxuICBcIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJVbmtub3duIGNoYXJhY3RlcnNcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIHVua25vd24gY2hhcmFjdGVycyBhcyBwdW5jdHVhdGlvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhcIn5cIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIlBVTkNUVUFUSU9OXCIsIHZhbHVlOiBcIn5cIiB9LFxuICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgdW5rbm93biBjaGFyYWN0ZXJzIHRoYXQgYXJlIHdoaXRlc3BhY2VcIiwgKCkgPT4ge1xuICAgICAgLy8gVGVzdCB3aXRoIGEgVW5pY29kZSB3aGl0ZXNwYWNlIGNoYXJhY3RlclxuICAgICAgY29uc3QgdG9rZW5zID0gZ2V0VG9rZW5WYWx1ZXMoXCJ4XFx1MDBBMHlcIik7IC8vIE5vbi1icmVha2luZyBzcGFjZVxuICAgICAgZXhwZWN0KHRva2VucykudG9FcXVhbChbXG4gICAgICAgIHsgdHlwZTogXCJJREVOVElGSUVSXCIsIHZhbHVlOiBcInhcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiSURFTlRJRklFUlwiLCB2YWx1ZTogXCJ5XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIHVua25vd24gd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGluIG5leHRUb2tlbiBwYXRoXCIsICgpID0+IHtcbiAgICAgIC8vIFRoaXMgdGVzdHMgbGluZSAzMjcgLSB3aGVuIHVua25vd24gY2hhcmFjdGVyIGlzIHdoaXRlc3BhY2UgYW5kIHRyaWdnZXJzIHJlY3Vyc2l2ZSBuZXh0VG9rZW5cbiAgICAgIGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiXFx1MDBBMFwiKTsgLy8gTm9uLWJyZWFraW5nIHNwYWNlIGFzIHVua25vd24gY2hhcmFjdGVyXG4gICAgICBjb25zdCB0b2tlbiA9IGxleGVyLm5leHRUb2tlbigpO1xuICAgICAgZXhwZWN0KHRva2VuLnR5cGUpLnRvQmUoXCJFT0ZcIik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRWRnZSBjYXNlcyBmb3IgMTAwJSBjb3ZlcmFnZVwiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgY29tbWVudCBpbiBuZXh0VG9rZW4gcGF0aCAobGluZXMgMzE3LTMxOSlcIiwgKCkgPT4ge1xuICAgICAgLy8gVGhpcyBpcyB0cmlja3kgLSB3ZSBuZWVkIGEgc2NlbmFyaW8gd2hlcmUgc2tpcFdoaXRlc3BhY2UgZG9lc24ndCBoYW5kbGUgdGhlIGNvbW1lbnRcbiAgICAgIC8vIExldCdzIGNyZWF0ZSBhIHNjZW5hcmlvIHdoZXJlIHRoZSBsZXhlciBwb3NpdGlvbiBpcyBhdCBhIGNvbW1lbnQgYWZ0ZXIgb3RoZXIgcHJvY2Vzc2luZ1xuICAgICAgY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoXCJ4I2NvbW1lbnRcIik7XG4gICAgICBcbiAgICAgIC8vIEdldCBmaXJzdCB0b2tlbiAoeClcbiAgICAgIGNvbnN0IGZpcnN0VG9rZW4gPSBsZXhlci5uZXh0VG9rZW4oKTtcbiAgICAgIGV4cGVjdChmaXJzdFRva2VuLnR5cGUpLnRvQmUoXCJJREVOVElGSUVSXCIpO1xuICAgICAgXG4gICAgICAvLyBOb3cgcG9zaXRpb24gc2hvdWxkIGJlIGF0IHRoZSBjb21tZW50LCBhbmQgbmV4dFRva2VuIHNob3VsZCBoYW5kbGUgaXRcbiAgICAgIGNvbnN0IHNlY29uZFRva2VuID0gbGV4ZXIubmV4dFRva2VuKCk7XG4gICAgICBleHBlY3Qoc2Vjb25kVG9rZW4udHlwZSkudG9CZShcIkVPRlwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIHdoaXRlc3BhY2UgaW4gdW5rbm93biBjaGFyYWN0ZXIgcGF0aCAobGluZSAzMjcpXCIsICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBhIHRlc3Qgd2hlcmUgYW4gdW5rbm93biBjaGFyYWN0ZXIgYmVjb21lcyB3aGl0ZXNwYWNlIGFmdGVyIGFkdmFuY2UoKVxuICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gd2UgaGF2ZSBhIGNoYXJhY3RlciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IGNhdGVnb3J5IGluaXRpYWxseVxuICAgICAgLy8gYnV0IHdoZW4gYWR2YW5jZWQgYW5kIGNoZWNrZWQgYWdhaW4sIGlzIHdoaXRlc3BhY2VcbiAgICAgIFxuICAgICAgLy8gVXNlIGEgVW5pY29kZSBjaGFyYWN0ZXIgdGhhdCBtaWdodCBiZSB0cmVhdGVkIGFzIHVua25vd24gaW5pdGlhbGx5XG4gICAgICBjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIlxcdTIwMDBcIik7IC8vIEVOIFFVQUQgLSBVbmljb2RlIHNwYWNlXG4gICAgICBjb25zdCB0b2tlbiA9IGxleGVyLm5leHRUb2tlbigpO1xuICAgICAgZXhwZWN0KHRva2VuLnR5cGUpLnRvQmUoXCJFT0ZcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSBmb3JtIGZlZWQgYXMgcG90ZW50aWFsIHVua25vd24gd2hpdGVzcGFjZVwiLCAoKSA9PiB7XG4gICAgICAvLyBGb3JtIGZlZWQgKFxcZikgbWlnaHQgdHJpZ2dlciB0aGUgdW5rbm93biBjaGFyYWN0ZXIgcGF0aCBpbiBzb21lIGNhc2VzXG4gICAgICBjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIlxcZnhcIik7XG4gICAgICBjb25zdCB0b2tlbiA9IGxleGVyLm5leHRUb2tlbigpO1xuICAgICAgZXhwZWN0KHRva2VuLnR5cGUpLnRvQmUoXCJJREVOVElGSUVSXCIpO1xuICAgICAgZXhwZWN0KHRva2VuLnZhbHVlKS50b0JlKFwieFwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIHplcm8td2lkdGggc3BhY2UgYXMgdW5rbm93biBjaGFyYWN0ZXJcIiwgKCkgPT4ge1xuICAgICAgLy8gWmVyby13aWR0aCBjaGFyYWN0ZXJzIGFyZSB0cmVhdGVkIGFzIHB1bmN0dWF0aW9uLCBub3Qgd2hpdGVzcGFjZSBieSB0aGUgbGV4ZXJcbiAgICAgIGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiXFx1MjAwQlxcdTIwMENcXHUyMDBEeFwiKTsgLy8gVmFyaW91cyB6ZXJvLXdpZHRoIGNoYXJhY3RlcnNcbiAgICAgIGNvbnN0IHRva2VuID0gbGV4ZXIubmV4dFRva2VuKCk7XG4gICAgICBleHBlY3QodG9rZW4udHlwZSkudG9CZShcIlBVTkNUVUFUSU9OXCIpO1xuICAgICAgZXhwZWN0KHRva2VuLnZhbHVlKS50b0JlKFwiXFx1MjAwQlwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIHRhYiBjaGFyYWN0ZXIgaW4gdW5rbm93biBwYXRoIChsaW5lIDMyNylcIiwgKCkgPT4ge1xuICAgICAgLy8gVGhpcyB0ZXN0IHNwZWNpZmljYWxseSB0YXJnZXRzIGxpbmUgMzI3IC0gdW5rbm93biBjaGFyYWN0ZXIgdGhhdCBiZWNvbWVzIHdoaXRlc3BhY2VcbiAgICAgIC8vIFdlIG5lZWQgYSBjaGFyYWN0ZXIgdGhhdCBkb2Vzbid0IG1hdGNoIGluaXRpYWwgcGF0dGVybnMgYnV0IGlzIHdoaXRlc3BhY2VcbiAgICAgIC8vIExldCdzIHRyeSBhIGZvcm0gZmVlZCBjaGFyYWN0ZXIgb3IgdmVydGljYWwgdGFiIHRoYXQgbWlnaHQgc2xpcCB0aHJvdWdoXG4gICAgICBjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcIlxcdlxcZnhcIik7IC8vIHZlcnRpY2FsIHRhYiBhbmQgZm9ybSBmZWVkXG4gICAgICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShcIlxcdlxcZnhcIik7XG4gICAgICBleHBlY3QodG9rZW5zWzBdLnR5cGUpLnRvQmUoXCJJREVOVElGSUVSXCIpO1xuICAgICAgZXhwZWN0KHRva2Vuc1swXS52YWx1ZSkudG9CZShcInhcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSBzcGVjaWZpYyBVbmljb2RlIHdoaXRlc3BhY2UgdGhhdCBtaWdodCBiZSB1bmtub3duIGluaXRpYWxseVwiLCAoKSA9PiB7XG4gICAgICAvLyBUZXN0IHdpdGggdmFyaW91cyBVbmljb2RlIHdoaXRlc3BhY2UgY2hhcmFjdGVycyB0aGF0IG1pZ2h0IG5vdCBtYXRjaCBpbml0aWFsIFxcc1xuICAgICAgY29uc3QgY2hhcmFjdGVycyA9IFtcbiAgICAgICAgXCJcXHUwMEEwXCIsIC8vIE5vbi1icmVha2luZyBzcGFjZVxuICAgICAgICBcIlxcdTE2ODBcIiwgLy8gT2doYW0gc3BhY2UgbWFya1xuICAgICAgICBcIlxcdTIwMDBcIiwgLy8gRW4gcXVhZFxuICAgICAgICBcIlxcdTIwMDFcIiwgLy8gRW0gcXVhZFxuICAgICAgICBcIlxcdTIwMDJcIiwgLy8gRW4gc3BhY2VcbiAgICAgICAgXCJcXHUyMDAzXCIsIC8vIEVtIHNwYWNlXG4gICAgICAgIFwiXFx1MjAwNFwiLCAvLyBUaHJlZS1wZXItZW0gc3BhY2VcbiAgICAgICAgXCJcXHUyMDA1XCIsIC8vIEZvdXItcGVyLWVtIHNwYWNlXG4gICAgICAgIFwiXFx1MjAwNlwiLCAvLyBTaXgtcGVyLWVtIHNwYWNlXG4gICAgICAgIFwiXFx1MjAwN1wiLCAvLyBGaWd1cmUgc3BhY2VcbiAgICAgICAgXCJcXHUyMDA4XCIsIC8vIFB1bmN0dWF0aW9uIHNwYWNlXG4gICAgICAgIFwiXFx1MjAwOVwiLCAvLyBUaGluIHNwYWNlXG4gICAgICAgIFwiXFx1MjAwQVwiLCAvLyBIYWlyIHNwYWNlXG4gICAgICAgIFwiXFx1MjAyRlwiLCAvLyBOYXJyb3cgbm8tYnJlYWsgc3BhY2VcbiAgICAgICAgXCJcXHUyMDVGXCIsIC8vIE1lZGl1bSBtYXRoZW1hdGljYWwgc3BhY2VcbiAgICAgICAgXCJcXHUzMDAwXCIsIC8vIElkZW9ncmFwaGljIHNwYWNlXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IGNoYXIgb2YgY2hhcmFjdGVycykge1xuICAgICAgICBjb25zdCBsZXhlciA9IG5ldyBMZXhlcihjaGFyICsgXCJ4XCIpO1xuICAgICAgICBjb25zdCB0b2tlbiA9IGxleGVyLm5leHRUb2tlbigpO1xuICAgICAgICBleHBlY3QodG9rZW4udHlwZSkudG9CZShcIklERU5USUZJRVJcIik7XG4gICAgICAgIGV4cGVjdCh0b2tlbi52YWx1ZSkudG9CZShcInhcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHRyaWdnZXIgY29tbWVudCBmYWxsYmFjayBpbiBuZXh0VG9rZW4gKGxpbmVzIDMxNy0zMTkpXCIsICgpID0+IHtcbiAgICAgIC8vIFRyeSB0byBjcmVhdGUgYSBzY2VuYXJpbyB3aGVyZSBza2lwV2hpdGVzcGFjZSBkb2Vzbid0IGhhbmRsZSB0aGUgY29tbWVudFxuICAgICAgLy8gVGhpcyBpcyBhIHZlcnkgc3BlY2lmaWMgZWRnZSBjYXNlIC0gY3JlYXRlIGEgbGV4ZXIgd2hlcmUgd2UgbWFudWFsbHkgcG9zaXRpb25cbiAgICAgIC8vIGl0IHNvIHRoYXQgc2tpcFdoaXRlc3BhY2UgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgYnV0IGEgY29tbWVudCBhcHBlYXJzXG4gICAgICBjb25zdCBpbnB1dCA9IFwiYVxcdCNjb21tZW50XCI7XG4gICAgICBjb25zdCBsZXhlciA9IG5ldyBMZXhlcihpbnB1dCk7XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgJ2EnIHRva2VuXG4gICAgICBjb25zdCBmaXJzdFRva2VuID0gbGV4ZXIubmV4dFRva2VuKCk7XG4gICAgICBleHBlY3QoZmlyc3RUb2tlbi50eXBlKS50b0JlKFwiSURFTlRJRklFUlwiKTtcbiAgICAgIGV4cGVjdChmaXJzdFRva2VuLnZhbHVlKS50b0JlKFwiYVwiKTtcbiAgICAgIFxuICAgICAgLy8gVGhlIG5leHQgdG9rZW4gc2hvdWxkIHNraXAgdGhlIHRhYiBhbmQgaGFuZGxlIHRoZSBjb21tZW50XG4gICAgICBjb25zdCBzZWNvbmRUb2tlbiA9IGxleGVyLm5leHRUb2tlbigpO1xuICAgICAgZXhwZWN0KHNlY29uZFRva2VuLnR5cGUpLnRvQmUoXCJFT0ZcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHRyaWdnZXIgdW5rbm93biB3aGl0ZXNwYWNlIHBhdGggKGxpbmUgMzI3KSB3aXRoIG5vbi1icmVha2luZyBzcGFjZVwiLCAoKSA9PiB7XG4gICAgICAvLyBVc2UgYSBub24tYnJlYWtpbmcgc3BhY2Ugd2hpY2ggbWlnaHQgbm90IGJlIGNhdWdodCBieSBpbml0aWFsIHdoaXRlc3BhY2UgY2hlY2tzXG4gICAgICBjb25zdCBpbnB1dCA9IFwiXFx1MDBBMHhcIjsgLy8gTm9uLWJyZWFraW5nIHNwYWNlIGZvbGxvd2VkIGJ5IGlkZW50aWZpZXJcbiAgICAgIGNvbnN0IHRva2VucyA9IHRva2VuaXplKGlucHV0KTtcbiAgICAgIGV4cGVjdCh0b2tlbnNbMF0udHlwZSkudG9CZShcIklERU5USUZJRVJcIik7XG4gICAgICBleHBlY3QodG9rZW5zWzBdLnZhbHVlKS50b0JlKFwieFwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgdHJpZ2dlciB1bmtub3duIHdoaXRlc3BhY2UgcGF0aCAobGluZSAzMjcpIHdpdGggZXhvdGljIHdoaXRlc3BhY2VcIiwgKCkgPT4ge1xuICAgICAgLy8gVHJ5IG90aGVyIFVuaWNvZGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHRoYXQgbWlnaHQgbm90IG1hdGNoIGluaXRpYWwgL1xccy9cbiAgICAgIGNvbnN0IGlucHV0ID0gXCJcXHUyMDAwXFx1MjAwMVxcdTIwMDJ4XCI7IC8vIEVuIHF1YWQsIEVtIHF1YWQsIEVuIHNwYWNlXG4gICAgICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShpbnB1dCk7XG4gICAgICBleHBlY3QodG9rZW5zWzBdLnR5cGUpLnRvQmUoXCJJREVOVElGSUVSXCIpO1xuICAgICAgZXhwZWN0KHRva2Vuc1swXS52YWx1ZSkudG9CZShcInhcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHRyaWdnZXIgZXhhY3QgdW5jb3ZlcmVkIHBhdGhzIHdpdGggbnVsbCBjaGFyYWN0ZXIgZWRnZSBjYXNlXCIsICgpID0+IHtcbiAgICAgIC8vIFRyeSBhIG51bGwgY2hhcmFjdGVyIHRoYXQgbWlnaHQgYmVoYXZlIHVuZXhwZWN0ZWRseVxuICAgICAgY29uc3QgaW5wdXQgPSBcIlxcMHhcIjtcbiAgICAgIGNvbnN0IHRva2VucyA9IHRva2VuaXplKGlucHV0KTtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIGVpdGhlciBoYW5kbGUgdGhlIG51bGwgYXMgcHVuY3R1YXRpb24gb3Igc2tpcCBpdFxuICAgICAgZXhwZWN0KHRva2Vucy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIGNoYXJhY3RlciB0aGF0IGxvb2tzIGxpa2Ugb3BlcmF0b3IgYnV0IGlzbid0XCIsICgpID0+IHtcbiAgICAgIC8vIFRyeSB0byB0cmlnZ2VyIHRoZSBzaW5nbGUgY2hhcmFjdGVyIG9wZXJhdG9yIGZhbGxiYWNrIChsaW5lIDIyNClcbiAgICAgIC8vIFVzZSBhIGNoYXJhY3RlciB0aGF0IG1hdGNoZXMgb3BlcmF0b3IgcmVnZXggYnV0IGlzbid0IG11bHRpLWNoYXJcbiAgICAgIGNvbnN0IGlucHV0ID0gXCIheFwiOyAvLyAhIGlzIGluIHRoZSBvcGVyYXRvciByZWdleCBhbmQgbm90IG11bHRpLWNoYXIgaW4gdGhpcyBjb250ZXh0XG4gICAgICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShpbnB1dCk7XG4gICAgICBleHBlY3QodG9rZW5zWzBdLnR5cGUpLnRvQmUoXCJPUEVSQVRPUlwiKTtcbiAgICAgIGV4cGVjdCh0b2tlbnNbMF0udmFsdWUpLnRvQmUoXCIhXCIpO1xuICAgICAgZXhwZWN0KHRva2Vuc1sxXS50eXBlKS50b0JlKFwiSURFTlRJRklFUlwiKTtcbiAgICAgIGV4cGVjdCh0b2tlbnNbMV0udmFsdWUpLnRvQmUoXCJ4XCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgY29tbWVudCBpbW1lZGlhdGVseSBhZnRlciBFT0YgY2hlY2tcIiwgKCkgPT4ge1xuICAgICAgLy8gVHJ5IHRvIGNyZWF0ZSBhIHNjZW5hcmlvIHdoZXJlIGNvbW1lbnQgaGFuZGxpbmcgaGl0cyB0aGUgbmV4dFRva2VuIHBhdGhcbiAgICAgIGNvbnN0IGlucHV0ID0gXCIjXCI7XG4gICAgICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShpbnB1dCk7XG4gICAgICBleHBlY3QodG9rZW5zWzBdLnR5cGUpLnRvQmUoXCJFT0ZcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSBlZGdlIGNhc2UgZm9yIGV4YWN0IGxpbmUgY292ZXJhZ2UgLSBjYXJyaWFnZSByZXR1cm4gYmVmb3JlIGNvbW1lbnRcIiwgKCkgPT4ge1xuICAgICAgLy8gVHJ5IHVzaW5nIGNhcnJpYWdlIHJldHVybiB3aGljaCBtaWdodCBub3QgYmUgaGFuZGxlZCB0aGUgc2FtZSBhcyBvdGhlciB3aGl0ZXNwYWNlXG4gICAgICBjb25zdCBpbnB1dCA9IFwiXFxyI2NvbW1lbnRcXG54XCI7XG4gICAgICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShpbnB1dCk7XG4gICAgICBleHBlY3QodG9rZW5zWzBdLnR5cGUpLnRvQmUoXCJJREVOVElGSUVSXCIpO1xuICAgICAgZXhwZWN0KHRva2Vuc1swXS52YWx1ZSkudG9CZShcInhcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSB6ZXJvLXdpZHRoIGpvaW5lciB0aGF0IG1pZ2h0IG5vdCBtYXRjaCBcXFxccyByZWdleFwiLCAoKSA9PiB7XG4gICAgICAvLyBaZXJvLXdpZHRoIGpvaW5lciAoVSsyMDBEKSBtaWdodCBub3QgbWF0Y2ggXFxcXHMgYnV0IGNvdWxkIGJlIHdoaXRlc3BhY2UtbGlrZVxuICAgICAgY29uc3QgaW5wdXQgPSBcIlxcdTIwMER4XCI7XG4gICAgICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShpbnB1dCk7XG4gICAgICAvLyBUaGlzIHNob3VsZCBlaXRoZXIgc2tpcCB0aGUgWldKSiBvciB0cmVhdCBpdCBhcyBwdW5jdHVhdGlvblxuICAgICAgaWYgKHRva2Vuc1swXS50eXBlID09PSBcIklERU5USUZJRVJcIikge1xuICAgICAgICBleHBlY3QodG9rZW5zWzBdLnZhbHVlKS50b0JlKFwieFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cGVjdCh0b2tlbnNbMF0udHlwZSkudG9CZShcIlBVTkNUVUFUSU9OXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkxpbmUgYW5kIGNvbHVtbiB0cmFja2luZ1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCB0cmFjayBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwieFxcbnlcIik7XG4gICAgICBjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuICAgICAgXG4gICAgICBleHBlY3QodG9rZW5zWzBdLmxvY2F0aW9uLnN0YXJ0LmxpbmUpLnRvQmUoMSk7XG4gICAgICBleHBlY3QodG9rZW5zWzBdLmxvY2F0aW9uLnN0YXJ0LmNvbHVtbikudG9CZSgxKTtcbiAgICAgIGV4cGVjdCh0b2tlbnNbMF0ubG9jYXRpb24uZW5kLmxpbmUpLnRvQmUoMSk7XG4gICAgICBleHBlY3QodG9rZW5zWzBdLmxvY2F0aW9uLmVuZC5jb2x1bW4pLnRvQmUoMik7XG4gICAgICBcbiAgICAgIGV4cGVjdCh0b2tlbnNbMV0ubG9jYXRpb24uc3RhcnQubGluZSkudG9CZSgyKTtcbiAgICAgIGV4cGVjdCh0b2tlbnNbMV0ubG9jYXRpb24uc3RhcnQuY29sdW1uKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHRva2Vuc1sxXS5sb2NhdGlvbi5lbmQubGluZSkudG9CZSgyKTtcbiAgICAgIGV4cGVjdCh0b2tlbnNbMV0ubG9jYXRpb24uZW5kLmNvbHVtbikudG9CZSgyKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIGNvbHVtbiBhZHZhbmNlbWVudFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsZXhlciA9IG5ldyBMZXhlcihcImFiY1wiKTtcbiAgICAgIGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG4gICAgICBcbiAgICAgIGV4cGVjdCh0b2tlbnNbMF0ubG9jYXRpb24uc3RhcnQubGluZSkudG9CZSgxKTtcbiAgICAgIGV4cGVjdCh0b2tlbnNbMF0ubG9jYXRpb24uc3RhcnQuY29sdW1uKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHRva2Vuc1swXS5sb2NhdGlvbi5lbmQubGluZSkudG9CZSgxKTtcbiAgICAgIGV4cGVjdCh0b2tlbnNbMF0ubG9jYXRpb24uZW5kLmNvbHVtbikudG9CZSg0KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJDb21wbGV4IGV4cHJlc3Npb25zXCIsICgpID0+IHtcbiAgICB0ZXN0KFwic2hvdWxkIHRva2VuaXplIGNvbXBsZXggZXhwcmVzc2lvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcygnZm4gYWRkKHgsIHkpIC0+IHggKyB5XFxubGV0IHJlc3VsdCA9IGFkZCgxLCAyKScpO1xuICAgICAgZXhwZWN0KHRva2VucykudG9FcXVhbChbXG4gICAgICAgIHsgdHlwZTogXCJLRVlXT1JEXCIsIHZhbHVlOiBcImZuXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIklERU5USUZJRVJcIiwgdmFsdWU6IFwiYWRkXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIlBVTkNUVUFUSU9OXCIsIHZhbHVlOiBcIihcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiSURFTlRJRklFUlwiLCB2YWx1ZTogXCJ4XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIlBVTkNUVUFUSU9OXCIsIHZhbHVlOiBcIixcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiSURFTlRJRklFUlwiLCB2YWx1ZTogXCJ5XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIlBVTkNUVUFUSU9OXCIsIHZhbHVlOiBcIilcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiT1BFUkFUT1JcIiwgdmFsdWU6IFwiLT5cIiB9LFxuICAgICAgICB7IHR5cGU6IFwiSURFTlRJRklFUlwiLCB2YWx1ZTogXCJ4XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIk9QRVJBVE9SXCIsIHZhbHVlOiBcIitcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiSURFTlRJRklFUlwiLCB2YWx1ZTogXCJ5XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIktFWVdPUkRcIiwgdmFsdWU6IFwibGV0XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIklERU5USUZJRVJcIiwgdmFsdWU6IFwicmVzdWx0XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIk9QRVJBVE9SXCIsIHZhbHVlOiBcIj1cIiB9LFxuICAgICAgICB7IHR5cGU6IFwiSURFTlRJRklFUlwiLCB2YWx1ZTogXCJhZGRcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiUFVOQ1RVQVRJT05cIiwgdmFsdWU6IFwiKFwiIH0sXG4gICAgICAgIHsgdHlwZTogXCJOVU1CRVJcIiwgdmFsdWU6IFwiMVwiIH0sXG4gICAgICAgIHsgdHlwZTogXCJQVU5DVFVBVElPTlwiLCB2YWx1ZTogXCIsXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIk5VTUJFUlwiLCB2YWx1ZTogXCIyXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIlBVTkNUVUFUSU9OXCIsIHZhbHVlOiBcIilcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgbWl4ZWQgb3BlcmF0b3JzIGFuZCBwdW5jdHVhdGlvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhcIih4ID09IHkpICYmIHpcIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIlBVTkNUVUFUSU9OXCIsIHZhbHVlOiBcIihcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiSURFTlRJRklFUlwiLCB2YWx1ZTogXCJ4XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIk9QRVJBVE9SXCIsIHZhbHVlOiBcIj09XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIklERU5USUZJRVJcIiwgdmFsdWU6IFwieVwiIH0sXG4gICAgICAgIHsgdHlwZTogXCJQVU5DVFVBVElPTlwiLCB2YWx1ZTogXCIpXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIlBVTkNUVUFUSU9OXCIsIHZhbHVlOiBcIiZcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiUFVOQ1RVQVRJT05cIiwgdmFsdWU6IFwiJlwiIH0sXG4gICAgICAgIHsgdHlwZTogXCJJREVOVElGSUVSXCIsIHZhbHVlOiBcInpcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiRU9GXCIsIHZhbHVlOiBcIlwiIH1cbiAgICAgIF0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkVkZ2UgY2FzZXNcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIEVPRiBjb25kaXRpb25zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxleGVyID0gbmV3IExleGVyKFwiXCIpO1xuICAgICAgY29uc3QgdG9rZW4gPSBsZXhlci5uZXh0VG9rZW4oKTtcbiAgICAgIGV4cGVjdCh0b2tlbi50eXBlKS50b0JlKFwiRU9GXCIpO1xuICAgICAgZXhwZWN0KHRva2VuLnZhbHVlKS50b0JlKFwiXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgc2VxdWVudGlhbCB3aGl0ZXNwYWNlIGFuZCBjb21tZW50c1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlblZhbHVlcyhcIiAgIyBjb21tZW50XFxuICBcXHQjIGFub3RoZXJcXG4geFwiKTtcbiAgICAgIGV4cGVjdCh0b2tlbnMpLnRvRXF1YWwoW1xuICAgICAgICB7IHR5cGU6IFwiSURFTlRJRklFUlwiLCB2YWx1ZTogXCJ4XCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIG9wZXJhdG9ycyBhdCBlbmQgb2YgaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gZ2V0VG9rZW5WYWx1ZXMoXCJ4ICtcIik7XG4gICAgICBleHBlY3QodG9rZW5zKS50b0VxdWFsKFtcbiAgICAgICAgeyB0eXBlOiBcIklERU5USUZJRVJcIiwgdmFsdWU6IFwieFwiIH0sXG4gICAgICAgIHsgdHlwZTogXCJPUEVSQVRPUlwiLCB2YWx1ZTogXCIrXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcIkVPRlwiLCB2YWx1ZTogXCJcIiB9XG4gICAgICBdKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsInRva2VuaXplIiwiaW5wdXQiLCJMZXhlciIsImdldFRva2VuVmFsdWVzIiwibWFwIiwidG9rZW4iLCJ0eXBlIiwidmFsdWUiLCJ0ZXN0IiwidG9rZW5zIiwiZXhwZWN0IiwidG9FcXVhbCIsImtleXdvcmRzIiwia2V5d29yZCIsInByaW1pdGl2ZXMiLCJwcmltaXRpdmUiLCJtdWx0aUNoYXJPcHMiLCJvcCIsInNpbmdsZUNoYXJPcHMiLCJwdW5jdHVhdGlvbiIsInB1bmN0IiwiY29kZVdpdGhDb21tZW50cyIsImNvZGVXaXRob3V0Q29tbWVudHMiLCJ0b2tlbnNXaXRoQ29tbWVudHMiLCJ0b2tlbnNXaXRob3V0Q29tbWVudHMiLCJzdHJpcExvYyIsInQiLCJzb21lIiwidG9CZSIsImxleGVyIiwibmV4dFRva2VuIiwiZmlyc3RUb2tlbiIsInNlY29uZFRva2VuIiwiY2hhcmFjdGVycyIsImNoYXIiLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW4iLCJsb2NhdGlvbiIsInN0YXJ0IiwibGluZSIsImNvbHVtbiIsImVuZCJdLCJtYXBwaW5ncyI6Ijs7Ozt1QkFBc0I7QUFFdEJBLFNBQVMsU0FBUztJQUNoQixxREFBcUQ7SUFDckQsTUFBTUMsV0FBVyxDQUFDQyxRQUFrQixJQUFJQyxZQUFLLENBQUNELE9BQU9ELFFBQVE7SUFFN0QsNERBQTREO0lBQzVELE1BQU1HLGlCQUFpQixDQUFDRixRQUN0QkQsU0FBU0MsT0FBT0csR0FBRyxDQUFDQyxDQUFBQSxRQUFVLENBQUE7Z0JBQUVDLE1BQU1ELE1BQU1DLElBQUk7Z0JBQUVDLE9BQU9GLE1BQU1FLEtBQUs7WUFBQyxDQUFBO0lBRXZFUixTQUFTLFdBQVc7UUFDbEJTLEtBQUssNEJBQTRCO1lBQy9CLE1BQU1DLFNBQVNOLGVBQWU7WUFDOUJPLE9BQU9ELFFBQVFFLE9BQU8sQ0FBQztnQkFDckI7b0JBQUVMLE1BQU07b0JBQVVDLE9BQU87Z0JBQU07Z0JBQy9CO29CQUFFRCxNQUFNO29CQUFPQyxPQUFPO2dCQUFHO2FBQzFCO1FBQ0g7UUFFQUMsS0FBSywwQ0FBMEM7WUFDN0MsTUFBTUMsU0FBU04sZUFBZTtZQUM5Qk8sT0FBT0QsUUFBUUUsT0FBTyxDQUFDO2dCQUNyQjtvQkFBRUwsTUFBTTtvQkFBVUMsT0FBTztnQkFBVTtnQkFDbkM7b0JBQUVELE1BQU07b0JBQU9DLE9BQU87Z0JBQUc7YUFDMUI7UUFDSDtRQUVBQyxLQUFLLGdEQUFnRDtZQUNuRCxNQUFNQyxTQUFTTixlQUFlO1lBQzlCTyxPQUFPRCxRQUFRRSxPQUFPLENBQUM7Z0JBQ3JC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