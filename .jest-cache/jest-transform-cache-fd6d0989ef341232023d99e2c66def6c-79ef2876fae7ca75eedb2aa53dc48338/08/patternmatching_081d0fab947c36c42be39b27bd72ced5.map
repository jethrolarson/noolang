{"version":3,"sources":["/workspace/src/typer/pattern-matching.ts"],"sourcesContent":["import {\n\ttype TypeDefinitionExpression,\n\ttype MatchExpression,\n\ttype MatchCase,\n\ttype Pattern,\n\ttype Type,\n\ttypeVariable,\n\tfunctionType,\n\tunitType,\n\tintType,\n\tstringType,\n} from '../ast';\nimport { \n\ttype TypeState, \n\ttype TypeResult, \n\tcreateTypeResult, \n\tcreatePureTypeResult, \n\tunionEffects \n} from './types';\nimport { substitute } from './substitute';\nimport { unify } from './unify';\nimport { freshTypeVariable } from './type-operations';\nimport { typeExpression } from './expression-dispatcher';\nimport { isTypeKind, typeToString } from './helpers';\n\n// Type inference for ADT type definitions\nexport const typeTypeDefinition = (\n\texpr: TypeDefinitionExpression,\n\tstate: TypeState,\n): TypeResult => {\n\t// Register the ADT in the registry first to enable recursive references\n\tconst constructorMap = new Map<string, Type[]>();\n\n\t// Pre-register the ADT so recursive references work\n\tconst newRegistry = new Map(state.adtRegistry);\n\tnewRegistry.set(expr.name, {\n\t\ttypeParams: expr.typeParams,\n\t\tconstructors: constructorMap, // Will be filled\n\t});\n\n\t// Also add the ADT type constructor to the environment\n\tconst adtType = {\n\t\tkind: \"variant\" as const,\n\t\tname: expr.name,\n\t\targs: expr.typeParams.map((param) => typeVariable(param)),\n\t};\n\tconst envWithType = new Map(state.environment);\n\tenvWithType.set(expr.name, {\n\t\ttype: adtType,\n\t\tquantifiedVars: expr.typeParams,\n\t});\n\n\tstate = { ...state, adtRegistry: newRegistry, environment: envWithType };\n\n\t// Process each constructor\n\tfor (const _constructor of expr.constructors) {\n\t\tconstructorMap.set(_constructor.name, _constructor.args);\n\n\t\t// Add constructor to environment as a function\n\t\t// Constructor type: arg1 -> arg2 -> ... -> ADTType typeParams\n\t\tconst adtType: Type = {\n\t\t\tkind: \"variant\",\n\t\t\tname: expr.name,\n\t\t\targs: expr.typeParams.map((param) => typeVariable(param)),\n\t\t};\n\n\t\tlet constructorType: Type;\n\t\tif (_constructor.args.length === 0) {\n\t\t\t// Nullary constructor: just the ADT type\n\t\t\tconstructorType = adtType;\n\t\t} else {\n\t\t\t// N-ary constructor: function from args to ADT type\n\t\t\tconstructorType = functionType(_constructor.args, adtType);\n\t\t}\n\n\t\t// Add constructor to environment\n\t\tconst newEnv = new Map(state.environment);\n\t\tnewEnv.set(_constructor.name, {\n\t\t\ttype: constructorType,\n\t\t\tquantifiedVars: expr.typeParams,\n\t\t});\n\t\tstate = { ...state, environment: newEnv };\n\t}\n\n\t// Update ADT registry with completed constructor map\n\tconst finalRegistry = new Map(state.adtRegistry);\n\tfinalRegistry.set(expr.name, {\n\t\ttypeParams: expr.typeParams,\n\t\tconstructors: constructorMap,\n\t});\n\n\t// Type definitions return unit and update state\n\treturn createPureTypeResult(\n\t\tunitType(),\n\t\t{ ...state, adtRegistry: finalRegistry }\n\t);\n};\n\n// Type inference for match expressions\nexport const typeMatch = (\n\texpr: MatchExpression,\n\tstate: TypeState,\n): TypeResult => {\n\t// Type the expression being matched\n\tconst exprResult = typeExpression(expr.expression, state);\n\tlet currentState = exprResult.state;\n\n\t// Type each case and ensure they all return the same type\n\tif (expr.cases.length === 0) {\n\t\tthrow new Error(\"Match expression must have at least one case\");\n\t}\n\n\t// Type first case to get result type\n\tconst firstCaseResult = typeMatchCase(\n\t\texpr.cases[0],\n\t\texprResult.type,\n\t\tcurrentState,\n\t);\n\tcurrentState = firstCaseResult.state;\n\tlet resultType = firstCaseResult.type;\n\tlet allEffects = unionEffects(exprResult.effects, firstCaseResult.effects);\n\n\t// Type remaining cases and unify with result type\n\tfor (let i = 1; i < expr.cases.length; i++) {\n\t\tconst caseResult = typeMatchCase(\n\t\t\texpr.cases[i],\n\t\t\texprResult.type,\n\t\t\tcurrentState,\n\t\t);\n\t\tcurrentState = caseResult.state;\n\t\tallEffects = unionEffects(allEffects, caseResult.effects);\n\n\t\t// Unify case result type with overall result type\n\t\tcurrentState = unify(\n\t\t\tresultType,\n\t\t\tcaseResult.type,\n\t\t\tcurrentState,\n\t\t\texpr.cases[i].location.start,\n\t\t);\n\t\tresultType = substitute(resultType, currentState.substitution);\n\t}\n\n\treturn createTypeResult(resultType, allEffects, currentState);\n};\n\n// Type a single match case\nconst typeMatchCase = (\n\tmatchCase: MatchCase,\n\tmatchedType: Type,\n\tstate: TypeState,\n): TypeResult => {\n\t// Type the pattern and get bindings\n\tconst patternResult = typePattern(matchCase.pattern, matchedType, state);\n\n\t// Create new environment with pattern bindings\n\tconst newEnv = new Map(patternResult.state.environment);\n\tfor (const [name, type] of patternResult.bindings) {\n\t\tnewEnv.set(name, { type, quantifiedVars: [] });\n\t}\n\n\tconst envState = { ...patternResult.state, environment: newEnv };\n\n\t// Type the expression with pattern bindings in scope\n\treturn typeExpression(matchCase.expression, envState);\n};\n\n// Type a pattern and return bindings\nconst typePattern = (\n\tpattern: Pattern,\n\texpectedType: Type,\n\tstate: TypeState,\n): { state: TypeState; bindings: Map<string, Type> } => {\n\tconst bindings = new Map<string, Type>();\n\n\tswitch (pattern.kind) {\n\t\tcase \"wildcard\":\n\t\t\t// Wildcard matches anything, no bindings\n\t\t\treturn { state, bindings };\n\n\t\tcase \"variable\":\n\t\t\t// Variable binds to the expected type\n\t\t\tbindings.set(pattern.name, expectedType);\n\t\t\treturn { state, bindings };\n\n\t\tcase \"constructor\": {\n\t\t\t// Constructor pattern matching with type variable handling\n\t\t\tlet actualType = expectedType;\n\t\t\tlet currentState = state;\n\n\t\t\t// If expected type is a type variable, we need to find the ADT from the constructor\n\t\t\tif (isTypeKind(expectedType, \"variable\")) {\n\t\t\t\t// Find which ADT this constructor belongs to\n\t\t\t\tlet foundAdt: string | null = null;\n\t\t\t\tfor (const [adtName, adtInfo] of state.adtRegistry) {\n\t\t\t\t\tif (adtInfo.constructors.has(pattern.name)) {\n\t\t\t\t\t\tfoundAdt = adtName;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!foundAdt) {\n\t\t\t\t\tthrow new Error(`Unknown constructor: ${pattern.name}`);\n\t\t\t\t}\n\n\t\t\t\t// Create the ADT type with fresh type variables for type parameters\n\t\t\t\tconst adtInfo = state.adtRegistry.get(foundAdt)!;\n\t\t\t\tconst typeArgs: Type[] = [];\n\t\t\t\tconst substitution = new Map<string, Type>();\n\t\t\t\tfor (let i = 0; i < adtInfo.typeParams.length; i++) {\n\t\t\t\t\tconst [freshVar, nextState] = freshTypeVariable(currentState);\n\t\t\t\t\ttypeArgs.push(freshVar);\n\t\t\t\t\tsubstitution.set(adtInfo.typeParams[i], freshVar);\n\t\t\t\t\tcurrentState = nextState;\n\t\t\t\t}\n\t\t\t\tactualType = { kind: \"variant\", name: foundAdt, args: typeArgs };\n\n\t\t\t\t// Unify the type variable with the ADT type\n\t\t\t\tcurrentState = unify(expectedType, actualType, currentState, undefined);\n\t\t\t} else if (!isTypeKind(expectedType, \"variant\")) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Pattern expects constructor but got ${typeToString(\n\t\t\t\t\t\texpectedType,\n\t\t\t\t\t\tstate.substitution,\n\t\t\t\t\t)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Look up constructor in ADT registry\n\t\t\tif (!isTypeKind(actualType, \"variant\")) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Internal error: actualType should be variant but got ${actualType.kind}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst adtInfo = state.adtRegistry.get(actualType.name);\n\t\t\tif (!adtInfo) {\n\t\t\t\tthrow new Error(`Unknown ADT: ${actualType.name}`);\n\t\t\t}\n\n\t\t\tconst constructorArgs = adtInfo.constructors.get(pattern.name);\n\t\t\tif (!constructorArgs) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Unknown constructor: ${pattern.name} for ADT ${actualType.name}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Create a substitution from type parameters to actual type arguments\n\t\t\tconst paramSubstitution = new Map<string, Type>();\n\t\t\tfor (let i = 0; i < adtInfo.typeParams.length; i++) {\n\t\t\t\tparamSubstitution.set(adtInfo.typeParams[i], actualType.args[i]);\n\t\t\t}\n\n\t\t\t// Substitute type parameters with actual type arguments\n\t\t\tconst substitutedArgs = constructorArgs.map((arg) =>\n\t\t\t\tsubstitute(arg, paramSubstitution),\n\t\t\t);\n\n\t\t\t// Check argument count\n\t\t\tif (pattern.args.length !== substitutedArgs.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Constructor ${pattern.name} expects ${substitutedArgs.length} arguments but got ${pattern.args.length}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Type each argument pattern\n\t\t\tfor (let i = 0; i < pattern.args.length; i++) {\n\t\t\t\tconst argResult = typePattern(\n\t\t\t\t\tpattern.args[i],\n\t\t\t\t\tsubstitutedArgs[i],\n\t\t\t\t\tcurrentState,\n\t\t\t\t);\n\t\t\t\tcurrentState = argResult.state;\n\n\t\t\t\t// Merge bindings\n\t\t\t\tfor (const [name, type] of argResult.bindings) {\n\t\t\t\t\tbindings.set(name, type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { state: currentState, bindings };\n\t\t}\n\n\t\tcase \"literal\": {\n\t\t\t// Literal patterns need to match the expected type\n\t\t\tlet literalType: Type;\n\t\t\tif (typeof pattern.value === \"number\") {\n\t\t\t\tliteralType = intType();\n\t\t\t} else if (typeof pattern.value === \"string\") {\n\t\t\t\tliteralType = stringType();\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Unsupported literal pattern: ${pattern.value}`);\n\t\t\t}\n\n\t\t\tconst unifiedState = unify(\n\t\t\t\texpectedType,\n\t\t\t\tliteralType,\n\t\t\t\tstate,\n\t\t\t\tpattern.location.start,\n\t\t\t);\n\t\t\treturn { state: unifiedState, bindings };\n\t\t}\n\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported pattern kind: ${(pattern as Pattern).kind}`);\n\t}\n};"],"names":["typeMatch","typeTypeDefinition","expr","state","constructorMap","Map","newRegistry","adtRegistry","set","name","typeParams","constructors","adtType","kind","args","map","param","typeVariable","envWithType","environment","type","quantifiedVars","_constructor","constructorType","length","functionType","newEnv","finalRegistry","createPureTypeResult","unitType","exprResult","typeExpression","expression","currentState","cases","Error","firstCaseResult","typeMatchCase","resultType","allEffects","unionEffects","effects","i","caseResult","unify","location","start","substitute","substitution","createTypeResult","matchCase","matchedType","patternResult","typePattern","pattern","bindings","envState","expectedType","actualType","isTypeKind","foundAdt","adtName","adtInfo","has","get","typeArgs","freshVar","nextState","freshTypeVariable","push","undefined","typeToString","constructorArgs","paramSubstitution","substitutedArgs","arg","argResult","literalType","value","intType","stringType","unifiedState"],"mappings":"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"}