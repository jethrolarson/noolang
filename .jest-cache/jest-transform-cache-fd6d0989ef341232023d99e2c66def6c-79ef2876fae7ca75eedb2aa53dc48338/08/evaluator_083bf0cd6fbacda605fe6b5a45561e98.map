{"version":3,"sources":["/workspace/src/evaluator.ts"],"sourcesContent":["import * as defaultFs from \"node:fs\";\nimport * as defaultPath from \"node:path\";\nimport type {\n\tExpression,\n\tProgram,\n\tLiteralExpression,\n\tVariableExpression,\n\tFunctionExpression,\n\tApplicationExpression,\n\tPipelineExpression,\n\tBinaryExpression,\n\tIfExpression,\n\tDefinitionExpression,\n\tImportExpression,\n\tRecordExpression,\n\tAccessorExpression,\n\tTypeDefinitionExpression,\n\tMatchExpression,\n\tPattern,\n\tWhereExpression,\n\tMutableDefinitionExpression,\n\tMutationExpression,\n} from \"./ast\";\nimport { createError } from \"./errors\";\nimport { formatValue } from \"./format\";\nimport { Lexer } from \"./lexer\";\nimport { parse } from \"./parser/parser\";\n\n// Value types (Phase 6: functions and native functions as tagged union)\nexport type Value =\n\t| { tag: \"number\"; value: number }\n\t| { tag: \"string\"; value: string }\n\t| { tag: \"tuple\"; values: Value[] }\n\t| { tag: \"list\"; values: Value[] }\n\t| { tag: \"record\"; fields: { [key: string]: Value } }\n\t| { tag: \"function\"; fn: (...args: Value[]) => Value }\n\t| { tag: \"native\"; name: string; fn: unknown }\n\t| { tag: \"constructor\"; name: string; args: Value[] }\n\t| { tag: \"unit\" };\n\n// --- Mutable Cell type ---\nexport type Cell = { cell: true; value: Value };\nexport const isCell = (val: any): val is Cell =>\n\tval && typeof val === \"object\" && val.cell === true && \"value\" in val;\n\nexport const createCell = (value: Value): Cell => ({ cell: true, value });\n\nexport const isNumber = (\n\tvalue: Value,\n): value is { tag: \"number\"; value: number } => value.tag === \"number\";\n\nexport const createNumber = (value: number): Value => ({\n\ttag: \"number\",\n\tvalue,\n});\n\nexport const isString = (\n\tvalue: Value,\n): value is { tag: \"string\"; value: string } => value.tag === \"string\";\n\nexport const createString = (value: string): Value => ({\n\ttag: \"string\",\n\tvalue,\n});\n\nexport const createTrue = (): Value => ({\n\ttag: \"constructor\",\n\tname: \"True\",\n\targs: [],\n});\n\nexport const createFalse = (): Value => ({\n\ttag: \"constructor\",\n\tname: \"False\",\n\targs: [],\n});\n\nexport const createBool = (value: boolean): Value =>\n\tcreateConstructor(value ? \"True\" : \"False\", []);\n\nexport const isBool = (\n\tvalue: Value,\n): value is { tag: \"constructor\"; name: \"True\" | \"False\"; args: [] } =>\n\tvalue.tag === \"constructor\" &&\n\t(value.name === \"True\" || value.name === \"False\");\n\nexport const boolValue = (value: Value): boolean => {\n\tif (value.tag === \"constructor\" && value.name === \"True\") return true;\n\tif (value.tag === \"constructor\" && value.name === \"False\") return false;\n\tthrow new Error(`Expected Bool constructor, got ${value.tag}`);\n};\n\nexport const isList = (\n\tvalue: Value,\n): value is { tag: \"list\"; values: Value[] } => value.tag === \"list\";\n\nexport const createList = (values: Value[]): Value => ({ tag: \"list\", values });\n\nexport const isRecord = (\n\tvalue: Value,\n): value is { tag: \"record\"; fields: { [key: string]: Value } } =>\n\tvalue.tag === \"record\";\n\nexport const createRecord = (fields: { [key: string]: Value }): Value => ({\n\ttag: \"record\",\n\tfields,\n});\n\nexport const isFunction = (\n\tvalue: Value,\n): value is { tag: \"function\"; fn: (...args: Value[]) => Value } =>\n\tvalue.tag === \"function\";\n\nexport const createFunction = (fn: (...args: Value[]) => Value): Value => ({\n\ttag: \"function\",\n\tfn,\n});\n\nexport const isNativeFunction = (\n\tvalue: Value,\n): value is { tag: \"native\"; name: string; fn: (...args: Value[]) => Value } =>\n\tvalue.tag === \"native\";\n\nexport const createNativeFunction = (name: string, fn: any): Value => {\n\tconst wrap = (fn: any, curriedName: string): Value => ({\n\t\ttag: \"native\",\n\t\tname: curriedName,\n\t\tfn: (...args: Value[]) => {\n\t\t\tconst result = fn(...args);\n\t\t\tif (typeof result === \"function\") {\n\t\t\t\treturn wrap(result, curriedName + \"_curried\");\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t});\n\treturn wrap(fn, name);\n};\n\nexport const isTuple = (\n\tvalue: Value,\n): value is { tag: \"tuple\"; values: Value[] } => value.tag === \"tuple\";\n\nexport const createTuple = (values: Value[]): Value => ({\n\ttag: \"tuple\",\n\tvalues,\n});\n\nexport const isUnit = (value: Value): value is { tag: \"unit\" } =>\n\tvalue.tag === \"unit\";\n\nexport const createUnit = (): Value => ({ tag: \"unit\" });\n\nexport const isConstructor = (\n\tvalue: Value,\n): value is { tag: \"constructor\"; name: string; args: Value[] } =>\n\tvalue.tag === \"constructor\";\n\nexport const createConstructor = (name: string, args: Value[]): Value => ({\n\ttag: \"constructor\",\n\tname,\n\targs,\n});\n\nexport type ExecutionStep = {\n\texpression: string;\n\tresult: Value;\n\ttype?: string;\n\tlocation?: { line: number; column: number };\n};\n\nexport type ProgramResult = {\n\tfinalResult: Value;\n\texecutionTrace: ExecutionStep[];\n\tenvironment: Map<string, Value>;\n};\n\nexport type Environment = Map<string, Value | Cell>;\n\n// Helper to flatten semicolon-separated binary expressions into individual statements\nconst flattenStatements = (expr: Expression): Expression[] => {\n\tif (expr.kind === \"binary\" && expr.operator === \";\") {\n\t\treturn [...flattenStatements(expr.left), ...flattenStatements(expr.right)];\n\t}\n\treturn [expr];\n};\n\nexport class Evaluator {\n\t\tpublic environment: Environment;\n\t\tprivate environmentStack: Environment[]; // Stack for efficient scoping\n\t\tprivate currentFileDir?: string; // Track the directory of the current file being evaluated\n\t\tprivate fs: typeof defaultFs;\n\t\tprivate path: typeof defaultPath;\n\n\t\tconstructor(opts?: {\n\t\t\tfs?: typeof defaultFs;\n\t\t\tpath?: typeof defaultPath;\n\t\t}) {\n\t\t\tthis.fs = opts?.fs ?? defaultFs;\n\t\t\tthis.path = opts?.path ?? defaultPath;\n\t\t\tthis.environment = new Map();\n\t\t\tthis.environmentStack = [];\n\t\t\tthis.initializeBuiltins();\n\t\t\tthis.loadStdlib();\n\t\t}\n\n\t\tprivate initializeBuiltins(): void {\n\t\t\t// Arithmetic operations\n\t\t\tthis.environment.set(\n\t\t\t\t'+',\n\t\t\t\tcreateNativeFunction('+', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b))\n\t\t\t\t\t\treturn createNumber(a.value + b.value);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot add ${a?.tag || 'unit'} and ${b?.tag || 'unit'}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'-',\n\t\t\t\tcreateNativeFunction('-', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b))\n\t\t\t\t\t\treturn createNumber(a.value - b.value);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot subtract ${b?.tag || 'unit'} from ${a?.tag || 'unit'}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'*',\n\t\t\t\tcreateNativeFunction('*', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b))\n\t\t\t\t\t\treturn createNumber(a.value * b.value);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot multiply ${a?.tag || 'unit'} and ${b?.tag || 'unit'}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'/',\n\t\t\t\tcreateNativeFunction('/', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) {\n\t\t\t\t\t\tif (b.value === 0) {\n\t\t\t\t\t\t\tconst error = createError(\n\t\t\t\t\t\t\t\t'RuntimeError',\n\t\t\t\t\t\t\t\t'Division by zero',\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t`${a.value} / ${b.value}`,\n\t\t\t\t\t\t\t\t'Check that the divisor is not zero before dividing'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn createNumber(a.value / b.value);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot divide ${a?.tag || 'unit'} by ${b?.tag || 'unit'}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Comparison operations\n\t\t\tthis.environment.set(\n\t\t\t\t'==',\n\t\t\t\tcreateNativeFunction('==', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) {\n\t\t\t\t\t\treturn createBool(a.value === b.value);\n\t\t\t\t\t} else if (isString(a) && isString(b)) {\n\t\t\t\t\t\treturn createBool(a.value === b.value);\n\t\t\t\t\t} else if (isBool(a) && isBool(b)) {\n\t\t\t\t\t\treturn createBool(boolValue(a) === boolValue(b));\n\t\t\t\t\t} else if (isUnit(a) && isUnit(b)) {\n\t\t\t\t\t\treturn createTrue();\n\t\t\t\t\t} else if (isUnit(a) || isUnit(b)) {\n\t\t\t\t\t\treturn createFalse();\n\t\t\t\t\t}\n\t\t\t\t\treturn createFalse();\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'!=',\n\t\t\t\tcreateNativeFunction('!=', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) {\n\t\t\t\t\t\treturn createBool(a.value !== b.value);\n\t\t\t\t\t} else if (isString(a) && isString(b)) {\n\t\t\t\t\t\treturn createBool(a.value !== b.value);\n\t\t\t\t\t} else if (isBool(a) && isBool(b)) {\n\t\t\t\t\t\treturn createBool(boolValue(a) !== boolValue(b));\n\t\t\t\t\t} else if (isUnit(a) && isUnit(b)) {\n\t\t\t\t\t\treturn createFalse();\n\t\t\t\t\t} else if (isUnit(a) || isUnit(b)) {\n\t\t\t\t\t\treturn createTrue();\n\t\t\t\t\t}\n\t\t\t\t\treturn createTrue();\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'<',\n\t\t\t\tcreateNativeFunction('<', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) return createBool(a.value < b.value);\n\t\t\t\t\tthrow new Error(`Cannot compare ${typeof a} and ${typeof b}`);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'>',\n\t\t\t\tcreateNativeFunction('>', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) return createBool(a.value > b.value);\n\t\t\t\t\tthrow new Error(`Cannot compare ${typeof a} and ${typeof b}`);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'<=',\n\t\t\t\tcreateNativeFunction('<=', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) return createBool(a.value <= b.value);\n\t\t\t\t\tthrow new Error(`Cannot compare ${typeof a} and ${typeof b}`);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'>=',\n\t\t\t\tcreateNativeFunction('>=', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) return createBool(a.value >= b.value);\n\t\t\t\t\tthrow new Error(`Cannot compare ${typeof a} and ${typeof b}`);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Pipeline operator\n\t\t\tthis.environment.set(\n\t\t\t\t'|',\n\t\t\t\tcreateNativeFunction('|', (value: Value) => (func: Value) => {\n\t\t\t\t\tif (isFunction(func)) return func.fn(value);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot apply non-function in thrush: ${func?.tag || 'unit'}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Left-to-right composition\n\t\t\tthis.environment.set(\n\t\t\t\t'|>',\n\t\t\t\tcreateNativeFunction('|>', (f: Value) => (g: Value) => {\n\t\t\t\t\tif (isFunction(f) && isFunction(g)) {\n\t\t\t\t\t\treturn createFunction((x: Value) => g.fn(f.fn(x)));\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot compose non-functions: ${f?.tag || 'unit'} and ${\n\t\t\t\t\t\t\tg?.tag || 'unit'\n\t\t\t\t\t\t}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Right-to-left composition\n\t\t\tthis.environment.set(\n\t\t\t\t'<|',\n\t\t\t\tcreateNativeFunction('<|', (f: Value) => (g: Value) => {\n\t\t\t\t\tif (isFunction(f) && isFunction(g)) {\n\t\t\t\t\t\treturn createFunction((x: Value) => f.fn(g.fn(x)));\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot compose non-functions: ${f?.tag || 'unit'} and ${\n\t\t\t\t\t\t\tg?.tag || 'unit'\n\t\t\t\t\t\t}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Semicolon operator\n\t\t\tthis.environment.set(\n\t\t\t\t';',\n\t\t\t\tcreateNativeFunction(';', (_left: Value) => (right: Value) => right)\n\t\t\t);\n\n\t\t\t// Dollar operator (low precedence function application)\n\t\t\tthis.environment.set(\n\t\t\t\t'$',\n\t\t\t\tcreateNativeFunction('$', (func: Value) => (arg: Value) => {\n\t\t\t\t\tif (isFunction(func)) return func.fn(arg);\n\t\t\t\t\tif (isNativeFunction(func)) return func.fn(arg);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot apply non-function in dollar operator: ${\n\t\t\t\t\t\t\tfunc?.tag || 'unit'\n\t\t\t\t\t\t}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// List operations - minimal built-ins for self-hosted functions\n\t\t\tthis.environment.set(\n\t\t\t\t'list_get',\n\t\t\t\tcreateNativeFunction('list_get', (index: Value) => (list: Value) => {\n\t\t\t\t\tif (isNumber(index) && isList(list)) {\n\t\t\t\t\t\tconst idx = index.value;\n\t\t\t\t\t\tif (idx >= 0 && idx < list.values.length) {\n\t\t\t\t\t\t\treturn list.values[idx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('list_get: invalid index or not a list');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// List operations\n\t\t\tthis.environment.set(\n\t\t\t\t'tail',\n\t\t\t\tcreateNativeFunction('tail', (list: Value) => {\n\t\t\t\t\tif (isList(list) && list.values.length > 0)\n\t\t\t\t\t\treturn createList(list.values.slice(1));\n\t\t\t\t\tthrow new Error('Cannot get tail of empty list or non-list');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'cons',\n\t\t\t\tcreateNativeFunction('cons', (head: Value) => (tail: Value) => {\n\t\t\t\t\tif (isList(tail)) return createList([head, ...tail.values]);\n\t\t\t\t\tthrow new Error('Second argument to cons must be a list');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// List utility functions\n\t\t\tthis.environment.set(\n\t\t\t\t'map',\n\t\t\t\tcreateNativeFunction('map', (func: Value) => (list: Value) => {\n\t\t\t\t\tif (isFunction(func) && isList(list)) {\n\t\t\t\t\t\treturn createList(list.values.map((item: Value) => func.fn(item)));\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('map requires a function and a list');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'filter',\n\t\t\t\tcreateNativeFunction('filter', (pred: Value) => (list: Value) => {\n\t\t\t\t\tif (isFunction(pred) && isList(list)) {\n\t\t\t\t\t\treturn createList(\n\t\t\t\t\t\t\tlist.values.filter((item: Value) => {\n\t\t\t\t\t\t\t\tconst result = pred.fn(item);\n\t\t\t\t\t\t\t\tif (isBool(result)) {\n\t\t\t\t\t\t\t\t\treturn boolValue(result);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// For non-boolean results, treat as truthy/falsy\n\t\t\t\t\t\t\t\treturn !isUnit(result);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('filter requires a predicate function and a list');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'reduce',\n\t\t\t\tcreateNativeFunction(\n\t\t\t\t\t'reduce',\n\t\t\t\t\t(func: Value) => (initial: Value) => (list: Value) => {\n\t\t\t\t\t\tif (isFunction(func) && isList(list)) {\n\t\t\t\t\t\t\treturn list.values.reduce((acc: Value, item: Value) => {\n\t\t\t\t\t\t\t\tconst partial = func.fn(acc);\n\t\t\t\t\t\t\t\tif (isFunction(partial)) {\n\t\t\t\t\t\t\t\t\treturn partial.fn(item);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t'reduce function must return a function after first argument'\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}, initial);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'reduce requires a function, initial value, and a list'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'length',\n\t\t\t\tcreateNativeFunction('length', (list: Value) => {\n\t\t\t\t\tif (isList(list)) return createNumber(list.values.length);\n\t\t\t\t\tthrow new Error('length requires a list');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'isEmpty',\n\t\t\t\tcreateNativeFunction('isEmpty', (list: Value) => {\n\t\t\t\t\tif (isList(list)) return createBool(list.values.length === 0);\n\t\t\t\t\tthrow new Error('isEmpty requires a list');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'append',\n\t\t\t\tcreateNativeFunction('append', (list1: Value) => (list2: Value) => {\n\t\t\t\t\tif (isList(list1) && isList(list2))\n\t\t\t\t\t\treturn createList([...list1.values, ...list2.values]);\n\t\t\t\t\tthrow new Error('append requires two lists');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Math utilities\n\t\t\tthis.environment.set(\n\t\t\t\t'abs',\n\t\t\t\tcreateNativeFunction('abs', (n: Value) => {\n\t\t\t\t\tif (isNumber(n)) return createNumber(Math.abs(n.value));\n\t\t\t\t\tthrow new Error('abs requires a number');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'max',\n\t\t\t\tcreateNativeFunction('max', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b))\n\t\t\t\t\t\treturn createNumber(Math.max(a.value, b.value));\n\t\t\t\t\tthrow new Error('max requires two numbers');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'min',\n\t\t\t\tcreateNativeFunction('min', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b))\n\t\t\t\t\t\treturn createNumber(Math.min(a.value, b.value));\n\t\t\t\t\tthrow new Error('min requires two numbers');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Effectful functions\n\t\t\tthis.environment.set(\n\t\t\t\t'print',\n\t\t\t\tcreateNativeFunction('print', (value: Value) => {\n\t\t\t\t\tconsole.log(formatValue(value));\n\t\t\t\t\treturn value; // Return the value that was printed\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// String utilities\n\t\t\tthis.environment.set(\n\t\t\t\t'concat',\n\t\t\t\tcreateNativeFunction('concat', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isString(a) && isString(b))\n\t\t\t\t\t\treturn createString(a.value + b.value);\n\t\t\t\t\tthrow new Error('concat requires two strings');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'toString',\n\t\t\t\tcreateNativeFunction('toString', (value: Value) =>\n\t\t\t\t\tcreateString(valueToString(value))\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// Record utilities\n\t\t\tthis.environment.set(\n\t\t\t\t'hasKey',\n\t\t\t\tcreateNativeFunction('hasKey', (record: Value) => (key: Value) => {\n\t\t\t\t\tif (isRecord(record) && isString(key)) {\n\t\t\t\t\t\treturn createBool(key.value in record.fields);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('hasKey requires a record and a string key');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'hasValue',\n\t\t\t\tcreateNativeFunction('hasValue', (record: Value) => (value: Value) => {\n\t\t\t\t\tif (isRecord(record)) {\n\t\t\t\t\t\treturn createBool(Object.values(record.fields).includes(value));\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('hasValue requires a record');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'set',\n\t\t\t\tcreateNativeFunction(\n\t\t\t\t\t'set',\n\t\t\t\t\t(accessor: Value) => (record: Value) => (newValue: Value) => {\n\t\t\t\t\t\tif (isNativeFunction(accessor) && isRecord(record)) {\n\t\t\t\t\t\t\t// For now, just handle simple field accessors\n\t\t\t\t\t\t\tconst field = accessor.name?.replace('@', '');\n\t\t\t\t\t\t\tif (field) {\n\t\t\t\t\t\t\t\treturn createRecord({ ...record.fields, [field]: newValue });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new Error('set requires an accessor, record, and new value');\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// Tuple operations\n\t\t\tthis.environment.set(\n\t\t\t\t'tupleLength',\n\t\t\t\tcreateNativeFunction('tupleLength', (tuple: Value) => {\n\t\t\t\t\tif (isTuple(tuple)) {\n\t\t\t\t\t\treturn createNumber(tuple.values.length);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('tupleLength requires a tuple');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'tupleIsEmpty',\n\t\t\t\tcreateNativeFunction('tupleIsEmpty', (tuple: Value) => {\n\t\t\t\t\tif (isTuple(tuple)) {\n\t\t\t\t\t\treturn createBool(tuple.values.length === 0);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('tupleIsEmpty requires a tuple');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Built-in ADT constructors are now self-hosted in stdlib.noo\n\n\t\t\t// Option utility functions\n\t\t\tthis.environment.set(\n\t\t\t\t'isSome',\n\t\t\t\tcreateNativeFunction('isSome', (option: Value) => {\n\t\t\t\t\tif (isConstructor(option) && option.name === 'Some') {\n\t\t\t\t\t\treturn createTrue();\n\t\t\t\t\t} else if (isConstructor(option) && option.name === 'None') {\n\t\t\t\t\t\treturn createFalse();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('isSome requires an Option value');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'isNone',\n\t\t\t\tcreateNativeFunction('isNone', (option: Value) => {\n\t\t\t\t\tif (isConstructor(option) && option.name === 'None') {\n\t\t\t\t\t\treturn createTrue();\n\t\t\t\t\t} else if (isConstructor(option) && option.name === 'Some') {\n\t\t\t\t\t\treturn createFalse();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('isNone requires an Option value');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'unwrap',\n\t\t\t\tcreateNativeFunction('unwrap', (option: Value) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tisConstructor(option) &&\n\t\t\t\t\t\toption.name === 'Some' &&\n\t\t\t\t\t\toption.args.length === 1\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn option.args[0];\n\t\t\t\t\t} else if (isConstructor(option) && option.name === 'None') {\n\t\t\t\t\t\tthrow new Error('Cannot unwrap None value');\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('unwrap requires a Some value');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Result utility functions\n\t\t\tthis.environment.set(\n\t\t\t\t'isOk',\n\t\t\t\tcreateNativeFunction('isOk', (result: Value) => {\n\t\t\t\t\tif (isConstructor(result) && result.name === 'Ok') {\n\t\t\t\t\t\treturn createTrue();\n\t\t\t\t\t} else if (isConstructor(result) && result.name === 'Err') {\n\t\t\t\t\t\treturn createFalse();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('isOk requires a Result value');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'isErr',\n\t\t\t\tcreateNativeFunction('isErr', (result: Value) => {\n\t\t\t\t\tif (isConstructor(result) && result.name === 'Err') {\n\t\t\t\t\t\treturn createTrue();\n\t\t\t\t\t} else if (isConstructor(result) && result.name === 'Ok') {\n\t\t\t\t\t\treturn createFalse();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('isErr requires a Result value');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Missing builtin implementations\n\t\t\tthis.environment.set(\n\t\t\t\t'println',\n\t\t\t\tcreateNativeFunction('println', (value: Value) => {\n\t\t\t\t\tconsole.log(valueToString(value));\n\t\t\t\t\treturn value;\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'readFile',\n\t\t\t\tcreateNativeFunction('readFile', (path: Value) => {\n\t\t\t\t\tif (!isString(path)) {\n\t\t\t\t\t\tthrow new Error('readFile requires a string path');\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst content = this.fs.readFileSync(path.value, 'utf-8');\n\t\t\t\t\t\treturn createString(content);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthrow new Error(`Failed to read file: ${error}`);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'writeFile',\n\t\t\t\tcreateNativeFunction('writeFile', (path: Value) => (content: Value) => {\n\t\t\t\t\tif (!isString(path)) {\n\t\t\t\t\t\tthrow new Error('writeFile requires a string path');\n\t\t\t\t\t}\n\t\t\t\t\tif (!isString(content)) {\n\t\t\t\t\t\tthrow new Error('writeFile requires string content');\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.fs.writeFileSync(path.value, content.value);\n\t\t\t\t\t\treturn createUnit();\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthrow new Error(`Failed to write file: ${error}`);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'log',\n\t\t\t\tcreateNativeFunction('log', (message: Value) => {\n\t\t\t\t\tif (!isString(message)) {\n\t\t\t\t\t\tthrow new Error('log requires a string message');\n\t\t\t\t\t}\n\t\t\t\t\tconsole.log(`[LOG] ${message.value}`);\n\t\t\t\t\treturn createUnit();\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'random',\n\t\t\t\tcreateNativeFunction('random', () => {\n\t\t\t\t\treturn createNumber(\n\t\t\t\t\t\tMath.floor(Math.random() * Number.MAX_SAFE_INTEGER)\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'randomRange',\n\t\t\t\tcreateNativeFunction('randomRange', (min: Value) => (max: Value) => {\n\t\t\t\t\tif (!isNumber(min) || !isNumber(max)) {\n\t\t\t\t\t\tthrow new Error('randomRange requires number arguments');\n\t\t\t\t\t}\n\t\t\t\t\tconst minVal = Math.min(min.value, max.value);\n\t\t\t\t\tconst maxVal = Math.max(min.value, max.value);\n\t\t\t\t\treturn createNumber(\n\t\t\t\t\t\tMath.floor(Math.random() * (maxVal - minVal + 1)) + minVal\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'mutSet',\n\t\t\t\tcreateNativeFunction('mutSet', (ref: Value) => (value: Value) => {\n\t\t\t\t\tif (!isCell(ref)) {\n\t\t\t\t\t\tthrow new Error('mutSet requires a mutable reference');\n\t\t\t\t\t}\n\t\t\t\t\tref.value = value;\n\t\t\t\t\treturn createUnit();\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'mutGet',\n\t\t\t\tcreateNativeFunction('mutGet', (ref: Value) => {\n\t\t\t\t\tif (!isCell(ref)) {\n\t\t\t\t\t\tthrow new Error('mutGet requires a mutable reference');\n\t\t\t\t\t}\n\t\t\t\t\treturn ref.value;\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\tprivate loadStdlib(): void {\n\t\t\t// Try multiple possible paths for stdlib.noo\n\t\t\tconst possiblePaths = [\n\t\t\t\tthis.path.join(__dirname, '..', 'stdlib.noo'),\n\t\t\t\tthis.path.join(process.cwd(), 'stdlib.noo'),\n\t\t\t\tthis.path.join(process.cwd(), 'src', '..', 'stdlib.noo'),\n\t\t\t];\n\n\n\n\t\t\tlet stdlibPath: string | null = null;\n\t\t\tfor (const path of possiblePaths) {\n\t\t\t\tif (this.fs.existsSync(path)) {\n\t\t\t\t\tstdlibPath = path;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!stdlibPath) {\n\t\t\t\tconst msg = `[Noolang ERROR] Could not find stdlib.noo in any of these paths:\\n  ${possiblePaths.join(\n\t\t\t\t\t'\\n  '\n\t\t\t\t)}`;\n\t\t\t\tconsole.error(msg);\n\t\t\t\tthrow new Error(msg);\n\t\t\t}\n\t\t\tconst stdlibContent = this.fs.readFileSync(stdlibPath, 'utf-8');\n\t\t\tconst lexer = new Lexer(stdlibContent);\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tconst stdlibProgram = parse(tokens);\n\t\t\tconst allStatements: Expression[] = [];\n\t\t\tfor (const statement of stdlibProgram.statements) {\n\t\t\t\tallStatements.push(...flattenStatements(statement));\n\t\t\t}\n\t\t\tfor (const statement of allStatements) {\n\t\t\t\tthis.evaluateExpression(statement);\n\t\t\t}\n\t\t}\n\n\t\tevaluateProgram(program: Program, filePath?: string): ProgramResult {\n\t\t\tif (filePath) {\n\t\t\t\tthis.currentFileDir = this.path.dirname(this.path.resolve(filePath));\n\t\t\t}\n\n\t\t\tconst executionTrace: ExecutionStep[] = [];\n\n\t\t\tif (program.statements.length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tfinalResult: createList([]),\n\t\t\t\t\texecutionTrace,\n\t\t\t\t\tenvironment: new Map(\n\t\t\t\t\t\tArray.from(this.environment.entries()).map(([k, v]) => [\n\t\t\t\t\t\t\tk,\n\t\t\t\t\t\t\tisCell(v) ? v.value : v,\n\t\t\t\t\t\t]),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tlet finalResult: Value = createList([]);\n\n\t\t\tfor (const statement of program.statements) {\n\t\t\t\tconst result = this.evaluateExpression(statement);\n\n\t\t\t\t// Add to execution trace\n\t\t\t\texecutionTrace.push({\n\t\t\t\t\texpression: this.expressionToString(statement),\n\t\t\t\t\tresult: result,\n\t\t\t\t\tlocation: {\n\t\t\t\t\t\tline: statement.location.start.line,\n\t\t\t\t\t\tcolumn: statement.location.start.column,\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tfinalResult = result;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tfinalResult,\n\t\t\t\texecutionTrace,\n\t\t\t\tenvironment: new Map(\n\t\t\t\t\tArray.from(this.environment.entries()).map(([k, v]) => [\n\t\t\t\t\t\tk,\n\t\t\t\t\t\tisCell(v) ? v.value : v,\n\t\t\t\t\t]),\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\n\t\tprivate evaluateDefinition(def: DefinitionExpression): Value {\n\t\t\t// Check if this definition might be recursive by looking for the name in the value\n\t\t\tconst isRecursive = this.containsVariable(def.value, def.name);\n\n\t\t\tif (isRecursive) {\n\t\t\t\t// For recursive definitions, we need a placeholder that gets updated\n\t\t\t\tconst cell = createCell(createUnit());\n\t\t\t\tthis.environment.set(def.name, cell);\n\t\t\t\tconst value = this.evaluateExpression(def.value);\n\t\t\t\tcell.value = value;\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\t// For non-recursive definitions, store the value directly\n\t\t\t\tconst value = this.evaluateExpression(def.value);\n\t\t\t\tthis.environment.set(def.name, value);\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluateMutableDefinition(\n\t\t\texpr: MutableDefinitionExpression,\n\t\t): Value {\n\t\t\t// Evaluate the right-hand side\n\t\t\tconst value = this.evaluateExpression(expr.value);\n\t\t\t// Store a cell in the environment\n\t\t\tthis.environment.set(expr.name, createCell(value));\n\t\t\treturn value;\n\t\t}\n\n\t\tprivate evaluateMutation(expr: MutationExpression): Value {\n\t\t\t// Look up the variable in the environment\n\t\t\tconst cell = this.environment.get(expr.target);\n\t\t\tif (!isCell(cell)) {\n\t\t\t\tthrow new Error(`Cannot mutate non-mutable variable: ${expr.target}`);\n\t\t\t}\n\t\t\t// Evaluate the new value\n\t\t\tconst value = this.evaluateExpression(expr.value);\n\t\t\t// Update the cell's value\n\t\t\tcell.value = value;\n\t\t\treturn value;\n\t\t}\n\n\t\tevaluateExpression(expr: Expression): Value {\n\t\t\tswitch (expr.kind) {\n\t\t\t\tcase \"literal\":\n\t\t\t\t\treturn this.evaluateLiteral(expr);\n\n\t\t\t\tcase \"variable\":\n\t\t\t\t\treturn this.evaluateVariable(expr);\n\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn this.evaluateFunction(expr);\n\n\t\t\t\tcase \"application\":\n\t\t\t\t\treturn this.evaluateApplication(expr);\n\n\t\t\t\tcase \"pipeline\":\n\t\t\t\t\treturn this.evaluatePipeline(expr);\n\n\t\t\t\tcase \"binary\":\n\t\t\t\t\treturn this.evaluateBinary(expr);\n\n\t\t\t\tcase \"if\":\n\t\t\t\t\treturn this.evaluateIf(expr);\n\n\t\t\t\tcase \"definition\":\n\t\t\t\t\treturn this.evaluateDefinition(expr);\n\n\t\t\t\tcase \"mutable-definition\":\n\t\t\t\t\treturn this.evaluateMutableDefinition(expr);\n\n\t\t\t\tcase \"mutation\":\n\t\t\t\t\treturn this.evaluateMutation(expr);\n\n\t\t\t\tcase \"import\":\n\t\t\t\t\treturn this.evaluateImport(expr);\n\n\t\t\t\tcase \"record\":\n\t\t\t\t\treturn this.evaluateRecord(expr);\n\n\t\t\t\tcase \"accessor\":\n\t\t\t\t\treturn this.evaluateAccessor(expr);\n\n\t\t\t\tcase \"tuple\": {\n\t\t\t\t\t// Evaluate all elements and return a tagged tuple value\n\t\t\t\t\tconst elements = expr.elements.map((e) => {\n\t\t\t\t\t\tlet val = this.evaluateExpression(e);\n\t\t\t\t\t\tif (isCell(val)) val = val.value;\n\t\t\t\t\t\treturn val;\n\t\t\t\t\t});\n\t\t\t\t\treturn createTuple(elements);\n\t\t\t\t}\n\t\t\t\tcase \"unit\": {\n\t\t\t\t\t// Return unit value\n\t\t\t\t\treturn createUnit();\n\t\t\t\t}\n\t\t\t\tcase \"list\": {\n\t\t\t\t\t// Evaluate all elements and return a tagged list value\n\t\t\t\t\tconst elements = expr.elements.map((e) => {\n\t\t\t\t\t\tlet val = this.evaluateExpression(e);\n\t\t\t\t\t\tif (isCell(val)) val = val.value;\n\t\t\t\t\t\treturn val;\n\t\t\t\t\t});\n\t\t\t\t\treturn createList(elements);\n\t\t\t\t}\n\t\t\t\tcase \"where\": {\n\t\t\t\t\treturn this.evaluateWhere(expr);\n\t\t\t\t}\n\t\t\t\tcase \"typed\":\n\t\t\t\t\t// Type annotations are erased at runtime; just evaluate the inner expression\n\t\t\t\t\treturn this.evaluateExpression(expr.expression);\n\t\t\t\tcase \"constrained\":\n\t\t\t\t\t// Constraint annotations are erased at runtime; just evaluate the inner expression\n\t\t\t\t\treturn this.evaluateExpression(expr.expression);\n\t\t\t\tcase \"type-definition\":\n\t\t\t\t\treturn this.evaluateTypeDefinition(expr as TypeDefinitionExpression);\n\t\t\t\tcase \"match\":\n\t\t\t\t\treturn this.evaluateMatch(expr as MatchExpression);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unknown expression kind: ${(expr as Expression).kind}`,\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluateLiteral(expr: LiteralExpression): Value {\n\t\t\tif (Array.isArray(expr.value)) {\n\t\t\t\t// If it's a list, evaluate each element\n\t\t\t\treturn createList(\n\t\t\t\t\texpr.value.map((element) => {\n\t\t\t\t\t\tif (element && typeof element === \"object\" && \"kind\" in element) {\n\t\t\t\t\t\t\t// It's an AST node, evaluate it\n\t\t\t\t\t\t\treturn this.evaluateExpression(element as Expression);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// It's already a value\n\t\t\t\t\t\t\treturn element;\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert primitive values to tagged values\n\t\t\tif (typeof expr.value === \"number\") {\n\t\t\t\treturn createNumber(expr.value);\n\t\t\t} else if (typeof expr.value === \"string\") {\n\t\t\t\treturn createString(expr.value);\n\t\t\t} else if (expr.value === null) {\n\t\t\t\t// Handle unit literals (null in AST represents unit)\n\t\t\t\treturn createUnit();\n\t\t\t}\n\n\t\t\t// Should not reach here anymore since we removed boolean literals\n\t\t\tthrow new Error(`Unsupported literal value: ${expr.value}`);\n\t\t}\n\n\t\tprivate evaluateVariable(expr: VariableExpression): Value {\n\t\t\tconst value = this.environment.get(expr.name);\n\t\t\tif (value === undefined) {\n\t\t\t\tconst error = createError(\n\t\t\t\t\t\"RuntimeError\",\n\t\t\t\t\t`Undefined variable: ${expr.name}`,\n\t\t\t\t\t{\n\t\t\t\t\t\tline: expr.location.start.line,\n\t\t\t\t\t\tcolumn: expr.location.start.column,\n\t\t\t\t\t\tstart: expr.location.start.line,\n\t\t\t\t\t\tend: expr.location.end.line,\n\t\t\t\t\t},\n\t\t\t\t\texpr.name,\n\t\t\t\t\t`Define the variable before using it: ${expr.name} = value`,\n\t\t\t\t);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\t// If it's a cell, return its value\n\t\t\tif (isCell(value)) {\n\t\t\t\treturn value.value;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tprivate evaluateFunction(expr: FunctionExpression): Value {\n\t\t\tconst self = this;\n\t\t\t// Create a closure that captures the current environment\n\t\t\tconst closureEnv = new Map(this.environment);\n\n\t\t\tfunction createCurriedFunction(\n\t\t\t\tparams: string[],\n\t\t\t\tbody: Expression,\n\t\t\t): Value {\n\t\t\t\treturn createFunction((arg: Value) => {\n\t\t\t\t\t// Create a new environment for this function call\n\t\t\t\t\tconst callEnv = new Map(closureEnv);\n\n\t\t\t\t\t// Set the parameter in the call environment\n\t\t\t\t\tconst param = params[0];\n\t\t\t\t\tcallEnv.set(param, arg);\n\n\t\t\t\t\tlet result: Value;\n\t\t\t\t\tif (params.length === 1) {\n\t\t\t\t\t\t// Use environment stacking for efficient scoping\n\t\t\t\t\t\tresult = self.withNewEnvironment(() => {\n\t\t\t\t\t\t\tself.environment = callEnv;\n\t\t\t\t\t\t\treturn self.evaluateExpression(body);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Create a function that captures the current parameter\n\t\t\t\t\t\tconst remainingParams = params.slice(1);\n\n\t\t\t\t\t\tconst nextFunction = createFunction((nextArg: Value) => {\n\t\t\t\t\t\t\tconst nextCallEnv = new Map(callEnv);\n\t\t\t\t\t\t\tnextCallEnv.set(remainingParams[0], nextArg);\n\n\t\t\t\t\t\t\tif (remainingParams.length === 1) {\n\t\t\t\t\t\t\t\treturn self.withNewEnvironment(() => {\n\t\t\t\t\t\t\t\t\tself.environment = nextCallEnv;\n\t\t\t\t\t\t\t\t\treturn self.evaluateExpression(body);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Continue currying for remaining parameters\n\t\t\t\t\t\t\t\tconst remainingFunction = self.withNewEnvironment(() => {\n\t\t\t\t\t\t\t\t\tself.environment = nextCallEnv;\n\t\t\t\t\t\t\t\t\treturn self.evaluateFunction({\n\t\t\t\t\t\t\t\t\t\t...expr,\n\t\t\t\t\t\t\t\t\t\tparams: remainingParams,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif (isFunction(remainingFunction)) {\n\t\t\t\t\t\t\t\t\treturn remainingFunction.fn(nextArg);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t`Expected function but got: ${typeof remainingFunction}`,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tresult = nextFunction;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn createCurriedFunction(expr.params, expr.body);\n\t\t}\n\n\t\tprivate evaluateApplication(expr: ApplicationExpression): Value {\n\t\t\tconst func = this.evaluateExpression(expr.func);\n\n\t\t\t// Only apply the function to the arguments present in the AST\n\t\t\tconst args = expr.args;\n\n\t\t\tif (isFunction(func)) {\n\t\t\t\t// Handle tagged function application\n\t\t\t\tlet result: any = func.fn;\n\n\t\t\t\tfor (const argExpr of args) {\n\t\t\t\t\tlet arg = this.evaluateExpression(argExpr);\n\t\t\t\t\tif (isCell(arg)) arg = arg.value;\n\t\t\t\t\tif (typeof result === \"function\") {\n\t\t\t\t\t\tresult = result(arg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Cannot apply argument to non-function: ${typeof result}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t} else if (isNativeFunction(func)) {\n\t\t\t\t// Handle native function application\n\t\t\t\tlet result: any = func.fn;\n\n\t\t\t\tfor (const argExpr of args) {\n\t\t\t\t\tlet arg = this.evaluateExpression(argExpr);\n\t\t\t\t\tif (isCell(arg)) arg = arg.value;\n\t\t\t\t\tif (typeof result === \"function\") {\n\t\t\t\t\t\tresult = result(arg);\n\t\t\t\t\t} else if (isFunction(result)) {\n\t\t\t\t\t\tresult = result.fn(arg);\n\t\t\t\t\t} else if (isNativeFunction(result)) {\n\t\t\t\t\t\tresult = result.fn(arg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Cannot apply argument to non-function: ${typeof result}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Cannot apply non-function: ${typeof func} (${func?.tag || \"unknown\"})`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluatePipeline(expr: PipelineExpression): Value {\n\t\t\t// Pipeline should be function composition, not function application\n\t\t\t// For a pipeline like f |> g |> h, we want to compose them as h(g(f(x)))\n\n\t\t\tif (expr.steps.length === 1) {\n\t\t\t\treturn this.evaluateExpression(expr.steps[0]);\n\t\t\t}\n\n\t\t\t// Start with the first function\n\t\t\tlet composed = this.evaluateExpression(expr.steps[0]);\n\n\t\t\t// Compose with each subsequent function\n\t\t\tfor (let i = 1; i < expr.steps.length; i++) {\n\t\t\t\tconst nextFunc = this.evaluateExpression(expr.steps[i]);\n\n\t\t\t\tif (isFunction(composed) && isFunction(nextFunc)) {\n\t\t\t\t\t// Compose: nextFunc(composed(x))\n\t\t\t\t\tconst composedFn = composed as {\n\t\t\t\t\t\ttag: \"function\";\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tconst nextFuncFn = nextFunc as {\n\t\t\t\t\t\ttag: \"function\";\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tcomposed = createFunction((x: Value) =>\n\t\t\t\t\t\tnextFuncFn.fn(composedFn.fn(x)),\n\t\t\t\t\t);\n\t\t\t\t} else if (isNativeFunction(composed) && isNativeFunction(nextFunc)) {\n\t\t\t\t\t// Compose: nextFunc(composed(x))\n\t\t\t\t\tconst composedFn = composed as {\n\t\t\t\t\t\ttag: \"native\";\n\t\t\t\t\t\tname: string;\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tconst nextFuncFn = nextFunc as {\n\t\t\t\t\t\ttag: \"native\";\n\t\t\t\t\t\tname: string;\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tcomposed = createFunction((x: Value) =>\n\t\t\t\t\t\tnextFuncFn.fn(composedFn.fn(x)),\n\t\t\t\t\t);\n\t\t\t\t} else if (isFunction(composed) && isNativeFunction(nextFunc)) {\n\t\t\t\t\t// Compose: nextFunc(composed(x))\n\t\t\t\t\tconst composedFn = composed as {\n\t\t\t\t\t\ttag: \"function\";\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tconst nextFuncFn = nextFunc as {\n\t\t\t\t\t\ttag: \"native\";\n\t\t\t\t\t\tname: string;\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tcomposed = createFunction((x: Value) =>\n\t\t\t\t\t\tnextFuncFn.fn(composedFn.fn(x)),\n\t\t\t\t\t);\n\t\t\t\t} else if (isNativeFunction(composed) && isFunction(nextFunc)) {\n\t\t\t\t\t// Compose: nextFunc(composed(x))\n\t\t\t\t\tconst composedFn = composed as {\n\t\t\t\t\t\ttag: \"native\";\n\t\t\t\t\t\tname: string;\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tconst nextFuncFn = nextFunc as {\n\t\t\t\t\t\ttag: \"function\";\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tcomposed = createFunction((x: Value) =>\n\t\t\t\t\t\tnextFuncFn.fn(composedFn.fn(x)),\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot compose non-functions in pipeline: ${valueToString(\n\t\t\t\t\t\t\tcomposed,\n\t\t\t\t\t\t)} and ${valueToString(nextFunc)}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn composed;\n\t\t}\n\n\t\tprivate evaluateBinary(expr: BinaryExpression): Value {\n\t\t\tif (expr.operator === ';') {\n\t\t\t\t// Handle semicolon operator (sequence)\n\t\t\t\t// Evaluate left expression and discard result\n\t\t\t\tthis.evaluateExpression(expr.left);\n\t\t\t\t// Evaluate and return right expression\n\t\t\t\treturn this.evaluateExpression(expr.right);\n\t\t\t} else if (expr.operator === '|') {\n\t\t\t\t// Handle thrush operator\n\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\n\t\t\t\tif (isFunction(right)) {\n\t\t\t\t\treturn right.fn(left);\n\t\t\t\t} else if (isNativeFunction(right)) {\n\t\t\t\t\treturn right.fn(left);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot apply non-function in thrush: ${valueToString(right)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === '|>') {\n\t\t\t\t// Handle pipeline operator (left-to-right composition)\n\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\n\t\t\t\tif (isFunction(left) && isFunction(right)) {\n\t\t\t\t\t// Left-to-right composition: g(f(x))\n\t\t\t\t\treturn createFunction((x: Value) => right.fn(left.fn(x)));\n\t\t\t\t} else if (isNativeFunction(left) && isNativeFunction(right)) {\n\t\t\t\t\t// Left-to-right composition: g(f(x))\n\t\t\t\t\treturn createFunction((x: Value) => right.fn(left.fn(x)));\n\t\t\t\t} else if (isFunction(left) && isNativeFunction(right)) {\n\t\t\t\t\t// Left-to-right composition: g(f(x))\n\t\t\t\t\treturn createFunction((x: Value) => right.fn(left.fn(x)));\n\t\t\t\t} else if (isNativeFunction(left) && isFunction(right)) {\n\t\t\t\t\t// Left-to-right composition: g(f(x))\n\t\t\t\t\treturn createFunction((x: Value) => right.fn(left.fn(x)));\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot compose non-functions in pipeline: ${valueToString(\n\t\t\t\t\t\t\tleft\n\t\t\t\t\t\t)} and ${valueToString(right)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === '<|') {\n\t\t\t\t// Handle right-to-left composition operator\n\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\n\t\t\t\tif (isFunction(left) && isFunction(right)) {\n\t\t\t\t\t// Right-to-left: f(g(x))\n\t\t\t\t\treturn createFunction((x: Value) => left.fn(right.fn(x)));\n\t\t\t\t} else if (isNativeFunction(left) && isNativeFunction(right)) {\n\t\t\t\t\t// Right-to-left: f(g(x))\n\t\t\t\t\treturn createFunction((x: Value) => left.fn(right.fn(x)));\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot compose non-functions: ${valueToString(\n\t\t\t\t\t\t\tleft\n\t\t\t\t\t\t)} and ${valueToString(right)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Handle other binary operators (arithmetic, comparison, etc.)\n\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\tconst leftVal = isCell(left) ? left.value : left;\n\t\t\t\tconst rightVal = isCell(right) ? right.value : right;\n\n\t\t\t\tconst operator = this.environment.get(expr.operator);\n\t\t\t\tconst operatorVal = isCell(operator) ? operator.value : operator;\n\t\t\t\tif (operatorVal && isNativeFunction(operatorVal)) {\n\t\t\t\t\tconst fn: any = operatorVal.fn(leftVal);\n\t\t\t\t\tif (typeof fn === 'function') {\n\t\t\t\t\t\treturn fn(rightVal);\n\t\t\t\t\t} else if (isFunction(fn)) {\n\t\t\t\t\t\treturn fn.fn(rightVal);\n\t\t\t\t\t} else if (isNativeFunction(fn)) {\n\t\t\t\t\t\treturn fn.fn(rightVal);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Operator ${expr.operator} did not return a function`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(`Unknown operator: ${expr.operator}`);\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluateIf(expr: IfExpression): Value {\n\t\t\tconst condition = this.evaluateExpression(expr.condition);\n\n\t\t\t// Check if condition is truthy - handle tagged boolean values\n\t\t\tlet isTruthy = false;\n\t\t\tif (isBool(condition)) {\n\t\t\t\tisTruthy = boolValue(condition);\n\t\t\t} else if (isNumber(condition)) {\n\t\t\t\tisTruthy = condition.value !== 0;\n\t\t\t} else if (isString(condition)) {\n\t\t\t\tisTruthy = condition.value !== \"\";\n\t\t\t} else if (isUnit(condition)) {\n\t\t\t\tisTruthy = true;\n\t\t\t} else {\n\t\t\t\t// For other types (functions, lists, records), consider them truthy\n\t\t\t\tisTruthy = true;\n\t\t\t}\n\n\t\t\tif (isTruthy) {\n\t\t\t\treturn this.evaluateExpression(expr.then);\n\t\t\t} else {\n\t\t\t\treturn this.evaluateExpression(expr.else);\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluateImport(expr: ImportExpression): Value {\n\t\t\ttry {\n\t\t\t\tconst filePath = expr.path.endsWith(\".noo\")\n\t\t\t\t\t? expr.path\n\t\t\t\t\t: `${expr.path}.noo`;\n\n\t\t\t\tlet fullPath: string;\n\t\t\t\tif (this.path.isAbsolute(filePath)) {\n\t\t\t\t\tfullPath = filePath;\n\t\t\t\t} else if (this.currentFileDir) {\n\t\t\t\t\tfullPath = this.path.resolve(this.currentFileDir, filePath);\n\t\t\t\t} else {\n\t\t\t\t\tfullPath = this.path.resolve(filePath);\n\t\t\t\t}\n\n\t\t\t\tconst content = this.fs.readFileSync(fullPath, \"utf8\");\n\t\t\t\tconst lexer = new Lexer(content);\n\t\t\t\tconst tokens = lexer.tokenize();\n\t\t\t\tconst program = parse(tokens);\n\t\t\t\tconst tempEvaluator = new Evaluator({ fs: this.fs, path: this.path });\n\t\t\t\tconst result = tempEvaluator.evaluateProgram(program, fullPath);\n\t\t\t\treturn result.finalResult;\n\t\t\t} catch (error) {\n\t\t\t\tlet errorMessage: string;\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\terrorMessage = error.message;\n\t\t\t\t\tif (error.stack) {\n\t\t\t\t\t\terrorMessage += \"\\nStack trace:\\n\" + error.stack;\n\t\t\t\t\t}\n\t\t\t\t} else if (typeof error === \"object\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\terrorMessage = JSON.stringify(error, null, 2);\n\t\t\t\t\t} catch (_e) {\n\t\t\t\t\t\terrorMessage = String(error);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrorMessage = String(error);\n\t\t\t\t}\n\t\t\t\tconst cwd = process.cwd();\n\t\t\t\tconst filePath = expr.path.endsWith(\".noo\")\n\t\t\t\t\t? expr.path\n\t\t\t\t\t: `${expr.path}.noo`;\n\n\t\t\t\tlet fullPath: string;\n\t\t\t\tif (this.path.isAbsolute(filePath)) {\n\t\t\t\t\tfullPath = filePath;\n\t\t\t\t} else if (this.currentFileDir) {\n\t\t\t\t\tfullPath = this.path.resolve(this.currentFileDir, filePath);\n\t\t\t\t} else {\n\t\t\t\t\tfullPath = this.path.resolve(filePath);\n\t\t\t\t}\n\n\t\t\t\tconst structuredError = createError(\n\t\t\t\t\t\"ImportError\",\n\t\t\t\t\t`Failed to import '${\n\t\t\t\t\t\texpr.path\n\t\t\t\t\t}': ${errorMessage}\\n  Tried to resolve: ${fullPath}\\n  Current working directory: ${cwd}\\n  Importing file directory: ${\n\t\t\t\t\t\tthis.currentFileDir || \"unknown\"\n\t\t\t\t\t}\\n  Suggestion: Use a path relative to the importing file, e.g., 'math_functions' or '../std/math'`,\n\t\t\t\t\t{\n\t\t\t\t\t\tline: expr.location.start.line,\n\t\t\t\t\t\tcolumn: expr.location.start.column,\n\t\t\t\t\t\tstart: expr.location.start.line,\n\t\t\t\t\t\tend: expr.location.end.line,\n\t\t\t\t\t},\n\t\t\t\t\t`import \"${expr.path}\"`,\n\t\t\t\t\t\"Check that the file exists and can be parsed, and that the path is correct relative to the importing file.\",\n\t\t\t\t);\n\t\t\t\tthrow structuredError;\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluateRecord(expr: RecordExpression): Value {\n\t\t\tconst record: { [key: string]: Value } = {};\n\t\t\tfor (const field of expr.fields) {\n\t\t\t\tlet val = this.evaluateExpression(field.value);\n\t\t\t\tif (isCell(val)) val = val.value;\n\t\t\t\trecord[field.name] = val;\n\t\t\t}\n\t\t\treturn createRecord(record);\n\t\t}\n\n\t\tprivate evaluateAccessor(expr: AccessorExpression): Value {\n\t\t\t// Return a function that takes a record and returns the field value\n\t\t\treturn createNativeFunction(`@${expr.field}`, (record: Value): Value => {\n\t\t\t\tif (isRecord(record)) {\n\t\t\t\t\tconst field = expr.field;\n\t\t\t\t\tif (field in record.fields) {\n\t\t\t\t\t\treturn record.fields[field];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new Error(`Field '${expr.field}' not found in record`);\n\t\t\t});\n\t\t}\n\n\t\tprivate evaluateWhere(expr: WhereExpression): Value {\n\t\t\t// Use environment stacking for where clause\n\t\t\treturn this.withNewEnvironment(() => {\n\t\t\t\t// Evaluate all definitions in the where clause\n\t\t\t\tfor (const def of expr.definitions) {\n\t\t\t\t\tif (def.kind === \"definition\") {\n\t\t\t\t\t\tconst value = this.evaluateExpression(def.value);\n\t\t\t\t\t\tthis.environment.set(def.name, value);\n\t\t\t\t\t} else if (def.kind === \"mutable-definition\") {\n\t\t\t\t\t\tconst value = this.evaluateExpression(def.value);\n\t\t\t\t\t\tthis.environment.set(def.name, createCell(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Evaluate the main expression\n\t\t\t\treturn this.evaluateExpression(expr.main);\n\t\t\t});\n\t\t}\n\n\t\tprivate containsVariable(expr: Expression, varName: string): boolean {\n\t\t\tswitch (expr.kind) {\n\t\t\t\tcase \"variable\":\n\t\t\t\t\treturn expr.name === varName;\n\t\t\t\tcase \"function\":\n\t\t\t\t\t// Don't check function parameters\n\t\t\t\t\treturn this.containsVariable(expr.body, varName);\n\t\t\t\tcase \"application\":\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.containsVariable(expr.func, varName) ||\n\t\t\t\t\t\texpr.args.some((arg) => this.containsVariable(arg, varName))\n\t\t\t\t\t);\n\t\t\t\tcase \"binary\":\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.containsVariable(expr.left, varName) ||\n\t\t\t\t\t\tthis.containsVariable(expr.right, varName)\n\t\t\t\t\t);\n\t\t\t\tcase \"if\":\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.containsVariable(expr.condition, varName) ||\n\t\t\t\t\t\tthis.containsVariable(expr.then, varName) ||\n\t\t\t\t\t\tthis.containsVariable(expr.else, varName)\n\t\t\t\t\t);\n\t\t\t\tcase \"definition\":\n\t\t\t\t\treturn this.containsVariable(expr.value, varName);\n\t\t\t\tcase \"mutable-definition\":\n\t\t\t\t\treturn this.containsVariable(expr.value, varName);\n\t\t\t\tcase \"mutation\":\n\t\t\t\t\treturn (\n\t\t\t\t\t\texpr.target === varName ||\n\t\t\t\t\t\tthis.containsVariable(expr.value, varName)\n\t\t\t\t\t);\n\t\t\t\tcase \"record\":\n\t\t\t\t\treturn expr.fields.some((field) =>\n\t\t\t\t\t\tthis.containsVariable(field.value, varName),\n\t\t\t\t\t);\n\t\t\t\tcase \"tuple\":\n\t\t\t\t\treturn expr.elements.some((element) =>\n\t\t\t\t\t\tthis.containsVariable(element, varName),\n\t\t\t\t\t);\n\t\t\t\tcase \"list\":\n\t\t\t\t\treturn expr.elements.some((element) =>\n\t\t\t\t\t\tthis.containsVariable(element, varName),\n\t\t\t\t\t);\n\t\t\t\tcase \"pipeline\":\n\t\t\t\t\treturn expr.steps.some((step) =>\n\t\t\t\t\t\tthis.containsVariable(step, varName),\n\t\t\t\t\t);\n\t\t\t\tcase \"import\":\n\t\t\t\tcase \"accessor\":\n\t\t\t\tcase \"literal\":\n\t\t\t\tcase \"unit\":\n\t\t\t\tcase \"typed\":\n\t\t\t\t\treturn false;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Efficient environment stack management\n\t\tprivate pushEnvironment(): void {\n\t\t\tthis.environmentStack.push(this.environment);\n\t\t\tthis.environment = new Map(this.environment);\n\t\t}\n\n\t\tprivate popEnvironment(): void {\n\t\t\tif (this.environmentStack[0]) {\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: we checked\n\t\t\t\tthis.environment = this.environmentStack.pop()!;\n\t\t\t}\n\t\t}\n\n\t\tprivate withNewEnvironment<T>(fn: () => T): T {\n\t\t\tthis.pushEnvironment();\n\t\t\ttry {\n\t\t\t\treturn fn();\n\t\t\t} finally {\n\t\t\t\tthis.popEnvironment();\n\t\t\t}\n\t\t}\n\n\t\t// Get the current environment (useful for debugging)\n\t\tgetEnvironment(): Map<string, Value> {\n\t\t\treturn new Map(\n\t\t\t\tArray.from(this.environment.entries()).map(([k, v]) => [\n\t\t\t\t\tk,\n\t\t\t\t\tisCell(v) ? v.value : v,\n\t\t\t\t]),\n\t\t\t);\n\t\t}\n\n\t\tprivate expressionToString(expr: Expression): string {\n\t\t\tswitch (expr.kind) {\n\t\t\t\tcase \"literal\":\n\t\t\t\t\tif (Array.isArray(expr.value)) {\n\t\t\t\t\t\treturn `[${expr.value\n\t\t\t\t\t\t\t.map((e) => this.expressionToString(e as Expression))\n\t\t\t\t\t\t\t.join(\" \")}]`;\n\t\t\t\t\t}\n\t\t\t\t\treturn String(expr.value);\n\t\t\t\tcase \"variable\":\n\t\t\t\t\treturn expr.name;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn `fn ${expr.params.join(\" \")} => ${this.expressionToString(\n\t\t\t\t\t\texpr.body,\n\t\t\t\t\t)}`;\n\t\t\t\tcase \"application\":\n\t\t\t\t\treturn `${this.expressionToString(expr.func)} ${expr.args\n\t\t\t\t\t\t.map((arg) => this.expressionToString(arg))\n\t\t\t\t\t\t.join(\" \")}`;\n\t\t\t\tcase \"pipeline\":\n\t\t\t\t\treturn expr.steps\n\t\t\t\t\t\t.map((step) => this.expressionToString(step))\n\t\t\t\t\t\t.join(\" | \");\n\t\t\t\tcase \"binary\":\n\t\t\t\t\treturn `${this.expressionToString(expr.left)} ${\n\t\t\t\t\t\texpr.operator\n\t\t\t\t\t} ${this.expressionToString(expr.right)}`;\n\t\t\t\tcase \"if\":\n\t\t\t\t\treturn `if ${this.expressionToString(\n\t\t\t\t\t\texpr.condition,\n\t\t\t\t\t)} then ${this.expressionToString(\n\t\t\t\t\t\texpr.then,\n\t\t\t\t\t)} else ${this.expressionToString(expr.else)}`;\n\t\t\t\tcase \"definition\":\n\t\t\t\t\treturn `${expr.name} = ${this.expressionToString(expr.value)}`;\n\t\t\t\tcase \"mutable-definition\":\n\t\t\t\t\treturn `${expr.name} = ${this.expressionToString(expr.value)}`;\n\t\t\t\tcase \"mutation\":\n\t\t\t\t\treturn `mut ${expr.target} = ${this.expressionToString(expr.value)}`;\n\t\t\t\tcase \"import\":\n\t\t\t\t\treturn `import \"${expr.path}\"`;\n\t\t\t\tcase \"record\":\n\t\t\t\t\treturn `{ ${expr.fields\n\t\t\t\t\t\t.map(\n\t\t\t\t\t\t\t(field) =>\n\t\t\t\t\t\t\t\t`${field.name} = ${this.expressionToString(field.value)}`,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.join(\", \")} }`;\n\t\t\t\tcase \"accessor\":\n\t\t\t\t\treturn `@${expr.field}`;\n\t\t\t\tcase \"where\":\n\t\t\t\t\treturn `${this.expressionToString(expr.main)} where (${expr.definitions\n\t\t\t\t\t\t.map((d) => this.expressionToString(d))\n\t\t\t\t\t\t.join(\"; \")})`;\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"unknown\";\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluateTypeDefinition(expr: TypeDefinitionExpression): Value {\n\t\t\t// Type definitions add constructors to the environment\n\t\t\tfor (const _constructor of expr.constructors) {\n\t\t\t\tif (_constructor.args.length === 0) {\n\t\t\t\t\t// Nullary constructor: just create the constructor value\n\t\t\t\t\tconst constructorValue = {\n\t\t\t\t\t\ttag: \"constructor\",\n\t\t\t\t\t\tname: _constructor.name,\n\t\t\t\t\t\targs: [],\n\t\t\t\t\t} as Value;\n\t\t\t\t\tthis.environment.set(_constructor.name, constructorValue);\n\t\t\t\t} else {\n\t\t\t\t\t// Create a simple constructor function that collects all arguments\n\t\t\t\t\tconst createCurriedConstructor = (arity: number, name: string) => {\n\t\t\t\t\t\tconst collectArgs = (collectedArgs: Value[] = []): Value => {\n\t\t\t\t\t\t\treturn createFunction((nextArg: Value) => {\n\t\t\t\t\t\t\t\tconst newArgs = [...collectedArgs, nextArg];\n\t\t\t\t\t\t\t\tif (newArgs.length === arity) {\n\t\t\t\t\t\t\t\t\treturn { tag: \"constructor\", name, args: newArgs } as Value;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn collectArgs(newArgs);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn collectArgs();\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.environment.set(\n\t\t\t\t\t\t_constructor.name,\n\t\t\t\t\t\tcreateCurriedConstructor(\n\t\t\t\t\t\t\t_constructor.args.length,\n\t\t\t\t\t\t\t_constructor.name,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Type definitions evaluate to unit\n\t\t\treturn createUnit();\n\t\t}\n\n\t\tprivate evaluateMatch(expr: MatchExpression): Value {\n\t\t\t// Evaluate the expression being matched\n\t\t\tconst value = this.evaluateExpression(expr.expression);\n\n\t\t\t// Try each case until one matches\n\t\t\tfor (const matchCase of expr.cases) {\n\t\t\t\tconst matchResult = this.tryMatchPattern(matchCase.pattern, value);\n\t\t\t\tif (matchResult.matched) {\n\t\t\t\t\t// Use environment stacking for pattern bindings\n\t\t\t\t\treturn this.withNewEnvironment(() => {\n\t\t\t\t\t\t// Add bindings to environment\n\t\t\t\t\t\tfor (const [name, boundValue] of matchResult.bindings) {\n\t\t\t\t\t\t\tthis.environment.set(name, boundValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Evaluate the case expression\n\t\t\t\t\t\treturn this.evaluateExpression(matchCase.expression);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new Error(\"No pattern matched in match expression\");\n\t\t}\n\n\t\tprivate tryMatchPattern(\n\t\t\tpattern: Pattern,\n\t\t\tvalue: Value,\n\t\t): { matched: boolean; bindings: Map<string, Value> } {\n\t\t\tconst bindings = new Map<string, Value>();\n\n\t\t\tswitch (pattern.kind) {\n\t\t\t\tcase \"wildcard\":\n\t\t\t\t\t// Wildcard always matches\n\t\t\t\t\treturn { matched: true, bindings };\n\n\t\t\t\tcase \"variable\":\n\t\t\t\t\t// Variable always matches and binds the value\n\t\t\t\t\tbindings.set(pattern.name, value);\n\t\t\t\t\treturn { matched: true, bindings };\n\n\t\t\t\tcase \"constructor\": {\n\t\t\t\t\t// Constructor pattern only matches constructor values\n\t\t\t\t\tif (value.tag !== \"constructor\") {\n\t\t\t\t\t\treturn { matched: false, bindings };\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check constructor name\n\t\t\t\t\tif (value.name !== pattern.name) {\n\t\t\t\t\t\treturn { matched: false, bindings };\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check argument count\n\t\t\t\t\tif (pattern.args.length !== value.args.length) {\n\t\t\t\t\t\treturn { matched: false, bindings };\n\t\t\t\t\t}\n\n\t\t\t\t\t// Match each argument\n\t\t\t\t\tfor (let i = 0; i < pattern.args.length; i++) {\n\t\t\t\t\t\tconst argMatch = this.tryMatchPattern(\n\t\t\t\t\t\t\tpattern.args[i],\n\t\t\t\t\t\t\tvalue.args[i],\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!argMatch.matched) {\n\t\t\t\t\t\t\treturn { matched: false, bindings };\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Merge bindings\n\t\t\t\t\t\tfor (const [name, boundValue] of argMatch.bindings) {\n\t\t\t\t\t\t\tbindings.set(name, boundValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { matched: true, bindings };\n\t\t\t\t}\n\n\t\t\t\tcase \"literal\": {\n\t\t\t\t\t// Literal pattern matches if values are equal\n\t\t\t\t\tlet matches = false;\n\n\t\t\t\t\tif (typeof pattern.value === \"number\" && isNumber(value)) {\n\t\t\t\t\t\tmatches = pattern.value === value.value;\n\t\t\t\t\t} else if (typeof pattern.value === \"string\" && isString(value)) {\n\t\t\t\t\t\tmatches = pattern.value === value.value;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { matched: matches, bindings };\n\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unsupported pattern kind: ${(pattern as Pattern).kind}`,\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n// Move valueToString to a standalone function\nfunction valueToString(value: Value): string {\n\tif (isNumber(value)) {\n\t\treturn String(value.value);\n\t} else if (isString(value)) {\n\t\treturn `\"${value.value}\"`;\n\t} else if (isBool(value)) {\n\t\treturn boolValue(value) ? \"True\" : \"False\";\n\t} else if (isList(value)) {\n\t\treturn `[${value.values.map(valueToString).join(\"; \")}]`;\n\t} else if (isTuple(value)) {\n\t\treturn `{${value.values.map(valueToString).join(\"; \")}}`;\n\t} else if (isRecord(value)) {\n\t\tconst fields = Object.entries(value.fields)\n\t\t\t.map(([k, v]) => `@${k} ${valueToString(v)}`)\n\t\t\t.join(\"; \");\n\t\treturn `{${fields}}`;\n\t} else if (isFunction(value)) {\n\t\treturn \"<function>\";\n\t} else if (isNativeFunction(value)) {\n\t\treturn `<native:${value.name}>`;\n\t} else if (isConstructor(value)) {\n\t\tif (value.args.length === 0) {\n\t\t\treturn value.name;\n\t\t} else {\n\t\t\treturn `${value.name} ${value.args.map(valueToString).join(\" \")}`;\n\t\t}\n\t} else if (isUnit(value)) {\n\t\treturn \"unit\";\n\t}\n\treturn \"[object Object]\";\n}\n"],"names":["Evaluator","boolValue","createBool","createCell","createConstructor","createFalse","createFunction","createList","createNativeFunction","createNumber","createRecord","createString","createTrue","createTuple","createUnit","isBool","isCell","isConstructor","isFunction","isList","isNativeFunction","isNumber","isRecord","isString","isTuple","isUnit","val","cell","value","tag","name","args","Error","values","fields","fn","wrap","curriedName","result","flattenStatements","expr","kind","operator","left","right","environment","environmentStack","currentFileDir","fs","path","opts","defaultFs","defaultPath","Map","initializeBuiltins","loadStdlib","set","a","b","error","createError","undefined","func","f","g","x","_left","arg","index","list","idx","length","slice","head","tail","map","item","pred","filter","initial","reduce","acc","partial","list1","list2","n","Math","abs","max","min","console","log","formatValue","valueToString","record","key","Object","includes","accessor","newValue","field","replace","tuple","option","content","readFileSync","writeFileSync","message","floor","random","Number","MAX_SAFE_INTEGER","minVal","maxVal","ref","possiblePaths","join","__dirname","process","cwd","stdlibPath","existsSync","msg","stdlibContent","lexer","Lexer","tokens","tokenize","stdlibProgram","parse","allStatements","statement","statements","push","evaluateExpression","evaluateProgram","program","filePath","dirname","resolve","executionTrace","finalResult","Array","from","entries","k","v","expression","expressionToString","location","line","start","column","evaluateDefinition","def","isRecursive","containsVariable","evaluateMutableDefinition","evaluateMutation","get","target","evaluateLiteral","evaluateVariable","evaluateFunction","evaluateApplication","evaluatePipeline","evaluateBinary","evaluateIf","evaluateImport","evaluateRecord","evaluateAccessor","elements","e","evaluateWhere","evaluateTypeDefinition","evaluateMatch","isArray","element","end","self","closureEnv","createCurriedFunction","params","body","callEnv","param","withNewEnvironment","remainingParams","nextFunction","nextArg","nextCallEnv","remainingFunction","argExpr","steps","composed","i","nextFunc","composedFn","nextFuncFn","leftVal","rightVal","operatorVal","condition","isTruthy","then","else","endsWith","fullPath","isAbsolute","tempEvaluator","errorMessage","stack","JSON","stringify","_e","String","structuredError","definitions","main","varName","some","step","pushEnvironment","popEnvironment","pop","getEnvironment","d","_constructor","constructors","constructorValue","createCurriedConstructor","arity","collectArgs","collectedArgs","newArgs","matchCase","cases","matchResult","tryMatchPattern","pattern","matched","boundValue","bindings","argMatch","matches"],"mappings":"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"}