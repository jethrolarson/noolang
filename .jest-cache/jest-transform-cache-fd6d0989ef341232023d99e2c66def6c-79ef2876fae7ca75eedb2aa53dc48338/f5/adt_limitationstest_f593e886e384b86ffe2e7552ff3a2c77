6c01b1cc1265cdc8ed8d62b136926715
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _lexer = require("../src/lexer");
const _parser = require("../src/parser/parser");
const _typer = require("../src/typer");
const _evaluator = require("../src/evaluator");
const _helpers = require("../src/typer/helpers");
// Helper function to run Noolang code and get both value and type
const runNoolang = (code)=>{
    const lexer = new _lexer.Lexer(code);
    const tokens = lexer.tokenize();
    const ast = (0, _parser.parse)(tokens);
    const decoratedResult = (0, _typer.typeAndDecorate)(ast);
    const evaluator = new _evaluator.Evaluator();
    const result = evaluator.evaluateProgram(decoratedResult.program);
    return {
        finalValue: result.finalResult,
        finalType: decoratedResult.state ? (0, _helpers.typeToString)(decoratedResult.program.statements[decoratedResult.program.statements.length - 1].type, decoratedResult.state.substitution) : "unknown"
    };
};
(0, _globals.describe)("ADT Language Limitations", ()=>{
    (0, _globals.describe)("Multiple ADT Definitions", ()=>{
        (0, _globals.it)("should now work with map and multiple ADTs (polymorphism fixed)", ()=>{
            // This test was previously failing due to lack of polymorphism in map
            // Now that map is properly polymorphic, it should work
            (0, _globals.expect)(()=>runNoolang(`
        type Color = Red | Green | Blue;
        type Shape a = Circle a | Rectangle a a | Triangle a a a;
        colors = [Red, Green, Blue];
        shapes = [Circle 3, Rectangle 5 4];
        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);
        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);
        color_numbers = map color_to_number colors;
        areas = map calculate_area shapes;
        color_numbers
      `)).not.toThrow();
        });
        (0, _globals.it)("should work when ADTs are used in separate programs", ()=>{
            // This demonstrates the workaround: use ADTs in separate programs
            const colorResult = runNoolang(`
        type Color = Red | Green | Blue;
        colors = [Red, Green, Blue];
        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);
        color_numbers = map color_to_number colors;
        color_numbers
      `);
            (0, _globals.expect)(colorResult.finalValue).toEqual({
                tag: "list",
                values: [
                    {
                        tag: "number",
                        value: 1
                    },
                    {
                        tag: "number",
                        value: 2
                    },
                    {
                        tag: "number",
                        value: 3
                    }
                ]
            });
            const shapeResult = runNoolang(`
        type Shape a = Circle a | Rectangle a a | Triangle a a a;
        shapes = [Circle 3, Rectangle 5 4];
        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);
        areas = map calculate_area shapes;
        areas
      `);
            (0, _globals.expect)(shapeResult.finalValue).toEqual({
                tag: "list",
                values: [
                    {
                        tag: "number",
                        value: 27
                    },
                    {
                        tag: "number",
                        value: 20
                    }
                ]
            });
        });
        (0, _globals.it)("should work when ADTs are used sequentially without map", ()=>{
            // This shows that the issue is specifically with map + multiple ADTs
            const result = runNoolang(`
        type Color = Red | Green | Blue;
        type Shape a = Circle a | Rectangle a a | Triangle a a a;
        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);
        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);
        color_result = color_to_number Red;
        shape_result = calculate_area (Circle 5);
        { @color color_result, @shape shape_result }
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "record",
                fields: {
                    color: {
                        tag: "number",
                        value: 1
                    },
                    shape: {
                        tag: "number",
                        value: 75
                    }
                }
            });
        });
    });
    (0, _globals.describe)("Root Cause Analysis", ()=>{
        (0, _globals.it)("should demonstrate that the type unification issue is now fixed", ()=>{
            // The issue was in the type system when it tried to unify
            // type variables that had been associated with different ADT types
            // This is now fixed with proper let-polymorphism for map
            (0, _globals.expect)(()=>runNoolang(`
        type Color = Red | Green | Blue;
        type Shape a = Circle a | Rectangle a a | Triangle a a a;
        # This works fine - no type unification issues
        colors = [Red, Green, Blue];
        shapes = [Circle 3, Rectangle 5 4];
        # This also works - separate operations
        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);
        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);
        # This now works - map is properly polymorphic
        color_numbers = map color_to_number colors;
        areas = map calculate_area shapes;
        color_numbers
      `)).not.toThrow();
        });
    });
    (0, _globals.describe)("Workarounds", ()=>{
        (0, _globals.it)("should work with separate type definitions", ()=>{
            // Workaround 1: Define ADTs in separate programs
            const result1 = runNoolang(`
        type Color = Red | Green | Blue;
        colors = [Red, Green, Blue];
        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);
        map color_to_number colors
      `);
            (0, _globals.expect)(result1.finalValue).toEqual({
                tag: "list",
                values: [
                    {
                        tag: "number",
                        value: 1
                    },
                    {
                        tag: "number",
                        value: 2
                    },
                    {
                        tag: "number",
                        value: 3
                    }
                ]
            });
        });
        (0, _globals.it)("should work with manual iteration instead of map", ()=>{
            // Workaround 2: Use manual iteration instead of map
            const result = runNoolang(`
        type Color = Red | Green | Blue;
        type Shape a = Circle a | Rectangle a a | Triangle a a a;
        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);
        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);
        # Manual iteration instead of map
        colors = [Red, Green, Blue];
        shapes = [Circle 3, Rectangle 5 4];
        color1 = color_to_number Red;
        color2 = color_to_number Green;
        color3 = color_to_number Blue;
        shape1 = calculate_area (Circle 3);
        shape2 = calculate_area (Rectangle 5 4);
        { @colors [color1, color2, color3], @shapes [shape1, shape2] }
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "record",
                fields: {
                    colors: {
                        tag: "list",
                        values: [
                            {
                                tag: "number",
                                value: 1
                            },
                            {
                                tag: "number",
                                value: 2
                            },
                            {
                                tag: "number",
                                value: 3
                            }
                        ]
                    },
                    shapes: {
                        tag: "list",
                        values: [
                            {
                                tag: "number",
                                value: 27
                            },
                            {
                                tag: "number",
                                value: 20
                            }
                        ]
                    }
                }
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2UvdGVzdC9hZHRfbGltaXRhdGlvbnMudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXNjcmliZSwgaXQsIGV4cGVjdCB9IGZyb20gXCJAamVzdC9nbG9iYWxzXCI7XG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi9zcmMvbGV4ZXJcIjtcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSBcIi4uL3NyYy9wYXJzZXIvcGFyc2VyXCI7XG5pbXBvcnQgeyB0eXBlQW5kRGVjb3JhdGUgfSBmcm9tICcuLi9zcmMvdHlwZXInO1xuaW1wb3J0IHsgRXZhbHVhdG9yIH0gZnJvbSBcIi4uL3NyYy9ldmFsdWF0b3JcIjtcbmltcG9ydCB7IHR5cGVUb1N0cmluZyB9IGZyb20gJy4uL3NyYy90eXBlci9oZWxwZXJzJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHJ1biBOb29sYW5nIGNvZGUgYW5kIGdldCBib3RoIHZhbHVlIGFuZCB0eXBlXG5jb25zdCBydW5Ob29sYW5nID0gKGNvZGU6IHN0cmluZykgPT4ge1xuICBjb25zdCBsZXhlciA9IG5ldyBMZXhlcihjb2RlKTtcbiAgY29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcbiAgY29uc3QgYXN0ID0gcGFyc2UodG9rZW5zKTtcbiAgY29uc3QgZGVjb3JhdGVkUmVzdWx0ID0gdHlwZUFuZERlY29yYXRlKGFzdCk7XG4gIGNvbnN0IGV2YWx1YXRvciA9IG5ldyBFdmFsdWF0b3IoKTtcbiAgY29uc3QgcmVzdWx0ID0gZXZhbHVhdG9yLmV2YWx1YXRlUHJvZ3JhbShkZWNvcmF0ZWRSZXN1bHQucHJvZ3JhbSk7XG5cbiAgcmV0dXJuIHtcbiAgICBmaW5hbFZhbHVlOiByZXN1bHQuZmluYWxSZXN1bHQsXG4gICAgZmluYWxUeXBlOiBkZWNvcmF0ZWRSZXN1bHQuc3RhdGVcbiAgICAgID8gdHlwZVRvU3RyaW5nKFxuICAgICAgICAgIGRlY29yYXRlZFJlc3VsdC5wcm9ncmFtLnN0YXRlbWVudHNbXG4gICAgICAgICAgICBkZWNvcmF0ZWRSZXN1bHQucHJvZ3JhbS5zdGF0ZW1lbnRzLmxlbmd0aCAtIDFcbiAgICAgICAgICBdLnR5cGUhLFxuICAgICAgICAgIGRlY29yYXRlZFJlc3VsdC5zdGF0ZS5zdWJzdGl0dXRpb24sXG4gICAgICAgIClcbiAgICAgIDogXCJ1bmtub3duXCIsXG4gIH07XG59O1xuXG5kZXNjcmliZShcIkFEVCBMYW5ndWFnZSBMaW1pdGF0aW9uc1wiLCAoKSA9PiB7XG4gIGRlc2NyaWJlKFwiTXVsdGlwbGUgQURUIERlZmluaXRpb25zXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBub3cgd29yayB3aXRoIG1hcCBhbmQgbXVsdGlwbGUgQURUcyAocG9seW1vcnBoaXNtIGZpeGVkKVwiLCAoKSA9PiB7XG4gICAgICAvLyBUaGlzIHRlc3Qgd2FzIHByZXZpb3VzbHkgZmFpbGluZyBkdWUgdG8gbGFjayBvZiBwb2x5bW9ycGhpc20gaW4gbWFwXG4gICAgICAvLyBOb3cgdGhhdCBtYXAgaXMgcHJvcGVybHkgcG9seW1vcnBoaWMsIGl0IHNob3VsZCB3b3JrXG4gICAgICBleHBlY3QoKCkgPT5cbiAgICAgICAgcnVuTm9vbGFuZyhgXG4gICAgICAgIHR5cGUgQ29sb3IgPSBSZWQgfCBHcmVlbiB8IEJsdWU7XG4gICAgICAgIHR5cGUgU2hhcGUgYSA9IENpcmNsZSBhIHwgUmVjdGFuZ2xlIGEgYSB8IFRyaWFuZ2xlIGEgYSBhO1xuICAgICAgICBjb2xvcnMgPSBbUmVkLCBHcmVlbiwgQmx1ZV07XG4gICAgICAgIHNoYXBlcyA9IFtDaXJjbGUgMywgUmVjdGFuZ2xlIDUgNF07XG4gICAgICAgIGNvbG9yX3RvX251bWJlciA9IGZuIGNvbG9yID0+IG1hdGNoIGNvbG9yIHdpdGggKFJlZCA9PiAxOyBHcmVlbiA9PiAyOyBCbHVlID0+IDMpO1xuICAgICAgICBjYWxjdWxhdGVfYXJlYSA9IGZuIHNoYXBlID0+IG1hdGNoIHNoYXBlIHdpdGggKENpcmNsZSByYWRpdXMgPT4gcmFkaXVzICogcmFkaXVzICogMzsgUmVjdGFuZ2xlIHdpZHRoIGhlaWdodCA9PiB3aWR0aCAqIGhlaWdodDsgVHJpYW5nbGUgYSBiIGMgPT4gKGEgKiBiKSAvIDIpO1xuICAgICAgICBjb2xvcl9udW1iZXJzID0gbWFwIGNvbG9yX3RvX251bWJlciBjb2xvcnM7XG4gICAgICAgIGFyZWFzID0gbWFwIGNhbGN1bGF0ZV9hcmVhIHNoYXBlcztcbiAgICAgICAgY29sb3JfbnVtYmVyc1xuICAgICAgYCksXG4gICAgICApLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCB3b3JrIHdoZW4gQURUcyBhcmUgdXNlZCBpbiBzZXBhcmF0ZSBwcm9ncmFtc1wiLCAoKSA9PiB7XG4gICAgICAvLyBUaGlzIGRlbW9uc3RyYXRlcyB0aGUgd29ya2Fyb3VuZDogdXNlIEFEVHMgaW4gc2VwYXJhdGUgcHJvZ3JhbXNcbiAgICAgIGNvbnN0IGNvbG9yUmVzdWx0ID0gcnVuTm9vbGFuZyhgXG4gICAgICAgIHR5cGUgQ29sb3IgPSBSZWQgfCBHcmVlbiB8IEJsdWU7XG4gICAgICAgIGNvbG9ycyA9IFtSZWQsIEdyZWVuLCBCbHVlXTtcbiAgICAgICAgY29sb3JfdG9fbnVtYmVyID0gZm4gY29sb3IgPT4gbWF0Y2ggY29sb3Igd2l0aCAoUmVkID0+IDE7IEdyZWVuID0+IDI7IEJsdWUgPT4gMyk7XG4gICAgICAgIGNvbG9yX251bWJlcnMgPSBtYXAgY29sb3JfdG9fbnVtYmVyIGNvbG9ycztcbiAgICAgICAgY29sb3JfbnVtYmVyc1xuICAgICAgYCk7XG5cbiAgICAgIGV4cGVjdChjb2xvclJlc3VsdC5maW5hbFZhbHVlKS50b0VxdWFsKHtcbiAgICAgICAgdGFnOiBcImxpc3RcIixcbiAgICAgICAgdmFsdWVzOiBbXG4gICAgICAgICAgeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAxIH0sXG4gICAgICAgICAgeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAyIH0sXG4gICAgICAgICAgeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAzIH0sXG4gICAgICAgIF0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2hhcGVSZXN1bHQgPSBydW5Ob29sYW5nKGBcbiAgICAgICAgdHlwZSBTaGFwZSBhID0gQ2lyY2xlIGEgfCBSZWN0YW5nbGUgYSBhIHwgVHJpYW5nbGUgYSBhIGE7XG4gICAgICAgIHNoYXBlcyA9IFtDaXJjbGUgMywgUmVjdGFuZ2xlIDUgNF07XG4gICAgICAgIGNhbGN1bGF0ZV9hcmVhID0gZm4gc2hhcGUgPT4gbWF0Y2ggc2hhcGUgd2l0aCAoQ2lyY2xlIHJhZGl1cyA9PiByYWRpdXMgKiByYWRpdXMgKiAzOyBSZWN0YW5nbGUgd2lkdGggaGVpZ2h0ID0+IHdpZHRoICogaGVpZ2h0OyBUcmlhbmdsZSBhIGIgYyA9PiAoYSAqIGIpIC8gMik7XG4gICAgICAgIGFyZWFzID0gbWFwIGNhbGN1bGF0ZV9hcmVhIHNoYXBlcztcbiAgICAgICAgYXJlYXNcbiAgICAgIGApO1xuXG4gICAgICBleHBlY3Qoc2hhcGVSZXN1bHQuZmluYWxWYWx1ZSkudG9FcXVhbCh7XG4gICAgICAgIHRhZzogXCJsaXN0XCIsXG4gICAgICAgIHZhbHVlczogW1xuICAgICAgICAgIHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogMjcgfSxcbiAgICAgICAgICB7IHRhZzogXCJudW1iZXJcIiwgdmFsdWU6IDIwIH0sXG4gICAgICAgIF0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHdvcmsgd2hlbiBBRFRzIGFyZSB1c2VkIHNlcXVlbnRpYWxseSB3aXRob3V0IG1hcFwiLCAoKSA9PiB7XG4gICAgICAvLyBUaGlzIHNob3dzIHRoYXQgdGhlIGlzc3VlIGlzIHNwZWNpZmljYWxseSB3aXRoIG1hcCArIG11bHRpcGxlIEFEVHNcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bk5vb2xhbmcoYFxuICAgICAgICB0eXBlIENvbG9yID0gUmVkIHwgR3JlZW4gfCBCbHVlO1xuICAgICAgICB0eXBlIFNoYXBlIGEgPSBDaXJjbGUgYSB8IFJlY3RhbmdsZSBhIGEgfCBUcmlhbmdsZSBhIGEgYTtcbiAgICAgICAgY29sb3JfdG9fbnVtYmVyID0gZm4gY29sb3IgPT4gbWF0Y2ggY29sb3Igd2l0aCAoUmVkID0+IDE7IEdyZWVuID0+IDI7IEJsdWUgPT4gMyk7XG4gICAgICAgIGNhbGN1bGF0ZV9hcmVhID0gZm4gc2hhcGUgPT4gbWF0Y2ggc2hhcGUgd2l0aCAoQ2lyY2xlIHJhZGl1cyA9PiByYWRpdXMgKiByYWRpdXMgKiAzOyBSZWN0YW5nbGUgd2lkdGggaGVpZ2h0ID0+IHdpZHRoICogaGVpZ2h0OyBUcmlhbmdsZSBhIGIgYyA9PiAoYSAqIGIpIC8gMik7XG4gICAgICAgIGNvbG9yX3Jlc3VsdCA9IGNvbG9yX3RvX251bWJlciBSZWQ7XG4gICAgICAgIHNoYXBlX3Jlc3VsdCA9IGNhbGN1bGF0ZV9hcmVhIChDaXJjbGUgNSk7XG4gICAgICAgIHsgQGNvbG9yIGNvbG9yX3Jlc3VsdCwgQHNoYXBlIHNoYXBlX3Jlc3VsdCB9XG4gICAgICBgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbFZhbHVlKS50b0VxdWFsKHtcbiAgICAgICAgdGFnOiBcInJlY29yZFwiLFxuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICBjb2xvcjogeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAxIH0sXG4gICAgICAgICAgc2hhcGU6IHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogNzUgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlJvb3QgQ2F1c2UgQW5hbHlzaXNcIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIGRlbW9uc3RyYXRlIHRoYXQgdGhlIHR5cGUgdW5pZmljYXRpb24gaXNzdWUgaXMgbm93IGZpeGVkXCIsICgpID0+IHtcbiAgICAgIC8vIFRoZSBpc3N1ZSB3YXMgaW4gdGhlIHR5cGUgc3lzdGVtIHdoZW4gaXQgdHJpZWQgdG8gdW5pZnlcbiAgICAgIC8vIHR5cGUgdmFyaWFibGVzIHRoYXQgaGFkIGJlZW4gYXNzb2NpYXRlZCB3aXRoIGRpZmZlcmVudCBBRFQgdHlwZXNcbiAgICAgIC8vIFRoaXMgaXMgbm93IGZpeGVkIHdpdGggcHJvcGVyIGxldC1wb2x5bW9ycGhpc20gZm9yIG1hcFxuICAgICAgZXhwZWN0KCgpID0+XG4gICAgICAgIHJ1bk5vb2xhbmcoYFxuICAgICAgICB0eXBlIENvbG9yID0gUmVkIHwgR3JlZW4gfCBCbHVlO1xuICAgICAgICB0eXBlIFNoYXBlIGEgPSBDaXJjbGUgYSB8IFJlY3RhbmdsZSBhIGEgfCBUcmlhbmdsZSBhIGEgYTtcbiAgICAgICAgIyBUaGlzIHdvcmtzIGZpbmUgLSBubyB0eXBlIHVuaWZpY2F0aW9uIGlzc3Vlc1xuICAgICAgICBjb2xvcnMgPSBbUmVkLCBHcmVlbiwgQmx1ZV07XG4gICAgICAgIHNoYXBlcyA9IFtDaXJjbGUgMywgUmVjdGFuZ2xlIDUgNF07XG4gICAgICAgICMgVGhpcyBhbHNvIHdvcmtzIC0gc2VwYXJhdGUgb3BlcmF0aW9uc1xuICAgICAgICBjb2xvcl90b19udW1iZXIgPSBmbiBjb2xvciA9PiBtYXRjaCBjb2xvciB3aXRoIChSZWQgPT4gMTsgR3JlZW4gPT4gMjsgQmx1ZSA9PiAzKTtcbiAgICAgICAgY2FsY3VsYXRlX2FyZWEgPSBmbiBzaGFwZSA9PiBtYXRjaCBzaGFwZSB3aXRoIChDaXJjbGUgcmFkaXVzID0+IHJhZGl1cyAqIHJhZGl1cyAqIDM7IFJlY3RhbmdsZSB3aWR0aCBoZWlnaHQgPT4gd2lkdGggKiBoZWlnaHQ7IFRyaWFuZ2xlIGEgYiBjID0+IChhICogYikgLyAyKTtcbiAgICAgICAgIyBUaGlzIG5vdyB3b3JrcyAtIG1hcCBpcyBwcm9wZXJseSBwb2x5bW9ycGhpY1xuICAgICAgICBjb2xvcl9udW1iZXJzID0gbWFwIGNvbG9yX3RvX251bWJlciBjb2xvcnM7XG4gICAgICAgIGFyZWFzID0gbWFwIGNhbGN1bGF0ZV9hcmVhIHNoYXBlcztcbiAgICAgICAgY29sb3JfbnVtYmVyc1xuICAgICAgYCksXG4gICAgICApLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiV29ya2Fyb3VuZHNcIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIHdvcmsgd2l0aCBzZXBhcmF0ZSB0eXBlIGRlZmluaXRpb25zXCIsICgpID0+IHtcbiAgICAgIC8vIFdvcmthcm91bmQgMTogRGVmaW5lIEFEVHMgaW4gc2VwYXJhdGUgcHJvZ3JhbXNcbiAgICAgIGNvbnN0IHJlc3VsdDEgPSBydW5Ob29sYW5nKGBcbiAgICAgICAgdHlwZSBDb2xvciA9IFJlZCB8IEdyZWVuIHwgQmx1ZTtcbiAgICAgICAgY29sb3JzID0gW1JlZCwgR3JlZW4sIEJsdWVdO1xuICAgICAgICBjb2xvcl90b19udW1iZXIgPSBmbiBjb2xvciA9PiBtYXRjaCBjb2xvciB3aXRoIChSZWQgPT4gMTsgR3JlZW4gPT4gMjsgQmx1ZSA9PiAzKTtcbiAgICAgICAgbWFwIGNvbG9yX3RvX251bWJlciBjb2xvcnNcbiAgICAgIGApO1xuXG4gICAgICBleHBlY3QocmVzdWx0MS5maW5hbFZhbHVlKS50b0VxdWFsKHtcbiAgICAgICAgdGFnOiBcImxpc3RcIixcbiAgICAgICAgdmFsdWVzOiBbXG4gICAgICAgICAgeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAxIH0sXG4gICAgICAgICAgeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAyIH0sXG4gICAgICAgICAgeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAzIH0sXG4gICAgICAgIF0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHdvcmsgd2l0aCBtYW51YWwgaXRlcmF0aW9uIGluc3RlYWQgb2YgbWFwXCIsICgpID0+IHtcbiAgICAgIC8vIFdvcmthcm91bmQgMjogVXNlIG1hbnVhbCBpdGVyYXRpb24gaW5zdGVhZCBvZiBtYXBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bk5vb2xhbmcoYFxuICAgICAgICB0eXBlIENvbG9yID0gUmVkIHwgR3JlZW4gfCBCbHVlO1xuICAgICAgICB0eXBlIFNoYXBlIGEgPSBDaXJjbGUgYSB8IFJlY3RhbmdsZSBhIGEgfCBUcmlhbmdsZSBhIGEgYTtcbiAgICAgICAgY29sb3JfdG9fbnVtYmVyID0gZm4gY29sb3IgPT4gbWF0Y2ggY29sb3Igd2l0aCAoUmVkID0+IDE7IEdyZWVuID0+IDI7IEJsdWUgPT4gMyk7XG4gICAgICAgIGNhbGN1bGF0ZV9hcmVhID0gZm4gc2hhcGUgPT4gbWF0Y2ggc2hhcGUgd2l0aCAoQ2lyY2xlIHJhZGl1cyA9PiByYWRpdXMgKiByYWRpdXMgKiAzOyBSZWN0YW5nbGUgd2lkdGggaGVpZ2h0ID0+IHdpZHRoICogaGVpZ2h0OyBUcmlhbmdsZSBhIGIgYyA9PiAoYSAqIGIpIC8gMik7XG4gICAgICAgICMgTWFudWFsIGl0ZXJhdGlvbiBpbnN0ZWFkIG9mIG1hcFxuICAgICAgICBjb2xvcnMgPSBbUmVkLCBHcmVlbiwgQmx1ZV07XG4gICAgICAgIHNoYXBlcyA9IFtDaXJjbGUgMywgUmVjdGFuZ2xlIDUgNF07XG4gICAgICAgIGNvbG9yMSA9IGNvbG9yX3RvX251bWJlciBSZWQ7XG4gICAgICAgIGNvbG9yMiA9IGNvbG9yX3RvX251bWJlciBHcmVlbjtcbiAgICAgICAgY29sb3IzID0gY29sb3JfdG9fbnVtYmVyIEJsdWU7XG4gICAgICAgIHNoYXBlMSA9IGNhbGN1bGF0ZV9hcmVhIChDaXJjbGUgMyk7XG4gICAgICAgIHNoYXBlMiA9IGNhbGN1bGF0ZV9hcmVhIChSZWN0YW5nbGUgNSA0KTtcbiAgICAgICAgeyBAY29sb3JzIFtjb2xvcjEsIGNvbG9yMiwgY29sb3IzXSwgQHNoYXBlcyBbc2hhcGUxLCBzaGFwZTJdIH1cbiAgICAgIGApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmZpbmFsVmFsdWUpLnRvRXF1YWwoe1xuICAgICAgICB0YWc6IFwicmVjb3JkXCIsXG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgdGFnOiBcImxpc3RcIixcbiAgICAgICAgICAgIHZhbHVlczogW1xuICAgICAgICAgICAgICB7IHRhZzogXCJudW1iZXJcIiwgdmFsdWU6IDEgfSxcbiAgICAgICAgICAgICAgeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAyIH0sXG4gICAgICAgICAgICAgIHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogMyB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNoYXBlczoge1xuICAgICAgICAgICAgdGFnOiBcImxpc3RcIixcbiAgICAgICAgICAgIHZhbHVlczogW1xuICAgICAgICAgICAgICB7IHRhZzogXCJudW1iZXJcIiwgdmFsdWU6IDI3IH0sXG4gICAgICAgICAgICAgIHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogMjAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbInJ1bk5vb2xhbmciLCJjb2RlIiwibGV4ZXIiLCJMZXhlciIsInRva2VucyIsInRva2VuaXplIiwiYXN0IiwicGFyc2UiLCJkZWNvcmF0ZWRSZXN1bHQiLCJ0eXBlQW5kRGVjb3JhdGUiLCJldmFsdWF0b3IiLCJFdmFsdWF0b3IiLCJyZXN1bHQiLCJldmFsdWF0ZVByb2dyYW0iLCJwcm9ncmFtIiwiZmluYWxWYWx1ZSIsImZpbmFsUmVzdWx0IiwiZmluYWxUeXBlIiwic3RhdGUiLCJ0eXBlVG9TdHJpbmciLCJzdGF0ZW1lbnRzIiwibGVuZ3RoIiwidHlwZSIsInN1YnN0aXR1dGlvbiIsImRlc2NyaWJlIiwiaXQiLCJleHBlY3QiLCJub3QiLCJ0b1Rocm93IiwiY29sb3JSZXN1bHQiLCJ0b0VxdWFsIiwidGFnIiwidmFsdWVzIiwidmFsdWUiLCJzaGFwZVJlc3VsdCIsImZpZWxkcyIsImNvbG9yIiwic2hhcGUiLCJyZXN1bHQxIiwiY29sb3JzIiwic2hhcGVzIl0sIm1hcHBpbmdzIjoiOzs7O3lCQUFxQzt1QkFDZjt3QkFDQTt1QkFDVTsyQkFDTjt5QkFDRztBQUU3QixrRUFBa0U7QUFDbEUsTUFBTUEsYUFBYSxDQUFDQztJQUNsQixNQUFNQyxRQUFRLElBQUlDLFlBQUssQ0FBQ0Y7SUFDeEIsTUFBTUcsU0FBU0YsTUFBTUcsUUFBUTtJQUM3QixNQUFNQyxNQUFNQyxJQUFBQSxhQUFLLEVBQUNIO0lBQ2xCLE1BQU1JLGtCQUFrQkMsSUFBQUEsc0JBQWUsRUFBQ0g7SUFDeEMsTUFBTUksWUFBWSxJQUFJQyxvQkFBUztJQUMvQixNQUFNQyxTQUFTRixVQUFVRyxlQUFlLENBQUNMLGdCQUFnQk0sT0FBTztJQUVoRSxPQUFPO1FBQ0xDLFlBQVlILE9BQU9JLFdBQVc7UUFDOUJDLFdBQVdULGdCQUFnQlUsS0FBSyxHQUM1QkMsSUFBQUEscUJBQVksRUFDVlgsZ0JBQWdCTSxPQUFPLENBQUNNLFVBQVUsQ0FDaENaLGdCQUFnQk0sT0FBTyxDQUFDTSxVQUFVLENBQUNDLE1BQU0sR0FBRyxFQUM3QyxDQUFDQyxJQUFJLEVBQ05kLGdCQUFnQlUsS0FBSyxDQUFDSyxZQUFZLElBRXBDO0lBQ047QUFDRjtBQUVBQyxJQUFBQSxpQkFBUSxFQUFDLDRCQUE0QjtJQUNuQ0EsSUFBQUEsaUJBQVEsRUFBQyw0QkFBNEI7UUFDbkNDLElBQUFBLFdBQUUsRUFBQyxtRUFBbUU7WUFDcEUsc0VBQXNFO1lBQ3RFLHVEQUF1RDtZQUN2REMsSUFBQUEsZUFBTSxFQUFDLElBQ0wxQixXQUFXLENBQUM7Ozs7Ozs7Ozs7TUFVZCxDQUFDLEdBQ0MyQixHQUFHLENBQUNDLE9BQU87UUFDZjtRQUVBSCxJQUFBQSxXQUFFLEVBQUMsdURBQXVEO1lBQ3hELGtFQUFrRTtZQUNsRSxNQUFNSSxjQUFjN0IsV0FBVyxDQUFDOzs7Ozs7TUFNaEMsQ0FBQztZQUVEMEIsSUFBQUEsZUFBTSxFQUFDRyxZQUFZZCxVQUFVLEVBQUVlLE9BQU8sQ0FBQztnQkFDckNDLEtBQUs7Z0JBQ0xDLFFBQVE7b0JBQ047d0JBQUVELEtBQUs7d0JBQVVFLE9BQU87b0JBQUU7b0JBQzFCO3dCQUFFRixLQUFLO3dCQUFVRSxPQUFPO29CQUFFO29CQUMxQjt3QkFBRUYsS0FBSzt3QkFBVUUsT0FBTztvQkFBRTtpQkFDM0I7WUFDSDtZQUVBLE1BQU1DLGNBQWNsQyxXQUFXLENBQUM7Ozs7OztNQU1oQyxDQUFDO1lBRUQwQixJQUFBQSxlQUFNLEVBQUNRLFlBQVluQixVQUFVLEVBQUVlLE9BQU8sQ0FBQztnQkFDckNDLEtBQUs7Z0JBQ0xDLFFBQVE7b0JBQ047d0JBQUVELEtBQUs7d0JBQVVFLE9BQU87b0JBQUc7b0JBQzNCO3dCQUFFRixLQUFLO3dCQUFVRSxPQUFPO29CQUFHO2lCQUM1QjtZQUNIO1FBQ0Y7UUFFQVIsSUFBQUEsV0FBRSxFQUFDLDJEQUEyRDtZQUM1RCxxRUFBcUU7WUFDckUsTUFBTWIsU0FBU1osV0FBVyxDQUFDOzs7Ozs7OztNQVEzQixDQUFDO1lBRUQwQixJQUFBQSxlQUFNLEVBQUNkLE9BQU9HLFVBQVUsRUFBRWUsT0FBTyxDQUFDO2dCQUNoQ0MsS0FBSztnQkFDTEksUUFBUTtvQkFDTkMsT0FBTzt3QkFBRUwsS0FBSzt3QkFBVUUsT0FBTztvQkFBRTtvQkFDakNJLE9BQU87d0JBQUVOLEtBQUs7d0JBQVVFLE9BQU87b0JBQUc7Z0JBQ3BDO1lBQ0Y7UUFDRjtJQUNGO0lBRUFULElBQUFBLGlCQUFRLEVBQUMsdUJBQXVCO1FBQzlCQyxJQUFBQSxXQUFFLEVBQUMsbUVBQW1FO1lBQ3BFLDBEQUEwRDtZQUMxRCxtRUFBbUU7WUFDbkUseURBQXlEO1lBQ3pEQyxJQUFBQSxlQUFNLEVBQUMsSUFDTDFCLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7OztNQWFkLENBQUMsR0FDQzJCLEdBQUcsQ0FBQ0MsT0FBTztRQUNmO0lBQ0Y7SUFFQUosSUFBQUEsaUJBQVEsRUFBQyxlQUFlO1FBQ3RCQyxJQUFBQSxXQUFFLEVBQUMsOENBQThDO1lBQy9DLGlEQUFpRDtZQUNqRCxNQUFNYSxVQUFVdEMsV0FBVyxDQUFDOzs7OztNQUs1QixDQUFDO1lBRUQwQixJQUFBQSxlQUFNLEVBQUNZLFFBQVF2QixVQUFVLEVBQUVlLE9BQU8sQ0FBQztnQkFDakNDLEtBQUs7Z0JBQ0xDLFFBQVE7b0JBQ047d0JBQUVELEtBQUs7d0JBQVVFLE9BQU87b0JBQUU7b0JBQzFCO3dCQUFFRixLQUFLO3dCQUFVRSxPQUFPO29CQUFFO29CQUMxQjt3QkFBRUYsS0FBSzt3QkFBVUUsT0FBTztvQkFBRTtpQkFDM0I7WUFDSDtRQUNGO1FBRUFSLElBQUFBLFdBQUUsRUFBQyxvREFBb0Q7WUFDckQsb0RBQW9EO1lBQ3BELE1BQU1iLFNBQVNaLFdBQVcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7TUFjM0IsQ0FBQztZQUVEMEIsSUFBQUEsZUFBTSxFQUFDZCxPQUFPRyxVQUFVLEVBQUVlLE9BQU8sQ0FBQztnQkFDaENDLEtBQUs7Z0JBQ0xJLFFBQVE7b0JBQ05JLFFBQVE7d0JBQ05SLEtBQUs7d0JBQ0xDLFFBQVE7NEJBQ047Z0NBQUVELEtBQUs7Z0NBQVVFLE9BQU87NEJBQUU7NEJBQzFCO2dDQUFFRixLQUFLO2dDQUFVRSxPQUFPOzRCQUFFOzRCQUMxQjtnQ0FBRUYsS0FBSztnQ0FBVUUsT0FBTzs0QkFBRTt5QkFDM0I7b0JBQ0g7b0JBQ0FPLFFBQVE7d0JBQ05ULEtBQUs7d0JBQ0xDLFFBQVE7NEJBQ047Z0NBQUVELEtBQUs7Z0NBQVVFLE9BQU87NEJBQUc7NEJBQzNCO2dDQUFFRixLQUFLO2dDQUFVRSxPQUFPOzRCQUFHO3lCQUM1QjtvQkFDSDtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtBQUNGIn0=