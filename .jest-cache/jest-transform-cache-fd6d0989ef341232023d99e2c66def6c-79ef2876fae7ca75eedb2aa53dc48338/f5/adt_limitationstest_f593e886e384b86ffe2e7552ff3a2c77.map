{"version":3,"sources":["/workspace/test/adt_limitations.test.ts"],"sourcesContent":["import { describe, it, expect } from \"@jest/globals\";\nimport { Lexer } from \"../src/lexer\";\nimport { parse } from \"../src/parser/parser\";\nimport { typeAndDecorate } from '../src/typer';\nimport { Evaluator } from \"../src/evaluator\";\nimport { typeToString } from '../src/typer/helpers';\n\n// Helper function to run Noolang code and get both value and type\nconst runNoolang = (code: string) => {\n  const lexer = new Lexer(code);\n  const tokens = lexer.tokenize();\n  const ast = parse(tokens);\n  const decoratedResult = typeAndDecorate(ast);\n  const evaluator = new Evaluator();\n  const result = evaluator.evaluateProgram(decoratedResult.program);\n\n  return {\n    finalValue: result.finalResult,\n    finalType: decoratedResult.state\n      ? typeToString(\n          decoratedResult.program.statements[\n            decoratedResult.program.statements.length - 1\n          ].type!,\n          decoratedResult.state.substitution,\n        )\n      : \"unknown\",\n  };\n};\n\ndescribe(\"ADT Language Limitations\", () => {\n  describe(\"Multiple ADT Definitions\", () => {\n    it(\"should now work with map and multiple ADTs (polymorphism fixed)\", () => {\n      // This test was previously failing due to lack of polymorphism in map\n      // Now that map is properly polymorphic, it should work\n      expect(() =>\n        runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        colors = [Red, Green, Blue];\n        shapes = [Circle 3, Rectangle 5 4];\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        color_numbers = map color_to_number colors;\n        areas = map calculate_area shapes;\n        color_numbers\n      `),\n      ).not.toThrow();\n    });\n\n    it(\"should work when ADTs are used in separate programs\", () => {\n      // This demonstrates the workaround: use ADTs in separate programs\n      const colorResult = runNoolang(`\n        type Color = Red | Green | Blue;\n        colors = [Red, Green, Blue];\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        color_numbers = map color_to_number colors;\n        color_numbers\n      `);\n\n      expect(colorResult.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"number\", value: 1 },\n          { tag: \"number\", value: 2 },\n          { tag: \"number\", value: 3 },\n        ],\n      });\n\n      const shapeResult = runNoolang(`\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        shapes = [Circle 3, Rectangle 5 4];\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        areas = map calculate_area shapes;\n        areas\n      `);\n\n      expect(shapeResult.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"number\", value: 27 },\n          { tag: \"number\", value: 20 },\n        ],\n      });\n    });\n\n    it(\"should work when ADTs are used sequentially without map\", () => {\n      // This shows that the issue is specifically with map + multiple ADTs\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        color_result = color_to_number Red;\n        shape_result = calculate_area (Circle 5);\n        { @color color_result, @shape shape_result }\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"record\",\n        fields: {\n          color: { tag: \"number\", value: 1 },\n          shape: { tag: \"number\", value: 75 },\n        },\n      });\n    });\n  });\n\n  describe(\"Root Cause Analysis\", () => {\n    it(\"should demonstrate that the type unification issue is now fixed\", () => {\n      // The issue was in the type system when it tried to unify\n      // type variables that had been associated with different ADT types\n      // This is now fixed with proper let-polymorphism for map\n      expect(() =>\n        runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        # This works fine - no type unification issues\n        colors = [Red, Green, Blue];\n        shapes = [Circle 3, Rectangle 5 4];\n        # This also works - separate operations\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        # This now works - map is properly polymorphic\n        color_numbers = map color_to_number colors;\n        areas = map calculate_area shapes;\n        color_numbers\n      `),\n      ).not.toThrow();\n    });\n  });\n\n  describe(\"Workarounds\", () => {\n    it(\"should work with separate type definitions\", () => {\n      // Workaround 1: Define ADTs in separate programs\n      const result1 = runNoolang(`\n        type Color = Red | Green | Blue;\n        colors = [Red, Green, Blue];\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        map color_to_number colors\n      `);\n\n      expect(result1.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"number\", value: 1 },\n          { tag: \"number\", value: 2 },\n          { tag: \"number\", value: 3 },\n        ],\n      });\n    });\n\n    it(\"should work with manual iteration instead of map\", () => {\n      // Workaround 2: Use manual iteration instead of map\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        # Manual iteration instead of map\n        colors = [Red, Green, Blue];\n        shapes = [Circle 3, Rectangle 5 4];\n        color1 = color_to_number Red;\n        color2 = color_to_number Green;\n        color3 = color_to_number Blue;\n        shape1 = calculate_area (Circle 3);\n        shape2 = calculate_area (Rectangle 5 4);\n        { @colors [color1, color2, color3], @shapes [shape1, shape2] }\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"record\",\n        fields: {\n          colors: {\n            tag: \"list\",\n            values: [\n              { tag: \"number\", value: 1 },\n              { tag: \"number\", value: 2 },\n              { tag: \"number\", value: 3 },\n            ],\n          },\n          shapes: {\n            tag: \"list\",\n            values: [\n              { tag: \"number\", value: 27 },\n              { tag: \"number\", value: 20 },\n            ],\n          },\n        },\n      });\n    });\n  });\n});\n"],"names":["runNoolang","code","lexer","Lexer","tokens","tokenize","ast","parse","decoratedResult","typeAndDecorate","evaluator","Evaluator","result","evaluateProgram","program","finalValue","finalResult","finalType","state","typeToString","statements","length","type","substitution","describe","it","expect","not","toThrow","colorResult","toEqual","tag","values","value","shapeResult","fields","color","shape","result1","colors","shapes"],"mappings":"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"}