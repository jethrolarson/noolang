{"version":3,"sources":["/workspace/src/typer/__tests__/typer.test.ts"],"sourcesContent":["import { describe, it, expect } from \"@jest/globals\";\nimport { Lexer } from \"../../lexer\";\nimport { parse } from \"../../parser/parser\";\nimport { typeProgram } from '..';\nimport { typeToString } from '../helpers';\nimport { createTypeState } from '..';\nimport { initializeBuiltins } from '../builtins';\n\n// Helper function to parse a string into a program\nconst parseProgram = (source: string) => {\n  const lexer = new Lexer(source);\n  const tokens = lexer.tokenize();\n  return parse(tokens);\n};\n\ndescribe(\"Functional Type Inference\", () => {\n  describe(\"Basic Types\", () => {\n    it(\"should infer integer literal\", () => {\n      const program = parseProgram(\"42\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should infer string literal\", () => {\n      const program = parseProgram('\"hello\"');\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\n        \"String\"\n      );\n    });\n\n    it(\"should infer boolean literal\", () => {\n      const program = parseProgram(\"True\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Bool\");\n    });\n  });\n\n  describe(\"Function Types\", () => {\n    it(\"should infer identity function\", () => {\n      const program = parseProgram(\"fn x => x\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\n        \"(α) -> α\"\n      );\n    });\n\n    it(\"should infer function with multiple parameters\", () => {\n      const program = parseProgram(\"fn x y => x + y\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\n        \"(Int) -> (Int) -> Int\"\n      );\n    });\n\n    it(\"should infer nested function\", () => {\n      const program = parseProgram(\"fn x => fn y => x + y\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\n        \"(Int) -> (Int) -> Int\"\n      );\n    });\n  });\n\n  describe(\"Let Polymorphism\", () => {\n    it(\"should generalize identity function\", () => {\n      const program = parseProgram(\"id = fn x => x; id 42\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should allow polymorphic function to be used with different types\", () => {\n      const program = parseProgram('id = fn x => x; id 42; id \"hello\"');\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\n        \"String\"\n      );\n    });\n\n    it(\"should handle recursive definitions\", () => {\n      const program = parseProgram(\n        \"fact = fn n => if n == 0 then 1 else n * (fact (n - 1)); fact 5\"\n      );\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n  });\n\n  describe(\"Function Application\", () => {\n    it(\"should apply function to argument\", () => {\n      const program = parseProgram(\"(fn x => x + 1) 42\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should handle partial application\", () => {\n      const program = parseProgram(\n        \"add = fn x y => x + y; add5 = add 5; add5 3\"\n      );\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should handle curried application\", () => {\n      const program = parseProgram(\"add = fn x y => x + y; add 2 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n  });\n\n  describe(\"Binary Operators\", () => {\n    it(\"should infer arithmetic operations\", () => {\n      const program = parseProgram(\"2 + 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should infer comparison operations\", () => {\n      const program = parseProgram(\"2 < 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Bool\");\n    });\n\n    it(\"should infer equality operations\", () => {\n      const program = parseProgram(\"2 == 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Bool\");\n    });\n  });\n\n  describe(\"If Expressions\", () => {\n    it(\"should infer if expression with same types\", () => {\n      const program = parseProgram(\"if True then 1 else 2\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should handle if expression with different types\", () => {\n      const program = parseProgram('if True then 1 else \"hello\"');\n      expect(() => typeProgram(program)).toThrow();\n    });\n  });\n\n  describe(\"Sequences\", () => {\n    it(\"should handle semicolon sequences\", () => {\n      const program = parseProgram(\"1; 2; 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should handle sequences with definitions\", () => {\n      const program = parseProgram(\"x = 1; y = 2; x + y\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n  });\n\n  describe(\"Built-in Functions\", () => {\n    it(\"should handle built-in arithmetic operators\", () => {\n      const program = parseProgram(\"2 + 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should handle built-in comparison operators\", () => {\n      const program = parseProgram(\"2 == 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Bool\");\n    });\n  });\n\n  describe(\"Type Environment\", () => {\n    it(\"should initialize with built-ins\", () => {\n      const state = createTypeState();\n      const newState = initializeBuiltins(state);\n\n      expect(newState.environment.has(\"+\")).toBe(true);\n      expect(newState.environment.has(\"-\")).toBe(true);\n      expect(newState.environment.has(\"*\")).toBe(true);\n      expect(newState.environment.has(\"/\")).toBe(true);\n      expect(newState.environment.has(\"==\")).toBe(true);\n      expect(newState.environment.has(\";\")).toBe(true);\n    });\n  });\n\n  describe(\"Error Cases\", () => {\n    it(\"should reject undefined variables\", () => {\n      const program = parseProgram(\"undefined_var\");\n      expect(() => typeProgram(program)).toThrow(\"Undefined variable\");\n    });\n\n    it(\"should reject type mismatches in function application\", () => {\n      const program = parseProgram('(fn x => x + 1) \"hello\"');\n      expect(() => typeProgram(program)).toThrow();\n    });\n\n    it(\"should reject non-boolean conditions in if expressions\", () => {\n      const program = parseProgram(\"if 42 then 1 else 2\");\n      expect(() => typeProgram(program)).toThrow();\n    });\n  });\n});\n\ndescribe(\"Constraint Propagation (Functional Typer)\", () => {\n  it(\"should throw a type error when constraints are not satisfied in composition\", () => {\n    const program = parseProgram(`\n      compose = fn f g => fn x => f (g x);\n      safeHead = compose head;\n      listId = fn x => x;\n      result = safeHead listId [1, 2, 3]\n    `);\n    // This should work now since head is safe and returns Option\n    const result = typeProgram(program);\n    expect(result).toBeDefined();\n  });\n\n  it(\"should allow composition when constraints are satisfied (functional typer)\", () => {\n    const program = parseProgram(`\n      compose = fn f g => fn x => f (g x);\n      safeHead = compose head;\n      listId = fn x => x;\n      result = safeHead listId [[1, 2, 3], [4, 5, 6]]\n    `);\n    const result = typeProgram(program);\n    const typeStr = typeToString(result.type, result.state.substitution);\n    // head now returns Option List Int instead of List Int\n    expect(typeStr).toBe(\"Option List Int\");\n  });\n});\n"],"names":["parseProgram","source","lexer","Lexer","tokens","tokenize","parse","describe","it","program","result","typeProgram","expect","typeToString","type","state","substitution","toBe","toThrow","createTypeState","newState","initializeBuiltins","environment","has","toBeDefined","typeStr"],"mappings":"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"}