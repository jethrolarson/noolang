{"version":3,"sources":["/workspace/test/dollar-operator.test.ts"],"sourcesContent":["import { Lexer } from '../src/lexer';\nimport { parse } from '../src/parser/parser';\nimport { Evaluator } from '../src/evaluator';\nimport { typeAndDecorate } from '../src/typer';\nimport { Value } from '../src/evaluator';\n\nlet evaluator: Evaluator;\n\nfunction runCode(code: string) {\n  const lexer = new Lexer(code);\n  const tokens = lexer.tokenize();\n  const ast = parse(tokens);\n  const decoratedResult = typeAndDecorate(ast);\n  return evaluator.evaluateProgram(decoratedResult.program);\n}\n\n// Type checking helper - simplified for now\nfunction hasCorrectType(code: string, expectedKind: string): boolean {\n  try {\n    const lexer = new Lexer(code);\n    const tokens = lexer.tokenize();\n    const ast = parse(tokens);\n    const decoratedResult = typeAndDecorate(ast);\n    // Just check if type decoration succeeded without errors\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction unwrapValue(val: Value): any {\n  if (val === null) return null;\n  if (typeof val !== \"object\") return val;\n  switch (val.tag) {\n    case \"number\":\n      return val.value;\n    case \"string\":\n      return val.value;\n    case \"constructor\":\n      if (val.name === \"True\") return true;\n      if (val.name === \"False\") return false;\n      return val;\n    case \"list\":\n      return val.values.map(unwrapValue);\n    case \"tuple\":\n      return val.values.map(unwrapValue);\n    case \"record\": {\n      const obj: any = {};\n      for (const k in val.fields) obj[k] = unwrapValue(val.fields[k]);\n      return obj;\n    }\n    default:\n      return val;\n  }\n}\n\ndescribe('Dollar Operator ($)', () => {\n  beforeEach(() => {\n    evaluator = new Evaluator();\n  });\n  describe('Basic Function Application', () => {\n    test('simple function application', () => {\n      const result = runCode('(fn x => x * 2) $ 5');\n      expect(unwrapValue(result.finalResult)).toBe(10);\n    });\n\n    test('curried function application', () => {\n      const result = runCode('add = fn x y => x + y; (add $ 3) $ 5');\n      expect(unwrapValue(result.finalResult)).toBe(8);\n    });\n\n    test('multiple arguments', () => {\n      const result = runCode('mul = fn x y z => x * y * z; ((mul $ 2) $ 3) $ 4');\n      expect(unwrapValue(result.finalResult)).toBe(24);\n    });\n  });\n\n  describe('Right Associativity', () => {\n    test('f $ g $ h should parse as f $ (g $ h)', () => {\n      // This should be equivalent to: const $ (\\x -> x + 1) $ 5\n      // Which is: const ((\\x -> x + 1) 5) = const 6 = \\y -> 6\n      const result = runCode('const = fn x y => x; f = fn x => x + 1; (const $ f $ 5) 999');\n      // const gets f(5) = 6, so const $ f $ 5 = const 6, which when applied to 999 returns 6\n      expect(unwrapValue(result.finalResult)).toBe(6);\n    });\n\n    test('right associativity with arithmetic', () => {\n      // This tests: add $ (mul $ (2 $ 3)) which should work since $ is right-associative\n      // But function-to-function application isn't what we want to test here\n      // Let's test a simpler case: const $ (add $ 1) $ 2\n      const result = runCode('const = fn x y => x; add = fn x y => x + y; (const $ (add $ 1)) $ 99');\n      // const gets (add 1) which is a function, so const returns that function\n      // The result should be a function, not a number. Let's test that it returns a function by applying it\n      const result3 = runCode('const = fn x y => x; add = fn x y => x + y; ((const $ (add $ 1)) $ 99) 7');\n      expect(unwrapValue(result3.finalResult)).toBe(8); // (add $ 1) 7 = 1 + 7 = 8\n      \n      // Better test: proper right associativity with valid functions  \n      const result4 = runCode('const = fn x y => x; id = fn x => x; (const $ id $ 99) 123');\n      expect(unwrapValue(result4.finalResult)).toBe(99); // const gets (id 99) = 99, so const 99 123 = 99\n    });\n  });\n\n  describe('Precedence with Other Operators', () => {\n    test('$ has lower precedence than |', () => {\n      const result = runCode('add = fn x y => x + y; [1, 2] | map $ add 1');\n      expect(unwrapValue(result.finalResult)).toEqual([2, 3]);\n    });\n\n    test('$ has lower precedence than function application', () => {\n      const result = runCode('add = fn x y => x + y; map (add 1) $ [1, 2, 3]');\n      expect(unwrapValue(result.finalResult)).toEqual([2, 3, 4]);\n    });\n\n    test('$ works with complex expressions', () => {\n      const result = runCode('map (fn x => x * 2) $ filter (fn x => x > 5) $ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]');\n      expect(unwrapValue(result.finalResult)).toEqual([12, 14, 16, 18, 20]);\n    });\n  });\n\n  describe('Type Checking', () => {\n    test('$ with built-in functions type checks correctly', () => {\n      // Just verify it doesn't throw type errors\n      expect(() => {\n        runCode('add = fn x y => x + y; result = map $ add 1; result [1, 2, 3]');\n      }).not.toThrow();\n    });\n\n    test('$ with user-defined functions type checks correctly', () => {\n      expect(() => {\n        runCode('add = fn x y => x + y; mymap = fn f list => map f list; result = mymap $ add 1; result [1, 2, 3]');\n      }).not.toThrow();\n    });\n\n    test('$ creates partial application correctly', () => {\n      const result = runCode('add = fn x y z => x + y + z; partialAdd = add $ 1; partialAdd 2 3');\n      expect(unwrapValue(result.finalResult)).toBe(6);\n    });\n  });\n\n  describe('Integration with Other Features', () => {\n    test('$ with pipeline operators', () => {\n      const result = runCode('add = fn x y => x + y; [1, 2, 3] | map $ add 10');\n      expect(unwrapValue(result.finalResult)).toEqual([11, 12, 13]);\n    });\n\n    test('$ with records and accessors', () => {\n      const result = runCode('person = { @name \"Alice\", @age 30 }; f = fn x => x; f $ person | @name');\n      expect(unwrapValue(result.finalResult)).toBe(\"Alice\");\n    });\n\n    test('$ with higher-order functions', () => {\n      const result = runCode('compose = fn f g => fn x => f (g x); add1 = fn x => x + 1; mul2 = fn x => x * 2; ((compose $ add1) $ mul2) 5');\n      expect(unwrapValue(result.finalResult)).toBe(11); // add1(mul2(5)) = add1(10) = 11\n    });\n\n    test('$ with constraint functions', () => {\n      const result = runCode('(filter $ (fn x => x > 3)) $ [1, 2, 3, 4, 5]');\n      expect(unwrapValue(result.finalResult)).toEqual([4, 5]);\n    });\n  });\n\n  describe('Complex Chaining', () => {\n    test('deep $ chaining', () => {\n      const result = runCode('f = fn a b c d => a + b + c + d; (((f $ 1) $ 2) $ 3) $ 4');\n      expect(unwrapValue(result.finalResult)).toBe(10);\n    });\n\n    test('$ with mixed operators', () => {\n      const result = runCode('add = fn x y => x + y; opt = [10] | head; match opt with (Some x => (add $ x) $ 5; None => 0)');\n      expect(unwrapValue(result.finalResult)).toBe(15);\n    });\n\n    test('$ in complex data flow', () => {\n      const result = runCode(`\n        process = fn f list => map f list;\n        transform = fn x => x * 2 + 1;\n        data = [1, 2, 3];\n        data | process $ transform\n      `);\n      expect(unwrapValue(result.finalResult)).toEqual([3, 5, 7]);\n    });\n  });\n\n  describe('Error Handling', () => {\n    test('$ with non-function should error', () => {\n      expect(() => {\n        runCode('5 $ 3');\n      }).toThrow();\n    });\n\n    test('$ with wrong arity should error appropriately', () => {\n      // This should work - partial application\n      expect(() => {\n        const result = runCode('add = fn x y => x + y; add $ 1');\n        // This should return a function, not throw\n      }).not.toThrow();\n    });\n  });\n});"],"names":["evaluator","runCode","code","lexer","Lexer","tokens","tokenize","ast","parse","decoratedResult","typeAndDecorate","evaluateProgram","program","hasCorrectType","expectedKind","error","unwrapValue","val","tag","value","name","values","map","obj","k","fields","describe","beforeEach","Evaluator","test","result","expect","finalResult","toBe","result3","result4","toEqual","not","toThrow"],"mappings":"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"}