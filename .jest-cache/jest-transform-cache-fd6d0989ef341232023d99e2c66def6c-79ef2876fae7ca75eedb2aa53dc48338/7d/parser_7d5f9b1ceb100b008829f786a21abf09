e59534ebd721049b7cd8ca21eaf0cc67
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get parse () {
        return parse;
    },
    get parseTypeExpression () {
        return parseTypeExpression;
    }
});
const _ast = require("../ast");
const _combinators = /*#__PURE__*/ _interop_require_wildcard(require("./combinators"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// --- Helper: parse type name (IDENTIFIER or type-related KEYWORD) ---
const parseTypeName = (tokens)=>{
    if (tokens.length === 0) {
        return {
            success: false,
            error: "Expected type name, but got end of input",
            position: 0
        };
    }
    const [first, ...rest] = tokens;
    const typeKeywords = [
        "Int",
        "Number",
        "String",
        "Unit",
        "List"
    ];
    if (first.type === "IDENTIFIER" || first.type === "KEYWORD" && typeKeywords.includes(first.value)) {
        return {
            success: true,
            value: first,
            remaining: rest
        };
    }
    return {
        success: false,
        error: `Expected type name, but got ${first.type} '${first.value}'`,
        position: first.location.start.line
    };
};
// --- Helper: parse a single type atom (primitive, variable, record, tuple, list) ---
function parseTypeAtom(tokens) {
    // Try primitive types first, but handle List as a parameterizable type constructor
    const primitiveTypes = [
        "Int",
        "Number",
        "String",
        "Unit"
    ];
    for (const typeName of primitiveTypes){
        const result = _combinators.keyword(typeName)(tokens);
        if (result.success) {
            switch(typeName){
                case "Int":
                case "Number":
                    return {
                        success: true,
                        value: (0, _ast.intType)(),
                        remaining: result.remaining
                    };
                case "String":
                    return {
                        success: true,
                        value: (0, _ast.stringType)(),
                        remaining: result.remaining
                    };
                case "Unit":
                    return {
                        success: true,
                        value: (0, _ast.unitType)(),
                        remaining: result.remaining
                    };
            }
        }
    }
    // Try List as a parameterizable type constructor
    const listKeywordResult = _combinators.keyword("List")(tokens);
    if (listKeywordResult.success) {
        // Try to parse a type argument for List
        const argResult = _combinators.lazy(()=>parseTypeAtom)(listKeywordResult.remaining);
        if (argResult.success) {
            // List with specific element type: List Number, List String, etc.
            return {
                success: true,
                value: (0, _ast.listTypeWithElement)(argResult.value),
                remaining: argResult.remaining
            };
        } else {
            // Just List (generic)
            return {
                success: true,
                value: (0, _ast.listTypeWithElement)((0, _ast.typeVariable)("a")),
                remaining: listKeywordResult.remaining
            };
        }
    }
    // Try record type
    const recordResult = _combinators.seq(_combinators.punctuation("{"), _combinators.optional(_combinators.sepBy(_combinators.map(_combinators.seq(_combinators.identifier(), _combinators.punctuation(":"), _combinators.lazy(()=>parseTypeExpression)), ([name, colon, type])=>[
            name.value,
            type
        ]), _combinators.punctuation(","))), _combinators.punctuation("}"))(tokens);
    if (recordResult.success) {
        const fields = recordResult.value[1] || [];
        const fieldObj = {};
        for (const [name, type] of fields){
            fieldObj[name] = type;
        }
        return {
            success: true,
            value: (0, _ast.recordType)(fieldObj),
            remaining: recordResult.remaining
        };
    }
    // Try tuple type
    const tupleResult = _combinators.seq(_combinators.punctuation("{"), _combinators.optional(_combinators.sepBy(_combinators.lazy(()=>parseTypeExpression), _combinators.punctuation(","))), _combinators.punctuation("}"))(tokens);
    if (tupleResult.success) {
        const elements = tupleResult.value[1] || [];
        return {
            success: true,
            value: (0, _ast.tupleType)(elements),
            remaining: tupleResult.remaining
        };
    }
    // Try List type
    const listResult = _combinators.seq(_combinators.keyword("List"), _combinators.lazy(()=>parseTypeExpression))(tokens);
    if (listResult.success) {
        return {
            success: true,
            value: (0, _ast.listTypeWithElement)(listResult.value[1]),
            remaining: listResult.remaining
        };
    }
    // Try Tuple type constructor: Tuple T1 T2 T3
    if (tokens.length > 0 && tokens[0].type === "IDENTIFIER" && tokens[0].value === "Tuple") {
        const tupleConstructorResult = _combinators.seq(_combinators.identifier(), _combinators.many(_combinators.lazy(()=>parseTypeExpression)))(tokens);
        if (tupleConstructorResult.success) {
            const elementTypes = tupleConstructorResult.value[1];
            return {
                success: true,
                value: (0, _ast.tupleTypeConstructor)(elementTypes),
                remaining: tupleConstructorResult.remaining
            };
        }
    }
    // Try parenthesized type: (Type)
    const parenResult = _combinators.seq(_combinators.punctuation("("), _combinators.lazy(()=>parseTypeExpression), _combinators.punctuation(")"))(tokens);
    if (parenResult.success) {
        return {
            success: true,
            value: parenResult.value[1],
            remaining: parenResult.remaining
        };
    }
    // Try uppercase type constructor: TypeName arg1 arg2 ... (preserve original logic)
    if (tokens.length > 0 && tokens[0].type === "IDENTIFIER" && /^[A-Z]/.test(tokens[0].value)) {
        const typeNameResult = _combinators.identifier()(tokens);
        if (typeNameResult.success) {
            // Try to parse type arguments
            const argsResult = _combinators.many(_combinators.lazy(()=>parseTypeAtom))(typeNameResult.remaining);
            if (argsResult.success) {
                return {
                    success: true,
                    value: {
                        kind: "variant",
                        name: typeNameResult.value.value,
                        args: argsResult.value
                    },
                    remaining: argsResult.remaining
                };
            }
        }
    }
    // Try type variable or simple identifier
    if (tokens.length > 0 && tokens[0].type === "IDENTIFIER") {
        const identifierResult = _combinators.identifier()(tokens);
        if (identifierResult.success) {
            return {
                success: true,
                value: (0, _ast.typeVariable)(identifierResult.value.value),
                remaining: identifierResult.remaining
            };
        }
    }
    return {
        success: false,
        error: "Expected type atom",
        position: tokens[0]?.location.start.line || 0
    };
}
// --- Type Expression ---
// Helper function to parse function types without top-level effects
const parseFunctionTypeWithoutEffects = (tokens)=>{
    let leftResult = parseTypeAtom(tokens);
    if (!leftResult.success) return leftResult;
    let left = leftResult.value;
    let rest = leftResult.remaining;
    while(rest && rest.length > 0 && rest[0].type === "OPERATOR" && rest[0].value === "->"){
        rest = rest.slice(1);
        const rightResult = parseFunctionTypeWithoutEffects(rest);
        if (!rightResult.success) return rightResult;
        if (!rightResult.value) return {
            success: false,
            error: "Expected type expression",
            position: tokens[0]?.location.start.line || 0
        };
        left = (0, _ast.functionType)([
            left
        ], rightResult.value);
        rest = rightResult.remaining;
    }
    return {
        success: true,
        value: left,
        remaining: rest
    };
};
const parseTypeExpression = (tokens)=>{
    // Try function type (right-associative): a -> b -> c FIRST
    const funcType = (()=>{
        let leftResult = parseTypeAtom(tokens);
        if (!leftResult.success) return leftResult;
        let left = leftResult.value;
        let rest = leftResult.remaining;
        while(rest && rest.length > 0 && rest[0].type === "OPERATOR" && rest[0].value === "->"){
            rest = rest.slice(1);
            const rightResult = parseFunctionTypeWithoutEffects(rest);
            if (!rightResult.success) return rightResult;
            if (!rightResult.value) return {
                success: false,
                error: "Expected type expression",
                position: tokens[0]?.location.start.line || 0
            };
            left = (0, _ast.functionType)([
                left
            ], rightResult.value);
            rest = rightResult.remaining;
        }
        // Parse effects at the end of the entire function type chain
        let effects = new Set();
        let effectRest = rest;
        // Parse effects: !effect1 !effect2 ...
        while(effectRest && effectRest.length > 0 && effectRest[0].type === "OPERATOR" && effectRest[0].value === "!"){
            effectRest = effectRest.slice(1); // consume !
            // Expect an effect name (identifier or keyword)
            if (!effectRest || effectRest.length === 0 || effectRest[0].type !== "IDENTIFIER" && effectRest[0].type !== "KEYWORD") {
                return {
                    success: false,
                    error: "Expected effect name after !",
                    position: effectRest?.[0]?.location?.start?.line || 0
                };
            }
            const effectName = effectRest[0].value;
            // Validate effect name
            const validEffects = [
                "log",
                "read",
                "write",
                "state",
                "time",
                "rand",
                "ffi",
                "async"
            ];
            if (!validEffects.includes(effectName)) {
                return {
                    success: false,
                    error: `Invalid effect: ${effectName}. Valid effects: ${validEffects.join(", ")}`,
                    position: effectRest[0].location.start.line
                };
            }
            effects.add(effectName);
            effectRest = effectRest.slice(1); // consume effect name
        }
        // Apply effects to the function type (including empty effects)
        if (left.kind === 'function') {
            left = {
                ...left,
                effects
            };
        }
        return {
            success: true,
            value: left,
            remaining: effectRest
        };
    })();
    if (funcType.success && funcType.value) {
        return funcType;
    }
    // If function type parsing failed with a specific effect error, return that error
    if (!funcType.success && (funcType.error.includes("Invalid effect:") || funcType.error.includes("Expected effect name after !"))) {
        return funcType;
    }
    // Try type variable (lowercase identifier)
    if (tokens.length > 0 && tokens[0].type === "IDENTIFIER" && /^[a-z]/.test(tokens[0].value)) {
        const varResult = _combinators.identifier()(tokens);
        if (varResult.success) {
            return {
                success: true,
                value: (0, _ast.typeVariable)(varResult.value.value),
                remaining: varResult.remaining
            };
        }
    }
    // Try record type: { name: String, age: Number }
    const recordResult = _combinators.seq(_combinators.punctuation("{"), _combinators.optional(_combinators.sepBy(_combinators.map(_combinators.seq(_combinators.identifier(), _combinators.punctuation(":"), _combinators.lazy(()=>parseTypeExpression)), ([name, colon, type])=>[
            name.value,
            type
        ]), _combinators.punctuation(","))), _combinators.punctuation("}"))(tokens);
    if (recordResult.success) {
        const fields = recordResult.value[1] || [];
        const fieldObj = {};
        for (const [name, type] of fields){
            fieldObj[name] = type;
        }
        return {
            success: true,
            value: (0, _ast.recordType)(fieldObj),
            remaining: recordResult.remaining
        };
    }
    // Try tuple type: { Number, String }
    const tupleResult = _combinators.seq(_combinators.punctuation("{"), _combinators.optional(_combinators.sepBy(_combinators.lazy(()=>parseTypeExpression), _combinators.punctuation(","))), _combinators.punctuation("}"))(tokens);
    if (tupleResult.success) {
        const elements = tupleResult.value[1] || [];
        return {
            success: true,
            value: (0, _ast.tupleType)(elements),
            remaining: tupleResult.remaining
        };
    }
    // Try List type
    const listResult = _combinators.seq(_combinators.keyword("List"), _combinators.lazy(()=>parseTypeExpression))(tokens);
    if (listResult.success) {
        return {
            success: true,
            value: (0, _ast.listTypeWithElement)(listResult.value[1]),
            remaining: listResult.remaining
        };
    }
    return {
        success: false,
        error: "Expected type expression",
        position: tokens[0]?.location.start.line || 0
    };
};
// --- Basic Parsers ---
const parseIdentifier = _combinators.map(_combinators.identifier(), (token)=>({
        kind: "variable",
        name: token.value,
        location: token.location
    }));
const parseNumber = _combinators.map(_combinators.number(), (token)=>({
        kind: "literal",
        value: parseFloat(token.value),
        location: token.location
    }));
const parseString = _combinators.map(_combinators.string(), (token)=>({
        kind: "literal",
        value: token.value,
        location: token.location
    }));
const parseAccessor = _combinators.map(_combinators.accessor(), (token)=>({
        kind: "accessor",
        field: token.value,
        location: token.location
    }));
// --- Record Parsing ---
const parseRecordFieldName = _combinators.map(_combinators.accessor(), (token)=>token.value // Just get the field name without @
);
// Parse an expression that stops at @ (accessor tokens) or semicolon
const parseRecordFieldValue = (tokens)=>{
    // Use the full expression parser to parse the complete expression
    // This includes records, so we can parse nested records
    const result = _combinators.lazy(()=>parseSequence)(tokens);
    if (!result.success) {
        return result;
    }
    // The expression parser should have consumed all the tokens it needs
    // and left us with the remaining tokens that come after the expression
    return {
        success: true,
        value: result.value,
        remaining: result.remaining
    };
};
const parseRecordField = _combinators.map(_combinators.seq(parseRecordFieldName, parseRecordFieldValue), ([fieldName, value])=>({
        name: fieldName,
        value,
        isNamed: true
    }));
// Parse a single record field (named or positional)
const parseRecordFieldOrPositional = (index)=>(tokens)=>{
        // Try to parse as named field first (with accessor)
        const namedFieldResult = parseRecordField(tokens);
        if (namedFieldResult.success) {
            return {
                ...namedFieldResult,
                value: {
                    ...namedFieldResult.value,
                    isNamed: true
                }
            };
        }
        // If that fails, try to parse as positional field (expression without accessor)
        const positionalFieldResult = parseRecordFieldValue(tokens);
        if (positionalFieldResult.success) {
            return {
                success: true,
                value: {
                    name: `@${index}`,
                    value: positionalFieldResult.value,
                    isNamed: false
                },
                remaining: positionalFieldResult.remaining
            };
        }
        return {
            success: false,
            error: "Expected record field (named or positional)",
            position: tokens[0]?.location.start.line || 0
        };
    };
// Custom parser for a sequence of fields separated by semicolons
const parseRecordFields = (tokens)=>{
    let fields = [];
    let rest = tokens;
    // Parse first field
    const firstFieldResult = parseRecordFieldOrPositional(0)(rest);
    if (!firstFieldResult.success) {
        return {
            success: false,
            error: "Expected at least one record field",
            position: tokens[0]?.location.start.line || 0
        };
    }
    fields.push(firstFieldResult.value);
    rest = firstFieldResult.remaining;
    const isNamed = firstFieldResult.value.isNamed;
    // Parse additional fields, each preceded by a comma
    while(rest.length > 0){
        const commaResult = _combinators.punctuation(",")(rest);
        if (!commaResult.success) {
            break; // No more commas, we're done
        }
        rest = commaResult.remaining;
        const fieldResult = parseRecordFieldOrPositional(fields.length)(rest);
        if (!fieldResult.success) {
            // Check if this is a trailing comma (no more fields after comma)
            // Look ahead to see if the next token is a closing brace
            if (rest.length > 0 && rest[0].type === "PUNCTUATION" && rest[0].value === "}") {
                break;
            }
            return {
                success: false,
                error: "Expected field after comma",
                position: rest[0]?.location.start.line || 0
            };
        }
        if (fieldResult.value.isNamed !== isNamed) {
            return {
                success: false,
                error: "Cannot mix named and positional fields in the same record/tuple",
                position: rest[0]?.location.start.line || 0
            };
        }
        fields.push(fieldResult.value);
        rest = fieldResult.remaining;
    }
    // Remove isNamed before returning
    return {
        success: true,
        value: fields.map(({ isNamed, ...rest })=>rest),
        remaining: rest
    };
};
// --- Record/Tuple Parsing ---
const parseRecord = _combinators.map(_combinators.seq(_combinators.punctuation("{"), _combinators.optional(parseRecordFields), _combinators.punctuation("}")), ([open, fields, close])=>{
    const fieldsList = fields || [];
    if (fieldsList.length === 0) {
        // Empty braces: unit
        return {
            kind: "unit",
            location: open.location
        };
    }
    const allNamed = fieldsList.every((f)=>f.name[0] !== "@");
    const allPositional = fieldsList.every((f, i)=>f.name === `@${i}`);
    if (allNamed) {
        // All named fields: record
        return {
            kind: "record",
            fields: fieldsList,
            location: open.location
        };
    } else if (allPositional) {
        // All positional fields: tuple
        return {
            kind: "tuple",
            elements: fieldsList.map((f)=>f.value),
            location: open.location
        };
    } else {
        // Mixed fields: error
        throw new Error("Cannot mix named and positional fields in the same record/tuple");
    }
});
// --- Parenthesized Expressions ---
const parseParenExpr = _combinators.map(_combinators.seq(_combinators.punctuation("("), _combinators.lazy(()=>parseSequence), _combinators.punctuation(")")), ([open, expr, close])=>expr);
// --- Lambda Expression ---
const parseLambdaExpression = (tokens)=>{
    // Try to parse fn keyword first
    const fnResult = _combinators.keyword("fn")(tokens);
    if (!fnResult.success) {
        return fnResult;
    }
    // Try unit parameter patterns first
    let paramNames = [];
    let remaining = fnResult.remaining;
    const parenResult = _combinators.seq(_combinators.punctuation("("), _combinators.punctuation(")"))(remaining);
    if (parenResult.success) {
        // No parameters (should not be used in Noolang, but keep for syntax completeness)
        paramNames = [];
        remaining = parenResult.remaining;
    } else {
        const braceResult = _combinators.seq(_combinators.punctuation("{"), _combinators.punctuation("}"))(remaining);
        if (braceResult.success) {
            // Unit parameter
            paramNames = [
                "_unit"
            ];
            remaining = braceResult.remaining;
        } else {
            // Try multiple identifiers last
            const idResult = _combinators.many(_combinators.identifier())(remaining);
            if (idResult.success) {
                paramNames = idResult.value.map((p)=>p.value);
                remaining = idResult.remaining;
            } else {
                return {
                    success: false,
                    error: "Expected parameter list, parentheses, or braces",
                    position: remaining[0]?.location.start.line || 0
                };
            }
        }
    }
    // Parse the arrow
    const arrowResult = _combinators.operator("=>")(remaining);
    if (!arrowResult.success) {
        return arrowResult;
    }
    // Parse the body (use parseSequenceTermWithIf to allow full expressions)
    const bodyResult = _combinators.lazy(()=>parseSequenceTermWithIf)(arrowResult.remaining);
    if (!bodyResult.success) {
        return bodyResult;
    }
    return {
        success: true,
        value: {
            kind: "function",
            params: paramNames,
            body: bodyResult.value,
            location: fnResult.value.location
        },
        remaining: bodyResult.remaining
    };
};
// --- List Parsing ---
// Custom parser for a sequence of expressions separated by semicolons
const parseListElements = (tokens)=>{
    let elements = [];
    let rest = tokens;
    // Parse first element
    const firstElementResult = _combinators.lazy(()=>parseThrush)(rest);
    if (!firstElementResult.success) {
        return {
            success: false,
            error: "Expected at least one list element",
            position: tokens[0]?.location.start.line || 0
        };
    }
    elements.push(firstElementResult.value);
    rest = firstElementResult.remaining;
    // Parse additional elements, each preceded by a comma
    while(rest.length > 0){
        const commaResult = _combinators.punctuation(",")(rest);
        if (!commaResult.success) {
            break; // No more commas, we're done
        }
        rest = commaResult.remaining;
        const elementResult = _combinators.lazy(()=>parseThrush)(rest);
        if (!elementResult.success) {
            // Check if this is a trailing comma (no more elements after comma)
            // Look ahead to see if the next token is a closing bracket
            if (rest.length > 0 && rest[0].type === "PUNCTUATION" && rest[0].value === "]") {
                break;
            }
            return {
                success: false,
                error: "Expected element after comma",
                position: rest[0]?.location.start.line || 0
            };
        }
        elements.push(elementResult.value);
        rest = elementResult.remaining;
    }
    return {
        success: true,
        value: elements,
        remaining: rest
    };
};
const parseList = _combinators.map(_combinators.seq(_combinators.punctuation("["), _combinators.optional(parseListElements), _combinators.punctuation("]")), ([open, elements, close])=>{
    const elementsList = elements || [];
    return {
        kind: "list",
        elements: elementsList,
        location: open.location
    };
});
// --- Import Expression ---
const parseImportExpression = _combinators.map(_combinators.seq(_combinators.keyword("import"), _combinators.string()), ([importKw, path])=>({
        kind: "import",
        path: path.value,
        location: importKw.location
    }));
// --- If Expression (special: do not allow semicolon in branches) ---
const parseIfExpression = _combinators.map(_combinators.seq(_combinators.keyword("if"), _combinators.lazy(()=>parseSequenceTerm), _combinators.keyword("then"), _combinators.lazy(()=>parseSequenceTerm), _combinators.keyword("else"), _combinators.lazy(()=>parseSequenceTerm)), ([ifKw, condition, thenKw, thenExpr, elseKw, elseExpr])=>{
    return {
        kind: "if",
        condition,
        then: thenExpr,
        else: elseExpr,
        location: ifKw.location
    };
});
// --- Primary Expressions (no unary minus) ---
const parsePrimary = (tokens)=>{
    // DEBUG: Log tokens at entry
    if (process.env.NOO_DEBUG_PARSE) {
        console.log("parsePrimary tokens:", tokens.map((t)=>t.value).join(" "));
    }
    // Fast token-based dispatch instead of sequential choice attempts
    if (tokens.length === 0) {
        return {
            success: false,
            error: "Unexpected end of input",
            position: 0
        };
    }
    const firstToken = tokens[0];
    let result;
    // Dispatch based on token type and value for O(1) selection
    switch(firstToken.type){
        case "NUMBER":
            result = parseNumber(tokens);
            break;
        case "STRING":
            result = parseString(tokens);
            break;
        case "IDENTIFIER":
            result = parseIdentifier(tokens);
            break;
        case "ACCESSOR":
            result = parseAccessor(tokens);
            break;
        case "PUNCTUATION":
            if (firstToken.value === "[") {
                result = parseList(tokens);
            } else if (firstToken.value === "{") {
                result = parseRecord(tokens);
            } else if (firstToken.value === "(") {
                result = parseParenExpr(tokens);
            } else {
                result = {
                    success: false,
                    error: `Unexpected punctuation: ${firstToken.value}`,
                    position: firstToken.location.start.line
                };
            }
            break;
        case "KEYWORD":
            if (firstToken.value === "fn") {
                result = parseLambdaExpression(tokens);
            } else if (firstToken.value === "let") {
                result = _combinators.lazy(()=>parseDefinitionWithType)(tokens);
            } else if (firstToken.value === "import") {
                result = parseImportExpression(tokens);
            } else {
                result = {
                    success: false,
                    error: `Unexpected keyword: ${firstToken.value}`,
                    position: firstToken.location.start.line
                };
            }
            break;
        default:
            result = {
                success: false,
                error: `Unexpected token type: ${firstToken.type}`,
                position: firstToken.location.start.line
            };
            break;
    }
    // DEBUG: Log result
    if (process.env.NOO_DEBUG_PARSE) {
        console.log("parsePrimary result:", result.success ? result.value : result.error);
    }
    return result;
};
// --- Primary with Postfix (type annotations) ---
const parsePrimaryWithPostfix = (tokens)=>{
    if (process.env.NOO_DEBUG_PARSE) {
        console.log("parsePrimaryWithPostfix tokens:", tokens.map((t)=>t.value).join(" "));
    }
    const primaryResult = parsePrimary(tokens);
    if (!primaryResult.success) return primaryResult;
    const postfixResult = parsePostfixFromResult(primaryResult.value, primaryResult.remaining);
    if (process.env.NOO_DEBUG_PARSE) {
        console.log("parsePrimaryWithPostfix result:", postfixResult.success ? postfixResult.value : postfixResult.error);
    }
    return postfixResult;
};
// --- Unary Operators (negation, only if '-' is adjacent to the next token) ---
const parseUnary = (tokens)=>{
    if (process.env.NOO_DEBUG_PARSE) {
        console.log("parseUnary tokens:", tokens.map((t)=>t.value).join(" "));
    }
    if (tokens.length >= 2 && tokens[0].type === "OPERATOR" && tokens[0].value === "-") {
        const minusToken = tokens[0];
        const nextToken = tokens[1];
        // Check if minus is directly adjacent to the next token (no space)
        if (minusToken.location.end.line === nextToken.location.start.line && minusToken.location.end.column === nextToken.location.start.column) {
            // Parse as unary minus
            const operandResult = parsePrimaryWithPostfix(tokens.slice(1));
            if (!operandResult.success) return operandResult;
            const result = {
                success: true,
                value: {
                    kind: "binary",
                    operator: "*",
                    left: {
                        kind: "literal",
                        value: -1,
                        location: minusToken.location
                    },
                    right: operandResult.value,
                    location: minusToken.location
                },
                remaining: operandResult.remaining
            };
            if (process.env.NOO_DEBUG_PARSE) {
                console.log("parseUnary result (negation):", result.value);
            }
            return result;
        }
    }
    // Otherwise, fall through to parsePrimaryWithPostfix
    const result = parsePrimaryWithPostfix(tokens);
    if (process.env.NOO_DEBUG_PARSE) {
        console.log("parseUnary result:", result.success ? result.value : result.error);
    }
    return result;
};
// --- Function Application (left-associative, tightest binding) ---
const parseApplication = (tokens)=>{
    const appResult = _combinators.map(_combinators.seq(parseUnary, _combinators.many(parseUnary)), ([func, args])=>{
        let result = func;
        for (const arg of args){
            result = {
                kind: "application",
                func: result,
                args: [
                    arg
                ],
                location: result.location
            };
        }
        return result;
    })(tokens);
    if (!appResult.success) return appResult;
    // Apply postfix operators (type annotations) to the result
    return parsePostfixFromResult(appResult.value, appResult.remaining);
};
// --- Multiplicative (*, /) ---
const parseMultiplicative = (tokens)=>{
    const multResult = _combinators.map(_combinators.seq(parseApplication, _combinators.many(_combinators.seq(_combinators.choice(_combinators.operator("*"), _combinators.operator("/")), parseApplication))), ([left, rest])=>{
        let result = left;
        for (const [op, right] of rest){
            result = {
                kind: "binary",
                operator: op.value,
                left: result,
                right,
                location: result.location
            };
        }
        return result;
    })(tokens);
    if (!multResult.success) return multResult;
    // Apply postfix operators (type annotations) to the result
    return parsePostfixFromResult(multResult.value, multResult.remaining);
};
// --- Additive (+, -) ---
const parseAdditive = (tokens)=>{
    const addResult = _combinators.map(_combinators.seq(parseMultiplicative, _combinators.many(_combinators.seq(_combinators.choice(_combinators.operator("+"), _combinators.operator("-")), parseMultiplicative))), ([left, rest])=>{
        let result = left;
        for (const [op, right] of rest){
            result = {
                kind: "binary",
                operator: op.value,
                left: result,
                right,
                location: result.location
            };
        }
        return result;
    })(tokens);
    if (!addResult.success) return addResult;
    // Apply postfix operators (type annotations) to the result
    return parsePostfixFromResult(addResult.value, addResult.remaining);
};
// --- Comparison (<, >, <=, >=, ==, !=) ---
const parseComparison = (tokens)=>{
    const compResult = _combinators.map(_combinators.seq(parseAdditive, _combinators.many(_combinators.seq(_combinators.choice(_combinators.operator("<"), _combinators.operator(">"), _combinators.operator("<="), _combinators.operator(">="), _combinators.operator("=="), _combinators.operator("!=")), parseAdditive))), ([left, rest])=>{
        let result = left;
        for (const [op, right] of rest){
            result = {
                kind: "binary",
                operator: op.value,
                left: result,
                right,
                location: result.location
            };
        }
        return result;
    })(tokens);
    if (!compResult.success) return compResult;
    // Apply postfix operators (type annotations) to the result
    return parsePostfixFromResult(compResult.value, compResult.remaining);
};
// --- Composition (|>, <|) ---
const parseCompose = (tokens)=>{
    const compResult = _combinators.map(_combinators.seq(parseComparison, _combinators.many(_combinators.seq(_combinators.choice(_combinators.operator("|>"), _combinators.operator("<|")), parseComparison))), ([left, rest])=>{
        // Build steps array for pipeline expression
        const steps = [
            left
        ];
        for (const [op, right] of rest){
            steps.push(right);
        }
        // If we have multiple steps, create a pipeline expression
        if (steps.length > 1) {
            return {
                kind: "pipeline",
                steps,
                location: left.location
            };
        }
        // Otherwise just return the single expression
        return left;
    })(tokens);
    if (!compResult.success) return compResult;
    // Apply postfix operators (type annotations) to the result
    return parsePostfixFromResult(compResult.value, compResult.remaining);
};
// --- Thrush (|) ---
const parseThrush = (tokens)=>{
    const thrushResult = _combinators.map(_combinators.seq(parseDollar, _combinators.many(_combinators.seq(_combinators.operator("|"), parseDollar))), ([left, rest])=>{
        let result = left;
        for (const [op, right] of rest){
            result = {
                kind: "binary",
                operator: "|",
                left: result,
                right,
                location: result.location
            };
        }
        return result;
    })(tokens);
    if (!thrushResult.success) return thrushResult;
    // Apply postfix operators (type annotations) to the result
    return parsePostfixFromResult(thrushResult.value, thrushResult.remaining);
};
// --- Dollar ($) - Low precedence function application (right-associative) ---
const parseDollar = (tokens)=>{
    const leftResult = parseCompose(tokens);
    if (!leftResult.success) return leftResult;
    // Check for $ operator
    if (leftResult.remaining.length > 0 && leftResult.remaining[0].type === "OPERATOR" && leftResult.remaining[0].value === "$") {
        // Consume the $ token
        const remaining = leftResult.remaining.slice(1);
        // Recursively parse the right side (this creates right-associativity)
        const rightResult = parseDollar(remaining);
        if (!rightResult.success) return rightResult;
        const result = {
            kind: "binary",
            operator: "$",
            left: leftResult.value,
            right: rightResult.value,
            location: leftResult.value.location
        };
        return parsePostfixFromResult(result, rightResult.remaining);
    }
    // No $ operator found, just return the left expression
    return parsePostfixFromResult(leftResult.value, leftResult.remaining);
};
// --- If Expression (after dollar, before sequence) ---
const parseIfAfterDollar = (tokens)=>{
    const ifResult = parseIfExpression(tokens);
    if (!ifResult.success) return ifResult;
    // Apply postfix operators (type annotations) to the result
    return parsePostfixFromResult(ifResult.value, ifResult.remaining);
};
// Helper function to apply postfix operators to an expression
const parsePostfixFromResult = (expr, tokens)=>{
    let result = expr;
    let remaining = tokens;
    // Try to parse postfix type annotations
    while(remaining.length > 0){
        // Try to parse : type given constraint
        if (remaining.length >= 2 && remaining[0].type === "PUNCTUATION" && remaining[0].value === ":") {
            const typeResult = parseTypeExpression(remaining.slice(1));
            if (!typeResult.success) break;
            // Check if there's a "given" constraint after the type
            if (typeResult.remaining.length > 0 && typeResult.remaining[0].type === "KEYWORD" && typeResult.remaining[0].value === "given") {
                const constraintResult = parseConstraintExpr(typeResult.remaining.slice(1));
                if (!constraintResult.success) break;
                result = {
                    kind: "constrained",
                    expression: result,
                    type: typeResult.value,
                    constraint: constraintResult.value,
                    location: result.location
                };
                remaining = constraintResult.remaining;
                continue;
            } else {
                // Just a type annotation without constraints
                result = {
                    kind: "typed",
                    expression: result,
                    type: typeResult.value,
                    location: result.location
                };
                remaining = typeResult.remaining;
                continue;
            }
        }
        break;
    }
    return {
        success: true,
        value: result,
        remaining
    };
};
// --- Definition ---
const parseDefinition = _combinators.map(_combinators.seq(_combinators.identifier(), _combinators.operator("="), _combinators.lazy(()=>parseSequenceTermWithIf)), ([name, equals, value])=>{
    return {
        kind: "definition",
        name: name.value,
        value,
        location: name.location
    };
});
// --- Definition with typed expression (now just a regular definition) ---
const parseDefinitionWithType = parseDefinition;
// --- Mutable Definition ---
const parseMutableDefinition = _combinators.map(_combinators.seq(_combinators.keyword("mut"), _combinators.identifier(), _combinators.operator("="), _combinators.lazy(()=>parseSequenceTermWithIf)), ([mut, name, equals, value])=>{
    return {
        kind: "mutable-definition",
        name: name.value,
        value,
        location: mut.location
    };
});
// --- Mutation ---
const parseMutation = _combinators.map(_combinators.seq(_combinators.keyword("mut!"), _combinators.identifier(), _combinators.operator("="), _combinators.lazy(()=>parseSequenceTermWithIf)), ([mut, name, equals, value])=>{
    return {
        kind: "mutation",
        target: name.value,
        value,
        location: mut.location
    };
});
// Custom parser for where clause definitions (both regular and mutable)
const parseWhereDefinition = (tokens)=>{
    // Try mutable definition first
    const mutableResult = parseMutableDefinition(tokens);
    if (mutableResult.success) {
        return mutableResult;
    }
    // Try regular definition
    const regularResult = parseDefinition(tokens);
    if (regularResult.success) {
        return regularResult;
    }
    return {
        success: false,
        error: "Expected definition in where clause",
        position: tokens[0]?.location.start.line || 0
    };
};
// --- ADT Constructor ---
const parseConstructor = _combinators.map(_combinators.seq(parseTypeName, _combinators.many(_combinators.lazy(()=>parseTypeExpression))), ([name, args])=>({
        name: name.value,
        args,
        location: (0, _ast.createLocation)(name.location.start, name.location.end)
    }));
// --- Type Definition ---
const parseTypeDefinition = _combinators.map(_combinators.seq(_combinators.keyword("type"), parseTypeName, _combinators.many(_combinators.identifier()), _combinators.operator("="), _combinators.sepBy(parseConstructor, _combinators.operator("|"))), ([type, name, typeParams, equals, constructors])=>({
        kind: "type-definition",
        name: name.value,
        typeParams: typeParams.map((p)=>p.value),
        constructors,
        location: (0, _ast.createLocation)(type.location.start, constructors[constructors.length - 1]?.location.end || equals.location.end)
    }));
// --- Constraint Function ---
const parseConstraintFunction = _combinators.map(_combinators.seq(_combinators.identifier(), _combinators.many(_combinators.identifier()), _combinators.punctuation(":"), _combinators.lazy(()=>parseTypeExpression)), ([name, typeParams, colon, type])=>({
        name: name.value,
        typeParams: typeParams.map((p)=>p.value),
        type,
        location: (0, _ast.createLocation)(name.location.start, colon.location.end)
    }));
// --- Constraint Definition ---
const parseConstraintDefinition = _combinators.map(_combinators.seq(_combinators.keyword("constraint"), _combinators.identifier(), _combinators.identifier(), _combinators.punctuation("("), _combinators.sepBy(parseConstraintFunction, _combinators.punctuation(";")), _combinators.punctuation(")")), ([constraintKeyword, name, typeParam, openParen, functions, closeParen])=>({
        kind: "constraint-definition",
        name: name.value,
        typeParam: typeParam.value,
        functions,
        location: (0, _ast.createLocation)(constraintKeyword.location.start, closeParen.location.end)
    }));
// --- Implementation Function ---
const parseImplementationFunction = _combinators.map(_combinators.seq(_combinators.identifier(), _combinators.operator("="), _combinators.lazy(()=>parseSequenceTerm)), ([name, equals, value])=>({
        name: name.value,
        value,
        location: (0, _ast.createLocation)(name.location.start, value.location.end)
    }));
// --- Implement Definition ---
const parseImplementDefinition = _combinators.map(_combinators.seq(_combinators.keyword("implement"), _combinators.identifier(), parseTypeName, _combinators.punctuation("("), _combinators.sepBy(parseImplementationFunction, _combinators.punctuation(";")), _combinators.punctuation(")")), ([implementKeyword, constraintName, typeName, openParen, implementations, closeParen])=>({
        kind: "implement-definition",
        constraintName: constraintName.value,
        typeName: typeName.value,
        implementations,
        location: (0, _ast.createLocation)(implementKeyword.location.start, closeParen.location.end)
    }));
// --- Pattern Parsing ---
// Basic pattern parsing for constructor arguments (no nested constructors with args)
const parseBasicPattern = _combinators.choice(// Wildcard pattern: _
_combinators.map(_combinators.punctuation("_"), (underscore)=>({
        kind: "wildcard",
        location: underscore.location
    })), // Literal pattern: number or string
_combinators.map(_combinators.number(), (num)=>({
        kind: "literal",
        value: parseInt(num.value),
        location: num.location
    })), _combinators.map(_combinators.string(), (str)=>({
        kind: "literal",
        value: str.value,
        location: str.location
    })), // Constructor or variable pattern: identifier (decide based on capitalization)
_combinators.map(_combinators.identifier(), (name)=>{
    // If identifier starts with uppercase, treat as constructor pattern (zero args)
    if (name.value.length > 0 && name.value[0] >= "A" && name.value[0] <= "Z") {
        return {
            kind: "constructor",
            name: name.value,
            args: [],
            location: name.location
        };
    } else {
        // Otherwise, treat as variable pattern
        return {
            kind: "variable",
            name: name.value,
            location: name.location
        };
    }
}));
const parsePattern = _combinators.choice(// Wildcard pattern: _
_combinators.map(_combinators.punctuation("_"), (underscore)=>({
        kind: "wildcard",
        location: underscore.location
    })), // Constructor pattern with arguments: Some x y
_combinators.map(_combinators.seq(_combinators.identifier(), _combinators.many1(parseBasicPattern)), ([name, args])=>({
        kind: "constructor",
        name: name.value,
        args,
        location: (0, _ast.createLocation)(name.location.start, args[args.length - 1].location.end)
    })), // Constructor pattern with parenthesized arguments: Wrap (Value n)
_combinators.map(_combinators.seq(_combinators.identifier(), _combinators.punctuation("("), _combinators.lazy(()=>parsePattern), _combinators.punctuation(")")), ([name, openParen, arg, closeParen])=>({
        kind: "constructor",
        name: name.value,
        args: [
            arg
        ],
        location: (0, _ast.createLocation)(name.location.start, closeParen.location.end)
    })), // Constructor or variable pattern: identifier (decide based on capitalization)
_combinators.map(_combinators.identifier(), (name)=>{
    // If identifier starts with uppercase, treat as constructor pattern
    if (name.value.length > 0 && name.value[0] >= "A" && name.value[0] <= "Z") {
        return {
            kind: "constructor",
            name: name.value,
            args: [],
            location: name.location
        };
    } else {
        // Otherwise, treat as variable pattern
        return {
            kind: "variable",
            name: name.value,
            location: name.location
        };
    }
}));
// --- Match Case Expression Parser ---
// This parser supports expressions in match cases, including nested match expressions
const parseMatchCaseExpression = _combinators.choice(_combinators.lazy(()=>parseMatchExpression), parseIfExpression, _combinators.lazy(()=>parseExprWithType) // Support all other expressions including type annotations
);
// --- Match Case ---
const parseMatchCase = _combinators.map(_combinators.seq(parsePattern, _combinators.operator("=>"), _combinators.lazy(()=>parseMatchCaseExpression) // Use dedicated parser for match case expressions
), ([pattern, arrow, expression])=>({
        pattern,
        expression,
        location: (0, _ast.createLocation)(pattern.location.start, expression.location.end)
    }));
// --- Match Expression ---
const parseMatchExpression = _combinators.map(_combinators.seq(_combinators.keyword("match"), _combinators.lazy(()=>parseThrush), _combinators.keyword("with"), _combinators.punctuation("("), _combinators.sepBy(parseMatchCase, _combinators.punctuation(";")), _combinators.punctuation(")")), ([match, expression, with_, openParen, cases, closeParen])=>({
        kind: "match",
        expression,
        cases,
        location: (0, _ast.createLocation)(match.location.start, closeParen.location.end)
    }));
// --- Where Expression ---
const parseWhereExpression = _combinators.map(_combinators.seq(_combinators.lazy(()=>parseSequenceTermWithIfExceptRecord), _combinators.keyword("where"), _combinators.punctuation("("), _combinators.sepBy(parseWhereDefinition, _combinators.punctuation(";")), _combinators.punctuation(")")), ([main, where, openParen, definitions, closeParen])=>{
    return {
        kind: "where",
        main,
        definitions,
        location: main.location
    };
});
// --- Sequence term: everything else ---
const parseSequenceTerm = _combinators.choice(// Parse keyword-based expressions first to avoid identifier conflicts
parseMatchExpression, parseTypeDefinition, parseConstraintDefinition, parseImplementDefinition, parseMutableDefinition, parseMutation, parseImportExpression, parseIfAfterDollar, // Then parse identifier-based expressions
parseDefinitionWithType, parseDefinition, parseWhereExpression, parseThrush, parseRecord, parseThrush, parseLambdaExpression);
// Version without records to avoid circular dependency
const parseSequenceTermExceptRecord = _combinators.choice(// Parse keyword-based expressions first
parseMatchExpression, parseTypeDefinition, parseConstraintDefinition, parseImplementDefinition, parseMutableDefinition, parseMutation, parseImportExpression, // Then identifier-based expressions
parseDefinition, parseThrush, parseLambdaExpression, parseNumber, parseString, parseIdentifier, parseList, parseAccessor, parseParenExpr);
// parseSequenceTerm now includes parseIfExpression
const parseSequenceTermWithIf = parseSequenceTerm;
// Version with if but without records to avoid circular dependency
const parseSequenceTermWithIfExceptRecord = _combinators.choice(parseSequenceTermExceptRecord, parseIfExpression);
// --- Parse atomic constraint ---
const parseAtomicConstraint = _combinators.choice(// Parenthesized constraint
_combinators.map(_combinators.seq(_combinators.punctuation("("), _combinators.lazy(()=>parseConstraintExpr), _combinators.punctuation(")")), ([open, expr, close])=>({
        kind: "paren",
        expr
    })), // a is Collection
_combinators.map(_combinators.seq(_combinators.identifier(), _combinators.keyword("is"), _combinators.choice(_combinators.identifier())), ([typeVar, isKeyword, constraint])=>({
        kind: "is",
        typeVar: typeVar.value,
        constraint: constraint.value
    })), // a has field "name" of type T
_combinators.map(_combinators.seq(_combinators.identifier(), _combinators.keyword("has"), _combinators.keyword("field"), _combinators.string(), _combinators.keyword("of"), _combinators.keyword("type"), _combinators.lazy(()=>parseTypeExpression)), ([typeVar, has, field, fieldName, of, type, fieldType])=>({
        kind: "hasField",
        typeVar: typeVar.value,
        field: fieldName.value,
        fieldType
    })), // a implements Interface
_combinators.map(_combinators.seq(_combinators.identifier(), _combinators.keyword("implements"), _combinators.identifier()), ([typeVar, implementsKeyword, interfaceName])=>({
        kind: "implements",
        typeVar: typeVar.value,
        interfaceName: interfaceName.value
    })));
// --- Parse constraint expression with precedence: and > or ---
const parseConstraintExpr = (tokens)=>{
    // Parse left side (and chains)
    let leftResult = parseConstraintAnd(tokens);
    if (!leftResult.success) return leftResult;
    let left = leftResult.value;
    let rest = leftResult.remaining;
    // Parse or chains
    while(rest.length > 0 && rest[0].type === "KEYWORD" && rest[0].value === "or"){
        rest = rest.slice(1);
        const rightResult = parseConstraintAnd(rest);
        if (!rightResult.success) return rightResult;
        left = {
            kind: "or",
            left,
            right: rightResult.value
        };
        rest = rightResult.remaining;
    }
    return {
        success: true,
        value: left,
        remaining: rest
    };
};
const parseConstraintAnd = (tokens)=>{
    let leftResult = parseAtomicConstraint(tokens);
    if (!leftResult.success) return leftResult;
    let left = leftResult.value;
    let rest = leftResult.remaining;
    while(rest.length > 0 && rest[0].type === "KEYWORD" && rest[0].value === "and"){
        rest = rest.slice(1);
        const rightResult = parseAtomicConstraint(rest);
        if (!rightResult.success) return rightResult;
        left = {
            kind: "and",
            left,
            right: rightResult.value
        };
        rest = rightResult.remaining;
    }
    return {
        success: true,
        value: left,
        remaining: rest
    };
};
// --- Expression with type annotation (just above semicolon) ---
const parseExprWithType = _combinators.choice(// Expression with type and constraints: expr : type given constraintExpr
_combinators.map(_combinators.seq(parseThrush, _combinators.punctuation(":"), _combinators.lazy(()=>parseTypeExpression), _combinators.keyword("given"), parseConstraintExpr), ([expr, colon, type, given, constraint])=>({
        kind: "constrained",
        expression: expr,
        type,
        constraint,
        location: expr.location
    })), // Expression with just type: expr : type
_combinators.map(_combinators.seq(parseThrush, _combinators.punctuation(":"), _combinators.lazy(()=>parseTypeExpression)), ([expr, colon, type])=>({
        kind: "typed",
        expression: expr,
        type,
        location: expr.location
    })), parseThrush // Fallback to regular expressions
);
// --- Sequence (semicolon) ---
// Accepts a sequence of definitions and/or expressions, separated by semicolons
const parseSequence = _combinators.map(_combinators.seq(_combinators.lazy(()=>parseSequenceTermWithIf), _combinators.many(_combinators.seq(_combinators.punctuation(";"), _combinators.lazy(()=>parseSequenceTermWithIf)))), ([left, rest])=>{
    let result = left;
    for (const [op, right] of rest){
        result = {
            kind: "binary",
            operator: ";",
            left: result,
            right,
            location: result.location
        };
    }
    return result;
});
// --- Expression (top-level) ---
const parseExpr = parseSequence;
const parse = (tokens)=>{
    // Filter out EOF tokens for parsing
    const nonEOFTokens = tokens.filter((t)=>t.type !== "EOF");
    // Parse multiple top-level expressions separated by semicolons
    let statements = [];
    let rest = nonEOFTokens;
    while(rest.length > 0){
        // Skip leading semicolons
        while(rest.length > 0 && rest[0].type === "PUNCTUATION" && rest[0].value === ";"){
            rest = rest.slice(1);
        }
        if (rest.length === 0) break;
        const result = parseExpr(rest);
        if (!result.success) {
            // Include line and column information in parse error
            const errorLocation = result.position > 0 ? ` at line ${result.position}` : "";
            throw new Error(`Parse error: ${result.error}${errorLocation}`);
        }
        statements.push(result.value);
        rest = result.remaining;
        // Skip trailing semicolons after each statement
        while(rest.length > 0 && rest[0].type === "PUNCTUATION" && rest[0].value === ";"){
            rest = rest.slice(1);
        }
    }
    // If there are still leftover tokens that aren't semicolons or EOF, throw an error
    if (rest.length > 0) {
        const next = rest[0];
        throw new Error(`Unexpected token after expression: ${next.type} '${next.value}' at line ${next.location.start.line}, column ${next.location.start.column}`);
    }
    return {
        statements,
        location: (0, _ast.createLocation)({
            line: 1,
            column: 1
        }, {
            line: 1,
            column: 1
        })
    };
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Uvc3JjL3BhcnNlci9wYXJzZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBUb2tlbiB9IGZyb20gXCIuLi9sZXhlclwiO1xuaW1wb3J0IHtcblx0dHlwZSBFeHByZXNzaW9uLFxuXHR0eXBlIFByb2dyYW0sXG5cdHR5cGUgTGl0ZXJhbEV4cHJlc3Npb24sXG5cdHR5cGUgVmFyaWFibGVFeHByZXNzaW9uLFxuXHR0eXBlIEZ1bmN0aW9uRXhwcmVzc2lvbixcblx0Y3JlYXRlTG9jYXRpb24sXG5cdHR5cGUgRGVmaW5pdGlvbkV4cHJlc3Npb24sXG5cdHR5cGUgTXV0YWJsZURlZmluaXRpb25FeHByZXNzaW9uLFxuXHR0eXBlIEltcG9ydEV4cHJlc3Npb24sXG5cdHR5cGUgQWNjZXNzb3JFeHByZXNzaW9uLFxuXHR0eXBlIFR5cGUsXG5cdHR5cGUgRWZmZWN0LFxuXHRpbnRUeXBlLFxuXHRzdHJpbmdUeXBlLFxuXHR1bml0VHlwZSxcblx0bGlzdFR5cGVXaXRoRWxlbWVudCxcblx0ZnVuY3Rpb25UeXBlLFxuXHR0eXBlVmFyaWFibGUsXG5cdHR5cGUgVHlwZWRFeHByZXNzaW9uLFxuXHR0eXBlIENvbnN0cmFpbmVkRXhwcmVzc2lvbixcblx0dHlwZSBMaXN0RXhwcmVzc2lvbixcblx0dHlwZSBXaGVyZUV4cHJlc3Npb24sXG5cdHJlY29yZFR5cGUsXG5cdHR1cGxlVHlwZSxcblx0dHVwbGVUeXBlQ29uc3RydWN0b3IsXG5cdHR5cGUgQ29uc3RyYWludEV4cHIsXG5cdHR5cGUgVHlwZURlZmluaXRpb25FeHByZXNzaW9uLFxuXHR0eXBlIE1hdGNoRXhwcmVzc2lvbixcblx0dHlwZSBDb25zdHJ1Y3RvckRlZmluaXRpb24sXG5cdHR5cGUgUGF0dGVybixcblx0dHlwZSBNYXRjaENhc2UsXG5cdHR5cGUgVW5pdEV4cHJlc3Npb24sXG5cdHR5cGUgUmVjb3JkRXhwcmVzc2lvbixcblx0dHlwZSBUdXBsZUV4cHJlc3Npb24sXG5cdHR5cGUgQ29uc3RyYWludERlZmluaXRpb25FeHByZXNzaW9uLFxuXHR0eXBlIEltcGxlbWVudERlZmluaXRpb25FeHByZXNzaW9uLFxuXHR0eXBlIENvbnN0cmFpbnRGdW5jdGlvbixcblx0dHlwZSBJbXBsZW1lbnRhdGlvbkZ1bmN0aW9uLFxufSBmcm9tICcuLi9hc3QnO1xuaW1wb3J0ICogYXMgQyBmcm9tIFwiLi9jb21iaW5hdG9yc1wiO1xuXG4vLyAtLS0gSGVscGVyOiBwYXJzZSB0eXBlIG5hbWUgKElERU5USUZJRVIgb3IgdHlwZS1yZWxhdGVkIEtFWVdPUkQpIC0tLVxuY29uc3QgcGFyc2VUeXBlTmFtZTogQy5QYXJzZXI8VG9rZW4+ID0gKHRva2VuczogVG9rZW5bXSkgPT4ge1xuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBcIkV4cGVjdGVkIHR5cGUgbmFtZSwgYnV0IGdvdCBlbmQgb2YgaW5wdXRcIixcbiAgICAgIHBvc2l0aW9uOiAwLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBbZmlyc3QsIC4uLnJlc3RdID0gdG9rZW5zO1xuICBjb25zdCB0eXBlS2V5d29yZHMgPSBbXCJJbnRcIiwgXCJOdW1iZXJcIiwgXCJTdHJpbmdcIiwgXCJVbml0XCIsIFwiTGlzdFwiXTtcblxuICBpZiAoXG4gICAgZmlyc3QudHlwZSA9PT0gXCJJREVOVElGSUVSXCIgfHxcbiAgICAoZmlyc3QudHlwZSA9PT0gXCJLRVlXT1JEXCIgJiYgdHlwZUtleXdvcmRzLmluY2x1ZGVzKGZpcnN0LnZhbHVlKSlcbiAgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICB2YWx1ZTogZmlyc3QsXG4gICAgICByZW1haW5pbmc6IHJlc3QsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogZmFsc2UsXG4gICAgZXJyb3I6IGBFeHBlY3RlZCB0eXBlIG5hbWUsIGJ1dCBnb3QgJHtmaXJzdC50eXBlfSAnJHtmaXJzdC52YWx1ZX0nYCxcbiAgICBwb3NpdGlvbjogZmlyc3QubG9jYXRpb24uc3RhcnQubGluZSxcbiAgfTtcbn07XG5cbi8vIC0tLSBIZWxwZXI6IHBhcnNlIGEgc2luZ2xlIHR5cGUgYXRvbSAocHJpbWl0aXZlLCB2YXJpYWJsZSwgcmVjb3JkLCB0dXBsZSwgbGlzdCkgLS0tXG5mdW5jdGlvbiBwYXJzZVR5cGVBdG9tKHRva2VuczogVG9rZW5bXSk6IEMuUGFyc2VSZXN1bHQ8VHlwZT4ge1xuICAvLyBUcnkgcHJpbWl0aXZlIHR5cGVzIGZpcnN0LCBidXQgaGFuZGxlIExpc3QgYXMgYSBwYXJhbWV0ZXJpemFibGUgdHlwZSBjb25zdHJ1Y3RvclxuICBjb25zdCBwcmltaXRpdmVUeXBlcyA9IFtcIkludFwiLCBcIk51bWJlclwiLCBcIlN0cmluZ1wiLCBcIlVuaXRcIl07XG4gIGZvciAoY29uc3QgdHlwZU5hbWUgb2YgcHJpbWl0aXZlVHlwZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBDLmtleXdvcmQodHlwZU5hbWUpKHRva2Vucyk7XG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVOYW1lKSB7XG4gICAgICAgIGNhc2UgXCJJbnRcIjpcbiAgICAgICAgY2FzZSBcIk51bWJlclwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlIGFzIGNvbnN0LFxuICAgICAgICAgICAgdmFsdWU6IGludFR5cGUoKSxcbiAgICAgICAgICAgIHJlbWFpbmluZzogcmVzdWx0LnJlbWFpbmluZyxcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiU3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUgYXMgY29uc3QsXG4gICAgICAgICAgICB2YWx1ZTogc3RyaW5nVHlwZSgpLFxuICAgICAgICAgICAgcmVtYWluaW5nOiByZXN1bHQucmVtYWluaW5nLFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJVbml0XCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUgYXMgY29uc3QsXG4gICAgICAgICAgICB2YWx1ZTogdW5pdFR5cGUoKSxcbiAgICAgICAgICAgIHJlbWFpbmluZzogcmVzdWx0LnJlbWFpbmluZyxcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRyeSBMaXN0IGFzIGEgcGFyYW1ldGVyaXphYmxlIHR5cGUgY29uc3RydWN0b3JcbiAgY29uc3QgbGlzdEtleXdvcmRSZXN1bHQgPSBDLmtleXdvcmQoXCJMaXN0XCIpKHRva2Vucyk7XG4gIGlmIChsaXN0S2V5d29yZFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgLy8gVHJ5IHRvIHBhcnNlIGEgdHlwZSBhcmd1bWVudCBmb3IgTGlzdFxuICAgIGNvbnN0IGFyZ1Jlc3VsdCA9IEMubGF6eSgoKSA9PiBwYXJzZVR5cGVBdG9tKShsaXN0S2V5d29yZFJlc3VsdC5yZW1haW5pbmcpO1xuICAgIGlmIChhcmdSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgLy8gTGlzdCB3aXRoIHNwZWNpZmljIGVsZW1lbnQgdHlwZTogTGlzdCBOdW1iZXIsIExpc3QgU3RyaW5nLCBldGMuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlIGFzIGNvbnN0LFxuICAgICAgICB2YWx1ZTogbGlzdFR5cGVXaXRoRWxlbWVudChhcmdSZXN1bHQudmFsdWUpLFxuICAgICAgICByZW1haW5pbmc6IGFyZ1Jlc3VsdC5yZW1haW5pbmcsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBKdXN0IExpc3QgKGdlbmVyaWMpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlIGFzIGNvbnN0LFxuICAgICAgICB2YWx1ZTogbGlzdFR5cGVXaXRoRWxlbWVudCh0eXBlVmFyaWFibGUoXCJhXCIpKSxcbiAgICAgICAgcmVtYWluaW5nOiBsaXN0S2V5d29yZFJlc3VsdC5yZW1haW5pbmcsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG5cblxuICAvLyBUcnkgcmVjb3JkIHR5cGVcbiAgY29uc3QgcmVjb3JkUmVzdWx0ID0gQy5zZXEoXG4gICAgQy5wdW5jdHVhdGlvbihcIntcIiksXG4gICAgQy5vcHRpb25hbChcbiAgICAgIEMuc2VwQnkoXG4gICAgICAgIEMubWFwKFxuICAgICAgICAgIEMuc2VxKFxuICAgICAgICAgICAgQy5pZGVudGlmaWVyKCksXG4gICAgICAgICAgICBDLnB1bmN0dWF0aW9uKFwiOlwiKSxcbiAgICAgICAgICAgIEMubGF6eSgoKSA9PiBwYXJzZVR5cGVFeHByZXNzaW9uKVxuICAgICAgICAgICksXG4gICAgICAgICAgKFtuYW1lLCBjb2xvbiwgdHlwZV0pID0+IFtuYW1lLnZhbHVlLCB0eXBlXSBhcyBbc3RyaW5nLCBUeXBlXVxuICAgICAgICApLFxuICAgICAgICBDLnB1bmN0dWF0aW9uKFwiLFwiKVxuICAgICAgKVxuICAgICksXG4gICAgQy5wdW5jdHVhdGlvbihcIn1cIilcbiAgKSh0b2tlbnMpO1xuICBpZiAocmVjb3JkUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICBjb25zdCBmaWVsZHM6IEFycmF5PFtzdHJpbmcsIFR5cGVdPiA9IHJlY29yZFJlc3VsdC52YWx1ZVsxXSB8fCBbXTtcbiAgICBjb25zdCBmaWVsZE9iajogUmVjb3JkPHN0cmluZywgVHlwZT4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB0eXBlXSBvZiBmaWVsZHMpIHtcbiAgICAgIGZpZWxkT2JqW25hbWVdID0gdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUgYXMgY29uc3QsXG4gICAgICB2YWx1ZTogcmVjb3JkVHlwZShmaWVsZE9iaiksXG4gICAgICByZW1haW5pbmc6IHJlY29yZFJlc3VsdC5yZW1haW5pbmcsXG4gICAgfTtcbiAgfVxuXG4gIC8vIFRyeSB0dXBsZSB0eXBlXG4gIGNvbnN0IHR1cGxlUmVzdWx0ID0gQy5zZXEoXG4gICAgQy5wdW5jdHVhdGlvbihcIntcIiksXG4gICAgQy5vcHRpb25hbChcbiAgICAgIEMuc2VwQnkoXG4gICAgICAgIEMubGF6eSgoKSA9PiBwYXJzZVR5cGVFeHByZXNzaW9uKSxcbiAgICAgICAgQy5wdW5jdHVhdGlvbihcIixcIilcbiAgICAgIClcbiAgICApLFxuICAgIEMucHVuY3R1YXRpb24oXCJ9XCIpXG4gICkodG9rZW5zKTtcbiAgaWYgKHR1cGxlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHR1cGxlUmVzdWx0LnZhbHVlWzFdIHx8IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlIGFzIGNvbnN0LFxuICAgICAgdmFsdWU6IHR1cGxlVHlwZShlbGVtZW50cyksXG4gICAgICByZW1haW5pbmc6IHR1cGxlUmVzdWx0LnJlbWFpbmluZyxcbiAgICB9O1xuICB9XG5cbiAgLy8gVHJ5IExpc3QgdHlwZVxuICBjb25zdCBsaXN0UmVzdWx0ID0gQy5zZXEoXG4gICAgQy5rZXl3b3JkKFwiTGlzdFwiKSxcbiAgICBDLmxhenkoKCkgPT4gcGFyc2VUeXBlRXhwcmVzc2lvbilcbiAgKSh0b2tlbnMpO1xuICBpZiAobGlzdFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUgYXMgY29uc3QsXG4gICAgICB2YWx1ZTogbGlzdFR5cGVXaXRoRWxlbWVudChsaXN0UmVzdWx0LnZhbHVlWzFdKSxcbiAgICAgIHJlbWFpbmluZzogbGlzdFJlc3VsdC5yZW1haW5pbmcsXG4gICAgfTtcbiAgfVxuXG4gIC8vIFRyeSBUdXBsZSB0eXBlIGNvbnN0cnVjdG9yOiBUdXBsZSBUMSBUMiBUM1xuICBpZiAoXG4gICAgdG9rZW5zLmxlbmd0aCA+IDAgJiZcbiAgICB0b2tlbnNbMF0udHlwZSA9PT0gXCJJREVOVElGSUVSXCIgJiZcbiAgICB0b2tlbnNbMF0udmFsdWUgPT09IFwiVHVwbGVcIlxuICApIHtcbiAgICBjb25zdCB0dXBsZUNvbnN0cnVjdG9yUmVzdWx0ID0gQy5zZXEoXG4gICAgICBDLmlkZW50aWZpZXIoKSxcbiAgICAgIEMubWFueShDLmxhenkoKCkgPT4gcGFyc2VUeXBlRXhwcmVzc2lvbikpXG4gICAgKSh0b2tlbnMpO1xuICAgIGlmICh0dXBsZUNvbnN0cnVjdG9yUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRUeXBlcyA9IHR1cGxlQ29uc3RydWN0b3JSZXN1bHQudmFsdWVbMV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlIGFzIGNvbnN0LFxuICAgICAgICB2YWx1ZTogdHVwbGVUeXBlQ29uc3RydWN0b3IoZWxlbWVudFR5cGVzKSxcbiAgICAgICAgcmVtYWluaW5nOiB0dXBsZUNvbnN0cnVjdG9yUmVzdWx0LnJlbWFpbmluZyxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gVHJ5IHBhcmVudGhlc2l6ZWQgdHlwZTogKFR5cGUpXG4gIGNvbnN0IHBhcmVuUmVzdWx0ID0gQy5zZXEoXG4gICAgQy5wdW5jdHVhdGlvbihcIihcIiksXG4gICAgQy5sYXp5KCgpID0+IHBhcnNlVHlwZUV4cHJlc3Npb24pLFxuICAgIEMucHVuY3R1YXRpb24oXCIpXCIpXG4gICkodG9rZW5zKTtcbiAgaWYgKHBhcmVuUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSBhcyBjb25zdCxcbiAgICAgIHZhbHVlOiBwYXJlblJlc3VsdC52YWx1ZVsxXSxcbiAgICAgIHJlbWFpbmluZzogcGFyZW5SZXN1bHQucmVtYWluaW5nLFxuICAgIH07XG4gIH1cblxuXG5cbiAgLy8gVHJ5IHVwcGVyY2FzZSB0eXBlIGNvbnN0cnVjdG9yOiBUeXBlTmFtZSBhcmcxIGFyZzIgLi4uIChwcmVzZXJ2ZSBvcmlnaW5hbCBsb2dpYylcbiAgaWYgKFxuICAgIHRva2Vucy5sZW5ndGggPiAwICYmXG4gICAgdG9rZW5zWzBdLnR5cGUgPT09IFwiSURFTlRJRklFUlwiICYmXG4gICAgL15bQS1aXS8udGVzdCh0b2tlbnNbMF0udmFsdWUpXG4gICkge1xuICAgIGNvbnN0IHR5cGVOYW1lUmVzdWx0ID0gQy5pZGVudGlmaWVyKCkodG9rZW5zKTtcbiAgICBpZiAodHlwZU5hbWVSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgLy8gVHJ5IHRvIHBhcnNlIHR5cGUgYXJndW1lbnRzXG4gICAgICBjb25zdCBhcmdzUmVzdWx0ID0gQy5tYW55KEMubGF6eSgoKSA9PiBwYXJzZVR5cGVBdG9tKSkoXG4gICAgICAgIHR5cGVOYW1lUmVzdWx0LnJlbWFpbmluZ1xuICAgICAgKTtcbiAgICAgIGlmIChhcmdzUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlIGFzIGNvbnN0LFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBraW5kOiBcInZhcmlhbnRcIixcbiAgICAgICAgICAgIG5hbWU6IHR5cGVOYW1lUmVzdWx0LnZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgYXJnczogYXJnc1Jlc3VsdC52YWx1ZSxcbiAgICAgICAgICB9IGFzIFR5cGUsXG4gICAgICAgICAgcmVtYWluaW5nOiBhcmdzUmVzdWx0LnJlbWFpbmluZyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUcnkgdHlwZSB2YXJpYWJsZSBvciBzaW1wbGUgaWRlbnRpZmllclxuICBpZiAodG9rZW5zLmxlbmd0aCA+IDAgJiYgdG9rZW5zWzBdLnR5cGUgPT09IFwiSURFTlRJRklFUlwiKSB7XG4gICAgY29uc3QgaWRlbnRpZmllclJlc3VsdCA9IEMuaWRlbnRpZmllcigpKHRva2Vucyk7XG4gICAgaWYgKGlkZW50aWZpZXJSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSBhcyBjb25zdCxcbiAgICAgICAgdmFsdWU6IHR5cGVWYXJpYWJsZShpZGVudGlmaWVyUmVzdWx0LnZhbHVlLnZhbHVlKSxcbiAgICAgICAgcmVtYWluaW5nOiBpZGVudGlmaWVyUmVzdWx0LnJlbWFpbmluZyxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICBlcnJvcjogXCJFeHBlY3RlZCB0eXBlIGF0b21cIixcbiAgICBwb3NpdGlvbjogdG9rZW5zWzBdPy5sb2NhdGlvbi5zdGFydC5saW5lIHx8IDAsXG4gIH07XG59XG5cblxuXG4vLyAtLS0gVHlwZSBFeHByZXNzaW9uIC0tLVxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGZ1bmN0aW9uIHR5cGVzIHdpdGhvdXQgdG9wLWxldmVsIGVmZmVjdHNcbmNvbnN0IHBhcnNlRnVuY3Rpb25UeXBlV2l0aG91dEVmZmVjdHM6IEMuUGFyc2VyPFR5cGU+ID0gKHRva2VucykgPT4ge1xuICBsZXQgbGVmdFJlc3VsdCA9IHBhcnNlVHlwZUF0b20odG9rZW5zKTtcbiAgaWYgKCFsZWZ0UmVzdWx0LnN1Y2Nlc3MpIHJldHVybiBsZWZ0UmVzdWx0O1xuICBsZXQgbGVmdCA9IGxlZnRSZXN1bHQudmFsdWU7XG4gIGxldCByZXN0ID0gbGVmdFJlc3VsdC5yZW1haW5pbmc7XG5cbiAgd2hpbGUgKFxuICAgIHJlc3QgJiZcbiAgICByZXN0Lmxlbmd0aCA+IDAgJiZcbiAgICByZXN0WzBdLnR5cGUgPT09IFwiT1BFUkFUT1JcIiAmJlxuICAgIHJlc3RbMF0udmFsdWUgPT09IFwiLT5cIlxuICApIHtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgxKTtcbiAgICBjb25zdCByaWdodFJlc3VsdCA9IHBhcnNlRnVuY3Rpb25UeXBlV2l0aG91dEVmZmVjdHMocmVzdCk7XG4gICAgaWYgKCFyaWdodFJlc3VsdC5zdWNjZXNzKSByZXR1cm4gcmlnaHRSZXN1bHQ7XG4gICAgaWYgKCFyaWdodFJlc3VsdC52YWx1ZSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogXCJFeHBlY3RlZCB0eXBlIGV4cHJlc3Npb25cIixcbiAgICAgICAgcG9zaXRpb246IHRva2Vuc1swXT8ubG9jYXRpb24uc3RhcnQubGluZSB8fCAwLFxuICAgICAgfTtcbiAgICBcbiAgICBsZWZ0ID0gZnVuY3Rpb25UeXBlKFtsZWZ0XSwgcmlnaHRSZXN1bHQudmFsdWUpO1xuICAgIHJlc3QgPSByaWdodFJlc3VsdC5yZW1haW5pbmc7XG4gIH1cbiAgXG4gIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgYXMgY29uc3QsIHZhbHVlOiBsZWZ0LCByZW1haW5pbmc6IHJlc3QgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVR5cGVFeHByZXNzaW9uOiBDLlBhcnNlcjxUeXBlPiA9ICh0b2tlbnMpID0+IHtcbiAgLy8gVHJ5IGZ1bmN0aW9uIHR5cGUgKHJpZ2h0LWFzc29jaWF0aXZlKTogYSAtPiBiIC0+IGMgRklSU1RcbiAgY29uc3QgZnVuY1R5cGUgPSAoKCkgPT4ge1xuICAgIGxldCBsZWZ0UmVzdWx0ID0gcGFyc2VUeXBlQXRvbSh0b2tlbnMpO1xuICAgIGlmICghbGVmdFJlc3VsdC5zdWNjZXNzKSByZXR1cm4gbGVmdFJlc3VsdDtcbiAgICBsZXQgbGVmdCA9IGxlZnRSZXN1bHQudmFsdWU7XG4gICAgbGV0IHJlc3QgPSBsZWZ0UmVzdWx0LnJlbWFpbmluZztcblxuICAgIHdoaWxlIChcbiAgICAgIHJlc3QgJiZcbiAgICAgIHJlc3QubGVuZ3RoID4gMCAmJlxuICAgICAgcmVzdFswXS50eXBlID09PSBcIk9QRVJBVE9SXCIgJiZcbiAgICAgIHJlc3RbMF0udmFsdWUgPT09IFwiLT5cIlxuICAgICkge1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMSk7XG4gICAgICBjb25zdCByaWdodFJlc3VsdCA9IHBhcnNlRnVuY3Rpb25UeXBlV2l0aG91dEVmZmVjdHMocmVzdCk7XG4gICAgICBpZiAoIXJpZ2h0UmVzdWx0LnN1Y2Nlc3MpIHJldHVybiByaWdodFJlc3VsdDtcbiAgICAgIGlmICghcmlnaHRSZXN1bHQudmFsdWUpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgdHlwZSBleHByZXNzaW9uXCIsXG4gICAgICAgICAgcG9zaXRpb246IHRva2Vuc1swXT8ubG9jYXRpb24uc3RhcnQubGluZSB8fCAwLFxuICAgICAgICB9O1xuICAgICAgXG4gICAgICBsZWZ0ID0gZnVuY3Rpb25UeXBlKFtsZWZ0XSwgcmlnaHRSZXN1bHQudmFsdWUpO1xuICAgICAgcmVzdCA9IHJpZ2h0UmVzdWx0LnJlbWFpbmluZztcbiAgICB9XG4gICAgXG4gICAgLy8gUGFyc2UgZWZmZWN0cyBhdCB0aGUgZW5kIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdHlwZSBjaGFpblxuICAgIGxldCBlZmZlY3RzID0gbmV3IFNldDxFZmZlY3Q+KCk7XG4gICAgbGV0IGVmZmVjdFJlc3QgPSByZXN0O1xuICAgIFxuICAgIC8vIFBhcnNlIGVmZmVjdHM6ICFlZmZlY3QxICFlZmZlY3QyIC4uLlxuICAgIHdoaWxlIChcbiAgICAgIGVmZmVjdFJlc3QgJiZcbiAgICAgIGVmZmVjdFJlc3QubGVuZ3RoID4gMCAmJlxuICAgICAgZWZmZWN0UmVzdFswXS50eXBlID09PSBcIk9QRVJBVE9SXCIgJiZcbiAgICAgIGVmZmVjdFJlc3RbMF0udmFsdWUgPT09IFwiIVwiXG4gICAgKSB7XG4gICAgICBlZmZlY3RSZXN0ID0gZWZmZWN0UmVzdC5zbGljZSgxKTsgLy8gY29uc3VtZSAhXG4gICAgICBcbiAgICAgIC8vIEV4cGVjdCBhbiBlZmZlY3QgbmFtZSAoaWRlbnRpZmllciBvciBrZXl3b3JkKVxuICAgICAgaWYgKFxuICAgICAgICAhZWZmZWN0UmVzdCB8fFxuICAgICAgICBlZmZlY3RSZXN0Lmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAoZWZmZWN0UmVzdFswXS50eXBlICE9PSBcIklERU5USUZJRVJcIiAmJiBlZmZlY3RSZXN0WzBdLnR5cGUgIT09IFwiS0VZV09SRFwiKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgZWZmZWN0IG5hbWUgYWZ0ZXIgIVwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBlZmZlY3RSZXN0Py5bMF0/LmxvY2F0aW9uPy5zdGFydD8ubGluZSB8fCAwLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBlZmZlY3ROYW1lID0gZWZmZWN0UmVzdFswXS52YWx1ZTtcbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgZWZmZWN0IG5hbWVcbiAgICAgIGNvbnN0IHZhbGlkRWZmZWN0czogRWZmZWN0W10gPSBbXCJsb2dcIiwgXCJyZWFkXCIsIFwid3JpdGVcIiwgXCJzdGF0ZVwiLCBcInRpbWVcIiwgXCJyYW5kXCIsIFwiZmZpXCIsIFwiYXN5bmNcIl07XG4gICAgICBpZiAoIXZhbGlkRWZmZWN0cy5pbmNsdWRlcyhlZmZlY3ROYW1lIGFzIEVmZmVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogYEludmFsaWQgZWZmZWN0OiAke2VmZmVjdE5hbWV9LiBWYWxpZCBlZmZlY3RzOiAke3ZhbGlkRWZmZWN0cy5qb2luKFwiLCBcIil9YCxcbiAgICAgICAgICBwb3NpdGlvbjogZWZmZWN0UmVzdFswXS5sb2NhdGlvbi5zdGFydC5saW5lLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBlZmZlY3RzLmFkZChlZmZlY3ROYW1lIGFzIEVmZmVjdCk7XG4gICAgICBlZmZlY3RSZXN0ID0gZWZmZWN0UmVzdC5zbGljZSgxKTsgLy8gY29uc3VtZSBlZmZlY3QgbmFtZVxuICAgIH1cbiAgICBcbiAgICAvLyBBcHBseSBlZmZlY3RzIHRvIHRoZSBmdW5jdGlvbiB0eXBlIChpbmNsdWRpbmcgZW1wdHkgZWZmZWN0cylcbiAgICBpZiAobGVmdC5raW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsZWZ0ID0geyAuLi5sZWZ0LCBlZmZlY3RzIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgYXMgY29uc3QsIHZhbHVlOiBsZWZ0LCByZW1haW5pbmc6IGVmZmVjdFJlc3QgfTtcbiAgfSkoKTtcblxuICBpZiAoZnVuY1R5cGUuc3VjY2VzcyAmJiBmdW5jVHlwZS52YWx1ZSkge1xuICAgIHJldHVybiBmdW5jVHlwZTtcbiAgfVxuICBcbiAgLy8gSWYgZnVuY3Rpb24gdHlwZSBwYXJzaW5nIGZhaWxlZCB3aXRoIGEgc3BlY2lmaWMgZWZmZWN0IGVycm9yLCByZXR1cm4gdGhhdCBlcnJvclxuICBpZiAoIWZ1bmNUeXBlLnN1Y2Nlc3MgJiYgKFxuICAgIGZ1bmNUeXBlLmVycm9yLmluY2x1ZGVzKFwiSW52YWxpZCBlZmZlY3Q6XCIpIHx8IFxuICAgIGZ1bmNUeXBlLmVycm9yLmluY2x1ZGVzKFwiRXhwZWN0ZWQgZWZmZWN0IG5hbWUgYWZ0ZXIgIVwiKVxuICApKSB7XG4gICAgcmV0dXJuIGZ1bmNUeXBlIGFzIEMuUGFyc2VFcnJvcjtcbiAgfVxuXG4gIC8vIFRyeSB0eXBlIHZhcmlhYmxlIChsb3dlcmNhc2UgaWRlbnRpZmllcilcbiAgaWYgKFxuICAgIHRva2Vucy5sZW5ndGggPiAwICYmXG4gICAgdG9rZW5zWzBdLnR5cGUgPT09IFwiSURFTlRJRklFUlwiICYmXG4gICAgL15bYS16XS8udGVzdCh0b2tlbnNbMF0udmFsdWUpXG4gICkge1xuICAgIGNvbnN0IHZhclJlc3VsdCA9IEMuaWRlbnRpZmllcigpKHRva2Vucyk7XG4gICAgaWYgKHZhclJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlIGFzIGNvbnN0LFxuICAgICAgICB2YWx1ZTogdHlwZVZhcmlhYmxlKHZhclJlc3VsdC52YWx1ZS52YWx1ZSksXG4gICAgICAgIHJlbWFpbmluZzogdmFyUmVzdWx0LnJlbWFpbmluZyxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gVHJ5IHJlY29yZCB0eXBlOiB7IG5hbWU6IFN0cmluZywgYWdlOiBOdW1iZXIgfVxuICBjb25zdCByZWNvcmRSZXN1bHQgPSBDLnNlcShcbiAgICBDLnB1bmN0dWF0aW9uKFwie1wiKSxcbiAgICBDLm9wdGlvbmFsKFxuICAgICAgQy5zZXBCeShcbiAgICAgICAgQy5tYXAoXG4gICAgICAgICAgQy5zZXEoXG4gICAgICAgICAgICBDLmlkZW50aWZpZXIoKSxcbiAgICAgICAgICAgIEMucHVuY3R1YXRpb24oXCI6XCIpLFxuICAgICAgICAgICAgQy5sYXp5KCgpID0+IHBhcnNlVHlwZUV4cHJlc3Npb24pXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoW25hbWUsIGNvbG9uLCB0eXBlXSkgPT4gW25hbWUudmFsdWUsIHR5cGVdIGFzIFtzdHJpbmcsIFR5cGVdXG4gICAgICAgICksXG4gICAgICAgIEMucHVuY3R1YXRpb24oXCIsXCIpXG4gICAgICApXG4gICAgKSxcbiAgICBDLnB1bmN0dWF0aW9uKFwifVwiKVxuICApKHRva2Vucyk7XG4gIGlmIChyZWNvcmRSZXN1bHQuc3VjY2Vzcykge1xuICAgIGNvbnN0IGZpZWxkczogQXJyYXk8W3N0cmluZywgVHlwZV0+ID0gcmVjb3JkUmVzdWx0LnZhbHVlWzFdIHx8IFtdO1xuICAgIGNvbnN0IGZpZWxkT2JqOiBSZWNvcmQ8c3RyaW5nLCBUeXBlPiA9IHt9O1xuICAgIGZvciAoY29uc3QgW25hbWUsIHR5cGVdIG9mIGZpZWxkcykge1xuICAgICAgZmllbGRPYmpbbmFtZV0gPSB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSBhcyBjb25zdCxcbiAgICAgIHZhbHVlOiByZWNvcmRUeXBlKGZpZWxkT2JqKSxcbiAgICAgIHJlbWFpbmluZzogcmVjb3JkUmVzdWx0LnJlbWFpbmluZyxcbiAgICB9O1xuICB9XG5cbiAgLy8gVHJ5IHR1cGxlIHR5cGU6IHsgTnVtYmVyLCBTdHJpbmcgfVxuICBjb25zdCB0dXBsZVJlc3VsdCA9IEMuc2VxKFxuICAgIEMucHVuY3R1YXRpb24oXCJ7XCIpLFxuICAgIEMub3B0aW9uYWwoXG4gICAgICBDLnNlcEJ5KFxuICAgICAgICBDLmxhenkoKCkgPT4gcGFyc2VUeXBlRXhwcmVzc2lvbiksXG4gICAgICAgIEMucHVuY3R1YXRpb24oXCIsXCIpXG4gICAgICApXG4gICAgKSxcbiAgICBDLnB1bmN0dWF0aW9uKFwifVwiKVxuICApKHRva2Vucyk7XG4gIGlmICh0dXBsZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0dXBsZVJlc3VsdC52YWx1ZVsxXSB8fCBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSBhcyBjb25zdCxcbiAgICAgIHZhbHVlOiB0dXBsZVR5cGUoZWxlbWVudHMpLFxuICAgICAgcmVtYWluaW5nOiB0dXBsZVJlc3VsdC5yZW1haW5pbmcsXG4gICAgfTtcbiAgfVxuXG4gIC8vIFRyeSBMaXN0IHR5cGVcbiAgY29uc3QgbGlzdFJlc3VsdCA9IEMuc2VxKFxuICAgIEMua2V5d29yZChcIkxpc3RcIiksXG4gICAgQy5sYXp5KCgpID0+IHBhcnNlVHlwZUV4cHJlc3Npb24pXG4gICkodG9rZW5zKTtcbiAgaWYgKGxpc3RSZXN1bHQuc3VjY2Vzcykge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlIGFzIGNvbnN0LFxuICAgICAgdmFsdWU6IGxpc3RUeXBlV2l0aEVsZW1lbnQobGlzdFJlc3VsdC52YWx1ZVsxXSksXG4gICAgICByZW1haW5pbmc6IGxpc3RSZXN1bHQucmVtYWluaW5nLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgIGVycm9yOiBcIkV4cGVjdGVkIHR5cGUgZXhwcmVzc2lvblwiLFxuICAgIHBvc2l0aW9uOiB0b2tlbnNbMF0/LmxvY2F0aW9uLnN0YXJ0LmxpbmUgfHwgMCxcbiAgfTtcbn07XG4vLyAtLS0gQmFzaWMgUGFyc2VycyAtLS1cbmNvbnN0IHBhcnNlSWRlbnRpZmllciA9IEMubWFwKFxuICBDLmlkZW50aWZpZXIoKSxcbiAgKHRva2VuKTogVmFyaWFibGVFeHByZXNzaW9uID0+ICh7XG4gICAga2luZDogXCJ2YXJpYWJsZVwiLFxuICAgIG5hbWU6IHRva2VuLnZhbHVlLFxuICAgIGxvY2F0aW9uOiB0b2tlbi5sb2NhdGlvbixcbiAgfSlcbik7XG5cbmNvbnN0IHBhcnNlTnVtYmVyID0gQy5tYXAoXG4gIEMubnVtYmVyKCksXG4gICh0b2tlbik6IExpdGVyYWxFeHByZXNzaW9uID0+ICh7XG4gICAga2luZDogXCJsaXRlcmFsXCIsXG4gICAgdmFsdWU6IHBhcnNlRmxvYXQodG9rZW4udmFsdWUpLFxuICAgIGxvY2F0aW9uOiB0b2tlbi5sb2NhdGlvbixcbiAgfSlcbik7XG5cbmNvbnN0IHBhcnNlU3RyaW5nID0gQy5tYXAoXG4gIEMuc3RyaW5nKCksXG4gICh0b2tlbik6IExpdGVyYWxFeHByZXNzaW9uID0+ICh7XG4gICAga2luZDogXCJsaXRlcmFsXCIsXG4gICAgdmFsdWU6IHRva2VuLnZhbHVlLFxuICAgIGxvY2F0aW9uOiB0b2tlbi5sb2NhdGlvbixcbiAgfSlcbik7XG5cbmNvbnN0IHBhcnNlQWNjZXNzb3IgPSBDLm1hcChcbiAgQy5hY2Nlc3NvcigpLFxuICAodG9rZW4pOiBBY2Nlc3NvckV4cHJlc3Npb24gPT4gKHtcbiAgICBraW5kOiBcImFjY2Vzc29yXCIsXG4gICAgZmllbGQ6IHRva2VuLnZhbHVlLFxuICAgIGxvY2F0aW9uOiB0b2tlbi5sb2NhdGlvbixcbiAgfSlcbik7XG5cbi8vIC0tLSBSZWNvcmQgUGFyc2luZyAtLS1cbmNvbnN0IHBhcnNlUmVjb3JkRmllbGROYW1lID0gQy5tYXAoXG4gIEMuYWNjZXNzb3IoKSxcbiAgKHRva2VuKSA9PiB0b2tlbi52YWx1ZSAvLyBKdXN0IGdldCB0aGUgZmllbGQgbmFtZSB3aXRob3V0IEBcbik7XG5cbi8vIFBhcnNlIGFuIGV4cHJlc3Npb24gdGhhdCBzdG9wcyBhdCBAIChhY2Nlc3NvciB0b2tlbnMpIG9yIHNlbWljb2xvblxuY29uc3QgcGFyc2VSZWNvcmRGaWVsZFZhbHVlID0gKHRva2VuczogVG9rZW5bXSk6IEMuUGFyc2VSZXN1bHQ8RXhwcmVzc2lvbj4gPT4ge1xuICAvLyBVc2UgdGhlIGZ1bGwgZXhwcmVzc2lvbiBwYXJzZXIgdG8gcGFyc2UgdGhlIGNvbXBsZXRlIGV4cHJlc3Npb25cbiAgLy8gVGhpcyBpbmNsdWRlcyByZWNvcmRzLCBzbyB3ZSBjYW4gcGFyc2UgbmVzdGVkIHJlY29yZHNcbiAgY29uc3QgcmVzdWx0ID0gQy5sYXp5KCgpID0+IHBhcnNlU2VxdWVuY2UpKHRva2Vucyk7XG4gIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gVGhlIGV4cHJlc3Npb24gcGFyc2VyIHNob3VsZCBoYXZlIGNvbnN1bWVkIGFsbCB0aGUgdG9rZW5zIGl0IG5lZWRzXG4gIC8vIGFuZCBsZWZ0IHVzIHdpdGggdGhlIHJlbWFpbmluZyB0b2tlbnMgdGhhdCBjb21lIGFmdGVyIHRoZSBleHByZXNzaW9uXG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgIHJlbWFpbmluZzogcmVzdWx0LnJlbWFpbmluZyxcbiAgfTtcbn07XG5cbmNvbnN0IHBhcnNlUmVjb3JkRmllbGQgPSBDLm1hcChcbiAgQy5zZXEocGFyc2VSZWNvcmRGaWVsZE5hbWUsIHBhcnNlUmVjb3JkRmllbGRWYWx1ZSksXG4gIChbZmllbGROYW1lLCB2YWx1ZV0pID0+ICh7XG4gICAgbmFtZTogZmllbGROYW1lLFxuICAgIHZhbHVlLFxuICAgIGlzTmFtZWQ6IHRydWUsXG4gIH0pXG4pO1xuXG4vLyBQYXJzZSBhIHNpbmdsZSByZWNvcmQgZmllbGQgKG5hbWVkIG9yIHBvc2l0aW9uYWwpXG5jb25zdCBwYXJzZVJlY29yZEZpZWxkT3JQb3NpdGlvbmFsID1cbiAgKFxuICAgIGluZGV4OiBudW1iZXJcbiAgKTogQy5QYXJzZXI8eyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBFeHByZXNzaW9uOyBpc05hbWVkOiBib29sZWFuIH0+ID0+XG4gICh0b2tlbnMpID0+IHtcbiAgICAvLyBUcnkgdG8gcGFyc2UgYXMgbmFtZWQgZmllbGQgZmlyc3QgKHdpdGggYWNjZXNzb3IpXG4gICAgY29uc3QgbmFtZWRGaWVsZFJlc3VsdCA9IHBhcnNlUmVjb3JkRmllbGQodG9rZW5zKTtcbiAgICBpZiAobmFtZWRGaWVsZFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5uYW1lZEZpZWxkUmVzdWx0LFxuICAgICAgICB2YWx1ZTogeyAuLi5uYW1lZEZpZWxkUmVzdWx0LnZhbHVlLCBpc05hbWVkOiB0cnVlIH0sXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBJZiB0aGF0IGZhaWxzLCB0cnkgdG8gcGFyc2UgYXMgcG9zaXRpb25hbCBmaWVsZCAoZXhwcmVzc2lvbiB3aXRob3V0IGFjY2Vzc29yKVxuICAgIGNvbnN0IHBvc2l0aW9uYWxGaWVsZFJlc3VsdCA9IHBhcnNlUmVjb3JkRmllbGRWYWx1ZSh0b2tlbnMpO1xuICAgIGlmIChwb3NpdGlvbmFsRmllbGRSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBuYW1lOiBgQCR7aW5kZXh9YCxcbiAgICAgICAgICB2YWx1ZTogcG9zaXRpb25hbEZpZWxkUmVzdWx0LnZhbHVlLFxuICAgICAgICAgIGlzTmFtZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICByZW1haW5pbmc6IHBvc2l0aW9uYWxGaWVsZFJlc3VsdC5yZW1haW5pbmcsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogXCJFeHBlY3RlZCByZWNvcmQgZmllbGQgKG5hbWVkIG9yIHBvc2l0aW9uYWwpXCIsXG4gICAgICBwb3NpdGlvbjogdG9rZW5zWzBdPy5sb2NhdGlvbi5zdGFydC5saW5lIHx8IDAsXG4gICAgfTtcbiAgfTtcblxuLy8gQ3VzdG9tIHBhcnNlciBmb3IgYSBzZXF1ZW5jZSBvZiBmaWVsZHMgc2VwYXJhdGVkIGJ5IHNlbWljb2xvbnNcbmNvbnN0IHBhcnNlUmVjb3JkRmllbGRzOiBDLlBhcnNlcjx7IG5hbWU6IHN0cmluZzsgdmFsdWU6IEV4cHJlc3Npb24gfVtdPiA9IChcbiAgdG9rZW5zXG4pID0+IHtcbiAgbGV0IGZpZWxkczogeyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBFeHByZXNzaW9uOyBpc05hbWVkOiBib29sZWFuIH1bXSA9IFtdO1xuICBsZXQgcmVzdCA9IHRva2VucztcbiAgLy8gUGFyc2UgZmlyc3QgZmllbGRcbiAgY29uc3QgZmlyc3RGaWVsZFJlc3VsdCA9IHBhcnNlUmVjb3JkRmllbGRPclBvc2l0aW9uYWwoMCkocmVzdCk7XG4gIGlmICghZmlyc3RGaWVsZFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIHJlY29yZCBmaWVsZFwiLFxuICAgICAgcG9zaXRpb246IHRva2Vuc1swXT8ubG9jYXRpb24uc3RhcnQubGluZSB8fCAwLFxuICAgIH07XG4gIH1cbiAgZmllbGRzLnB1c2goZmlyc3RGaWVsZFJlc3VsdC52YWx1ZSk7XG4gIHJlc3QgPSBmaXJzdEZpZWxkUmVzdWx0LnJlbWFpbmluZztcbiAgY29uc3QgaXNOYW1lZCA9IGZpcnN0RmllbGRSZXN1bHQudmFsdWUuaXNOYW1lZDtcbiAgLy8gUGFyc2UgYWRkaXRpb25hbCBmaWVsZHMsIGVhY2ggcHJlY2VkZWQgYnkgYSBjb21tYVxuICB3aGlsZSAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY29tbWFSZXN1bHQgPSBDLnB1bmN0dWF0aW9uKFwiLFwiKShyZXN0KTtcbiAgICBpZiAoIWNvbW1hUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGJyZWFrOyAvLyBObyBtb3JlIGNvbW1hcywgd2UncmUgZG9uZVxuICAgIH1cbiAgICByZXN0ID0gY29tbWFSZXN1bHQucmVtYWluaW5nO1xuICAgIGNvbnN0IGZpZWxkUmVzdWx0ID0gcGFyc2VSZWNvcmRGaWVsZE9yUG9zaXRpb25hbChmaWVsZHMubGVuZ3RoKShyZXN0KTtcbiAgICBpZiAoIWZpZWxkUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSB0cmFpbGluZyBjb21tYSAobm8gbW9yZSBmaWVsZHMgYWZ0ZXIgY29tbWEpXG4gICAgICAvLyBMb29rIGFoZWFkIHRvIHNlZSBpZiB0aGUgbmV4dCB0b2tlbiBpcyBhIGNsb3NpbmcgYnJhY2VcbiAgICAgIGlmIChcbiAgICAgICAgcmVzdC5sZW5ndGggPiAwICYmXG4gICAgICAgIHJlc3RbMF0udHlwZSA9PT0gXCJQVU5DVFVBVElPTlwiICYmXG4gICAgICAgIHJlc3RbMF0udmFsdWUgPT09IFwifVwiXG4gICAgICApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHRyYWlsaW5nIGNvbW1hLCB3aGljaCBpcyBhbGxvd2VkXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBcIkV4cGVjdGVkIGZpZWxkIGFmdGVyIGNvbW1hXCIsXG4gICAgICAgIHBvc2l0aW9uOiByZXN0WzBdPy5sb2NhdGlvbi5zdGFydC5saW5lIHx8IDAsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZmllbGRSZXN1bHQudmFsdWUuaXNOYW1lZCAhPT0gaXNOYW1lZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOlxuICAgICAgICAgIFwiQ2Fubm90IG1peCBuYW1lZCBhbmQgcG9zaXRpb25hbCBmaWVsZHMgaW4gdGhlIHNhbWUgcmVjb3JkL3R1cGxlXCIsXG4gICAgICAgIHBvc2l0aW9uOiByZXN0WzBdPy5sb2NhdGlvbi5zdGFydC5saW5lIHx8IDAsXG4gICAgICB9O1xuICAgIH1cbiAgICBmaWVsZHMucHVzaChmaWVsZFJlc3VsdC52YWx1ZSk7XG4gICAgcmVzdCA9IGZpZWxkUmVzdWx0LnJlbWFpbmluZztcbiAgfVxuICAvLyBSZW1vdmUgaXNOYW1lZCBiZWZvcmUgcmV0dXJuaW5nXG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICB2YWx1ZTogZmllbGRzLm1hcCgoeyBpc05hbWVkLCAuLi5yZXN0IH0pID0+IHJlc3QpLFxuICAgIHJlbWFpbmluZzogcmVzdCxcbiAgfTtcbn07XG5cbi8vIC0tLSBSZWNvcmQvVHVwbGUgUGFyc2luZyAtLS1cbmNvbnN0IHBhcnNlUmVjb3JkID0gQy5tYXAoXG4gIEMuc2VxKEMucHVuY3R1YXRpb24oXCJ7XCIpLCBDLm9wdGlvbmFsKHBhcnNlUmVjb3JkRmllbGRzKSwgQy5wdW5jdHVhdGlvbihcIn1cIikpLFxuICAoW29wZW4sIGZpZWxkcywgY2xvc2VdKTogRXhwcmVzc2lvbiA9PiB7XG4gICAgY29uc3QgZmllbGRzTGlzdCA9IGZpZWxkcyB8fCBbXTtcbiAgICBpZiAoZmllbGRzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEVtcHR5IGJyYWNlczogdW5pdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJ1bml0XCIsXG4gICAgICAgIGxvY2F0aW9uOiBvcGVuLmxvY2F0aW9uLFxuICAgICAgfSBhcyBVbml0RXhwcmVzc2lvbjtcbiAgICB9XG4gICAgY29uc3QgYWxsTmFtZWQgPSBmaWVsZHNMaXN0LmV2ZXJ5KChmKSA9PiBmLm5hbWVbMF0gIT09IFwiQFwiKTtcbiAgICBjb25zdCBhbGxQb3NpdGlvbmFsID0gZmllbGRzTGlzdC5ldmVyeSgoZiwgaSkgPT4gZi5uYW1lID09PSBgQCR7aX1gKTtcbiAgICBpZiAoYWxsTmFtZWQpIHtcbiAgICAgIC8vIEFsbCBuYW1lZCBmaWVsZHM6IHJlY29yZFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJyZWNvcmRcIixcbiAgICAgICAgZmllbGRzOiBmaWVsZHNMaXN0LFxuICAgICAgICBsb2NhdGlvbjogb3Blbi5sb2NhdGlvbixcbiAgICAgIH0gYXMgUmVjb3JkRXhwcmVzc2lvbjtcbiAgICB9IGVsc2UgaWYgKGFsbFBvc2l0aW9uYWwpIHtcbiAgICAgIC8vIEFsbCBwb3NpdGlvbmFsIGZpZWxkczogdHVwbGVcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFwidHVwbGVcIixcbiAgICAgICAgZWxlbWVudHM6IGZpZWxkc0xpc3QubWFwKChmKSA9PiBmLnZhbHVlKSxcbiAgICAgICAgbG9jYXRpb246IG9wZW4ubG9jYXRpb24sXG4gICAgICB9IGFzIFR1cGxlRXhwcmVzc2lvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWl4ZWQgZmllbGRzOiBlcnJvclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbm5vdCBtaXggbmFtZWQgYW5kIHBvc2l0aW9uYWwgZmllbGRzIGluIHRoZSBzYW1lIHJlY29yZC90dXBsZVwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuKTtcblxuLy8gLS0tIFBhcmVudGhlc2l6ZWQgRXhwcmVzc2lvbnMgLS0tXG5jb25zdCBwYXJzZVBhcmVuRXhwcjogQy5QYXJzZXI8RXhwcmVzc2lvbj4gPSBDLm1hcChcbiAgQy5zZXEoXG4gICAgQy5wdW5jdHVhdGlvbihcIihcIiksXG4gICAgQy5sYXp5KCgpID0+IHBhcnNlU2VxdWVuY2UpLCAvLyBVc2UgcGFyc2VTZXF1ZW5jZSB0byBhbGxvdyBmdWxsIHNlbWljb2xvbi1zZXBhcmF0ZWQgc2VxdWVuY2VzXG4gICAgQy5wdW5jdHVhdGlvbihcIilcIilcbiAgKSxcbiAgKFtvcGVuLCBleHByLCBjbG9zZV0pID0+IGV4cHJcbik7XG5cbi8vIC0tLSBMYW1iZGEgRXhwcmVzc2lvbiAtLS1cbmNvbnN0IHBhcnNlTGFtYmRhRXhwcmVzc2lvbjogQy5QYXJzZXI8RnVuY3Rpb25FeHByZXNzaW9uPiA9ICh0b2tlbnMpID0+IHtcbiAgLy8gVHJ5IHRvIHBhcnNlIGZuIGtleXdvcmQgZmlyc3RcbiAgY29uc3QgZm5SZXN1bHQgPSBDLmtleXdvcmQoXCJmblwiKSh0b2tlbnMpO1xuICBpZiAoIWZuUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICByZXR1cm4gZm5SZXN1bHQ7XG4gIH1cblxuICAvLyBUcnkgdW5pdCBwYXJhbWV0ZXIgcGF0dGVybnMgZmlyc3RcbiAgbGV0IHBhcmFtTmFtZXM6IHN0cmluZ1tdID0gW107XG4gIGxldCByZW1haW5pbmcgPSBmblJlc3VsdC5yZW1haW5pbmc7XG5cbiAgY29uc3QgcGFyZW5SZXN1bHQgPSBDLnNlcShDLnB1bmN0dWF0aW9uKFwiKFwiKSwgQy5wdW5jdHVhdGlvbihcIilcIikpKHJlbWFpbmluZyk7XG4gIGlmIChwYXJlblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgLy8gTm8gcGFyYW1ldGVycyAoc2hvdWxkIG5vdCBiZSB1c2VkIGluIE5vb2xhbmcsIGJ1dCBrZWVwIGZvciBzeW50YXggY29tcGxldGVuZXNzKVxuICAgIHBhcmFtTmFtZXMgPSBbXTtcbiAgICByZW1haW5pbmcgPSBwYXJlblJlc3VsdC5yZW1haW5pbmc7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnJhY2VSZXN1bHQgPSBDLnNlcShcbiAgICAgIEMucHVuY3R1YXRpb24oXCJ7XCIpLFxuICAgICAgQy5wdW5jdHVhdGlvbihcIn1cIilcbiAgICApKHJlbWFpbmluZyk7XG4gICAgaWYgKGJyYWNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIC8vIFVuaXQgcGFyYW1ldGVyXG4gICAgICBwYXJhbU5hbWVzID0gW1wiX3VuaXRcIl07XG4gICAgICByZW1haW5pbmcgPSBicmFjZVJlc3VsdC5yZW1haW5pbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyeSBtdWx0aXBsZSBpZGVudGlmaWVycyBsYXN0XG4gICAgICBjb25zdCBpZFJlc3VsdCA9IEMubWFueShDLmlkZW50aWZpZXIoKSkocmVtYWluaW5nKTtcbiAgICAgIGlmIChpZFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHBhcmFtTmFtZXMgPSBpZFJlc3VsdC52YWx1ZS5tYXAoKHApID0+IHAudmFsdWUpO1xuICAgICAgICByZW1haW5pbmcgPSBpZFJlc3VsdC5yZW1haW5pbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBcIkV4cGVjdGVkIHBhcmFtZXRlciBsaXN0LCBwYXJlbnRoZXNlcywgb3IgYnJhY2VzXCIsXG4gICAgICAgICAgcG9zaXRpb246IHJlbWFpbmluZ1swXT8ubG9jYXRpb24uc3RhcnQubGluZSB8fCAwLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlIHRoZSBhcnJvd1xuICBjb25zdCBhcnJvd1Jlc3VsdCA9IEMub3BlcmF0b3IoXCI9PlwiKShyZW1haW5pbmcpO1xuICBpZiAoIWFycm93UmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICByZXR1cm4gYXJyb3dSZXN1bHQ7XG4gIH1cblxuICAvLyBQYXJzZSB0aGUgYm9keSAodXNlIHBhcnNlU2VxdWVuY2VUZXJtV2l0aElmIHRvIGFsbG93IGZ1bGwgZXhwcmVzc2lvbnMpXG4gIGNvbnN0IGJvZHlSZXN1bHQgPSBDLmxhenkoKCkgPT4gcGFyc2VTZXF1ZW5jZVRlcm1XaXRoSWYpKFxuICAgIGFycm93UmVzdWx0LnJlbWFpbmluZ1xuICApO1xuICBpZiAoIWJvZHlSZXN1bHQuc3VjY2Vzcykge1xuICAgIHJldHVybiBib2R5UmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiB0cnVlLFxuICAgIHZhbHVlOiB7XG4gICAgICBraW5kOiBcImZ1bmN0aW9uXCIsXG4gICAgICBwYXJhbXM6IHBhcmFtTmFtZXMsXG4gICAgICBib2R5OiBib2R5UmVzdWx0LnZhbHVlLFxuICAgICAgbG9jYXRpb246IGZuUmVzdWx0LnZhbHVlLmxvY2F0aW9uLFxuICAgIH0sXG4gICAgcmVtYWluaW5nOiBib2R5UmVzdWx0LnJlbWFpbmluZyxcbiAgfTtcbn07XG5cbi8vIC0tLSBMaXN0IFBhcnNpbmcgLS0tXG4vLyBDdXN0b20gcGFyc2VyIGZvciBhIHNlcXVlbmNlIG9mIGV4cHJlc3Npb25zIHNlcGFyYXRlZCBieSBzZW1pY29sb25zXG5jb25zdCBwYXJzZUxpc3RFbGVtZW50czogQy5QYXJzZXI8RXhwcmVzc2lvbltdPiA9ICh0b2tlbnMpID0+IHtcbiAgbGV0IGVsZW1lbnRzOiBFeHByZXNzaW9uW10gPSBbXTtcbiAgbGV0IHJlc3QgPSB0b2tlbnM7XG5cbiAgLy8gUGFyc2UgZmlyc3QgZWxlbWVudFxuICBjb25zdCBmaXJzdEVsZW1lbnRSZXN1bHQgPSBDLmxhenkoKCkgPT4gcGFyc2VUaHJ1c2gpKHJlc3QpO1xuICBpZiAoIWZpcnN0RWxlbWVudFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGxpc3QgZWxlbWVudFwiLFxuICAgICAgcG9zaXRpb246IHRva2Vuc1swXT8ubG9jYXRpb24uc3RhcnQubGluZSB8fCAwLFxuICAgIH07XG4gIH1cbiAgZWxlbWVudHMucHVzaChmaXJzdEVsZW1lbnRSZXN1bHQudmFsdWUpO1xuICByZXN0ID0gZmlyc3RFbGVtZW50UmVzdWx0LnJlbWFpbmluZztcblxuICAvLyBQYXJzZSBhZGRpdGlvbmFsIGVsZW1lbnRzLCBlYWNoIHByZWNlZGVkIGJ5IGEgY29tbWFcbiAgd2hpbGUgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGNvbW1hUmVzdWx0ID0gQy5wdW5jdHVhdGlvbihcIixcIikocmVzdCk7XG4gICAgaWYgKCFjb21tYVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBicmVhazsgLy8gTm8gbW9yZSBjb21tYXMsIHdlJ3JlIGRvbmVcbiAgICB9XG4gICAgcmVzdCA9IGNvbW1hUmVzdWx0LnJlbWFpbmluZztcblxuICAgIGNvbnN0IGVsZW1lbnRSZXN1bHQgPSBDLmxhenkoKCkgPT4gcGFyc2VUaHJ1c2gpKHJlc3QpO1xuICAgIGlmICghZWxlbWVudFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgdHJhaWxpbmcgY29tbWEgKG5vIG1vcmUgZWxlbWVudHMgYWZ0ZXIgY29tbWEpXG4gICAgICAvLyBMb29rIGFoZWFkIHRvIHNlZSBpZiB0aGUgbmV4dCB0b2tlbiBpcyBhIGNsb3NpbmcgYnJhY2tldFxuICAgICAgaWYgKFxuICAgICAgICByZXN0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgcmVzdFswXS50eXBlID09PSBcIlBVTkNUVUFUSU9OXCIgJiZcbiAgICAgICAgcmVzdFswXS52YWx1ZSA9PT0gXCJdXCJcbiAgICAgICkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgdHJhaWxpbmcgY29tbWEsIHdoaWNoIGlzIGFsbG93ZWRcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgZWxlbWVudCBhZnRlciBjb21tYVwiLFxuICAgICAgICBwb3NpdGlvbjogcmVzdFswXT8ubG9jYXRpb24uc3RhcnQubGluZSB8fCAwLFxuICAgICAgfTtcbiAgICB9XG4gICAgZWxlbWVudHMucHVzaChlbGVtZW50UmVzdWx0LnZhbHVlKTtcbiAgICByZXN0ID0gZWxlbWVudFJlc3VsdC5yZW1haW5pbmc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgdmFsdWU6IGVsZW1lbnRzLFxuICAgIHJlbWFpbmluZzogcmVzdCxcbiAgfTtcbn07XG5cbmNvbnN0IHBhcnNlTGlzdDogQy5QYXJzZXI8TGlzdEV4cHJlc3Npb24+ID0gQy5tYXAoXG4gIEMuc2VxKEMucHVuY3R1YXRpb24oXCJbXCIpLCBDLm9wdGlvbmFsKHBhcnNlTGlzdEVsZW1lbnRzKSwgQy5wdW5jdHVhdGlvbihcIl1cIikpLFxuICAoW29wZW4sIGVsZW1lbnRzLCBjbG9zZV0pID0+IHtcbiAgICBjb25zdCBlbGVtZW50c0xpc3Q6IEV4cHJlc3Npb25bXSA9IGVsZW1lbnRzIHx8IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBcImxpc3RcIixcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50c0xpc3QsXG4gICAgICBsb2NhdGlvbjogb3Blbi5sb2NhdGlvbixcbiAgICB9O1xuICB9XG4pO1xuXG4vLyAtLS0gSW1wb3J0IEV4cHJlc3Npb24gLS0tXG5jb25zdCBwYXJzZUltcG9ydEV4cHJlc3Npb246IEMuUGFyc2VyPEltcG9ydEV4cHJlc3Npb24+ID0gQy5tYXAoXG4gIEMuc2VxKEMua2V5d29yZChcImltcG9ydFwiKSwgQy5zdHJpbmcoKSksXG4gIChbaW1wb3J0S3csIHBhdGhdKTogSW1wb3J0RXhwcmVzc2lvbiA9PiAoe1xuICAgIGtpbmQ6IFwiaW1wb3J0XCIsXG4gICAgcGF0aDogcGF0aC52YWx1ZSxcbiAgICBsb2NhdGlvbjogaW1wb3J0S3cubG9jYXRpb24sXG4gIH0pXG4pO1xuXG4vLyAtLS0gSWYgRXhwcmVzc2lvbiAoc3BlY2lhbDogZG8gbm90IGFsbG93IHNlbWljb2xvbiBpbiBicmFuY2hlcykgLS0tXG5jb25zdCBwYXJzZUlmRXhwcmVzc2lvbjogQy5QYXJzZXI8RXhwcmVzc2lvbj4gPSBDLm1hcChcbiAgQy5zZXEoXG4gICAgQy5rZXl3b3JkKFwiaWZcIiksXG4gICAgQy5sYXp5KCgpID0+IHBhcnNlU2VxdWVuY2VUZXJtKSxcbiAgICBDLmtleXdvcmQoXCJ0aGVuXCIpLFxuICAgIEMubGF6eSgoKSA9PiBwYXJzZVNlcXVlbmNlVGVybSksXG4gICAgQy5rZXl3b3JkKFwiZWxzZVwiKSxcbiAgICBDLmxhenkoKCkgPT4gcGFyc2VTZXF1ZW5jZVRlcm0pXG4gICksXG4gIChbaWZLdywgY29uZGl0aW9uLCB0aGVuS3csIHRoZW5FeHByLCBlbHNlS3csIGVsc2VFeHByXSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBcImlmXCIsXG4gICAgICBjb25kaXRpb24sXG4gICAgICB0aGVuOiB0aGVuRXhwcixcbiAgICAgIGVsc2U6IGVsc2VFeHByLFxuICAgICAgbG9jYXRpb246IGlmS3cubG9jYXRpb24sXG4gICAgfTtcbiAgfVxuKTtcblxuLy8gLS0tIFByaW1hcnkgRXhwcmVzc2lvbnMgKG5vIHVuYXJ5IG1pbnVzKSAtLS1cbmNvbnN0IHBhcnNlUHJpbWFyeTogQy5QYXJzZXI8RXhwcmVzc2lvbj4gPSAodG9rZW5zKSA9PiB7XG4gIC8vIERFQlVHOiBMb2cgdG9rZW5zIGF0IGVudHJ5XG4gIGlmIChwcm9jZXNzLmVudi5OT09fREVCVUdfUEFSU0UpIHtcbiAgICBjb25zb2xlLmxvZyhcInBhcnNlUHJpbWFyeSB0b2tlbnM6XCIsIHRva2Vucy5tYXAoKHQpID0+IHQudmFsdWUpLmpvaW4oXCIgXCIpKTtcbiAgfVxuICBcbiAgLy8gRmFzdCB0b2tlbi1iYXNlZCBkaXNwYXRjaCBpbnN0ZWFkIG9mIHNlcXVlbnRpYWwgY2hvaWNlIGF0dGVtcHRzXG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIlVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0XCIsIHBvc2l0aW9uOiAwIH07XG4gIH1cbiAgXG4gIGNvbnN0IGZpcnN0VG9rZW4gPSB0b2tlbnNbMF07XG4gIGxldCByZXN1bHQ6IEMuUGFyc2VSZXN1bHQ8RXhwcmVzc2lvbj47XG4gIFxuICAvLyBEaXNwYXRjaCBiYXNlZCBvbiB0b2tlbiB0eXBlIGFuZCB2YWx1ZSBmb3IgTygxKSBzZWxlY3Rpb25cbiAgc3dpdGNoIChmaXJzdFRva2VuLnR5cGUpIHtcbiAgICBjYXNlIFwiTlVNQkVSXCI6XG4gICAgICByZXN1bHQgPSBwYXJzZU51bWJlcih0b2tlbnMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlNUUklOR1wiOiBcbiAgICAgIHJlc3VsdCA9IHBhcnNlU3RyaW5nKHRva2Vucyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiSURFTlRJRklFUlwiOlxuICAgICAgcmVzdWx0ID0gcGFyc2VJZGVudGlmaWVyKHRva2Vucyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiQUNDRVNTT1JcIjpcbiAgICAgIHJlc3VsdCA9IHBhcnNlQWNjZXNzb3IodG9rZW5zKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQVU5DVFVBVElPTlwiOlxuICAgICAgaWYgKGZpcnN0VG9rZW4udmFsdWUgPT09IFwiW1wiKSB7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlTGlzdCh0b2tlbnMpO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdFRva2VuLnZhbHVlID09PSBcIntcIikge1xuICAgICAgICByZXN1bHQgPSBwYXJzZVJlY29yZCh0b2tlbnMpO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdFRva2VuLnZhbHVlID09PSBcIihcIikge1xuICAgICAgICByZXN1bHQgPSBwYXJzZVBhcmVuRXhwcih0b2tlbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGBVbmV4cGVjdGVkIHB1bmN0dWF0aW9uOiAke2ZpcnN0VG9rZW4udmFsdWV9YCwgcG9zaXRpb246IGZpcnN0VG9rZW4ubG9jYXRpb24uc3RhcnQubGluZSB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIktFWVdPUkRcIjpcbiAgICAgIGlmIChmaXJzdFRva2VuLnZhbHVlID09PSBcImZuXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gcGFyc2VMYW1iZGFFeHByZXNzaW9uKHRva2Vucyk7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0VG9rZW4udmFsdWUgPT09IFwibGV0XCIpIHtcbiAgICAgICAgcmVzdWx0ID0gQy5sYXp5KCgpID0+IHBhcnNlRGVmaW5pdGlvbldpdGhUeXBlKSh0b2tlbnMpO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdFRva2VuLnZhbHVlID09PSBcImltcG9ydFwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlSW1wb3J0RXhwcmVzc2lvbih0b2tlbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGBVbmV4cGVjdGVkIGtleXdvcmQ6ICR7Zmlyc3RUb2tlbi52YWx1ZX1gLCBwb3NpdGlvbjogZmlyc3RUb2tlbi5sb2NhdGlvbi5zdGFydC5saW5lIH07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVzdWx0ID0geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGBVbmV4cGVjdGVkIHRva2VuIHR5cGU6ICR7Zmlyc3RUb2tlbi50eXBlfWAsIHBvc2l0aW9uOiBmaXJzdFRva2VuLmxvY2F0aW9uLnN0YXJ0LmxpbmUgfTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICAvLyBERUJVRzogTG9nIHJlc3VsdFxuICBpZiAocHJvY2Vzcy5lbnYuTk9PX0RFQlVHX1BBUlNFKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBcInBhcnNlUHJpbWFyeSByZXN1bHQ6XCIsXG4gICAgICByZXN1bHQuc3VjY2VzcyA/IHJlc3VsdC52YWx1ZSA6IHJlc3VsdC5lcnJvclxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIC0tLSBQcmltYXJ5IHdpdGggUG9zdGZpeCAodHlwZSBhbm5vdGF0aW9ucykgLS0tXG5jb25zdCBwYXJzZVByaW1hcnlXaXRoUG9zdGZpeDogQy5QYXJzZXI8RXhwcmVzc2lvbj4gPSAodG9rZW5zKSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT09fREVCVUdfUEFSU0UpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIFwicGFyc2VQcmltYXJ5V2l0aFBvc3RmaXggdG9rZW5zOlwiLFxuICAgICAgdG9rZW5zLm1hcCgodCkgPT4gdC52YWx1ZSkuam9pbihcIiBcIilcbiAgICApO1xuICB9XG4gIGNvbnN0IHByaW1hcnlSZXN1bHQgPSBwYXJzZVByaW1hcnkodG9rZW5zKTtcbiAgaWYgKCFwcmltYXJ5UmVzdWx0LnN1Y2Nlc3MpIHJldHVybiBwcmltYXJ5UmVzdWx0O1xuICBjb25zdCBwb3N0Zml4UmVzdWx0ID0gcGFyc2VQb3N0Zml4RnJvbVJlc3VsdChcbiAgICBwcmltYXJ5UmVzdWx0LnZhbHVlLFxuICAgIHByaW1hcnlSZXN1bHQucmVtYWluaW5nXG4gICk7XG4gIGlmIChwcm9jZXNzLmVudi5OT09fREVCVUdfUEFSU0UpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIFwicGFyc2VQcmltYXJ5V2l0aFBvc3RmaXggcmVzdWx0OlwiLFxuICAgICAgcG9zdGZpeFJlc3VsdC5zdWNjZXNzID8gcG9zdGZpeFJlc3VsdC52YWx1ZSA6IHBvc3RmaXhSZXN1bHQuZXJyb3JcbiAgICApO1xuICB9XG4gIHJldHVybiBwb3N0Zml4UmVzdWx0O1xufTtcblxuLy8gLS0tIFVuYXJ5IE9wZXJhdG9ycyAobmVnYXRpb24sIG9ubHkgaWYgJy0nIGlzIGFkamFjZW50IHRvIHRoZSBuZXh0IHRva2VuKSAtLS1cbmNvbnN0IHBhcnNlVW5hcnk6IEMuUGFyc2VyPEV4cHJlc3Npb24+ID0gKHRva2VucykgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9PX0RFQlVHX1BBUlNFKSB7XG4gICAgY29uc29sZS5sb2coXCJwYXJzZVVuYXJ5IHRva2VuczpcIiwgdG9rZW5zLm1hcCgodCkgPT4gdC52YWx1ZSkuam9pbihcIiBcIikpO1xuICB9XG4gIGlmIChcbiAgICB0b2tlbnMubGVuZ3RoID49IDIgJiZcbiAgICB0b2tlbnNbMF0udHlwZSA9PT0gXCJPUEVSQVRPUlwiICYmXG4gICAgdG9rZW5zWzBdLnZhbHVlID09PSBcIi1cIlxuICApIHtcbiAgICBjb25zdCBtaW51c1Rva2VuID0gdG9rZW5zWzBdO1xuICAgIGNvbnN0IG5leHRUb2tlbiA9IHRva2Vuc1sxXTtcbiAgICAvLyBDaGVjayBpZiBtaW51cyBpcyBkaXJlY3RseSBhZGphY2VudCB0byB0aGUgbmV4dCB0b2tlbiAobm8gc3BhY2UpXG4gICAgaWYgKFxuICAgICAgbWludXNUb2tlbi5sb2NhdGlvbi5lbmQubGluZSA9PT0gbmV4dFRva2VuLmxvY2F0aW9uLnN0YXJ0LmxpbmUgJiZcbiAgICAgIG1pbnVzVG9rZW4ubG9jYXRpb24uZW5kLmNvbHVtbiA9PT0gbmV4dFRva2VuLmxvY2F0aW9uLnN0YXJ0LmNvbHVtblxuICAgICkge1xuICAgICAgLy8gUGFyc2UgYXMgdW5hcnkgbWludXNcbiAgICAgIGNvbnN0IG9wZXJhbmRSZXN1bHQgPSBwYXJzZVByaW1hcnlXaXRoUG9zdGZpeCh0b2tlbnMuc2xpY2UoMSkpO1xuICAgICAgaWYgKCFvcGVyYW5kUmVzdWx0LnN1Y2Nlc3MpIHJldHVybiBvcGVyYW5kUmVzdWx0O1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlIGFzIGNvbnN0LFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGtpbmQ6IFwiYmluYXJ5XCIgYXMgY29uc3QsXG4gICAgICAgICAgb3BlcmF0b3I6IFwiKlwiIGFzIGNvbnN0LFxuICAgICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICAgIGtpbmQ6IFwibGl0ZXJhbFwiIGFzIGNvbnN0LFxuICAgICAgICAgICAgdmFsdWU6IC0xLFxuICAgICAgICAgICAgbG9jYXRpb246IG1pbnVzVG9rZW4ubG9jYXRpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgICByaWdodDogb3BlcmFuZFJlc3VsdC52YWx1ZSxcbiAgICAgICAgICBsb2NhdGlvbjogbWludXNUb2tlbi5sb2NhdGlvbixcbiAgICAgICAgfSxcbiAgICAgICAgcmVtYWluaW5nOiBvcGVyYW5kUmVzdWx0LnJlbWFpbmluZyxcbiAgICAgIH07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9PX0RFQlVHX1BBUlNFKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwicGFyc2VVbmFyeSByZXN1bHQgKG5lZ2F0aW9uKTpcIiwgcmVzdWx0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIC8vIE90aGVyd2lzZSwgZmFsbCB0aHJvdWdoIHRvIHBhcnNlUHJpbWFyeVdpdGhQb3N0Zml4XG4gIGNvbnN0IHJlc3VsdCA9IHBhcnNlUHJpbWFyeVdpdGhQb3N0Zml4KHRva2Vucyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT09fREVCVUdfUEFSU0UpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIFwicGFyc2VVbmFyeSByZXN1bHQ6XCIsXG4gICAgICByZXN1bHQuc3VjY2VzcyA/IHJlc3VsdC52YWx1ZSA6IHJlc3VsdC5lcnJvclxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIC0tLSBGdW5jdGlvbiBBcHBsaWNhdGlvbiAobGVmdC1hc3NvY2lhdGl2ZSwgdGlnaHRlc3QgYmluZGluZykgLS0tXG5jb25zdCBwYXJzZUFwcGxpY2F0aW9uOiBDLlBhcnNlcjxFeHByZXNzaW9uPiA9ICh0b2tlbnMpID0+IHtcbiAgY29uc3QgYXBwUmVzdWx0ID0gQy5tYXAoXG4gICAgQy5zZXEocGFyc2VVbmFyeSwgQy5tYW55KHBhcnNlVW5hcnkpKSxcbiAgICAoW2Z1bmMsIGFyZ3NdKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gZnVuYztcbiAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIGtpbmQ6IFwiYXBwbGljYXRpb25cIixcbiAgICAgICAgICBmdW5jOiByZXN1bHQsXG4gICAgICAgICAgYXJnczogW2FyZ10sXG4gICAgICAgICAgbG9jYXRpb246IHJlc3VsdC5sb2NhdGlvbixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICApKHRva2Vucyk7XG5cbiAgaWYgKCFhcHBSZXN1bHQuc3VjY2VzcykgcmV0dXJuIGFwcFJlc3VsdDtcblxuICAvLyBBcHBseSBwb3N0Zml4IG9wZXJhdG9ycyAodHlwZSBhbm5vdGF0aW9ucykgdG8gdGhlIHJlc3VsdFxuICByZXR1cm4gcGFyc2VQb3N0Zml4RnJvbVJlc3VsdChhcHBSZXN1bHQudmFsdWUsIGFwcFJlc3VsdC5yZW1haW5pbmcpO1xufTtcblxuLy8gLS0tIE11bHRpcGxpY2F0aXZlICgqLCAvKSAtLS1cbmNvbnN0IHBhcnNlTXVsdGlwbGljYXRpdmU6IEMuUGFyc2VyPEV4cHJlc3Npb24+ID0gKHRva2VucykgPT4ge1xuICBjb25zdCBtdWx0UmVzdWx0ID0gQy5tYXAoXG4gICAgQy5zZXEoXG4gICAgICBwYXJzZUFwcGxpY2F0aW9uLFxuICAgICAgQy5tYW55KFxuICAgICAgICBDLnNlcShDLmNob2ljZShDLm9wZXJhdG9yKFwiKlwiKSwgQy5vcGVyYXRvcihcIi9cIikpLCBwYXJzZUFwcGxpY2F0aW9uKVxuICAgICAgKVxuICAgICksXG4gICAgKFtsZWZ0LCByZXN0XSkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IGxlZnQ7XG4gICAgICBmb3IgKGNvbnN0IFtvcCwgcmlnaHRdIG9mIHJlc3QpIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIGtpbmQ6IFwiYmluYXJ5XCIsXG4gICAgICAgICAgb3BlcmF0b3I6IG9wLnZhbHVlIGFzIFwiKlwiIHwgXCIvXCIsXG4gICAgICAgICAgbGVmdDogcmVzdWx0LFxuICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgIGxvY2F0aW9uOiByZXN1bHQubG9jYXRpb24sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgKSh0b2tlbnMpO1xuXG4gIGlmICghbXVsdFJlc3VsdC5zdWNjZXNzKSByZXR1cm4gbXVsdFJlc3VsdDtcblxuICAvLyBBcHBseSBwb3N0Zml4IG9wZXJhdG9ycyAodHlwZSBhbm5vdGF0aW9ucykgdG8gdGhlIHJlc3VsdFxuICByZXR1cm4gcGFyc2VQb3N0Zml4RnJvbVJlc3VsdChtdWx0UmVzdWx0LnZhbHVlLCBtdWx0UmVzdWx0LnJlbWFpbmluZyk7XG59O1xuXG4vLyAtLS0gQWRkaXRpdmUgKCssIC0pIC0tLVxuY29uc3QgcGFyc2VBZGRpdGl2ZTogQy5QYXJzZXI8RXhwcmVzc2lvbj4gPSAodG9rZW5zKSA9PiB7XG4gIGNvbnN0IGFkZFJlc3VsdCA9IEMubWFwKFxuICAgIEMuc2VxKFxuICAgICAgcGFyc2VNdWx0aXBsaWNhdGl2ZSxcbiAgICAgIEMubWFueShcbiAgICAgICAgQy5zZXEoQy5jaG9pY2UoQy5vcGVyYXRvcihcIitcIiksIEMub3BlcmF0b3IoXCItXCIpKSwgcGFyc2VNdWx0aXBsaWNhdGl2ZSlcbiAgICAgIClcbiAgICApLFxuICAgIChbbGVmdCwgcmVzdF0pID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSBsZWZ0O1xuICAgICAgZm9yIChjb25zdCBbb3AsIHJpZ2h0XSBvZiByZXN0KSB7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICBraW5kOiBcImJpbmFyeVwiLFxuICAgICAgICAgIG9wZXJhdG9yOiBvcC52YWx1ZSBhcyBcIitcIiB8IFwiLVwiLFxuICAgICAgICAgIGxlZnQ6IHJlc3VsdCxcbiAgICAgICAgICByaWdodCxcbiAgICAgICAgICBsb2NhdGlvbjogcmVzdWx0LmxvY2F0aW9uLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICkodG9rZW5zKTtcblxuICBpZiAoIWFkZFJlc3VsdC5zdWNjZXNzKSByZXR1cm4gYWRkUmVzdWx0O1xuXG4gIC8vIEFwcGx5IHBvc3RmaXggb3BlcmF0b3JzICh0eXBlIGFubm90YXRpb25zKSB0byB0aGUgcmVzdWx0XG4gIHJldHVybiBwYXJzZVBvc3RmaXhGcm9tUmVzdWx0KGFkZFJlc3VsdC52YWx1ZSwgYWRkUmVzdWx0LnJlbWFpbmluZyk7XG59O1xuXG4vLyAtLS0gQ29tcGFyaXNvbiAoPCwgPiwgPD0sID49LCA9PSwgIT0pIC0tLVxuY29uc3QgcGFyc2VDb21wYXJpc29uOiBDLlBhcnNlcjxFeHByZXNzaW9uPiA9ICh0b2tlbnMpID0+IHtcbiAgY29uc3QgY29tcFJlc3VsdCA9IEMubWFwKFxuICAgIEMuc2VxKFxuICAgICAgcGFyc2VBZGRpdGl2ZSxcbiAgICAgIEMubWFueShcbiAgICAgICAgQy5zZXEoXG4gICAgICAgICAgQy5jaG9pY2UoXG4gICAgICAgICAgICBDLm9wZXJhdG9yKFwiPFwiKSxcbiAgICAgICAgICAgIEMub3BlcmF0b3IoXCI+XCIpLFxuICAgICAgICAgICAgQy5vcGVyYXRvcihcIjw9XCIpLFxuICAgICAgICAgICAgQy5vcGVyYXRvcihcIj49XCIpLFxuICAgICAgICAgICAgQy5vcGVyYXRvcihcIj09XCIpLFxuICAgICAgICAgICAgQy5vcGVyYXRvcihcIiE9XCIpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBwYXJzZUFkZGl0aXZlXG4gICAgICAgIClcbiAgICAgIClcbiAgICApLFxuICAgIChbbGVmdCwgcmVzdF0pID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSBsZWZ0O1xuICAgICAgZm9yIChjb25zdCBbb3AsIHJpZ2h0XSBvZiByZXN0KSB7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICBraW5kOiBcImJpbmFyeVwiLFxuICAgICAgICAgIG9wZXJhdG9yOiBvcC52YWx1ZSBhcyBcIjxcIiB8IFwiPlwiIHwgXCI8PVwiIHwgXCI+PVwiIHwgXCI9PVwiIHwgXCIhPVwiLFxuICAgICAgICAgIGxlZnQ6IHJlc3VsdCxcbiAgICAgICAgICByaWdodCxcbiAgICAgICAgICBsb2NhdGlvbjogcmVzdWx0LmxvY2F0aW9uLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICkodG9rZW5zKTtcblxuICBpZiAoIWNvbXBSZXN1bHQuc3VjY2VzcykgcmV0dXJuIGNvbXBSZXN1bHQ7XG5cbiAgLy8gQXBwbHkgcG9zdGZpeCBvcGVyYXRvcnMgKHR5cGUgYW5ub3RhdGlvbnMpIHRvIHRoZSByZXN1bHRcbiAgcmV0dXJuIHBhcnNlUG9zdGZpeEZyb21SZXN1bHQoY29tcFJlc3VsdC52YWx1ZSwgY29tcFJlc3VsdC5yZW1haW5pbmcpO1xufTtcblxuLy8gLS0tIENvbXBvc2l0aW9uICh8PiwgPHwpIC0tLVxuY29uc3QgcGFyc2VDb21wb3NlOiBDLlBhcnNlcjxFeHByZXNzaW9uPiA9ICh0b2tlbnMpID0+IHtcbiAgY29uc3QgY29tcFJlc3VsdCA9IEMubWFwKFxuICAgIEMuc2VxKFxuICAgICAgcGFyc2VDb21wYXJpc29uLFxuICAgICAgQy5tYW55KFxuICAgICAgICBDLnNlcShDLmNob2ljZShDLm9wZXJhdG9yKFwifD5cIiksIEMub3BlcmF0b3IoXCI8fFwiKSksIHBhcnNlQ29tcGFyaXNvbilcbiAgICAgIClcbiAgICApLFxuICAgIChbbGVmdCwgcmVzdF0pID0+IHtcbiAgICAgIC8vIEJ1aWxkIHN0ZXBzIGFycmF5IGZvciBwaXBlbGluZSBleHByZXNzaW9uXG4gICAgICBjb25zdCBzdGVwcyA9IFtsZWZ0XTtcbiAgICAgIGZvciAoY29uc3QgW29wLCByaWdodF0gb2YgcmVzdCkge1xuICAgICAgICBzdGVwcy5wdXNoKHJpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgaGF2ZSBtdWx0aXBsZSBzdGVwcywgY3JlYXRlIGEgcGlwZWxpbmUgZXhwcmVzc2lvblxuICAgICAgaWYgKHN0ZXBzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBraW5kOiBcInBpcGVsaW5lXCIsXG4gICAgICAgICAgc3RlcHMsXG4gICAgICAgICAgbG9jYXRpb246IGxlZnQubG9jYXRpb24sXG4gICAgICAgIH0gYXMgaW1wb3J0KFwiLi4vYXN0XCIpLlBpcGVsaW5lRXhwcmVzc2lvbjtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHRoZSBzaW5nbGUgZXhwcmVzc2lvblxuICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfVxuICApKHRva2Vucyk7XG5cbiAgaWYgKCFjb21wUmVzdWx0LnN1Y2Nlc3MpIHJldHVybiBjb21wUmVzdWx0O1xuXG4gIC8vIEFwcGx5IHBvc3RmaXggb3BlcmF0b3JzICh0eXBlIGFubm90YXRpb25zKSB0byB0aGUgcmVzdWx0XG4gIHJldHVybiBwYXJzZVBvc3RmaXhGcm9tUmVzdWx0KGNvbXBSZXN1bHQudmFsdWUsIGNvbXBSZXN1bHQucmVtYWluaW5nKTtcbn07XG5cbi8vIC0tLSBUaHJ1c2ggKHwpIC0tLVxuY29uc3QgcGFyc2VUaHJ1c2g6IEMuUGFyc2VyPEV4cHJlc3Npb24+ID0gKHRva2VucykgPT4ge1xuICBjb25zdCB0aHJ1c2hSZXN1bHQgPSBDLm1hcChcbiAgICBDLnNlcShwYXJzZURvbGxhciwgQy5tYW55KEMuc2VxKEMub3BlcmF0b3IoXCJ8XCIpLCBwYXJzZURvbGxhcikpKSxcbiAgICAoW2xlZnQsIHJlc3RdKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gbGVmdDtcbiAgICAgIGZvciAoY29uc3QgW29wLCByaWdodF0gb2YgcmVzdCkge1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAga2luZDogXCJiaW5hcnlcIixcbiAgICAgICAgICBvcGVyYXRvcjogXCJ8XCIsXG4gICAgICAgICAgbGVmdDogcmVzdWx0LFxuICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgIGxvY2F0aW9uOiByZXN1bHQubG9jYXRpb24sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgKSh0b2tlbnMpO1xuXG4gIGlmICghdGhydXNoUmVzdWx0LnN1Y2Nlc3MpIHJldHVybiB0aHJ1c2hSZXN1bHQ7XG5cbiAgLy8gQXBwbHkgcG9zdGZpeCBvcGVyYXRvcnMgKHR5cGUgYW5ub3RhdGlvbnMpIHRvIHRoZSByZXN1bHRcbiAgcmV0dXJuIHBhcnNlUG9zdGZpeEZyb21SZXN1bHQodGhydXNoUmVzdWx0LnZhbHVlLCB0aHJ1c2hSZXN1bHQucmVtYWluaW5nKTtcbn07XG5cbi8vIC0tLSBEb2xsYXIgKCQpIC0gTG93IHByZWNlZGVuY2UgZnVuY3Rpb24gYXBwbGljYXRpb24gKHJpZ2h0LWFzc29jaWF0aXZlKSAtLS1cbmNvbnN0IHBhcnNlRG9sbGFyOiBDLlBhcnNlcjxFeHByZXNzaW9uPiA9ICh0b2tlbnMpID0+IHtcbiAgY29uc3QgbGVmdFJlc3VsdCA9IHBhcnNlQ29tcG9zZSh0b2tlbnMpO1xuICBpZiAoIWxlZnRSZXN1bHQuc3VjY2VzcykgcmV0dXJuIGxlZnRSZXN1bHQ7XG4gIFxuICAvLyBDaGVjayBmb3IgJCBvcGVyYXRvclxuICBpZiAobGVmdFJlc3VsdC5yZW1haW5pbmcubGVuZ3RoID4gMCAmJiBcbiAgICAgIGxlZnRSZXN1bHQucmVtYWluaW5nWzBdLnR5cGUgPT09IFwiT1BFUkFUT1JcIiAmJiBcbiAgICAgIGxlZnRSZXN1bHQucmVtYWluaW5nWzBdLnZhbHVlID09PSBcIiRcIikge1xuICAgIFxuICAgIC8vIENvbnN1bWUgdGhlICQgdG9rZW5cbiAgICBjb25zdCByZW1haW5pbmcgPSBsZWZ0UmVzdWx0LnJlbWFpbmluZy5zbGljZSgxKTtcbiAgICBcbiAgICAvLyBSZWN1cnNpdmVseSBwYXJzZSB0aGUgcmlnaHQgc2lkZSAodGhpcyBjcmVhdGVzIHJpZ2h0LWFzc29jaWF0aXZpdHkpXG4gICAgY29uc3QgcmlnaHRSZXN1bHQgPSBwYXJzZURvbGxhcihyZW1haW5pbmcpO1xuICAgIGlmICghcmlnaHRSZXN1bHQuc3VjY2VzcykgcmV0dXJuIHJpZ2h0UmVzdWx0O1xuICAgIFxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGtpbmQ6IFwiYmluYXJ5XCIgYXMgY29uc3QsXG4gICAgICBvcGVyYXRvcjogXCIkXCIgYXMgY29uc3QsXG4gICAgICBsZWZ0OiBsZWZ0UmVzdWx0LnZhbHVlLFxuICAgICAgcmlnaHQ6IHJpZ2h0UmVzdWx0LnZhbHVlLFxuICAgICAgbG9jYXRpb246IGxlZnRSZXN1bHQudmFsdWUubG9jYXRpb24sXG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gcGFyc2VQb3N0Zml4RnJvbVJlc3VsdChyZXN1bHQsIHJpZ2h0UmVzdWx0LnJlbWFpbmluZyk7XG4gIH1cbiAgXG4gIC8vIE5vICQgb3BlcmF0b3IgZm91bmQsIGp1c3QgcmV0dXJuIHRoZSBsZWZ0IGV4cHJlc3Npb25cbiAgcmV0dXJuIHBhcnNlUG9zdGZpeEZyb21SZXN1bHQobGVmdFJlc3VsdC52YWx1ZSwgbGVmdFJlc3VsdC5yZW1haW5pbmcpO1xufTtcblxuLy8gLS0tIElmIEV4cHJlc3Npb24gKGFmdGVyIGRvbGxhciwgYmVmb3JlIHNlcXVlbmNlKSAtLS1cbmNvbnN0IHBhcnNlSWZBZnRlckRvbGxhcjogQy5QYXJzZXI8RXhwcmVzc2lvbj4gPSAodG9rZW5zKSA9PiB7XG4gIGNvbnN0IGlmUmVzdWx0ID0gcGFyc2VJZkV4cHJlc3Npb24odG9rZW5zKTtcbiAgaWYgKCFpZlJlc3VsdC5zdWNjZXNzKSByZXR1cm4gaWZSZXN1bHQ7XG5cbiAgLy8gQXBwbHkgcG9zdGZpeCBvcGVyYXRvcnMgKHR5cGUgYW5ub3RhdGlvbnMpIHRvIHRoZSByZXN1bHRcbiAgcmV0dXJuIHBhcnNlUG9zdGZpeEZyb21SZXN1bHQoaWZSZXN1bHQudmFsdWUsIGlmUmVzdWx0LnJlbWFpbmluZyk7XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gYXBwbHkgcG9zdGZpeCBvcGVyYXRvcnMgdG8gYW4gZXhwcmVzc2lvblxuY29uc3QgcGFyc2VQb3N0Zml4RnJvbVJlc3VsdCA9IChcbiAgZXhwcjogRXhwcmVzc2lvbixcbiAgdG9rZW5zOiBUb2tlbltdXG4pOiBDLlBhcnNlUmVzdWx0PEV4cHJlc3Npb24+ID0+IHtcbiAgbGV0IHJlc3VsdCA9IGV4cHI7XG4gIGxldCByZW1haW5pbmcgPSB0b2tlbnM7XG5cbiAgLy8gVHJ5IHRvIHBhcnNlIHBvc3RmaXggdHlwZSBhbm5vdGF0aW9uc1xuICB3aGlsZSAocmVtYWluaW5nLmxlbmd0aCA+IDApIHtcbiAgICAvLyBUcnkgdG8gcGFyc2UgOiB0eXBlIGdpdmVuIGNvbnN0cmFpbnRcbiAgICBpZiAoXG4gICAgICByZW1haW5pbmcubGVuZ3RoID49IDIgJiZcbiAgICAgIHJlbWFpbmluZ1swXS50eXBlID09PSBcIlBVTkNUVUFUSU9OXCIgJiZcbiAgICAgIHJlbWFpbmluZ1swXS52YWx1ZSA9PT0gXCI6XCJcbiAgICApIHtcbiAgICAgIGNvbnN0IHR5cGVSZXN1bHQgPSBwYXJzZVR5cGVFeHByZXNzaW9uKHJlbWFpbmluZy5zbGljZSgxKSk7XG4gICAgICBpZiAoIXR5cGVSZXN1bHQuc3VjY2VzcykgYnJlYWs7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYSBcImdpdmVuXCIgY29uc3RyYWludCBhZnRlciB0aGUgdHlwZVxuICAgICAgaWYgKFxuICAgICAgICB0eXBlUmVzdWx0LnJlbWFpbmluZy5sZW5ndGggPiAwICYmXG4gICAgICAgIHR5cGVSZXN1bHQucmVtYWluaW5nWzBdLnR5cGUgPT09IFwiS0VZV09SRFwiICYmXG4gICAgICAgIHR5cGVSZXN1bHQucmVtYWluaW5nWzBdLnZhbHVlID09PSBcImdpdmVuXCJcbiAgICAgICkge1xuICAgICAgICBjb25zdCBjb25zdHJhaW50UmVzdWx0ID0gcGFyc2VDb25zdHJhaW50RXhwcihcbiAgICAgICAgICB0eXBlUmVzdWx0LnJlbWFpbmluZy5zbGljZSgxKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIWNvbnN0cmFpbnRSZXN1bHQuc3VjY2VzcykgYnJlYWs7XG5cbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIGtpbmQ6IFwiY29uc3RyYWluZWRcIixcbiAgICAgICAgICBleHByZXNzaW9uOiByZXN1bHQsXG4gICAgICAgICAgdHlwZTogdHlwZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgICBjb25zdHJhaW50OiBjb25zdHJhaW50UmVzdWx0LnZhbHVlLFxuICAgICAgICAgIGxvY2F0aW9uOiByZXN1bHQubG9jYXRpb24sXG4gICAgICAgIH07XG4gICAgICAgIHJlbWFpbmluZyA9IGNvbnN0cmFpbnRSZXN1bHQucmVtYWluaW5nO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEp1c3QgYSB0eXBlIGFubm90YXRpb24gd2l0aG91dCBjb25zdHJhaW50c1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAga2luZDogXCJ0eXBlZFwiLFxuICAgICAgICAgIGV4cHJlc3Npb246IHJlc3VsdCxcbiAgICAgICAgICB0eXBlOiB0eXBlUmVzdWx0LnZhbHVlLFxuICAgICAgICAgIGxvY2F0aW9uOiByZXN1bHQubG9jYXRpb24sXG4gICAgICAgIH07XG4gICAgICAgIHJlbWFpbmluZyA9IHR5cGVSZXN1bHQucmVtYWluaW5nO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyBtb3JlIHBvc3RmaXggb3BlcmF0b3JzXG4gICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgdmFsdWU6IHJlc3VsdCxcbiAgICByZW1haW5pbmcsXG4gIH07XG59O1xuXG4vLyAtLS0gRGVmaW5pdGlvbiAtLS1cbmNvbnN0IHBhcnNlRGVmaW5pdGlvbjogQy5QYXJzZXI8RGVmaW5pdGlvbkV4cHJlc3Npb24+ID0gQy5tYXAoXG4gIEMuc2VxKFxuICAgIEMuaWRlbnRpZmllcigpLFxuICAgIEMub3BlcmF0b3IoXCI9XCIpLFxuICAgIEMubGF6eSgoKSA9PiBwYXJzZVNlcXVlbmNlVGVybVdpdGhJZilcbiAgKSxcbiAgKFtuYW1lLCBlcXVhbHMsIHZhbHVlXSk6IERlZmluaXRpb25FeHByZXNzaW9uID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogXCJkZWZpbml0aW9uXCIsXG4gICAgICBuYW1lOiBuYW1lLnZhbHVlLFxuICAgICAgdmFsdWUsXG4gICAgICBsb2NhdGlvbjogbmFtZS5sb2NhdGlvbixcbiAgICB9O1xuICB9XG4pO1xuXG4vLyAtLS0gRGVmaW5pdGlvbiB3aXRoIHR5cGVkIGV4cHJlc3Npb24gKG5vdyBqdXN0IGEgcmVndWxhciBkZWZpbml0aW9uKSAtLS1cbmNvbnN0IHBhcnNlRGVmaW5pdGlvbldpdGhUeXBlOiBDLlBhcnNlcjxEZWZpbml0aW9uRXhwcmVzc2lvbj4gPSBwYXJzZURlZmluaXRpb247XG5cbi8vIC0tLSBNdXRhYmxlIERlZmluaXRpb24gLS0tXG5jb25zdCBwYXJzZU11dGFibGVEZWZpbml0aW9uOiBDLlBhcnNlcjxcbiAgaW1wb3J0KFwiLi4vYXN0XCIpLk11dGFibGVEZWZpbml0aW9uRXhwcmVzc2lvblxuPiA9IEMubWFwKFxuICBDLnNlcShcbiAgICBDLmtleXdvcmQoXCJtdXRcIiksXG4gICAgQy5pZGVudGlmaWVyKCksXG4gICAgQy5vcGVyYXRvcihcIj1cIiksXG4gICAgQy5sYXp5KCgpID0+IHBhcnNlU2VxdWVuY2VUZXJtV2l0aElmKVxuICApLFxuICAoW1xuICAgIG11dCxcbiAgICBuYW1lLFxuICAgIGVxdWFscyxcbiAgICB2YWx1ZSxcbiAgXSk6IGltcG9ydChcIi4uL2FzdFwiKS5NdXRhYmxlRGVmaW5pdGlvbkV4cHJlc3Npb24gPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiBcIm11dGFibGUtZGVmaW5pdGlvblwiLFxuICAgICAgbmFtZTogbmFtZS52YWx1ZSxcbiAgICAgIHZhbHVlLFxuICAgICAgbG9jYXRpb246IG11dC5sb2NhdGlvbixcbiAgICB9O1xuICB9XG4pO1xuXG4vLyAtLS0gTXV0YXRpb24gLS0tXG5jb25zdCBwYXJzZU11dGF0aW9uOiBDLlBhcnNlcjxpbXBvcnQoXCIuLi9hc3RcIikuTXV0YXRpb25FeHByZXNzaW9uPiA9IEMubWFwKFxuICBDLnNlcShcbiAgICBDLmtleXdvcmQoXCJtdXQhXCIpLFxuICAgIEMuaWRlbnRpZmllcigpLFxuICAgIEMub3BlcmF0b3IoXCI9XCIpLFxuICAgIEMubGF6eSgoKSA9PiBwYXJzZVNlcXVlbmNlVGVybVdpdGhJZilcbiAgKSxcbiAgKFttdXQsIG5hbWUsIGVxdWFscywgdmFsdWVdKTogaW1wb3J0KFwiLi4vYXN0XCIpLk11dGF0aW9uRXhwcmVzc2lvbiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IFwibXV0YXRpb25cIixcbiAgICAgIHRhcmdldDogbmFtZS52YWx1ZSxcbiAgICAgIHZhbHVlLFxuICAgICAgbG9jYXRpb246IG11dC5sb2NhdGlvbixcbiAgICB9O1xuICB9XG4pO1xuXG4vLyBDdXN0b20gcGFyc2VyIGZvciB3aGVyZSBjbGF1c2UgZGVmaW5pdGlvbnMgKGJvdGggcmVndWxhciBhbmQgbXV0YWJsZSlcbmNvbnN0IHBhcnNlV2hlcmVEZWZpbml0aW9uOiBDLlBhcnNlcjxcbiAgRGVmaW5pdGlvbkV4cHJlc3Npb24gfCBNdXRhYmxlRGVmaW5pdGlvbkV4cHJlc3Npb25cbj4gPSAodG9rZW5zKSA9PiB7XG4gIC8vIFRyeSBtdXRhYmxlIGRlZmluaXRpb24gZmlyc3RcbiAgY29uc3QgbXV0YWJsZVJlc3VsdCA9IHBhcnNlTXV0YWJsZURlZmluaXRpb24odG9rZW5zKTtcbiAgaWYgKG11dGFibGVSZXN1bHQuc3VjY2Vzcykge1xuICAgIHJldHVybiBtdXRhYmxlUmVzdWx0O1xuICB9XG4gIC8vIFRyeSByZWd1bGFyIGRlZmluaXRpb25cbiAgY29uc3QgcmVndWxhclJlc3VsdCA9IHBhcnNlRGVmaW5pdGlvbih0b2tlbnMpO1xuICBpZiAocmVndWxhclJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHJlZ3VsYXJSZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICBlcnJvcjogXCJFeHBlY3RlZCBkZWZpbml0aW9uIGluIHdoZXJlIGNsYXVzZVwiLFxuICAgIHBvc2l0aW9uOiB0b2tlbnNbMF0/LmxvY2F0aW9uLnN0YXJ0LmxpbmUgfHwgMCxcbiAgfTtcbn07XG5cbi8vIC0tLSBBRFQgQ29uc3RydWN0b3IgLS0tXG5jb25zdCBwYXJzZUNvbnN0cnVjdG9yOiBDLlBhcnNlcjxDb25zdHJ1Y3RvckRlZmluaXRpb24+ID0gQy5tYXAoXG4gIEMuc2VxKHBhcnNlVHlwZU5hbWUsIEMubWFueShDLmxhenkoKCkgPT4gcGFyc2VUeXBlRXhwcmVzc2lvbikpKSxcbiAgKFtuYW1lLCBhcmdzXSk6IENvbnN0cnVjdG9yRGVmaW5pdGlvbiA9PiAoe1xuICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgYXJncyxcbiAgICBsb2NhdGlvbjogY3JlYXRlTG9jYXRpb24obmFtZS5sb2NhdGlvbi5zdGFydCwgbmFtZS5sb2NhdGlvbi5lbmQpLFxuICB9KVxuKTtcblxuLy8gLS0tIFR5cGUgRGVmaW5pdGlvbiAtLS1cbmNvbnN0IHBhcnNlVHlwZURlZmluaXRpb246IEMuUGFyc2VyPFR5cGVEZWZpbml0aW9uRXhwcmVzc2lvbj4gPSBDLm1hcChcbiAgQy5zZXEoXG4gICAgQy5rZXl3b3JkKFwidHlwZVwiKSxcbiAgICBwYXJzZVR5cGVOYW1lLFxuICAgIEMubWFueShDLmlkZW50aWZpZXIoKSksXG4gICAgQy5vcGVyYXRvcihcIj1cIiksXG4gICAgQy5zZXBCeShwYXJzZUNvbnN0cnVjdG9yLCBDLm9wZXJhdG9yKFwifFwiKSlcbiAgKSxcbiAgKFtcbiAgICB0eXBlLFxuICAgIG5hbWUsXG4gICAgdHlwZVBhcmFtcyxcbiAgICBlcXVhbHMsXG4gICAgY29uc3RydWN0b3JzLFxuICBdKTogVHlwZURlZmluaXRpb25FeHByZXNzaW9uID0+ICh7XG4gICAga2luZDogXCJ0eXBlLWRlZmluaXRpb25cIixcbiAgICBuYW1lOiBuYW1lLnZhbHVlLFxuICAgIHR5cGVQYXJhbXM6IHR5cGVQYXJhbXMubWFwKChwOiBhbnkpID0+IHAudmFsdWUpLFxuICAgIGNvbnN0cnVjdG9ycyxcbiAgICBsb2NhdGlvbjogY3JlYXRlTG9jYXRpb24oXG4gICAgICB0eXBlLmxvY2F0aW9uLnN0YXJ0LFxuICAgICAgY29uc3RydWN0b3JzW2NvbnN0cnVjdG9ycy5sZW5ndGggLSAxXT8ubG9jYXRpb24uZW5kIHx8IGVxdWFscy5sb2NhdGlvbi5lbmRcbiAgICApLFxuICB9KVxuKTtcblxuLy8gLS0tIENvbnN0cmFpbnQgRnVuY3Rpb24gLS0tXG5jb25zdCBwYXJzZUNvbnN0cmFpbnRGdW5jdGlvbjogQy5QYXJzZXI8Q29uc3RyYWludEZ1bmN0aW9uPiA9IEMubWFwKFxuICBDLnNlcShcbiAgICBDLmlkZW50aWZpZXIoKSxcbiAgICBDLm1hbnkoQy5pZGVudGlmaWVyKCkpLCAvLyB0eXBlIHBhcmFtZXRlcnMgbGlrZSBcImEgYlwiIGluIFwiYmluZCBhIGJcIlxuICAgIEMucHVuY3R1YXRpb24oXCI6XCIpLFxuICAgIEMubGF6eSgoKSA9PiBwYXJzZVR5cGVFeHByZXNzaW9uKVxuICApLFxuICAoW25hbWUsIHR5cGVQYXJhbXMsIGNvbG9uLCB0eXBlXSk6IENvbnN0cmFpbnRGdW5jdGlvbiA9PiAoe1xuICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgdHlwZVBhcmFtczogdHlwZVBhcmFtcy5tYXAoKHA6IGFueSkgPT4gcC52YWx1ZSksXG4gICAgdHlwZSxcbiAgICBsb2NhdGlvbjogY3JlYXRlTG9jYXRpb24obmFtZS5sb2NhdGlvbi5zdGFydCwgY29sb24ubG9jYXRpb24uZW5kKSxcbiAgfSlcbik7XG5cbi8vIC0tLSBDb25zdHJhaW50IERlZmluaXRpb24gLS0tXG5jb25zdCBwYXJzZUNvbnN0cmFpbnREZWZpbml0aW9uOiBDLlBhcnNlcjxDb25zdHJhaW50RGVmaW5pdGlvbkV4cHJlc3Npb24+ID0gQy5tYXAoXG4gIEMuc2VxKFxuICAgIEMua2V5d29yZChcImNvbnN0cmFpbnRcIiksXG4gICAgQy5pZGVudGlmaWVyKCksIC8vIGNvbnN0cmFpbnQgbmFtZSBsaWtlIFwiTW9uYWRcIlxuICAgIEMuaWRlbnRpZmllcigpLCAvLyB0eXBlIHBhcmFtZXRlciBsaWtlIFwibVwiXG4gICAgQy5wdW5jdHVhdGlvbihcIihcIiksXG4gICAgQy5zZXBCeShwYXJzZUNvbnN0cmFpbnRGdW5jdGlvbiwgQy5wdW5jdHVhdGlvbihcIjtcIikpLFxuICAgIEMucHVuY3R1YXRpb24oXCIpXCIpXG4gICksXG4gIChbY29uc3RyYWludEtleXdvcmQsIG5hbWUsIHR5cGVQYXJhbSwgb3BlblBhcmVuLCBmdW5jdGlvbnMsIGNsb3NlUGFyZW5dKTogQ29uc3RyYWludERlZmluaXRpb25FeHByZXNzaW9uID0+ICh7XG4gICAga2luZDogXCJjb25zdHJhaW50LWRlZmluaXRpb25cIixcbiAgICBuYW1lOiBuYW1lLnZhbHVlLFxuICAgIHR5cGVQYXJhbTogdHlwZVBhcmFtLnZhbHVlLFxuICAgIGZ1bmN0aW9ucyxcbiAgICBsb2NhdGlvbjogY3JlYXRlTG9jYXRpb24oY29uc3RyYWludEtleXdvcmQubG9jYXRpb24uc3RhcnQsIGNsb3NlUGFyZW4ubG9jYXRpb24uZW5kKSxcbiAgfSlcbik7XG5cbi8vIC0tLSBJbXBsZW1lbnRhdGlvbiBGdW5jdGlvbiAtLS1cbmNvbnN0IHBhcnNlSW1wbGVtZW50YXRpb25GdW5jdGlvbjogQy5QYXJzZXI8SW1wbGVtZW50YXRpb25GdW5jdGlvbj4gPSBDLm1hcChcbiAgQy5zZXEoXG4gICAgQy5pZGVudGlmaWVyKCksXG4gICAgQy5vcGVyYXRvcihcIj1cIiksXG4gICAgQy5sYXp5KCgpID0+IHBhcnNlU2VxdWVuY2VUZXJtKVxuICApLFxuICAoW25hbWUsIGVxdWFscywgdmFsdWVdKTogSW1wbGVtZW50YXRpb25GdW5jdGlvbiA9PiAoe1xuICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgdmFsdWUsXG4gICAgbG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uKG5hbWUubG9jYXRpb24uc3RhcnQsIHZhbHVlLmxvY2F0aW9uLmVuZCksXG4gIH0pXG4pO1xuXG4vLyAtLS0gSW1wbGVtZW50IERlZmluaXRpb24gLS0tXG5jb25zdCBwYXJzZUltcGxlbWVudERlZmluaXRpb246IEMuUGFyc2VyPEltcGxlbWVudERlZmluaXRpb25FeHByZXNzaW9uPiA9IEMubWFwKFxuICBDLnNlcShcbiAgICBDLmtleXdvcmQoXCJpbXBsZW1lbnRcIiksXG4gICAgQy5pZGVudGlmaWVyKCksIC8vIGNvbnN0cmFpbnQgbmFtZSBsaWtlIFwiTW9uYWRcIlxuICAgIHBhcnNlVHlwZU5hbWUsIC8vIHR5cGUgbmFtZSBsaWtlIFwiTGlzdFwiIG9yIFwiSW50XCJcbiAgICBDLnB1bmN0dWF0aW9uKFwiKFwiKSxcbiAgICBDLnNlcEJ5KHBhcnNlSW1wbGVtZW50YXRpb25GdW5jdGlvbiwgQy5wdW5jdHVhdGlvbihcIjtcIikpLFxuICAgIEMucHVuY3R1YXRpb24oXCIpXCIpXG4gICksXG4gIChbaW1wbGVtZW50S2V5d29yZCwgY29uc3RyYWludE5hbWUsIHR5cGVOYW1lLCBvcGVuUGFyZW4sIGltcGxlbWVudGF0aW9ucywgY2xvc2VQYXJlbl0pOiBJbXBsZW1lbnREZWZpbml0aW9uRXhwcmVzc2lvbiA9PiAoe1xuICAgIGtpbmQ6IFwiaW1wbGVtZW50LWRlZmluaXRpb25cIixcbiAgICBjb25zdHJhaW50TmFtZTogY29uc3RyYWludE5hbWUudmFsdWUsXG4gICAgdHlwZU5hbWU6IHR5cGVOYW1lLnZhbHVlLFxuICAgIGltcGxlbWVudGF0aW9ucyxcbiAgICBsb2NhdGlvbjogY3JlYXRlTG9jYXRpb24oaW1wbGVtZW50S2V5d29yZC5sb2NhdGlvbi5zdGFydCwgY2xvc2VQYXJlbi5sb2NhdGlvbi5lbmQpLFxuICB9KVxuKTtcblxuLy8gLS0tIFBhdHRlcm4gUGFyc2luZyAtLS1cbi8vIEJhc2ljIHBhdHRlcm4gcGFyc2luZyBmb3IgY29uc3RydWN0b3IgYXJndW1lbnRzIChubyBuZXN0ZWQgY29uc3RydWN0b3JzIHdpdGggYXJncylcbmNvbnN0IHBhcnNlQmFzaWNQYXR0ZXJuOiBDLlBhcnNlcjxQYXR0ZXJuPiA9IEMuY2hvaWNlKFxuICAvLyBXaWxkY2FyZCBwYXR0ZXJuOiBfXG4gIEMubWFwKFxuICAgIEMucHVuY3R1YXRpb24oXCJfXCIpLFxuICAgICh1bmRlcnNjb3JlKTogUGF0dGVybiA9PiAoe1xuICAgICAga2luZDogXCJ3aWxkY2FyZFwiLFxuICAgICAgbG9jYXRpb246IHVuZGVyc2NvcmUubG9jYXRpb24sXG4gICAgfSlcbiAgKSxcbiAgLy8gTGl0ZXJhbCBwYXR0ZXJuOiBudW1iZXIgb3Igc3RyaW5nXG4gIEMubWFwKFxuICAgIEMubnVtYmVyKCksXG4gICAgKG51bSk6IFBhdHRlcm4gPT4gKHtcbiAgICAgIGtpbmQ6IFwibGl0ZXJhbFwiLFxuICAgICAgdmFsdWU6IHBhcnNlSW50KG51bS52YWx1ZSksXG4gICAgICBsb2NhdGlvbjogbnVtLmxvY2F0aW9uLFxuICAgIH0pXG4gICksXG4gIEMubWFwKFxuICAgIEMuc3RyaW5nKCksXG4gICAgKHN0cik6IFBhdHRlcm4gPT4gKHtcbiAgICAgIGtpbmQ6IFwibGl0ZXJhbFwiLFxuICAgICAgdmFsdWU6IHN0ci52YWx1ZSxcbiAgICAgIGxvY2F0aW9uOiBzdHIubG9jYXRpb24sXG4gICAgfSlcbiAgKSxcbiAgLy8gQ29uc3RydWN0b3Igb3IgdmFyaWFibGUgcGF0dGVybjogaWRlbnRpZmllciAoZGVjaWRlIGJhc2VkIG9uIGNhcGl0YWxpemF0aW9uKVxuICBDLm1hcChDLmlkZW50aWZpZXIoKSwgKG5hbWUpOiBQYXR0ZXJuID0+IHtcbiAgICAvLyBJZiBpZGVudGlmaWVyIHN0YXJ0cyB3aXRoIHVwcGVyY2FzZSwgdHJlYXQgYXMgY29uc3RydWN0b3IgcGF0dGVybiAoemVybyBhcmdzKVxuICAgIGlmIChuYW1lLnZhbHVlLmxlbmd0aCA+IDAgJiYgbmFtZS52YWx1ZVswXSA+PSBcIkFcIiAmJiBuYW1lLnZhbHVlWzBdIDw9IFwiWlwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICBsb2NhdGlvbjogbmFtZS5sb2NhdGlvbixcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgdHJlYXQgYXMgdmFyaWFibGUgcGF0dGVyblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJ2YXJpYWJsZVwiLFxuICAgICAgICBuYW1lOiBuYW1lLnZhbHVlLFxuICAgICAgICBsb2NhdGlvbjogbmFtZS5sb2NhdGlvbixcbiAgICAgIH07XG4gICAgfVxuICB9KVxuKTtcblxuY29uc3QgcGFyc2VQYXR0ZXJuOiBDLlBhcnNlcjxQYXR0ZXJuPiA9IEMuY2hvaWNlKFxuICAvLyBXaWxkY2FyZCBwYXR0ZXJuOiBfXG4gIEMubWFwKFxuICAgIEMucHVuY3R1YXRpb24oXCJfXCIpLFxuICAgICh1bmRlcnNjb3JlKTogUGF0dGVybiA9PiAoe1xuICAgICAga2luZDogXCJ3aWxkY2FyZFwiLFxuICAgICAgbG9jYXRpb246IHVuZGVyc2NvcmUubG9jYXRpb24sXG4gICAgfSlcbiAgKSxcbiAgLy8gQ29uc3RydWN0b3IgcGF0dGVybiB3aXRoIGFyZ3VtZW50czogU29tZSB4IHlcbiAgQy5tYXAoXG4gICAgQy5zZXEoQy5pZGVudGlmaWVyKCksIEMubWFueTEocGFyc2VCYXNpY1BhdHRlcm4pKSxcbiAgICAoW25hbWUsIGFyZ3NdKTogUGF0dGVybiA9PiAoe1xuICAgICAga2luZDogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgbmFtZTogbmFtZS52YWx1ZSxcbiAgICAgIGFyZ3MsXG4gICAgICBsb2NhdGlvbjogY3JlYXRlTG9jYXRpb24oXG4gICAgICAgIG5hbWUubG9jYXRpb24uc3RhcnQsXG4gICAgICAgIGFyZ3NbYXJncy5sZW5ndGggLSAxXS5sb2NhdGlvbi5lbmRcbiAgICAgICksXG4gICAgfSlcbiAgKSxcbiAgLy8gQ29uc3RydWN0b3IgcGF0dGVybiB3aXRoIHBhcmVudGhlc2l6ZWQgYXJndW1lbnRzOiBXcmFwIChWYWx1ZSBuKVxuICBDLm1hcChcbiAgICBDLnNlcShcbiAgICAgIEMuaWRlbnRpZmllcigpLFxuICAgICAgQy5wdW5jdHVhdGlvbihcIihcIiksXG4gICAgICBDLmxhenkoKCkgPT4gcGFyc2VQYXR0ZXJuKSxcbiAgICAgIEMucHVuY3R1YXRpb24oXCIpXCIpXG4gICAgKSxcbiAgICAoW25hbWUsIG9wZW5QYXJlbiwgYXJnLCBjbG9zZVBhcmVuXSk6IFBhdHRlcm4gPT4gKHtcbiAgICAgIGtpbmQ6IFwiY29uc3RydWN0b3JcIixcbiAgICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgICBhcmdzOiBbYXJnXSxcbiAgICAgIGxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvbihuYW1lLmxvY2F0aW9uLnN0YXJ0LCBjbG9zZVBhcmVuLmxvY2F0aW9uLmVuZCksXG4gICAgfSlcbiAgKSxcbiAgLy8gQ29uc3RydWN0b3Igb3IgdmFyaWFibGUgcGF0dGVybjogaWRlbnRpZmllciAoZGVjaWRlIGJhc2VkIG9uIGNhcGl0YWxpemF0aW9uKVxuICBDLm1hcChDLmlkZW50aWZpZXIoKSwgKG5hbWUpOiBQYXR0ZXJuID0+IHtcbiAgICAvLyBJZiBpZGVudGlmaWVyIHN0YXJ0cyB3aXRoIHVwcGVyY2FzZSwgdHJlYXQgYXMgY29uc3RydWN0b3IgcGF0dGVyblxuICAgIGlmIChuYW1lLnZhbHVlLmxlbmd0aCA+IDAgJiYgbmFtZS52YWx1ZVswXSA+PSBcIkFcIiAmJiBuYW1lLnZhbHVlWzBdIDw9IFwiWlwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICBsb2NhdGlvbjogbmFtZS5sb2NhdGlvbixcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgdHJlYXQgYXMgdmFyaWFibGUgcGF0dGVyblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogXCJ2YXJpYWJsZVwiLFxuICAgICAgICBuYW1lOiBuYW1lLnZhbHVlLFxuICAgICAgICBsb2NhdGlvbjogbmFtZS5sb2NhdGlvbixcbiAgICAgIH07XG4gICAgfVxuICB9KVxuKTtcblxuLy8gLS0tIE1hdGNoIENhc2UgRXhwcmVzc2lvbiBQYXJzZXIgLS0tXG4vLyBUaGlzIHBhcnNlciBzdXBwb3J0cyBleHByZXNzaW9ucyBpbiBtYXRjaCBjYXNlcywgaW5jbHVkaW5nIG5lc3RlZCBtYXRjaCBleHByZXNzaW9uc1xuY29uc3QgcGFyc2VNYXRjaENhc2VFeHByZXNzaW9uOiBDLlBhcnNlcjxFeHByZXNzaW9uPiA9IEMuY2hvaWNlKFxuICBDLmxhenkoKCkgPT4gcGFyc2VNYXRjaEV4cHJlc3Npb24pLCAvLyBTdXBwb3J0IG5lc3RlZCBtYXRjaCBleHByZXNzaW9uc1xuICBwYXJzZUlmRXhwcmVzc2lvbiwgLy8gU3VwcG9ydCBpZiBleHByZXNzaW9ucyAgXG4gIEMubGF6eSgoKSA9PiBwYXJzZUV4cHJXaXRoVHlwZSkgLy8gU3VwcG9ydCBhbGwgb3RoZXIgZXhwcmVzc2lvbnMgaW5jbHVkaW5nIHR5cGUgYW5ub3RhdGlvbnNcbik7XG5cbi8vIC0tLSBNYXRjaCBDYXNlIC0tLVxuY29uc3QgcGFyc2VNYXRjaENhc2U6IEMuUGFyc2VyPE1hdGNoQ2FzZT4gPSBDLm1hcChcbiAgQy5zZXEoXG4gICAgcGFyc2VQYXR0ZXJuLFxuICAgIEMub3BlcmF0b3IoXCI9PlwiKSxcbiAgICBDLmxhenkoKCkgPT4gcGFyc2VNYXRjaENhc2VFeHByZXNzaW9uKSAvLyBVc2UgZGVkaWNhdGVkIHBhcnNlciBmb3IgbWF0Y2ggY2FzZSBleHByZXNzaW9uc1xuICApLFxuICAoW3BhdHRlcm4sIGFycm93LCBleHByZXNzaW9uXSk6IE1hdGNoQ2FzZSA9PiAoe1xuICAgIHBhdHRlcm4sXG4gICAgZXhwcmVzc2lvbixcbiAgICBsb2NhdGlvbjogY3JlYXRlTG9jYXRpb24ocGF0dGVybi5sb2NhdGlvbi5zdGFydCwgZXhwcmVzc2lvbi5sb2NhdGlvbi5lbmQpLFxuICB9KVxuKTtcblxuLy8gLS0tIE1hdGNoIEV4cHJlc3Npb24gLS0tXG5jb25zdCBwYXJzZU1hdGNoRXhwcmVzc2lvbjogQy5QYXJzZXI8TWF0Y2hFeHByZXNzaW9uPiA9IEMubWFwKFxuICBDLnNlcShcbiAgICBDLmtleXdvcmQoXCJtYXRjaFwiKSxcbiAgICBDLmxhenkoKCkgPT4gcGFyc2VUaHJ1c2gpLCAvLyBVc2UgYSBzaW1wbGVyIGV4cHJlc3Npb24gcGFyc2VyIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAgICBDLmtleXdvcmQoXCJ3aXRoXCIpLFxuICAgIEMucHVuY3R1YXRpb24oXCIoXCIpLFxuICAgIEMuc2VwQnkocGFyc2VNYXRjaENhc2UsIEMucHVuY3R1YXRpb24oXCI7XCIpKSxcbiAgICBDLnB1bmN0dWF0aW9uKFwiKVwiKVxuICApLFxuICAoW1xuICAgIG1hdGNoLFxuICAgIGV4cHJlc3Npb24sXG4gICAgd2l0aF8sXG4gICAgb3BlblBhcmVuLFxuICAgIGNhc2VzLFxuICAgIGNsb3NlUGFyZW4sXG4gIF0pOiBNYXRjaEV4cHJlc3Npb24gPT4gKHtcbiAgICBraW5kOiBcIm1hdGNoXCIsXG4gICAgZXhwcmVzc2lvbixcbiAgICBjYXNlcyxcbiAgICBsb2NhdGlvbjogY3JlYXRlTG9jYXRpb24obWF0Y2gubG9jYXRpb24uc3RhcnQsIGNsb3NlUGFyZW4ubG9jYXRpb24uZW5kKSxcbiAgfSlcbik7XG5cbi8vIC0tLSBXaGVyZSBFeHByZXNzaW9uIC0tLVxuY29uc3QgcGFyc2VXaGVyZUV4cHJlc3Npb246IEMuUGFyc2VyPFdoZXJlRXhwcmVzc2lvbj4gPSBDLm1hcChcbiAgQy5zZXEoXG4gICAgQy5sYXp5KCgpID0+IHBhcnNlU2VxdWVuY2VUZXJtV2l0aElmRXhjZXB0UmVjb3JkKSwgLy8gTWFpbiBleHByZXNzaW9uIChubyByZWNvcmRzIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kpXG4gICAgQy5rZXl3b3JkKFwid2hlcmVcIiksXG4gICAgQy5wdW5jdHVhdGlvbihcIihcIiksXG4gICAgQy5zZXBCeShwYXJzZVdoZXJlRGVmaW5pdGlvbiwgQy5wdW5jdHVhdGlvbihcIjtcIikpLFxuICAgIEMucHVuY3R1YXRpb24oXCIpXCIpXG4gICksXG4gIChbbWFpbiwgd2hlcmUsIG9wZW5QYXJlbiwgZGVmaW5pdGlvbnMsIGNsb3NlUGFyZW5dKTogV2hlcmVFeHByZXNzaW9uID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogXCJ3aGVyZVwiLFxuICAgICAgbWFpbixcbiAgICAgIGRlZmluaXRpb25zLFxuICAgICAgbG9jYXRpb246IG1haW4ubG9jYXRpb24sXG4gICAgfTtcbiAgfVxuKTtcblxuLy8gLS0tIFNlcXVlbmNlIHRlcm06IGV2ZXJ5dGhpbmcgZWxzZSAtLS1cbmNvbnN0IHBhcnNlU2VxdWVuY2VUZXJtOiBDLlBhcnNlcjxFeHByZXNzaW9uPiA9IEMuY2hvaWNlKFxuICAvLyBQYXJzZSBrZXl3b3JkLWJhc2VkIGV4cHJlc3Npb25zIGZpcnN0IHRvIGF2b2lkIGlkZW50aWZpZXIgY29uZmxpY3RzXG4gIHBhcnNlTWF0Y2hFeHByZXNzaW9uLCAvLyBBRFQgcGF0dGVybiBtYXRjaGluZyAoc3RhcnRzIHdpdGggXCJtYXRjaFwiKVxuICBwYXJzZVR5cGVEZWZpbml0aW9uLCAvLyBBRFQgdHlwZSBkZWZpbml0aW9ucyAoc3RhcnRzIHdpdGggXCJ0eXBlXCIpXG4gIHBhcnNlQ29uc3RyYWludERlZmluaXRpb24sIC8vIGNvbnN0cmFpbnQgZGVmaW5pdGlvbnMgKHN0YXJ0cyB3aXRoIFwiY29uc3RyYWludFwiKVxuICBwYXJzZUltcGxlbWVudERlZmluaXRpb24sIC8vIGltcGxlbWVudCBkZWZpbml0aW9ucyAoc3RhcnRzIHdpdGggXCJpbXBsZW1lbnRcIilcbiAgcGFyc2VNdXRhYmxlRGVmaW5pdGlvbiwgLy8gc3RhcnRzIHdpdGggXCJtdXRcIlxuICBwYXJzZU11dGF0aW9uLCAvLyBzdGFydHMgd2l0aCBcIm11dCFcIlxuICBwYXJzZUltcG9ydEV4cHJlc3Npb24sIC8vIHN0YXJ0cyB3aXRoIFwiaW1wb3J0XCJcbiAgcGFyc2VJZkFmdGVyRG9sbGFyLCAvLyBpZiBleHByZXNzaW9ucyAoc3RhcnRzIHdpdGggXCJpZlwiKVxuICAvLyBUaGVuIHBhcnNlIGlkZW50aWZpZXItYmFzZWQgZXhwcmVzc2lvbnNcbiAgcGFyc2VEZWZpbml0aW9uV2l0aFR5cGUsIC8vIGFsbG93IGRlZmluaXRpb25zIHdpdGggdHlwZSBhbm5vdGF0aW9uc1xuICBwYXJzZURlZmluaXRpb24sIC8vIGZhbGxiYWNrIHRvIHJlZ3VsYXIgZGVmaW5pdGlvbnMgIFxuICBwYXJzZVdoZXJlRXhwcmVzc2lvbixcbiAgcGFyc2VUaHJ1c2gsIC8vIGZ1bGwgZXhwcmVzc2lvbiBoaWVyYXJjaHkgKGluY2x1ZGVzIGFsbCBwcmltYXJpZXMgYW5kIHR5cGUgYW5ub3RhdGlvbnMpXG4gIHBhcnNlUmVjb3JkLFxuICBwYXJzZVRocnVzaCxcbiAgcGFyc2VMYW1iZGFFeHByZXNzaW9uXG4pO1xuXG4vLyBWZXJzaW9uIHdpdGhvdXQgcmVjb3JkcyB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5XG5jb25zdCBwYXJzZVNlcXVlbmNlVGVybUV4Y2VwdFJlY29yZDogQy5QYXJzZXI8RXhwcmVzc2lvbj4gPSBDLmNob2ljZShcbiAgLy8gUGFyc2Uga2V5d29yZC1iYXNlZCBleHByZXNzaW9ucyBmaXJzdFxuICBwYXJzZU1hdGNoRXhwcmVzc2lvbiwgLy8gQURUIHBhdHRlcm4gbWF0Y2hpbmdcbiAgcGFyc2VUeXBlRGVmaW5pdGlvbiwgLy8gQURUIHR5cGUgZGVmaW5pdGlvbnNcbiAgcGFyc2VDb25zdHJhaW50RGVmaW5pdGlvbiwgLy8gY29uc3RyYWludCBkZWZpbml0aW9uc1xuICBwYXJzZUltcGxlbWVudERlZmluaXRpb24sIC8vIGltcGxlbWVudCBkZWZpbml0aW9uc1xuICBwYXJzZU11dGFibGVEZWZpbml0aW9uLFxuICBwYXJzZU11dGF0aW9uLFxuICBwYXJzZUltcG9ydEV4cHJlc3Npb24sXG4gIC8vIFRoZW4gaWRlbnRpZmllci1iYXNlZCBleHByZXNzaW9uc1xuICBwYXJzZURlZmluaXRpb24sIC8vIFJlZ3VsYXIgZGVmaW5pdGlvbnNcbiAgcGFyc2VUaHJ1c2gsXG4gIHBhcnNlTGFtYmRhRXhwcmVzc2lvbixcbiAgcGFyc2VOdW1iZXIsXG4gIHBhcnNlU3RyaW5nLFxuICBwYXJzZUlkZW50aWZpZXIsXG4gIHBhcnNlTGlzdCxcbiAgcGFyc2VBY2Nlc3NvcixcbiAgcGFyc2VQYXJlbkV4cHJcbik7XG5cbi8vIHBhcnNlU2VxdWVuY2VUZXJtIG5vdyBpbmNsdWRlcyBwYXJzZUlmRXhwcmVzc2lvblxuY29uc3QgcGFyc2VTZXF1ZW5jZVRlcm1XaXRoSWY6IEMuUGFyc2VyPEV4cHJlc3Npb24+ID0gcGFyc2VTZXF1ZW5jZVRlcm07XG5cbi8vIFZlcnNpb24gd2l0aCBpZiBidXQgd2l0aG91dCByZWNvcmRzIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3lcbmNvbnN0IHBhcnNlU2VxdWVuY2VUZXJtV2l0aElmRXhjZXB0UmVjb3JkOiBDLlBhcnNlcjxFeHByZXNzaW9uPiA9IEMuY2hvaWNlKFxuICBwYXJzZVNlcXVlbmNlVGVybUV4Y2VwdFJlY29yZCxcbiAgcGFyc2VJZkV4cHJlc3Npb25cbik7XG5cbi8vIC0tLSBQYXJzZSBhdG9taWMgY29uc3RyYWludCAtLS1cbmNvbnN0IHBhcnNlQXRvbWljQ29uc3RyYWludDogQy5QYXJzZXI8Q29uc3RyYWludEV4cHI+ID0gQy5jaG9pY2UoXG4gIC8vIFBhcmVudGhlc2l6ZWQgY29uc3RyYWludFxuICBDLm1hcChcbiAgICBDLnNlcShcbiAgICAgIEMucHVuY3R1YXRpb24oXCIoXCIpLFxuICAgICAgQy5sYXp5KCgpID0+IHBhcnNlQ29uc3RyYWludEV4cHIpLFxuICAgICAgQy5wdW5jdHVhdGlvbihcIilcIilcbiAgICApLFxuICAgIChbb3BlbiwgZXhwciwgY2xvc2VdKSA9PiAoeyBraW5kOiBcInBhcmVuXCIsIGV4cHIgfSlcbiAgKSxcbiAgLy8gYSBpcyBDb2xsZWN0aW9uXG4gIEMubWFwKFxuICAgIEMuc2VxKFxuICAgICAgQy5pZGVudGlmaWVyKCksXG4gICAgICBDLmtleXdvcmQoXCJpc1wiKSxcbiAgICAgIEMuY2hvaWNlKFxuICAgICAgICBDLmlkZW50aWZpZXIoKVxuICAgICAgICAvLyBSZW1vdmVkIG1lYW5pbmdsZXNzIGNvbnN0cmFpbnQga2V5d29yZHNcbiAgICAgIClcbiAgICApLFxuICAgIChbdHlwZVZhciwgaXNLZXl3b3JkLCBjb25zdHJhaW50XSk6IENvbnN0cmFpbnRFeHByID0+ICh7XG4gICAgICBraW5kOiBcImlzXCIsXG4gICAgICB0eXBlVmFyOiB0eXBlVmFyLnZhbHVlLFxuICAgICAgY29uc3RyYWludDogY29uc3RyYWludC52YWx1ZSxcbiAgICB9KVxuICApLFxuICAvLyBhIGhhcyBmaWVsZCBcIm5hbWVcIiBvZiB0eXBlIFRcbiAgQy5tYXAoXG4gICAgQy5zZXEoXG4gICAgICBDLmlkZW50aWZpZXIoKSxcbiAgICAgIEMua2V5d29yZChcImhhc1wiKSxcbiAgICAgIEMua2V5d29yZChcImZpZWxkXCIpLFxuICAgICAgQy5zdHJpbmcoKSxcbiAgICAgIEMua2V5d29yZChcIm9mXCIpLFxuICAgICAgQy5rZXl3b3JkKFwidHlwZVwiKSxcbiAgICAgIEMubGF6eSgoKSA9PiBwYXJzZVR5cGVFeHByZXNzaW9uKVxuICAgICksXG4gICAgKFtcbiAgICAgIHR5cGVWYXIsXG4gICAgICBoYXMsXG4gICAgICBmaWVsZCxcbiAgICAgIGZpZWxkTmFtZSxcbiAgICAgIG9mLFxuICAgICAgdHlwZSxcbiAgICAgIGZpZWxkVHlwZSxcbiAgICBdKTogQ29uc3RyYWludEV4cHIgPT4gKHtcbiAgICAgIGtpbmQ6IFwiaGFzRmllbGRcIixcbiAgICAgIHR5cGVWYXI6IHR5cGVWYXIudmFsdWUsXG4gICAgICBmaWVsZDogZmllbGROYW1lLnZhbHVlLFxuICAgICAgZmllbGRUeXBlLFxuICAgIH0pXG4gICksXG4gIC8vIGEgaW1wbGVtZW50cyBJbnRlcmZhY2VcbiAgQy5tYXAoXG4gICAgQy5zZXEoQy5pZGVudGlmaWVyKCksIEMua2V5d29yZChcImltcGxlbWVudHNcIiksIEMuaWRlbnRpZmllcigpKSxcbiAgICAoW3R5cGVWYXIsIGltcGxlbWVudHNLZXl3b3JkLCBpbnRlcmZhY2VOYW1lXSk6IENvbnN0cmFpbnRFeHByID0+ICh7XG4gICAgICBraW5kOiBcImltcGxlbWVudHNcIixcbiAgICAgIHR5cGVWYXI6IHR5cGVWYXIudmFsdWUsXG4gICAgICBpbnRlcmZhY2VOYW1lOiBpbnRlcmZhY2VOYW1lLnZhbHVlLFxuICAgIH0pXG4gIClcbik7XG5cbi8vIC0tLSBQYXJzZSBjb25zdHJhaW50IGV4cHJlc3Npb24gd2l0aCBwcmVjZWRlbmNlOiBhbmQgPiBvciAtLS1cbmNvbnN0IHBhcnNlQ29uc3RyYWludEV4cHI6IEMuUGFyc2VyPENvbnN0cmFpbnRFeHByPiA9ICh0b2tlbnMpID0+IHtcbiAgLy8gUGFyc2UgbGVmdCBzaWRlIChhbmQgY2hhaW5zKVxuICBsZXQgbGVmdFJlc3VsdCA9IHBhcnNlQ29uc3RyYWludEFuZCh0b2tlbnMpO1xuICBpZiAoIWxlZnRSZXN1bHQuc3VjY2VzcykgcmV0dXJuIGxlZnRSZXN1bHQ7XG4gIGxldCBsZWZ0ID0gbGVmdFJlc3VsdC52YWx1ZTtcbiAgbGV0IHJlc3QgPSBsZWZ0UmVzdWx0LnJlbWFpbmluZztcblxuICAvLyBQYXJzZSBvciBjaGFpbnNcbiAgd2hpbGUgKFxuICAgIHJlc3QubGVuZ3RoID4gMCAmJlxuICAgIHJlc3RbMF0udHlwZSA9PT0gXCJLRVlXT1JEXCIgJiZcbiAgICByZXN0WzBdLnZhbHVlID09PSBcIm9yXCJcbiAgKSB7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMSk7XG4gICAgY29uc3QgcmlnaHRSZXN1bHQgPSBwYXJzZUNvbnN0cmFpbnRBbmQocmVzdCk7XG4gICAgaWYgKCFyaWdodFJlc3VsdC5zdWNjZXNzKSByZXR1cm4gcmlnaHRSZXN1bHQ7XG4gICAgbGVmdCA9IHsga2luZDogXCJvclwiLCBsZWZ0LCByaWdodDogcmlnaHRSZXN1bHQudmFsdWUgfTtcbiAgICByZXN0ID0gcmlnaHRSZXN1bHQucmVtYWluaW5nO1xuICB9XG4gIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgYXMgY29uc3QsIHZhbHVlOiBsZWZ0LCByZW1haW5pbmc6IHJlc3QgfTtcbn07XG5cbmNvbnN0IHBhcnNlQ29uc3RyYWludEFuZDogQy5QYXJzZXI8Q29uc3RyYWludEV4cHI+ID0gKHRva2VucykgPT4ge1xuICBsZXQgbGVmdFJlc3VsdCA9IHBhcnNlQXRvbWljQ29uc3RyYWludCh0b2tlbnMpO1xuICBpZiAoIWxlZnRSZXN1bHQuc3VjY2VzcykgcmV0dXJuIGxlZnRSZXN1bHQ7XG4gIGxldCBsZWZ0ID0gbGVmdFJlc3VsdC52YWx1ZTtcbiAgbGV0IHJlc3QgPSBsZWZ0UmVzdWx0LnJlbWFpbmluZztcblxuICB3aGlsZSAoXG4gICAgcmVzdC5sZW5ndGggPiAwICYmXG4gICAgcmVzdFswXS50eXBlID09PSBcIktFWVdPUkRcIiAmJlxuICAgIHJlc3RbMF0udmFsdWUgPT09IFwiYW5kXCJcbiAgKSB7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMSk7XG4gICAgY29uc3QgcmlnaHRSZXN1bHQgPSBwYXJzZUF0b21pY0NvbnN0cmFpbnQocmVzdCk7XG4gICAgaWYgKCFyaWdodFJlc3VsdC5zdWNjZXNzKSByZXR1cm4gcmlnaHRSZXN1bHQ7XG4gICAgbGVmdCA9IHsga2luZDogXCJhbmRcIiwgbGVmdCwgcmlnaHQ6IHJpZ2h0UmVzdWx0LnZhbHVlIH07XG4gICAgcmVzdCA9IHJpZ2h0UmVzdWx0LnJlbWFpbmluZztcbiAgfVxuICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIGFzIGNvbnN0LCB2YWx1ZTogbGVmdCwgcmVtYWluaW5nOiByZXN0IH07XG59O1xuXG4vLyAtLS0gRXhwcmVzc2lvbiB3aXRoIHR5cGUgYW5ub3RhdGlvbiAoanVzdCBhYm92ZSBzZW1pY29sb24pIC0tLVxuY29uc3QgcGFyc2VFeHByV2l0aFR5cGU6IEMuUGFyc2VyPEV4cHJlc3Npb24+ID0gQy5jaG9pY2UoXG4gIC8vIEV4cHJlc3Npb24gd2l0aCB0eXBlIGFuZCBjb25zdHJhaW50czogZXhwciA6IHR5cGUgZ2l2ZW4gY29uc3RyYWludEV4cHJcbiAgQy5tYXAoXG4gICAgQy5zZXEoXG4gICAgICBwYXJzZVRocnVzaCwgLy8gVXNlIHBhcnNlVGhydXNoIHRvIHN1cHBvcnQgZnVsbCBleHByZXNzaW9uIGhpZXJhcmNoeVxuICAgICAgQy5wdW5jdHVhdGlvbihcIjpcIiksXG4gICAgICBDLmxhenkoKCkgPT4gcGFyc2VUeXBlRXhwcmVzc2lvbiksXG4gICAgICBDLmtleXdvcmQoXCJnaXZlblwiKSxcbiAgICAgIHBhcnNlQ29uc3RyYWludEV4cHJcbiAgICApLFxuICAgIChbZXhwciwgY29sb24sIHR5cGUsIGdpdmVuLCBjb25zdHJhaW50XSk6IENvbnN0cmFpbmVkRXhwcmVzc2lvbiA9PiAoe1xuICAgICAga2luZDogXCJjb25zdHJhaW5lZFwiLFxuICAgICAgZXhwcmVzc2lvbjogZXhwcixcbiAgICAgIHR5cGUsXG4gICAgICBjb25zdHJhaW50LFxuICAgICAgbG9jYXRpb246IGV4cHIubG9jYXRpb24sXG4gICAgfSlcbiAgKSxcbiAgLy8gRXhwcmVzc2lvbiB3aXRoIGp1c3QgdHlwZTogZXhwciA6IHR5cGVcbiAgQy5tYXAoXG4gICAgQy5zZXEoXG4gICAgICBwYXJzZVRocnVzaCwgLy8gVXNlIHBhcnNlVGhydXNoIHRvIHN1cHBvcnQgZnVsbCBleHByZXNzaW9uIGhpZXJhcmNoeVxuICAgICAgQy5wdW5jdHVhdGlvbihcIjpcIiksXG4gICAgICBDLmxhenkoKCkgPT4gcGFyc2VUeXBlRXhwcmVzc2lvbilcbiAgICApLFxuICAgIChbZXhwciwgY29sb24sIHR5cGVdKTogVHlwZWRFeHByZXNzaW9uID0+ICh7XG4gICAgICBraW5kOiBcInR5cGVkXCIsXG4gICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgdHlwZSxcbiAgICAgIGxvY2F0aW9uOiBleHByLmxvY2F0aW9uLFxuICAgIH0pXG4gICksXG4gIHBhcnNlVGhydXNoIC8vIEZhbGxiYWNrIHRvIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbik7XG5cbi8vIC0tLSBTZXF1ZW5jZSAoc2VtaWNvbG9uKSAtLS1cbi8vIEFjY2VwdHMgYSBzZXF1ZW5jZSBvZiBkZWZpbml0aW9ucyBhbmQvb3IgZXhwcmVzc2lvbnMsIHNlcGFyYXRlZCBieSBzZW1pY29sb25zXG5jb25zdCBwYXJzZVNlcXVlbmNlOiBDLlBhcnNlcjxFeHByZXNzaW9uPiA9IEMubWFwKFxuICBDLnNlcShcbiAgICBDLmxhenkoKCkgPT4gcGFyc2VTZXF1ZW5jZVRlcm1XaXRoSWYpLFxuICAgIEMubWFueShcbiAgICAgIEMuc2VxKFxuICAgICAgICBDLnB1bmN0dWF0aW9uKFwiO1wiKSxcbiAgICAgICAgQy5sYXp5KCgpID0+IHBhcnNlU2VxdWVuY2VUZXJtV2l0aElmKVxuICAgICAgKVxuICAgIClcbiAgKSxcbiAgKFtsZWZ0LCByZXN0XSkgPT4ge1xuICAgIGxldCByZXN1bHQgPSBsZWZ0O1xuICAgIGZvciAoY29uc3QgW29wLCByaWdodF0gb2YgcmVzdCkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBraW5kOiBcImJpbmFyeVwiLFxuICAgICAgICBvcGVyYXRvcjogXCI7XCIsXG4gICAgICAgIGxlZnQ6IHJlc3VsdCxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIGxvY2F0aW9uOiByZXN1bHQubG9jYXRpb24sXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4pO1xuXG4vLyAtLS0gRXhwcmVzc2lvbiAodG9wLWxldmVsKSAtLS1cbmNvbnN0IHBhcnNlRXhwcjogQy5QYXJzZXI8RXhwcmVzc2lvbj4gPSBwYXJzZVNlcXVlbmNlO1xuXG4vLyAtLS0gTWFpbiBQYXJzZSBGdW5jdGlvbiAtLS1cbmV4cG9ydCBjb25zdCBwYXJzZSA9ICh0b2tlbnM6IFRva2VuW10pOiBQcm9ncmFtID0+IHtcbiAgLy8gRmlsdGVyIG91dCBFT0YgdG9rZW5zIGZvciBwYXJzaW5nXG4gIGNvbnN0IG5vbkVPRlRva2VucyA9IHRva2Vucy5maWx0ZXIoKHQpID0+IHQudHlwZSAhPT0gXCJFT0ZcIik7XG5cbiAgLy8gUGFyc2UgbXVsdGlwbGUgdG9wLWxldmVsIGV4cHJlc3Npb25zIHNlcGFyYXRlZCBieSBzZW1pY29sb25zXG4gIGxldCBzdGF0ZW1lbnRzOiBFeHByZXNzaW9uW10gPSBbXTtcbiAgbGV0IHJlc3QgPSBub25FT0ZUb2tlbnM7XG4gIHdoaWxlIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAvLyBTa2lwIGxlYWRpbmcgc2VtaWNvbG9uc1xuICAgIHdoaWxlIChcbiAgICAgIHJlc3QubGVuZ3RoID4gMCAmJlxuICAgICAgcmVzdFswXS50eXBlID09PSBcIlBVTkNUVUFUSU9OXCIgJiZcbiAgICAgIHJlc3RbMF0udmFsdWUgPT09IFwiO1wiXG4gICAgKSB7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZSgxKTtcbiAgICB9XG4gICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSBicmVhaztcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZUV4cHIocmVzdCk7XG4gICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgLy8gSW5jbHVkZSBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gaW4gcGFyc2UgZXJyb3JcbiAgICAgIGNvbnN0IGVycm9yTG9jYXRpb24gPVxuICAgICAgICByZXN1bHQucG9zaXRpb24gPiAwID8gYCBhdCBsaW5lICR7cmVzdWx0LnBvc2l0aW9ufWAgOiBcIlwiO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJzZSBlcnJvcjogJHtyZXN1bHQuZXJyb3J9JHtlcnJvckxvY2F0aW9ufWApO1xuICAgIH1cbiAgICBzdGF0ZW1lbnRzLnB1c2gocmVzdWx0LnZhbHVlKTtcbiAgICByZXN0ID0gcmVzdWx0LnJlbWFpbmluZztcbiAgICAvLyBTa2lwIHRyYWlsaW5nIHNlbWljb2xvbnMgYWZ0ZXIgZWFjaCBzdGF0ZW1lbnRcbiAgICB3aGlsZSAoXG4gICAgICByZXN0Lmxlbmd0aCA+IDAgJiZcbiAgICAgIHJlc3RbMF0udHlwZSA9PT0gXCJQVU5DVFVBVElPTlwiICYmXG4gICAgICByZXN0WzBdLnZhbHVlID09PSBcIjtcIlxuICAgICkge1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMSk7XG4gICAgfVxuICB9XG4gIC8vIElmIHRoZXJlIGFyZSBzdGlsbCBsZWZ0b3ZlciB0b2tlbnMgdGhhdCBhcmVuJ3Qgc2VtaWNvbG9ucyBvciBFT0YsIHRocm93IGFuIGVycm9yXG4gIGlmIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBuZXh0ID0gcmVzdFswXTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVW5leHBlY3RlZCB0b2tlbiBhZnRlciBleHByZXNzaW9uOiAke25leHQudHlwZX0gJyR7bmV4dC52YWx1ZX0nIGF0IGxpbmUgJHtuZXh0LmxvY2F0aW9uLnN0YXJ0LmxpbmV9LCBjb2x1bW4gJHtuZXh0LmxvY2F0aW9uLnN0YXJ0LmNvbHVtbn1gXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXRlbWVudHMsXG4gICAgbG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uKHsgbGluZTogMSwgY29sdW1uOiAxIH0sIHsgbGluZTogMSwgY29sdW1uOiAxIH0pLFxuICB9O1xufTtcbiJdLCJuYW1lcyI6WyJwYXJzZSIsInBhcnNlVHlwZUV4cHJlc3Npb24iLCJwYXJzZVR5cGVOYW1lIiwidG9rZW5zIiwibGVuZ3RoIiwic3VjY2VzcyIsImVycm9yIiwicG9zaXRpb24iLCJmaXJzdCIsInJlc3QiLCJ0eXBlS2V5d29yZHMiLCJ0eXBlIiwiaW5jbHVkZXMiLCJ2YWx1ZSIsInJlbWFpbmluZyIsImxvY2F0aW9uIiwic3RhcnQiLCJsaW5lIiwicGFyc2VUeXBlQXRvbSIsInByaW1pdGl2ZVR5cGVzIiwidHlwZU5hbWUiLCJyZXN1bHQiLCJDIiwia2V5d29yZCIsImludFR5cGUiLCJzdHJpbmdUeXBlIiwidW5pdFR5cGUiLCJsaXN0S2V5d29yZFJlc3VsdCIsImFyZ1Jlc3VsdCIsImxhenkiLCJsaXN0VHlwZVdpdGhFbGVtZW50IiwidHlwZVZhcmlhYmxlIiwicmVjb3JkUmVzdWx0Iiwic2VxIiwicHVuY3R1YXRpb24iLCJvcHRpb25hbCIsInNlcEJ5IiwibWFwIiwiaWRlbnRpZmllciIsIm5hbWUiLCJjb2xvbiIsImZpZWxkcyIsImZpZWxkT2JqIiwicmVjb3JkVHlwZSIsInR1cGxlUmVzdWx0IiwiZWxlbWVudHMiLCJ0dXBsZVR5cGUiLCJsaXN0UmVzdWx0IiwidHVwbGVDb25zdHJ1Y3RvclJlc3VsdCIsIm1hbnkiLCJlbGVtZW50VHlwZXMiLCJ0dXBsZVR5cGVDb25zdHJ1Y3RvciIsInBhcmVuUmVzdWx0IiwidGVzdCIsInR5cGVOYW1lUmVzdWx0IiwiYXJnc1Jlc3VsdCIsImtpbmQiLCJhcmdzIiwiaWRlbnRpZmllclJlc3VsdCIsInBhcnNlRnVuY3Rpb25UeXBlV2l0aG91dEVmZmVjdHMiLCJsZWZ0UmVzdWx0IiwibGVmdCIsInNsaWNlIiwicmlnaHRSZXN1bHQiLCJmdW5jdGlvblR5cGUiLCJmdW5jVHlwZSIsImVmZmVjdHMiLCJTZXQiLCJlZmZlY3RSZXN0IiwiZWZmZWN0TmFtZSIsInZhbGlkRWZmZWN0cyIsImpvaW4iLCJhZGQiLCJ2YXJSZXN1bHQiLCJwYXJzZUlkZW50aWZpZXIiLCJ0b2tlbiIsInBhcnNlTnVtYmVyIiwibnVtYmVyIiwicGFyc2VGbG9hdCIsInBhcnNlU3RyaW5nIiwic3RyaW5nIiwicGFyc2VBY2Nlc3NvciIsImFjY2Vzc29yIiwiZmllbGQiLCJwYXJzZVJlY29yZEZpZWxkTmFtZSIsInBhcnNlUmVjb3JkRmllbGRWYWx1ZSIsInBhcnNlU2VxdWVuY2UiLCJwYXJzZVJlY29yZEZpZWxkIiwiZmllbGROYW1lIiwiaXNOYW1lZCIsInBhcnNlUmVjb3JkRmllbGRPclBvc2l0aW9uYWwiLCJpbmRleCIsIm5hbWVkRmllbGRSZXN1bHQiLCJwb3NpdGlvbmFsRmllbGRSZXN1bHQiLCJwYXJzZVJlY29yZEZpZWxkcyIsImZpcnN0RmllbGRSZXN1bHQiLCJwdXNoIiwiY29tbWFSZXN1bHQiLCJmaWVsZFJlc3VsdCIsInBhcnNlUmVjb3JkIiwib3BlbiIsImNsb3NlIiwiZmllbGRzTGlzdCIsImFsbE5hbWVkIiwiZXZlcnkiLCJmIiwiYWxsUG9zaXRpb25hbCIsImkiLCJFcnJvciIsInBhcnNlUGFyZW5FeHByIiwiZXhwciIsInBhcnNlTGFtYmRhRXhwcmVzc2lvbiIsImZuUmVzdWx0IiwicGFyYW1OYW1lcyIsImJyYWNlUmVzdWx0IiwiaWRSZXN1bHQiLCJwIiwiYXJyb3dSZXN1bHQiLCJvcGVyYXRvciIsImJvZHlSZXN1bHQiLCJwYXJzZVNlcXVlbmNlVGVybVdpdGhJZiIsInBhcmFtcyIsImJvZHkiLCJwYXJzZUxpc3RFbGVtZW50cyIsImZpcnN0RWxlbWVudFJlc3VsdCIsInBhcnNlVGhydXNoIiwiZWxlbWVudFJlc3VsdCIsInBhcnNlTGlzdCIsImVsZW1lbnRzTGlzdCIsInBhcnNlSW1wb3J0RXhwcmVzc2lvbiIsImltcG9ydEt3IiwicGF0aCIsInBhcnNlSWZFeHByZXNzaW9uIiwicGFyc2VTZXF1ZW5jZVRlcm0iLCJpZkt3IiwiY29uZGl0aW9uIiwidGhlbkt3IiwidGhlbkV4cHIiLCJlbHNlS3ciLCJlbHNlRXhwciIsInRoZW4iLCJlbHNlIiwicGFyc2VQcmltYXJ5IiwicHJvY2VzcyIsImVudiIsIk5PT19ERUJVR19QQVJTRSIsImNvbnNvbGUiLCJsb2ciLCJ0IiwiZmlyc3RUb2tlbiIsInBhcnNlRGVmaW5pdGlvbldpdGhUeXBlIiwicGFyc2VQcmltYXJ5V2l0aFBvc3RmaXgiLCJwcmltYXJ5UmVzdWx0IiwicG9zdGZpeFJlc3VsdCIsInBhcnNlUG9zdGZpeEZyb21SZXN1bHQiLCJwYXJzZVVuYXJ5IiwibWludXNUb2tlbiIsIm5leHRUb2tlbiIsImVuZCIsImNvbHVtbiIsIm9wZXJhbmRSZXN1bHQiLCJyaWdodCIsInBhcnNlQXBwbGljYXRpb24iLCJhcHBSZXN1bHQiLCJmdW5jIiwiYXJnIiwicGFyc2VNdWx0aXBsaWNhdGl2ZSIsIm11bHRSZXN1bHQiLCJjaG9pY2UiLCJvcCIsInBhcnNlQWRkaXRpdmUiLCJhZGRSZXN1bHQiLCJwYXJzZUNvbXBhcmlzb24iLCJjb21wUmVzdWx0IiwicGFyc2VDb21wb3NlIiwic3RlcHMiLCJ0aHJ1c2hSZXN1bHQiLCJwYXJzZURvbGxhciIsInBhcnNlSWZBZnRlckRvbGxhciIsImlmUmVzdWx0IiwidHlwZVJlc3VsdCIsImNvbnN0cmFpbnRSZXN1bHQiLCJwYXJzZUNvbnN0cmFpbnRFeHByIiwiZXhwcmVzc2lvbiIsImNvbnN0cmFpbnQiLCJwYXJzZURlZmluaXRpb24iLCJlcXVhbHMiLCJwYXJzZU11dGFibGVEZWZpbml0aW9uIiwibXV0IiwicGFyc2VNdXRhdGlvbiIsInRhcmdldCIsInBhcnNlV2hlcmVEZWZpbml0aW9uIiwibXV0YWJsZVJlc3VsdCIsInJlZ3VsYXJSZXN1bHQiLCJwYXJzZUNvbnN0cnVjdG9yIiwiY3JlYXRlTG9jYXRpb24iLCJwYXJzZVR5cGVEZWZpbml0aW9uIiwidHlwZVBhcmFtcyIsImNvbnN0cnVjdG9ycyIsInBhcnNlQ29uc3RyYWludEZ1bmN0aW9uIiwicGFyc2VDb25zdHJhaW50RGVmaW5pdGlvbiIsImNvbnN0cmFpbnRLZXl3b3JkIiwidHlwZVBhcmFtIiwib3BlblBhcmVuIiwiZnVuY3Rpb25zIiwiY2xvc2VQYXJlbiIsInBhcnNlSW1wbGVtZW50YXRpb25GdW5jdGlvbiIsInBhcnNlSW1wbGVtZW50RGVmaW5pdGlvbiIsImltcGxlbWVudEtleXdvcmQiLCJjb25zdHJhaW50TmFtZSIsImltcGxlbWVudGF0aW9ucyIsInBhcnNlQmFzaWNQYXR0ZXJuIiwidW5kZXJzY29yZSIsIm51bSIsInBhcnNlSW50Iiwic3RyIiwicGFyc2VQYXR0ZXJuIiwibWFueTEiLCJwYXJzZU1hdGNoQ2FzZUV4cHJlc3Npb24iLCJwYXJzZU1hdGNoRXhwcmVzc2lvbiIsInBhcnNlRXhwcldpdGhUeXBlIiwicGFyc2VNYXRjaENhc2UiLCJwYXR0ZXJuIiwiYXJyb3ciLCJtYXRjaCIsIndpdGhfIiwiY2FzZXMiLCJwYXJzZVdoZXJlRXhwcmVzc2lvbiIsInBhcnNlU2VxdWVuY2VUZXJtV2l0aElmRXhjZXB0UmVjb3JkIiwibWFpbiIsIndoZXJlIiwiZGVmaW5pdGlvbnMiLCJwYXJzZVNlcXVlbmNlVGVybUV4Y2VwdFJlY29yZCIsInBhcnNlQXRvbWljQ29uc3RyYWludCIsInR5cGVWYXIiLCJpc0tleXdvcmQiLCJoYXMiLCJvZiIsImZpZWxkVHlwZSIsImltcGxlbWVudHNLZXl3b3JkIiwiaW50ZXJmYWNlTmFtZSIsInBhcnNlQ29uc3RyYWludEFuZCIsImdpdmVuIiwicGFyc2VFeHByIiwibm9uRU9GVG9rZW5zIiwiZmlsdGVyIiwic3RhdGVtZW50cyIsImVycm9yTG9jYXRpb24iLCJuZXh0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztRQXcxRGFBO2VBQUFBOztRQXJpREFDO2VBQUFBOzs7cUJBM1FOO3FFQUNZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFbkIsdUVBQXVFO0FBQ3ZFLE1BQU1DLGdCQUFpQyxDQUFDQztJQUN0QyxJQUFJQSxPQUFPQyxNQUFNLEtBQUssR0FBRztRQUN2QixPQUFPO1lBQ0xDLFNBQVM7WUFDVEMsT0FBTztZQUNQQyxVQUFVO1FBQ1o7SUFDRjtJQUVBLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHQyxLQUFLLEdBQUdOO0lBQ3pCLE1BQU1PLGVBQWU7UUFBQztRQUFPO1FBQVU7UUFBVTtRQUFRO0tBQU87SUFFaEUsSUFDRUYsTUFBTUcsSUFBSSxLQUFLLGdCQUNkSCxNQUFNRyxJQUFJLEtBQUssYUFBYUQsYUFBYUUsUUFBUSxDQUFDSixNQUFNSyxLQUFLLEdBQzlEO1FBQ0EsT0FBTztZQUNMUixTQUFTO1lBQ1RRLE9BQU9MO1lBQ1BNLFdBQVdMO1FBQ2I7SUFDRjtJQUVBLE9BQU87UUFDTEosU0FBUztRQUNUQyxPQUFPLENBQUMsNEJBQTRCLEVBQUVFLE1BQU1HLElBQUksQ0FB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