{"version":3,"sources":["/workspace/src/parser/parser.ts"],"sourcesContent":["import type { Token } from \"../lexer\";\nimport {\n\ttype Expression,\n\ttype Program,\n\ttype LiteralExpression,\n\ttype VariableExpression,\n\ttype FunctionExpression,\n\tcreateLocation,\n\ttype DefinitionExpression,\n\ttype MutableDefinitionExpression,\n\ttype ImportExpression,\n\ttype AccessorExpression,\n\ttype Type,\n\ttype Effect,\n\tintType,\n\tstringType,\n\tunitType,\n\tlistTypeWithElement,\n\tfunctionType,\n\ttypeVariable,\n\ttype TypedExpression,\n\ttype ConstrainedExpression,\n\ttype ListExpression,\n\ttype WhereExpression,\n\trecordType,\n\ttupleType,\n\ttupleTypeConstructor,\n\ttype ConstraintExpr,\n\ttype TypeDefinitionExpression,\n\ttype MatchExpression,\n\ttype ConstructorDefinition,\n\ttype Pattern,\n\ttype MatchCase,\n\ttype UnitExpression,\n\ttype RecordExpression,\n\ttype TupleExpression,\n\ttype ConstraintDefinitionExpression,\n\ttype ImplementDefinitionExpression,\n\ttype ConstraintFunction,\n\ttype ImplementationFunction,\n} from '../ast';\nimport * as C from \"./combinators\";\n\n// --- Helper: parse type name (IDENTIFIER or type-related KEYWORD) ---\nconst parseTypeName: C.Parser<Token> = (tokens: Token[]) => {\n  if (tokens.length === 0) {\n    return {\n      success: false,\n      error: \"Expected type name, but got end of input\",\n      position: 0,\n    };\n  }\n\n  const [first, ...rest] = tokens;\n  const typeKeywords = [\"Int\", \"Number\", \"String\", \"Unit\", \"List\"];\n\n  if (\n    first.type === \"IDENTIFIER\" ||\n    (first.type === \"KEYWORD\" && typeKeywords.includes(first.value))\n  ) {\n    return {\n      success: true,\n      value: first,\n      remaining: rest,\n    };\n  }\n\n  return {\n    success: false,\n    error: `Expected type name, but got ${first.type} '${first.value}'`,\n    position: first.location.start.line,\n  };\n};\n\n// --- Helper: parse a single type atom (primitive, variable, record, tuple, list) ---\nfunction parseTypeAtom(tokens: Token[]): C.ParseResult<Type> {\n  // Try primitive types first, but handle List as a parameterizable type constructor\n  const primitiveTypes = [\"Int\", \"Number\", \"String\", \"Unit\"];\n  for (const typeName of primitiveTypes) {\n    const result = C.keyword(typeName)(tokens);\n    if (result.success) {\n      switch (typeName) {\n        case \"Int\":\n        case \"Number\":\n          return {\n            success: true as const,\n            value: intType(),\n            remaining: result.remaining,\n          };\n        case \"String\":\n          return {\n            success: true as const,\n            value: stringType(),\n            remaining: result.remaining,\n          };\n        case \"Unit\":\n          return {\n            success: true as const,\n            value: unitType(),\n            remaining: result.remaining,\n          };\n      }\n    }\n  }\n\n  // Try List as a parameterizable type constructor\n  const listKeywordResult = C.keyword(\"List\")(tokens);\n  if (listKeywordResult.success) {\n    // Try to parse a type argument for List\n    const argResult = C.lazy(() => parseTypeAtom)(listKeywordResult.remaining);\n    if (argResult.success) {\n      // List with specific element type: List Number, List String, etc.\n      return {\n        success: true as const,\n        value: listTypeWithElement(argResult.value),\n        remaining: argResult.remaining,\n      };\n    } else {\n      // Just List (generic)\n      return {\n        success: true as const,\n        value: listTypeWithElement(typeVariable(\"a\")),\n        remaining: listKeywordResult.remaining,\n      };\n    }\n  }\n\n\n\n  // Try record type\n  const recordResult = C.seq(\n    C.punctuation(\"{\"),\n    C.optional(\n      C.sepBy(\n        C.map(\n          C.seq(\n            C.identifier(),\n            C.punctuation(\":\"),\n            C.lazy(() => parseTypeExpression)\n          ),\n          ([name, colon, type]) => [name.value, type] as [string, Type]\n        ),\n        C.punctuation(\",\")\n      )\n    ),\n    C.punctuation(\"}\")\n  )(tokens);\n  if (recordResult.success) {\n    const fields: Array<[string, Type]> = recordResult.value[1] || [];\n    const fieldObj: Record<string, Type> = {};\n    for (const [name, type] of fields) {\n      fieldObj[name] = type;\n    }\n    return {\n      success: true as const,\n      value: recordType(fieldObj),\n      remaining: recordResult.remaining,\n    };\n  }\n\n  // Try tuple type\n  const tupleResult = C.seq(\n    C.punctuation(\"{\"),\n    C.optional(\n      C.sepBy(\n        C.lazy(() => parseTypeExpression),\n        C.punctuation(\",\")\n      )\n    ),\n    C.punctuation(\"}\")\n  )(tokens);\n  if (tupleResult.success) {\n    const elements = tupleResult.value[1] || [];\n    return {\n      success: true as const,\n      value: tupleType(elements),\n      remaining: tupleResult.remaining,\n    };\n  }\n\n  // Try List type\n  const listResult = C.seq(\n    C.keyword(\"List\"),\n    C.lazy(() => parseTypeExpression)\n  )(tokens);\n  if (listResult.success) {\n    return {\n      success: true as const,\n      value: listTypeWithElement(listResult.value[1]),\n      remaining: listResult.remaining,\n    };\n  }\n\n  // Try Tuple type constructor: Tuple T1 T2 T3\n  if (\n    tokens.length > 0 &&\n    tokens[0].type === \"IDENTIFIER\" &&\n    tokens[0].value === \"Tuple\"\n  ) {\n    const tupleConstructorResult = C.seq(\n      C.identifier(),\n      C.many(C.lazy(() => parseTypeExpression))\n    )(tokens);\n    if (tupleConstructorResult.success) {\n      const elementTypes = tupleConstructorResult.value[1];\n      return {\n        success: true as const,\n        value: tupleTypeConstructor(elementTypes),\n        remaining: tupleConstructorResult.remaining,\n      };\n    }\n  }\n\n  // Try parenthesized type: (Type)\n  const parenResult = C.seq(\n    C.punctuation(\"(\"),\n    C.lazy(() => parseTypeExpression),\n    C.punctuation(\")\")\n  )(tokens);\n  if (parenResult.success) {\n    return {\n      success: true as const,\n      value: parenResult.value[1],\n      remaining: parenResult.remaining,\n    };\n  }\n\n\n\n  // Try uppercase type constructor: TypeName arg1 arg2 ... (preserve original logic)\n  if (\n    tokens.length > 0 &&\n    tokens[0].type === \"IDENTIFIER\" &&\n    /^[A-Z]/.test(tokens[0].value)\n  ) {\n    const typeNameResult = C.identifier()(tokens);\n    if (typeNameResult.success) {\n      // Try to parse type arguments\n      const argsResult = C.many(C.lazy(() => parseTypeAtom))(\n        typeNameResult.remaining\n      );\n      if (argsResult.success) {\n        return {\n          success: true as const,\n          value: {\n            kind: \"variant\",\n            name: typeNameResult.value.value,\n            args: argsResult.value,\n          } as Type,\n          remaining: argsResult.remaining,\n        };\n      }\n    }\n  }\n\n  // Try type variable or simple identifier\n  if (tokens.length > 0 && tokens[0].type === \"IDENTIFIER\") {\n    const identifierResult = C.identifier()(tokens);\n    if (identifierResult.success) {\n      return {\n        success: true as const,\n        value: typeVariable(identifierResult.value.value),\n        remaining: identifierResult.remaining,\n      };\n    }\n  }\n\n  return {\n    success: false,\n    error: \"Expected type atom\",\n    position: tokens[0]?.location.start.line || 0,\n  };\n}\n\n\n\n// --- Type Expression ---\n// Helper function to parse function types without top-level effects\nconst parseFunctionTypeWithoutEffects: C.Parser<Type> = (tokens) => {\n  let leftResult = parseTypeAtom(tokens);\n  if (!leftResult.success) return leftResult;\n  let left = leftResult.value;\n  let rest = leftResult.remaining;\n\n  while (\n    rest &&\n    rest.length > 0 &&\n    rest[0].type === \"OPERATOR\" &&\n    rest[0].value === \"->\"\n  ) {\n    rest = rest.slice(1);\n    const rightResult = parseFunctionTypeWithoutEffects(rest);\n    if (!rightResult.success) return rightResult;\n    if (!rightResult.value)\n      return {\n        success: false,\n        error: \"Expected type expression\",\n        position: tokens[0]?.location.start.line || 0,\n      };\n    \n    left = functionType([left], rightResult.value);\n    rest = rightResult.remaining;\n  }\n  \n  return { success: true as const, value: left, remaining: rest };\n};\n\nexport const parseTypeExpression: C.Parser<Type> = (tokens) => {\n  // Try function type (right-associative): a -> b -> c FIRST\n  const funcType = (() => {\n    let leftResult = parseTypeAtom(tokens);\n    if (!leftResult.success) return leftResult;\n    let left = leftResult.value;\n    let rest = leftResult.remaining;\n\n    while (\n      rest &&\n      rest.length > 0 &&\n      rest[0].type === \"OPERATOR\" &&\n      rest[0].value === \"->\"\n    ) {\n      rest = rest.slice(1);\n      const rightResult = parseFunctionTypeWithoutEffects(rest);\n      if (!rightResult.success) return rightResult;\n      if (!rightResult.value)\n        return {\n          success: false,\n          error: \"Expected type expression\",\n          position: tokens[0]?.location.start.line || 0,\n        };\n      \n      left = functionType([left], rightResult.value);\n      rest = rightResult.remaining;\n    }\n    \n    // Parse effects at the end of the entire function type chain\n    let effects = new Set<Effect>();\n    let effectRest = rest;\n    \n    // Parse effects: !effect1 !effect2 ...\n    while (\n      effectRest &&\n      effectRest.length > 0 &&\n      effectRest[0].type === \"OPERATOR\" &&\n      effectRest[0].value === \"!\"\n    ) {\n      effectRest = effectRest.slice(1); // consume !\n      \n      // Expect an effect name (identifier or keyword)\n      if (\n        !effectRest ||\n        effectRest.length === 0 ||\n        (effectRest[0].type !== \"IDENTIFIER\" && effectRest[0].type !== \"KEYWORD\")\n      ) {\n        return {\n          success: false,\n          error: \"Expected effect name after !\",\n          position: effectRest?.[0]?.location?.start?.line || 0,\n        };\n      }\n      \n      const effectName = effectRest[0].value;\n      \n      // Validate effect name\n      const validEffects: Effect[] = [\"log\", \"read\", \"write\", \"state\", \"time\", \"rand\", \"ffi\", \"async\"];\n      if (!validEffects.includes(effectName as Effect)) {\n        return {\n          success: false,\n          error: `Invalid effect: ${effectName}. Valid effects: ${validEffects.join(\", \")}`,\n          position: effectRest[0].location.start.line,\n        };\n      }\n      \n      effects.add(effectName as Effect);\n      effectRest = effectRest.slice(1); // consume effect name\n    }\n    \n    // Apply effects to the function type (including empty effects)\n    if (left.kind === 'function') {\n      left = { ...left, effects };\n    }\n    \n    return { success: true as const, value: left, remaining: effectRest };\n  })();\n\n  if (funcType.success && funcType.value) {\n    return funcType;\n  }\n  \n  // If function type parsing failed with a specific effect error, return that error\n  if (!funcType.success && (\n    funcType.error.includes(\"Invalid effect:\") || \n    funcType.error.includes(\"Expected effect name after !\")\n  )) {\n    return funcType as C.ParseError;\n  }\n\n  // Try type variable (lowercase identifier)\n  if (\n    tokens.length > 0 &&\n    tokens[0].type === \"IDENTIFIER\" &&\n    /^[a-z]/.test(tokens[0].value)\n  ) {\n    const varResult = C.identifier()(tokens);\n    if (varResult.success) {\n      return {\n        success: true as const,\n        value: typeVariable(varResult.value.value),\n        remaining: varResult.remaining,\n      };\n    }\n  }\n\n  // Try record type: { name: String, age: Number }\n  const recordResult = C.seq(\n    C.punctuation(\"{\"),\n    C.optional(\n      C.sepBy(\n        C.map(\n          C.seq(\n            C.identifier(),\n            C.punctuation(\":\"),\n            C.lazy(() => parseTypeExpression)\n          ),\n          ([name, colon, type]) => [name.value, type] as [string, Type]\n        ),\n        C.punctuation(\",\")\n      )\n    ),\n    C.punctuation(\"}\")\n  )(tokens);\n  if (recordResult.success) {\n    const fields: Array<[string, Type]> = recordResult.value[1] || [];\n    const fieldObj: Record<string, Type> = {};\n    for (const [name, type] of fields) {\n      fieldObj[name] = type;\n    }\n    return {\n      success: true as const,\n      value: recordType(fieldObj),\n      remaining: recordResult.remaining,\n    };\n  }\n\n  // Try tuple type: { Number, String }\n  const tupleResult = C.seq(\n    C.punctuation(\"{\"),\n    C.optional(\n      C.sepBy(\n        C.lazy(() => parseTypeExpression),\n        C.punctuation(\",\")\n      )\n    ),\n    C.punctuation(\"}\")\n  )(tokens);\n  if (tupleResult.success) {\n    const elements = tupleResult.value[1] || [];\n    return {\n      success: true as const,\n      value: tupleType(elements),\n      remaining: tupleResult.remaining,\n    };\n  }\n\n  // Try List type\n  const listResult = C.seq(\n    C.keyword(\"List\"),\n    C.lazy(() => parseTypeExpression)\n  )(tokens);\n  if (listResult.success) {\n    return {\n      success: true as const,\n      value: listTypeWithElement(listResult.value[1]),\n      remaining: listResult.remaining,\n    };\n  }\n\n  return {\n    success: false,\n    error: \"Expected type expression\",\n    position: tokens[0]?.location.start.line || 0,\n  };\n};\n// --- Basic Parsers ---\nconst parseIdentifier = C.map(\n  C.identifier(),\n  (token): VariableExpression => ({\n    kind: \"variable\",\n    name: token.value,\n    location: token.location,\n  })\n);\n\nconst parseNumber = C.map(\n  C.number(),\n  (token): LiteralExpression => ({\n    kind: \"literal\",\n    value: parseFloat(token.value),\n    location: token.location,\n  })\n);\n\nconst parseString = C.map(\n  C.string(),\n  (token): LiteralExpression => ({\n    kind: \"literal\",\n    value: token.value,\n    location: token.location,\n  })\n);\n\nconst parseAccessor = C.map(\n  C.accessor(),\n  (token): AccessorExpression => ({\n    kind: \"accessor\",\n    field: token.value,\n    location: token.location,\n  })\n);\n\n// --- Record Parsing ---\nconst parseRecordFieldName = C.map(\n  C.accessor(),\n  (token) => token.value // Just get the field name without @\n);\n\n// Parse an expression that stops at @ (accessor tokens) or semicolon\nconst parseRecordFieldValue = (tokens: Token[]): C.ParseResult<Expression> => {\n  // Use the full expression parser to parse the complete expression\n  // This includes records, so we can parse nested records\n  const result = C.lazy(() => parseSequence)(tokens);\n  if (!result.success) {\n    return result;\n  }\n\n  // The expression parser should have consumed all the tokens it needs\n  // and left us with the remaining tokens that come after the expression\n  return {\n    success: true,\n    value: result.value,\n    remaining: result.remaining,\n  };\n};\n\nconst parseRecordField = C.map(\n  C.seq(parseRecordFieldName, parseRecordFieldValue),\n  ([fieldName, value]) => ({\n    name: fieldName,\n    value,\n    isNamed: true,\n  })\n);\n\n// Parse a single record field (named or positional)\nconst parseRecordFieldOrPositional =\n  (\n    index: number\n  ): C.Parser<{ name: string; value: Expression; isNamed: boolean }> =>\n  (tokens) => {\n    // Try to parse as named field first (with accessor)\n    const namedFieldResult = parseRecordField(tokens);\n    if (namedFieldResult.success) {\n      return {\n        ...namedFieldResult,\n        value: { ...namedFieldResult.value, isNamed: true },\n      };\n    }\n    // If that fails, try to parse as positional field (expression without accessor)\n    const positionalFieldResult = parseRecordFieldValue(tokens);\n    if (positionalFieldResult.success) {\n      return {\n        success: true,\n        value: {\n          name: `@${index}`,\n          value: positionalFieldResult.value,\n          isNamed: false,\n        },\n        remaining: positionalFieldResult.remaining,\n      };\n    }\n    return {\n      success: false,\n      error: \"Expected record field (named or positional)\",\n      position: tokens[0]?.location.start.line || 0,\n    };\n  };\n\n// Custom parser for a sequence of fields separated by semicolons\nconst parseRecordFields: C.Parser<{ name: string; value: Expression }[]> = (\n  tokens\n) => {\n  let fields: { name: string; value: Expression; isNamed: boolean }[] = [];\n  let rest = tokens;\n  // Parse first field\n  const firstFieldResult = parseRecordFieldOrPositional(0)(rest);\n  if (!firstFieldResult.success) {\n    return {\n      success: false,\n      error: \"Expected at least one record field\",\n      position: tokens[0]?.location.start.line || 0,\n    };\n  }\n  fields.push(firstFieldResult.value);\n  rest = firstFieldResult.remaining;\n  const isNamed = firstFieldResult.value.isNamed;\n  // Parse additional fields, each preceded by a comma\n  while (rest.length > 0) {\n    const commaResult = C.punctuation(\",\")(rest);\n    if (!commaResult.success) {\n      break; // No more commas, we're done\n    }\n    rest = commaResult.remaining;\n    const fieldResult = parseRecordFieldOrPositional(fields.length)(rest);\n    if (!fieldResult.success) {\n      // Check if this is a trailing comma (no more fields after comma)\n      // Look ahead to see if the next token is a closing brace\n      if (\n        rest.length > 0 &&\n        rest[0].type === \"PUNCTUATION\" &&\n        rest[0].value === \"}\"\n      ) {\n        // This is a trailing comma, which is allowed\n        break;\n      }\n      return {\n        success: false,\n        error: \"Expected field after comma\",\n        position: rest[0]?.location.start.line || 0,\n      };\n    }\n    if (fieldResult.value.isNamed !== isNamed) {\n      return {\n        success: false,\n        error:\n          \"Cannot mix named and positional fields in the same record/tuple\",\n        position: rest[0]?.location.start.line || 0,\n      };\n    }\n    fields.push(fieldResult.value);\n    rest = fieldResult.remaining;\n  }\n  // Remove isNamed before returning\n  return {\n    success: true,\n    value: fields.map(({ isNamed, ...rest }) => rest),\n    remaining: rest,\n  };\n};\n\n// --- Record/Tuple Parsing ---\nconst parseRecord = C.map(\n  C.seq(C.punctuation(\"{\"), C.optional(parseRecordFields), C.punctuation(\"}\")),\n  ([open, fields, close]): Expression => {\n    const fieldsList = fields || [];\n    if (fieldsList.length === 0) {\n      // Empty braces: unit\n      return {\n        kind: \"unit\",\n        location: open.location,\n      } as UnitExpression;\n    }\n    const allNamed = fieldsList.every((f) => f.name[0] !== \"@\");\n    const allPositional = fieldsList.every((f, i) => f.name === `@${i}`);\n    if (allNamed) {\n      // All named fields: record\n      return {\n        kind: \"record\",\n        fields: fieldsList,\n        location: open.location,\n      } as RecordExpression;\n    } else if (allPositional) {\n      // All positional fields: tuple\n      return {\n        kind: \"tuple\",\n        elements: fieldsList.map((f) => f.value),\n        location: open.location,\n      } as TupleExpression;\n    } else {\n      // Mixed fields: error\n      throw new Error(\n        \"Cannot mix named and positional fields in the same record/tuple\"\n      );\n    }\n  }\n);\n\n// --- Parenthesized Expressions ---\nconst parseParenExpr: C.Parser<Expression> = C.map(\n  C.seq(\n    C.punctuation(\"(\"),\n    C.lazy(() => parseSequence), // Use parseSequence to allow full semicolon-separated sequences\n    C.punctuation(\")\")\n  ),\n  ([open, expr, close]) => expr\n);\n\n// --- Lambda Expression ---\nconst parseLambdaExpression: C.Parser<FunctionExpression> = (tokens) => {\n  // Try to parse fn keyword first\n  const fnResult = C.keyword(\"fn\")(tokens);\n  if (!fnResult.success) {\n    return fnResult;\n  }\n\n  // Try unit parameter patterns first\n  let paramNames: string[] = [];\n  let remaining = fnResult.remaining;\n\n  const parenResult = C.seq(C.punctuation(\"(\"), C.punctuation(\")\"))(remaining);\n  if (parenResult.success) {\n    // No parameters (should not be used in Noolang, but keep for syntax completeness)\n    paramNames = [];\n    remaining = parenResult.remaining;\n  } else {\n    const braceResult = C.seq(\n      C.punctuation(\"{\"),\n      C.punctuation(\"}\")\n    )(remaining);\n    if (braceResult.success) {\n      // Unit parameter\n      paramNames = [\"_unit\"];\n      remaining = braceResult.remaining;\n    } else {\n      // Try multiple identifiers last\n      const idResult = C.many(C.identifier())(remaining);\n      if (idResult.success) {\n        paramNames = idResult.value.map((p) => p.value);\n        remaining = idResult.remaining;\n      } else {\n        return {\n          success: false,\n          error: \"Expected parameter list, parentheses, or braces\",\n          position: remaining[0]?.location.start.line || 0,\n        };\n      }\n    }\n  }\n\n  // Parse the arrow\n  const arrowResult = C.operator(\"=>\")(remaining);\n  if (!arrowResult.success) {\n    return arrowResult;\n  }\n\n  // Parse the body (use parseSequenceTermWithIf to allow full expressions)\n  const bodyResult = C.lazy(() => parseSequenceTermWithIf)(\n    arrowResult.remaining\n  );\n  if (!bodyResult.success) {\n    return bodyResult;\n  }\n\n  return {\n    success: true,\n    value: {\n      kind: \"function\",\n      params: paramNames,\n      body: bodyResult.value,\n      location: fnResult.value.location,\n    },\n    remaining: bodyResult.remaining,\n  };\n};\n\n// --- List Parsing ---\n// Custom parser for a sequence of expressions separated by semicolons\nconst parseListElements: C.Parser<Expression[]> = (tokens) => {\n  let elements: Expression[] = [];\n  let rest = tokens;\n\n  // Parse first element\n  const firstElementResult = C.lazy(() => parseThrush)(rest);\n  if (!firstElementResult.success) {\n    return {\n      success: false,\n      error: \"Expected at least one list element\",\n      position: tokens[0]?.location.start.line || 0,\n    };\n  }\n  elements.push(firstElementResult.value);\n  rest = firstElementResult.remaining;\n\n  // Parse additional elements, each preceded by a comma\n  while (rest.length > 0) {\n    const commaResult = C.punctuation(\",\")(rest);\n    if (!commaResult.success) {\n      break; // No more commas, we're done\n    }\n    rest = commaResult.remaining;\n\n    const elementResult = C.lazy(() => parseThrush)(rest);\n    if (!elementResult.success) {\n      // Check if this is a trailing comma (no more elements after comma)\n      // Look ahead to see if the next token is a closing bracket\n      if (\n        rest.length > 0 &&\n        rest[0].type === \"PUNCTUATION\" &&\n        rest[0].value === \"]\"\n      ) {\n        // This is a trailing comma, which is allowed\n        break;\n      }\n      return {\n        success: false,\n        error: \"Expected element after comma\",\n        position: rest[0]?.location.start.line || 0,\n      };\n    }\n    elements.push(elementResult.value);\n    rest = elementResult.remaining;\n  }\n\n  return {\n    success: true,\n    value: elements,\n    remaining: rest,\n  };\n};\n\nconst parseList: C.Parser<ListExpression> = C.map(\n  C.seq(C.punctuation(\"[\"), C.optional(parseListElements), C.punctuation(\"]\")),\n  ([open, elements, close]) => {\n    const elementsList: Expression[] = elements || [];\n    return {\n      kind: \"list\",\n      elements: elementsList,\n      location: open.location,\n    };\n  }\n);\n\n// --- Import Expression ---\nconst parseImportExpression: C.Parser<ImportExpression> = C.map(\n  C.seq(C.keyword(\"import\"), C.string()),\n  ([importKw, path]): ImportExpression => ({\n    kind: \"import\",\n    path: path.value,\n    location: importKw.location,\n  })\n);\n\n// --- If Expression (special: do not allow semicolon in branches) ---\nconst parseIfExpression: C.Parser<Expression> = C.map(\n  C.seq(\n    C.keyword(\"if\"),\n    C.lazy(() => parseSequenceTerm),\n    C.keyword(\"then\"),\n    C.lazy(() => parseSequenceTerm),\n    C.keyword(\"else\"),\n    C.lazy(() => parseSequenceTerm)\n  ),\n  ([ifKw, condition, thenKw, thenExpr, elseKw, elseExpr]) => {\n    return {\n      kind: \"if\",\n      condition,\n      then: thenExpr,\n      else: elseExpr,\n      location: ifKw.location,\n    };\n  }\n);\n\n// --- Primary Expressions (no unary minus) ---\nconst parsePrimary: C.Parser<Expression> = (tokens) => {\n  // DEBUG: Log tokens at entry\n  if (process.env.NOO_DEBUG_PARSE) {\n    console.log(\"parsePrimary tokens:\", tokens.map((t) => t.value).join(\" \"));\n  }\n  \n  // Fast token-based dispatch instead of sequential choice attempts\n  if (tokens.length === 0) {\n    return { success: false, error: \"Unexpected end of input\", position: 0 };\n  }\n  \n  const firstToken = tokens[0];\n  let result: C.ParseResult<Expression>;\n  \n  // Dispatch based on token type and value for O(1) selection\n  switch (firstToken.type) {\n    case \"NUMBER\":\n      result = parseNumber(tokens);\n      break;\n    case \"STRING\": \n      result = parseString(tokens);\n      break;\n    case \"IDENTIFIER\":\n      result = parseIdentifier(tokens);\n      break;\n    case \"ACCESSOR\":\n      result = parseAccessor(tokens);\n      break;\n    case \"PUNCTUATION\":\n      if (firstToken.value === \"[\") {\n        result = parseList(tokens);\n      } else if (firstToken.value === \"{\") {\n        result = parseRecord(tokens);\n      } else if (firstToken.value === \"(\") {\n        result = parseParenExpr(tokens);\n      } else {\n        result = { success: false, error: `Unexpected punctuation: ${firstToken.value}`, position: firstToken.location.start.line };\n      }\n      break;\n    case \"KEYWORD\":\n      if (firstToken.value === \"fn\") {\n        result = parseLambdaExpression(tokens);\n      } else if (firstToken.value === \"let\") {\n        result = C.lazy(() => parseDefinitionWithType)(tokens);\n      } else if (firstToken.value === \"import\") {\n        result = parseImportExpression(tokens);\n      } else {\n        result = { success: false, error: `Unexpected keyword: ${firstToken.value}`, position: firstToken.location.start.line };\n      }\n      break;\n    default:\n      result = { success: false, error: `Unexpected token type: ${firstToken.type}`, position: firstToken.location.start.line };\n      break;\n  }\n  \n  // DEBUG: Log result\n  if (process.env.NOO_DEBUG_PARSE) {\n    console.log(\n      \"parsePrimary result:\",\n      result.success ? result.value : result.error\n    );\n  }\n  return result;\n};\n\n// --- Primary with Postfix (type annotations) ---\nconst parsePrimaryWithPostfix: C.Parser<Expression> = (tokens) => {\n  if (process.env.NOO_DEBUG_PARSE) {\n    console.log(\n      \"parsePrimaryWithPostfix tokens:\",\n      tokens.map((t) => t.value).join(\" \")\n    );\n  }\n  const primaryResult = parsePrimary(tokens);\n  if (!primaryResult.success) return primaryResult;\n  const postfixResult = parsePostfixFromResult(\n    primaryResult.value,\n    primaryResult.remaining\n  );\n  if (process.env.NOO_DEBUG_PARSE) {\n    console.log(\n      \"parsePrimaryWithPostfix result:\",\n      postfixResult.success ? postfixResult.value : postfixResult.error\n    );\n  }\n  return postfixResult;\n};\n\n// --- Unary Operators (negation, only if '-' is adjacent to the next token) ---\nconst parseUnary: C.Parser<Expression> = (tokens) => {\n  if (process.env.NOO_DEBUG_PARSE) {\n    console.log(\"parseUnary tokens:\", tokens.map((t) => t.value).join(\" \"));\n  }\n  if (\n    tokens.length >= 2 &&\n    tokens[0].type === \"OPERATOR\" &&\n    tokens[0].value === \"-\"\n  ) {\n    const minusToken = tokens[0];\n    const nextToken = tokens[1];\n    // Check if minus is directly adjacent to the next token (no space)\n    if (\n      minusToken.location.end.line === nextToken.location.start.line &&\n      minusToken.location.end.column === nextToken.location.start.column\n    ) {\n      // Parse as unary minus\n      const operandResult = parsePrimaryWithPostfix(tokens.slice(1));\n      if (!operandResult.success) return operandResult;\n      const result = {\n        success: true as const,\n        value: {\n          kind: \"binary\" as const,\n          operator: \"*\" as const,\n          left: {\n            kind: \"literal\" as const,\n            value: -1,\n            location: minusToken.location,\n          },\n          right: operandResult.value,\n          location: minusToken.location,\n        },\n        remaining: operandResult.remaining,\n      };\n      if (process.env.NOO_DEBUG_PARSE) {\n        console.log(\"parseUnary result (negation):\", result.value);\n      }\n      return result;\n    }\n  }\n  // Otherwise, fall through to parsePrimaryWithPostfix\n  const result = parsePrimaryWithPostfix(tokens);\n  if (process.env.NOO_DEBUG_PARSE) {\n    console.log(\n      \"parseUnary result:\",\n      result.success ? result.value : result.error\n    );\n  }\n  return result;\n};\n\n// --- Function Application (left-associative, tightest binding) ---\nconst parseApplication: C.Parser<Expression> = (tokens) => {\n  const appResult = C.map(\n    C.seq(parseUnary, C.many(parseUnary)),\n    ([func, args]) => {\n      let result = func;\n      for (const arg of args) {\n        result = {\n          kind: \"application\",\n          func: result,\n          args: [arg],\n          location: result.location,\n        };\n      }\n      return result;\n    }\n  )(tokens);\n\n  if (!appResult.success) return appResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(appResult.value, appResult.remaining);\n};\n\n// --- Multiplicative (*, /) ---\nconst parseMultiplicative: C.Parser<Expression> = (tokens) => {\n  const multResult = C.map(\n    C.seq(\n      parseApplication,\n      C.many(\n        C.seq(C.choice(C.operator(\"*\"), C.operator(\"/\")), parseApplication)\n      )\n    ),\n    ([left, rest]) => {\n      let result = left;\n      for (const [op, right] of rest) {\n        result = {\n          kind: \"binary\",\n          operator: op.value as \"*\" | \"/\",\n          left: result,\n          right,\n          location: result.location,\n        };\n      }\n      return result;\n    }\n  )(tokens);\n\n  if (!multResult.success) return multResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(multResult.value, multResult.remaining);\n};\n\n// --- Additive (+, -) ---\nconst parseAdditive: C.Parser<Expression> = (tokens) => {\n  const addResult = C.map(\n    C.seq(\n      parseMultiplicative,\n      C.many(\n        C.seq(C.choice(C.operator(\"+\"), C.operator(\"-\")), parseMultiplicative)\n      )\n    ),\n    ([left, rest]) => {\n      let result = left;\n      for (const [op, right] of rest) {\n        result = {\n          kind: \"binary\",\n          operator: op.value as \"+\" | \"-\",\n          left: result,\n          right,\n          location: result.location,\n        };\n      }\n      return result;\n    }\n  )(tokens);\n\n  if (!addResult.success) return addResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(addResult.value, addResult.remaining);\n};\n\n// --- Comparison (<, >, <=, >=, ==, !=) ---\nconst parseComparison: C.Parser<Expression> = (tokens) => {\n  const compResult = C.map(\n    C.seq(\n      parseAdditive,\n      C.many(\n        C.seq(\n          C.choice(\n            C.operator(\"<\"),\n            C.operator(\">\"),\n            C.operator(\"<=\"),\n            C.operator(\">=\"),\n            C.operator(\"==\"),\n            C.operator(\"!=\")\n          ),\n          parseAdditive\n        )\n      )\n    ),\n    ([left, rest]) => {\n      let result = left;\n      for (const [op, right] of rest) {\n        result = {\n          kind: \"binary\",\n          operator: op.value as \"<\" | \">\" | \"<=\" | \">=\" | \"==\" | \"!=\",\n          left: result,\n          right,\n          location: result.location,\n        };\n      }\n      return result;\n    }\n  )(tokens);\n\n  if (!compResult.success) return compResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(compResult.value, compResult.remaining);\n};\n\n// --- Composition (|>, <|) ---\nconst parseCompose: C.Parser<Expression> = (tokens) => {\n  const compResult = C.map(\n    C.seq(\n      parseComparison,\n      C.many(\n        C.seq(C.choice(C.operator(\"|>\"), C.operator(\"<|\")), parseComparison)\n      )\n    ),\n    ([left, rest]) => {\n      // Build steps array for pipeline expression\n      const steps = [left];\n      for (const [op, right] of rest) {\n        steps.push(right);\n      }\n\n      // If we have multiple steps, create a pipeline expression\n      if (steps.length > 1) {\n        return {\n          kind: \"pipeline\",\n          steps,\n          location: left.location,\n        } as import(\"../ast\").PipelineExpression;\n      }\n\n      // Otherwise just return the single expression\n      return left;\n    }\n  )(tokens);\n\n  if (!compResult.success) return compResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(compResult.value, compResult.remaining);\n};\n\n// --- Thrush (|) ---\nconst parseThrush: C.Parser<Expression> = (tokens) => {\n  const thrushResult = C.map(\n    C.seq(parseDollar, C.many(C.seq(C.operator(\"|\"), parseDollar))),\n    ([left, rest]) => {\n      let result = left;\n      for (const [op, right] of rest) {\n        result = {\n          kind: \"binary\",\n          operator: \"|\",\n          left: result,\n          right,\n          location: result.location,\n        };\n      }\n      return result;\n    }\n  )(tokens);\n\n  if (!thrushResult.success) return thrushResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(thrushResult.value, thrushResult.remaining);\n};\n\n// --- Dollar ($) - Low precedence function application (right-associative) ---\nconst parseDollar: C.Parser<Expression> = (tokens) => {\n  const leftResult = parseCompose(tokens);\n  if (!leftResult.success) return leftResult;\n  \n  // Check for $ operator\n  if (leftResult.remaining.length > 0 && \n      leftResult.remaining[0].type === \"OPERATOR\" && \n      leftResult.remaining[0].value === \"$\") {\n    \n    // Consume the $ token\n    const remaining = leftResult.remaining.slice(1);\n    \n    // Recursively parse the right side (this creates right-associativity)\n    const rightResult = parseDollar(remaining);\n    if (!rightResult.success) return rightResult;\n    \n    const result = {\n      kind: \"binary\" as const,\n      operator: \"$\" as const,\n      left: leftResult.value,\n      right: rightResult.value,\n      location: leftResult.value.location,\n    };\n    \n    return parsePostfixFromResult(result, rightResult.remaining);\n  }\n  \n  // No $ operator found, just return the left expression\n  return parsePostfixFromResult(leftResult.value, leftResult.remaining);\n};\n\n// --- If Expression (after dollar, before sequence) ---\nconst parseIfAfterDollar: C.Parser<Expression> = (tokens) => {\n  const ifResult = parseIfExpression(tokens);\n  if (!ifResult.success) return ifResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(ifResult.value, ifResult.remaining);\n};\n\n// Helper function to apply postfix operators to an expression\nconst parsePostfixFromResult = (\n  expr: Expression,\n  tokens: Token[]\n): C.ParseResult<Expression> => {\n  let result = expr;\n  let remaining = tokens;\n\n  // Try to parse postfix type annotations\n  while (remaining.length > 0) {\n    // Try to parse : type given constraint\n    if (\n      remaining.length >= 2 &&\n      remaining[0].type === \"PUNCTUATION\" &&\n      remaining[0].value === \":\"\n    ) {\n      const typeResult = parseTypeExpression(remaining.slice(1));\n      if (!typeResult.success) break;\n\n      // Check if there's a \"given\" constraint after the type\n      if (\n        typeResult.remaining.length > 0 &&\n        typeResult.remaining[0].type === \"KEYWORD\" &&\n        typeResult.remaining[0].value === \"given\"\n      ) {\n        const constraintResult = parseConstraintExpr(\n          typeResult.remaining.slice(1)\n        );\n        if (!constraintResult.success) break;\n\n        result = {\n          kind: \"constrained\",\n          expression: result,\n          type: typeResult.value,\n          constraint: constraintResult.value,\n          location: result.location,\n        };\n        remaining = constraintResult.remaining;\n        continue;\n      } else {\n        // Just a type annotation without constraints\n        result = {\n          kind: \"typed\",\n          expression: result,\n          type: typeResult.value,\n          location: result.location,\n        };\n        remaining = typeResult.remaining;\n        continue;\n      }\n    }\n\n    // No more postfix operators\n    break;\n  }\n\n  return {\n    success: true,\n    value: result,\n    remaining,\n  };\n};\n\n// --- Definition ---\nconst parseDefinition: C.Parser<DefinitionExpression> = C.map(\n  C.seq(\n    C.identifier(),\n    C.operator(\"=\"),\n    C.lazy(() => parseSequenceTermWithIf)\n  ),\n  ([name, equals, value]): DefinitionExpression => {\n    return {\n      kind: \"definition\",\n      name: name.value,\n      value,\n      location: name.location,\n    };\n  }\n);\n\n// --- Definition with typed expression (now just a regular definition) ---\nconst parseDefinitionWithType: C.Parser<DefinitionExpression> = parseDefinition;\n\n// --- Mutable Definition ---\nconst parseMutableDefinition: C.Parser<\n  import(\"../ast\").MutableDefinitionExpression\n> = C.map(\n  C.seq(\n    C.keyword(\"mut\"),\n    C.identifier(),\n    C.operator(\"=\"),\n    C.lazy(() => parseSequenceTermWithIf)\n  ),\n  ([\n    mut,\n    name,\n    equals,\n    value,\n  ]): import(\"../ast\").MutableDefinitionExpression => {\n    return {\n      kind: \"mutable-definition\",\n      name: name.value,\n      value,\n      location: mut.location,\n    };\n  }\n);\n\n// --- Mutation ---\nconst parseMutation: C.Parser<import(\"../ast\").MutationExpression> = C.map(\n  C.seq(\n    C.keyword(\"mut!\"),\n    C.identifier(),\n    C.operator(\"=\"),\n    C.lazy(() => parseSequenceTermWithIf)\n  ),\n  ([mut, name, equals, value]): import(\"../ast\").MutationExpression => {\n    return {\n      kind: \"mutation\",\n      target: name.value,\n      value,\n      location: mut.location,\n    };\n  }\n);\n\n// Custom parser for where clause definitions (both regular and mutable)\nconst parseWhereDefinition: C.Parser<\n  DefinitionExpression | MutableDefinitionExpression\n> = (tokens) => {\n  // Try mutable definition first\n  const mutableResult = parseMutableDefinition(tokens);\n  if (mutableResult.success) {\n    return mutableResult;\n  }\n  // Try regular definition\n  const regularResult = parseDefinition(tokens);\n  if (regularResult.success) {\n    return regularResult;\n  }\n  return {\n    success: false,\n    error: \"Expected definition in where clause\",\n    position: tokens[0]?.location.start.line || 0,\n  };\n};\n\n// --- ADT Constructor ---\nconst parseConstructor: C.Parser<ConstructorDefinition> = C.map(\n  C.seq(parseTypeName, C.many(C.lazy(() => parseTypeExpression))),\n  ([name, args]): ConstructorDefinition => ({\n    name: name.value,\n    args,\n    location: createLocation(name.location.start, name.location.end),\n  })\n);\n\n// --- Type Definition ---\nconst parseTypeDefinition: C.Parser<TypeDefinitionExpression> = C.map(\n  C.seq(\n    C.keyword(\"type\"),\n    parseTypeName,\n    C.many(C.identifier()),\n    C.operator(\"=\"),\n    C.sepBy(parseConstructor, C.operator(\"|\"))\n  ),\n  ([\n    type,\n    name,\n    typeParams,\n    equals,\n    constructors,\n  ]): TypeDefinitionExpression => ({\n    kind: \"type-definition\",\n    name: name.value,\n    typeParams: typeParams.map((p: any) => p.value),\n    constructors,\n    location: createLocation(\n      type.location.start,\n      constructors[constructors.length - 1]?.location.end || equals.location.end\n    ),\n  })\n);\n\n// --- Constraint Function ---\nconst parseConstraintFunction: C.Parser<ConstraintFunction> = C.map(\n  C.seq(\n    C.identifier(),\n    C.many(C.identifier()), // type parameters like \"a b\" in \"bind a b\"\n    C.punctuation(\":\"),\n    C.lazy(() => parseTypeExpression)\n  ),\n  ([name, typeParams, colon, type]): ConstraintFunction => ({\n    name: name.value,\n    typeParams: typeParams.map((p: any) => p.value),\n    type,\n    location: createLocation(name.location.start, colon.location.end),\n  })\n);\n\n// --- Constraint Definition ---\nconst parseConstraintDefinition: C.Parser<ConstraintDefinitionExpression> = C.map(\n  C.seq(\n    C.keyword(\"constraint\"),\n    C.identifier(), // constraint name like \"Monad\"\n    C.identifier(), // type parameter like \"m\"\n    C.punctuation(\"(\"),\n    C.sepBy(parseConstraintFunction, C.punctuation(\";\")),\n    C.punctuation(\")\")\n  ),\n  ([constraintKeyword, name, typeParam, openParen, functions, closeParen]): ConstraintDefinitionExpression => ({\n    kind: \"constraint-definition\",\n    name: name.value,\n    typeParam: typeParam.value,\n    functions,\n    location: createLocation(constraintKeyword.location.start, closeParen.location.end),\n  })\n);\n\n// --- Implementation Function ---\nconst parseImplementationFunction: C.Parser<ImplementationFunction> = C.map(\n  C.seq(\n    C.identifier(),\n    C.operator(\"=\"),\n    C.lazy(() => parseSequenceTerm)\n  ),\n  ([name, equals, value]): ImplementationFunction => ({\n    name: name.value,\n    value,\n    location: createLocation(name.location.start, value.location.end),\n  })\n);\n\n// --- Implement Definition ---\nconst parseImplementDefinition: C.Parser<ImplementDefinitionExpression> = C.map(\n  C.seq(\n    C.keyword(\"implement\"),\n    C.identifier(), // constraint name like \"Monad\"\n    parseTypeName, // type name like \"List\" or \"Int\"\n    C.punctuation(\"(\"),\n    C.sepBy(parseImplementationFunction, C.punctuation(\";\")),\n    C.punctuation(\")\")\n  ),\n  ([implementKeyword, constraintName, typeName, openParen, implementations, closeParen]): ImplementDefinitionExpression => ({\n    kind: \"implement-definition\",\n    constraintName: constraintName.value,\n    typeName: typeName.value,\n    implementations,\n    location: createLocation(implementKeyword.location.start, closeParen.location.end),\n  })\n);\n\n// --- Pattern Parsing ---\n// Basic pattern parsing for constructor arguments (no nested constructors with args)\nconst parseBasicPattern: C.Parser<Pattern> = C.choice(\n  // Wildcard pattern: _\n  C.map(\n    C.punctuation(\"_\"),\n    (underscore): Pattern => ({\n      kind: \"wildcard\",\n      location: underscore.location,\n    })\n  ),\n  // Literal pattern: number or string\n  C.map(\n    C.number(),\n    (num): Pattern => ({\n      kind: \"literal\",\n      value: parseInt(num.value),\n      location: num.location,\n    })\n  ),\n  C.map(\n    C.string(),\n    (str): Pattern => ({\n      kind: \"literal\",\n      value: str.value,\n      location: str.location,\n    })\n  ),\n  // Constructor or variable pattern: identifier (decide based on capitalization)\n  C.map(C.identifier(), (name): Pattern => {\n    // If identifier starts with uppercase, treat as constructor pattern (zero args)\n    if (name.value.length > 0 && name.value[0] >= \"A\" && name.value[0] <= \"Z\") {\n      return {\n        kind: \"constructor\",\n        name: name.value,\n        args: [],\n        location: name.location,\n      };\n    } else {\n      // Otherwise, treat as variable pattern\n      return {\n        kind: \"variable\",\n        name: name.value,\n        location: name.location,\n      };\n    }\n  })\n);\n\nconst parsePattern: C.Parser<Pattern> = C.choice(\n  // Wildcard pattern: _\n  C.map(\n    C.punctuation(\"_\"),\n    (underscore): Pattern => ({\n      kind: \"wildcard\",\n      location: underscore.location,\n    })\n  ),\n  // Constructor pattern with arguments: Some x y\n  C.map(\n    C.seq(C.identifier(), C.many1(parseBasicPattern)),\n    ([name, args]): Pattern => ({\n      kind: \"constructor\",\n      name: name.value,\n      args,\n      location: createLocation(\n        name.location.start,\n        args[args.length - 1].location.end\n      ),\n    })\n  ),\n  // Constructor pattern with parenthesized arguments: Wrap (Value n)\n  C.map(\n    C.seq(\n      C.identifier(),\n      C.punctuation(\"(\"),\n      C.lazy(() => parsePattern),\n      C.punctuation(\")\")\n    ),\n    ([name, openParen, arg, closeParen]): Pattern => ({\n      kind: \"constructor\",\n      name: name.value,\n      args: [arg],\n      location: createLocation(name.location.start, closeParen.location.end),\n    })\n  ),\n  // Constructor or variable pattern: identifier (decide based on capitalization)\n  C.map(C.identifier(), (name): Pattern => {\n    // If identifier starts with uppercase, treat as constructor pattern\n    if (name.value.length > 0 && name.value[0] >= \"A\" && name.value[0] <= \"Z\") {\n      return {\n        kind: \"constructor\",\n        name: name.value,\n        args: [],\n        location: name.location,\n      };\n    } else {\n      // Otherwise, treat as variable pattern\n      return {\n        kind: \"variable\",\n        name: name.value,\n        location: name.location,\n      };\n    }\n  })\n);\n\n// --- Match Case Expression Parser ---\n// This parser supports expressions in match cases, including nested match expressions\nconst parseMatchCaseExpression: C.Parser<Expression> = C.choice(\n  C.lazy(() => parseMatchExpression), // Support nested match expressions\n  parseIfExpression, // Support if expressions  \n  C.lazy(() => parseExprWithType) // Support all other expressions including type annotations\n);\n\n// --- Match Case ---\nconst parseMatchCase: C.Parser<MatchCase> = C.map(\n  C.seq(\n    parsePattern,\n    C.operator(\"=>\"),\n    C.lazy(() => parseMatchCaseExpression) // Use dedicated parser for match case expressions\n  ),\n  ([pattern, arrow, expression]): MatchCase => ({\n    pattern,\n    expression,\n    location: createLocation(pattern.location.start, expression.location.end),\n  })\n);\n\n// --- Match Expression ---\nconst parseMatchExpression: C.Parser<MatchExpression> = C.map(\n  C.seq(\n    C.keyword(\"match\"),\n    C.lazy(() => parseThrush), // Use a simpler expression parser to avoid circular dependency\n    C.keyword(\"with\"),\n    C.punctuation(\"(\"),\n    C.sepBy(parseMatchCase, C.punctuation(\";\")),\n    C.punctuation(\")\")\n  ),\n  ([\n    match,\n    expression,\n    with_,\n    openParen,\n    cases,\n    closeParen,\n  ]): MatchExpression => ({\n    kind: \"match\",\n    expression,\n    cases,\n    location: createLocation(match.location.start, closeParen.location.end),\n  })\n);\n\n// --- Where Expression ---\nconst parseWhereExpression: C.Parser<WhereExpression> = C.map(\n  C.seq(\n    C.lazy(() => parseSequenceTermWithIfExceptRecord), // Main expression (no records to avoid circular dependency)\n    C.keyword(\"where\"),\n    C.punctuation(\"(\"),\n    C.sepBy(parseWhereDefinition, C.punctuation(\";\")),\n    C.punctuation(\")\")\n  ),\n  ([main, where, openParen, definitions, closeParen]): WhereExpression => {\n    return {\n      kind: \"where\",\n      main,\n      definitions,\n      location: main.location,\n    };\n  }\n);\n\n// --- Sequence term: everything else ---\nconst parseSequenceTerm: C.Parser<Expression> = C.choice(\n  // Parse keyword-based expressions first to avoid identifier conflicts\n  parseMatchExpression, // ADT pattern matching (starts with \"match\")\n  parseTypeDefinition, // ADT type definitions (starts with \"type\")\n  parseConstraintDefinition, // constraint definitions (starts with \"constraint\")\n  parseImplementDefinition, // implement definitions (starts with \"implement\")\n  parseMutableDefinition, // starts with \"mut\"\n  parseMutation, // starts with \"mut!\"\n  parseImportExpression, // starts with \"import\"\n  parseIfAfterDollar, // if expressions (starts with \"if\")\n  // Then parse identifier-based expressions\n  parseDefinitionWithType, // allow definitions with type annotations\n  parseDefinition, // fallback to regular definitions  \n  parseWhereExpression,\n  parseThrush, // full expression hierarchy (includes all primaries and type annotations)\n  parseRecord,\n  parseThrush,\n  parseLambdaExpression\n);\n\n// Version without records to avoid circular dependency\nconst parseSequenceTermExceptRecord: C.Parser<Expression> = C.choice(\n  // Parse keyword-based expressions first\n  parseMatchExpression, // ADT pattern matching\n  parseTypeDefinition, // ADT type definitions\n  parseConstraintDefinition, // constraint definitions\n  parseImplementDefinition, // implement definitions\n  parseMutableDefinition,\n  parseMutation,\n  parseImportExpression,\n  // Then identifier-based expressions\n  parseDefinition, // Regular definitions\n  parseThrush,\n  parseLambdaExpression,\n  parseNumber,\n  parseString,\n  parseIdentifier,\n  parseList,\n  parseAccessor,\n  parseParenExpr\n);\n\n// parseSequenceTerm now includes parseIfExpression\nconst parseSequenceTermWithIf: C.Parser<Expression> = parseSequenceTerm;\n\n// Version with if but without records to avoid circular dependency\nconst parseSequenceTermWithIfExceptRecord: C.Parser<Expression> = C.choice(\n  parseSequenceTermExceptRecord,\n  parseIfExpression\n);\n\n// --- Parse atomic constraint ---\nconst parseAtomicConstraint: C.Parser<ConstraintExpr> = C.choice(\n  // Parenthesized constraint\n  C.map(\n    C.seq(\n      C.punctuation(\"(\"),\n      C.lazy(() => parseConstraintExpr),\n      C.punctuation(\")\")\n    ),\n    ([open, expr, close]) => ({ kind: \"paren\", expr })\n  ),\n  // a is Collection\n  C.map(\n    C.seq(\n      C.identifier(),\n      C.keyword(\"is\"),\n      C.choice(\n        C.identifier()\n        // Removed meaningless constraint keywords\n      )\n    ),\n    ([typeVar, isKeyword, constraint]): ConstraintExpr => ({\n      kind: \"is\",\n      typeVar: typeVar.value,\n      constraint: constraint.value,\n    })\n  ),\n  // a has field \"name\" of type T\n  C.map(\n    C.seq(\n      C.identifier(),\n      C.keyword(\"has\"),\n      C.keyword(\"field\"),\n      C.string(),\n      C.keyword(\"of\"),\n      C.keyword(\"type\"),\n      C.lazy(() => parseTypeExpression)\n    ),\n    ([\n      typeVar,\n      has,\n      field,\n      fieldName,\n      of,\n      type,\n      fieldType,\n    ]): ConstraintExpr => ({\n      kind: \"hasField\",\n      typeVar: typeVar.value,\n      field: fieldName.value,\n      fieldType,\n    })\n  ),\n  // a implements Interface\n  C.map(\n    C.seq(C.identifier(), C.keyword(\"implements\"), C.identifier()),\n    ([typeVar, implementsKeyword, interfaceName]): ConstraintExpr => ({\n      kind: \"implements\",\n      typeVar: typeVar.value,\n      interfaceName: interfaceName.value,\n    })\n  )\n);\n\n// --- Parse constraint expression with precedence: and > or ---\nconst parseConstraintExpr: C.Parser<ConstraintExpr> = (tokens) => {\n  // Parse left side (and chains)\n  let leftResult = parseConstraintAnd(tokens);\n  if (!leftResult.success) return leftResult;\n  let left = leftResult.value;\n  let rest = leftResult.remaining;\n\n  // Parse or chains\n  while (\n    rest.length > 0 &&\n    rest[0].type === \"KEYWORD\" &&\n    rest[0].value === \"or\"\n  ) {\n    rest = rest.slice(1);\n    const rightResult = parseConstraintAnd(rest);\n    if (!rightResult.success) return rightResult;\n    left = { kind: \"or\", left, right: rightResult.value };\n    rest = rightResult.remaining;\n  }\n  return { success: true as const, value: left, remaining: rest };\n};\n\nconst parseConstraintAnd: C.Parser<ConstraintExpr> = (tokens) => {\n  let leftResult = parseAtomicConstraint(tokens);\n  if (!leftResult.success) return leftResult;\n  let left = leftResult.value;\n  let rest = leftResult.remaining;\n\n  while (\n    rest.length > 0 &&\n    rest[0].type === \"KEYWORD\" &&\n    rest[0].value === \"and\"\n  ) {\n    rest = rest.slice(1);\n    const rightResult = parseAtomicConstraint(rest);\n    if (!rightResult.success) return rightResult;\n    left = { kind: \"and\", left, right: rightResult.value };\n    rest = rightResult.remaining;\n  }\n  return { success: true as const, value: left, remaining: rest };\n};\n\n// --- Expression with type annotation (just above semicolon) ---\nconst parseExprWithType: C.Parser<Expression> = C.choice(\n  // Expression with type and constraints: expr : type given constraintExpr\n  C.map(\n    C.seq(\n      parseThrush, // Use parseThrush to support full expression hierarchy\n      C.punctuation(\":\"),\n      C.lazy(() => parseTypeExpression),\n      C.keyword(\"given\"),\n      parseConstraintExpr\n    ),\n    ([expr, colon, type, given, constraint]): ConstrainedExpression => ({\n      kind: \"constrained\",\n      expression: expr,\n      type,\n      constraint,\n      location: expr.location,\n    })\n  ),\n  // Expression with just type: expr : type\n  C.map(\n    C.seq(\n      parseThrush, // Use parseThrush to support full expression hierarchy\n      C.punctuation(\":\"),\n      C.lazy(() => parseTypeExpression)\n    ),\n    ([expr, colon, type]): TypedExpression => ({\n      kind: \"typed\",\n      expression: expr,\n      type,\n      location: expr.location,\n    })\n  ),\n  parseThrush // Fallback to regular expressions\n);\n\n// --- Sequence (semicolon) ---\n// Accepts a sequence of definitions and/or expressions, separated by semicolons\nconst parseSequence: C.Parser<Expression> = C.map(\n  C.seq(\n    C.lazy(() => parseSequenceTermWithIf),\n    C.many(\n      C.seq(\n        C.punctuation(\";\"),\n        C.lazy(() => parseSequenceTermWithIf)\n      )\n    )\n  ),\n  ([left, rest]) => {\n    let result = left;\n    for (const [op, right] of rest) {\n      result = {\n        kind: \"binary\",\n        operator: \";\",\n        left: result,\n        right,\n        location: result.location,\n      };\n    }\n    return result;\n  }\n);\n\n// --- Expression (top-level) ---\nconst parseExpr: C.Parser<Expression> = parseSequence;\n\n// --- Main Parse Function ---\nexport const parse = (tokens: Token[]): Program => {\n  // Filter out EOF tokens for parsing\n  const nonEOFTokens = tokens.filter((t) => t.type !== \"EOF\");\n\n  // Parse multiple top-level expressions separated by semicolons\n  let statements: Expression[] = [];\n  let rest = nonEOFTokens;\n  while (rest.length > 0) {\n    // Skip leading semicolons\n    while (\n      rest.length > 0 &&\n      rest[0].type === \"PUNCTUATION\" &&\n      rest[0].value === \";\"\n    ) {\n      rest = rest.slice(1);\n    }\n    if (rest.length === 0) break;\n    const result = parseExpr(rest);\n    if (!result.success) {\n      // Include line and column information in parse error\n      const errorLocation =\n        result.position > 0 ? ` at line ${result.position}` : \"\";\n      throw new Error(`Parse error: ${result.error}${errorLocation}`);\n    }\n    statements.push(result.value);\n    rest = result.remaining;\n    // Skip trailing semicolons after each statement\n    while (\n      rest.length > 0 &&\n      rest[0].type === \"PUNCTUATION\" &&\n      rest[0].value === \";\"\n    ) {\n      rest = rest.slice(1);\n    }\n  }\n  // If there are still leftover tokens that aren't semicolons or EOF, throw an error\n  if (rest.length > 0) {\n    const next = rest[0];\n    throw new Error(\n      `Unexpected token after expression: ${next.type} '${next.value}' at line ${next.location.start.line}, column ${next.location.start.column}`\n    );\n  }\n  return {\n    statements,\n    location: createLocation({ line: 1, column: 1 }, { line: 1, column: 1 }),\n  };\n};\n"],"names":["parse","parseTypeExpression","parseTypeName","tokens","length","success","error","position","first","rest","typeKeywords","type","includes","value","remaining","location","start","line","parseTypeAtom","primitiveTypes","typeName","result","C","keyword","intType","stringType","unitType","listKeywordResult","argResult","lazy","listTypeWithElement","typeVariable","recordResult","seq","punctuation","optional","sepBy","map","identifier","name","colon","fields","fieldObj","recordType","tupleResult","elements","tupleType","listResult","tupleConstructorResult","many","elementTypes","tupleTypeConstructor","parenResult","test","typeNameResult","argsResult","kind","args","identifierResult","parseFunctionTypeWithoutEffects","leftResult","left","slice","rightResult","functionType","funcType","effects","Set","effectRest","effectName","validEffects","join","add","varResult","parseIdentifier","token","parseNumber","number","parseFloat","parseString","string","parseAccessor","accessor","field","parseRecordFieldName","parseRecordFieldValue","parseSequence","parseRecordField","fieldName","isNamed","parseRecordFieldOrPositional","index","namedFieldResult","positionalFieldResult","parseRecordFields","firstFieldResult","push","commaResult","fieldResult","parseRecord","open","close","fieldsList","allNamed","every","f","allPositional","i","Error","parseParenExpr","expr","parseLambdaExpression","fnResult","paramNames","braceResult","idResult","p","arrowResult","operator","bodyResult","parseSequenceTermWithIf","params","body","parseListElements","firstElementResult","parseThrush","elementResult","parseList","elementsList","parseImportExpression","importKw","path","parseIfExpression","parseSequenceTerm","ifKw","condition","thenKw","thenExpr","elseKw","elseExpr","then","else","parsePrimary","process","env","NOO_DEBUG_PARSE","console","log","t","firstToken","parseDefinitionWithType","parsePrimaryWithPostfix","primaryResult","postfixResult","parsePostfixFromResult","parseUnary","minusToken","nextToken","end","column","operandResult","right","parseApplication","appResult","func","arg","parseMultiplicative","multResult","choice","op","parseAdditive","addResult","parseComparison","compResult","parseCompose","steps","thrushResult","parseDollar","parseIfAfterDollar","ifResult","typeResult","constraintResult","parseConstraintExpr","expression","constraint","parseDefinition","equals","parseMutableDefinition","mut","parseMutation","target","parseWhereDefinition","mutableResult","regularResult","parseConstructor","createLocation","parseTypeDefinition","typeParams","constructors","parseConstraintFunction","parseConstraintDefinition","constraintKeyword","typeParam","openParen","functions","closeParen","parseImplementationFunction","parseImplementDefinition","implementKeyword","constraintName","implementations","parseBasicPattern","underscore","num","parseInt","str","parsePattern","many1","parseMatchCaseExpression","parseMatchExpression","parseExprWithType","parseMatchCase","pattern","arrow","match","with_","cases","parseWhereExpression","parseSequenceTermWithIfExceptRecord","main","where","definitions","parseSequenceTermExceptRecord","parseAtomicConstraint","typeVar","isKeyword","has","of","fieldType","implementsKeyword","interfaceName","parseConstraintAnd","given","parseExpr","nonEOFTokens","filter","statements","errorLocation","next"],"mappings":"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"}