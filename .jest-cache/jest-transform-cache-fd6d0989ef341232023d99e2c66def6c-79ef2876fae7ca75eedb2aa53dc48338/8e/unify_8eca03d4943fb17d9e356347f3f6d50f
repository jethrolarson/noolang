fcabc1154e3997b96dde0f9a3e55010b
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unify", {
    enumerable: true,
    get: function() {
        return unify;
    }
});
const _substitute = require("./substitute");
const _helpers = require("./helpers");
const _typeerrors = require("./type-errors");
const _constraints = require("./constraints");
// Performance tracking
let unifyCallCount = 0;
let totalUnifyTime = 0;
let slowUnifyCalls = [];
let unifyCallSources = new Map(); // Track where unify calls come from
let unifyTypePatterns = new Map(); // Track what types are being unified
const typeToPattern = (t)=>{
    switch(t.kind){
        case 'variable':
            return `var:${t.name}`;
        case 'primitive':
            return `prim:${t.name}`;
        case 'function':
            return `fn:${t.params.length}p`;
        case 'list':
            return `list`;
        case 'record':
            return `rec:${Object.keys(t.fields).length}f`;
        case 'tuple':
            return `tup:${t.elements.length}e`;
        case 'variant':
            return `var:${t.name}:${t.args.length}a`;
        default:
            return t.kind;
    }
};
// Cache for unification results to avoid repeated work
const unifyCache = new Map();
const unifyInternal = (t1, t2, state, location, context)=>{
    // Early equality check before substitution for performance
    if (t1 === t2) return state;
    const s1 = (0, _substitute.substitute)(t1, state.substitution);
    const s2 = (0, _substitute.substitute)(t2, state.substitution);
    if ((0, _helpers.typesEqual)(s1, s2)) return state;
    // Handle variables (either order)
    if ((0, _helpers.isTypeKind)(s1, 'variable')) return unifyVariable(s1, s2, state, location);
    if ((0, _helpers.isTypeKind)(s2, 'variable')) return unifyVariable(s2, s1, state, location);
    // Handle function types
    if ((0, _helpers.isTypeKind)(s1, 'function') && (0, _helpers.isTypeKind)(s2, 'function')) {
        return unifyFunction(s1, s2, state, location);
    }
    // Handle list types
    if ((0, _helpers.isTypeKind)(s1, 'list') && (0, _helpers.isTypeKind)(s2, 'list')) {
        return unifyList(s1, s2, state, location);
    }
    // Handle tuple types
    if ((0, _helpers.isTypeKind)(s1, 'tuple') && (0, _helpers.isTypeKind)(s2, 'tuple')) {
        return unifyTuple(s1, s2, state, location);
    }
    // Handle record types
    if ((0, _helpers.isTypeKind)(s1, 'record') && (0, _helpers.isTypeKind)(s2, 'record')) {
        return unifyRecord(s1, s2, state, location);
    }
    // Handle union types
    if ((0, _helpers.isTypeKind)(s1, 'union') && (0, _helpers.isTypeKind)(s2, 'union')) {
        return unifyUnion(s1, s2, state, location);
    }
    // Handle primitive types
    if ((0, _helpers.isTypeKind)(s1, 'primitive') && (0, _helpers.isTypeKind)(s2, 'primitive')) {
        return unifyPrimitive(s1, s2, state, location);
    }
    // Handle unit types
    if ((0, _helpers.isTypeKind)(s1, 'unit') && (0, _helpers.isTypeKind)(s2, 'unit')) {
        return unifyUnit(s1, s2, state, location);
    }
    // Handle variant types (ADTs like Option, Result, etc.)
    if ((0, _helpers.isTypeKind)(s1, 'variant') && (0, _helpers.isTypeKind)(s2, 'variant')) {
        return unifyVariant(s1, s2, state, location);
    }
    // If we get here, the types cannot be unified
    // Add debug info for difficult cases
    const debugContext = context || {};
    if (s1.kind === s2.kind && s1.kind === 'primitive' && s1.name === s2.name) {
        debugContext.reason = 'concrete_vs_variable';
        debugContext.hint = `Both types appear to be ${s1.name} but they are not unifying. This suggests the type equality check is failing. Type 1: ${JSON.stringify(s1)}, Type 2: ${JSON.stringify(s2)}. Check if there are extra properties or constraints causing inequality.`;
    }
    throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.unificationError)(s1, s2, debugContext, location || {
        line: 1,
        column: 1
    })));
};
const unify = (t1, t2, state, location, context)=>{
    const start = Date.now();
    unifyCallCount++;
    // Track call sources using stack trace
    const stack = new Error().stack || '';
    const caller = stack.split('\n')[2] || 'unknown';
    const source = caller.includes('at ') ? caller.split('at ')[1].split(' ')[0] : 'unknown';
    unifyCallSources.set(source, (unifyCallSources.get(source) || 0) + 1);
    // Track type patterns being unified
    const pattern = `${typeToPattern(t1)} = ${typeToPattern(t2)}`;
    unifyTypePatterns.set(pattern, (unifyTypePatterns.get(pattern) || 0) + 1);
    const result = unifyInternal(t1, t2, state, location, context);
    const time = Date.now() - start;
    totalUnifyTime += time;
    if (time > 10) {
        slowUnifyCalls.push({
            type1: `${t1.kind}:${t1.kind === 'variable' ? t1.name : '?'}`,
            type2: `${t2.kind}:${t2.kind === 'variable' ? t2.name : '?'}`,
            time
        });
    }
    if (unifyCallCount % 5000 === 0) {
        console.warn(`Unify: ${unifyCallCount} calls, ${totalUnifyTime}ms total, ${slowUnifyCalls.length} slow calls`);
        // Show top call sources
        const topSources = Array.from(unifyCallSources.entries()).sort((a, b)=>b[1] - a[1]).slice(0, 5);
        console.warn('Top unify call sources:', topSources);
        // Show most repeated type patterns
        const topPatterns = Array.from(unifyTypePatterns.entries()).sort((a, b)=>b[1] - a[1]).slice(0, 5);
        console.warn('Most repeated unifications:', topPatterns);
    }
    return result;
};
function unifyUnion(s1, s2, state, location) {
    if (!(0, _helpers.isTypeKind)(s1, 'union') || !(0, _helpers.isTypeKind)(s2, 'union')) {
        throw new Error('unifyUnion called with non-union types');
    }
    // For now, require exact match of union types
    if (s1.types.length !== s2.types.length) throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.createTypeError)(`Union type mismatch: ${s1.types.length} vs ${s2.types.length} types`, {}, location || {
        line: 1,
        column: 1
    })));
    let currentState = state;
    for(let i = 0; i < s1.types.length; i++){
        currentState = unify(s1.types[i], s2.types[i], currentState, location);
    }
    return currentState;
}
function unifyPrimitive(s1, s2, state, location) {
    if (!(0, _helpers.isTypeKind)(s1, 'primitive') || !(0, _helpers.isTypeKind)(s2, 'primitive')) {
        throw new Error('unifyPrimitive called with non-primitive types');
    }
    if (s1.name !== s2.name) throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.operatorTypeError)('', s1, s2, location || {
        line: 1,
        column: 1
    })));
    return state;
}
function unifyUnit(s1, s2, state, location) {
    if (!(0, _helpers.isTypeKind)(s1, 'unit') || !(0, _helpers.isTypeKind)(s2, 'unit')) {
        throw new Error('unifyUnit called with non-unit types');
    }
    return state;
}
// --- Unification helpers ---
function unifyVariable(s1, s2, state, location) {
    if (!(0, _helpers.isTypeKind)(s1, 'variable')) {
        throw new Error('unifyVariable called with non-variable s1');
    }
    // Optimized constraint collection - avoid array spreading
    let constraintsToCheck = [];
    let seenVars = new Set();
    let currentVar = s1;
    while((0, _helpers.isTypeKind)(currentVar, 'variable')){
        if (seenVars.has(currentVar.name)) break;
        seenVars.add(currentVar.name);
        if (currentVar.constraints) {
            // Use forEach instead of spread for better performance
            currentVar.constraints.forEach((c)=>constraintsToCheck.push(c));
        }
        const next = state.substitution.get(currentVar.name);
        if (!next) break;
        currentVar = next;
    }
    // If s2 is a variable, merge all constraints into it
    if ((0, _helpers.isTypeKind)(s2, 'variable')) {
        s2.constraints = s2.constraints || [];
        // Optimized constraint merging - use efficient constraint comparison
        for (const c of constraintsToCheck){
            if (!s2.constraints.some((existing)=>(0, _helpers.constraintsEqual)(c, existing))) {
                s2.constraints.push(c);
            }
        }
    }
    // Occurs check
    if ((0, _helpers.occursIn)(s1.name, s2)) throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.createTypeError)(`Occurs check failed: ${s1.name} occurs in ${(0, _helpers.typeToString)(s2, state.substitution)}`, {}, location || {
        line: 1,
        column: 1
    })));
    let newState = {
        ...state,
        substitution: (0, _helpers.mapSet)(state.substitution, s1.name, s2)
    };
    // If s2 is not a variable, propagate or check constraints
    if (!(0, _helpers.isTypeKind)(s2, 'variable')) {
        for (const constraint of constraintsToCheck){
            if (constraint.kind === 'hasField' && (0, _helpers.isTypeKind)(s2, 'record')) {
                newState = unify(s2.fields[constraint.field], constraint.fieldType, newState, location);
            } else if (constraint.kind === 'is') {
                if ((0, _helpers.isTypeKind)(s2, 'primitive')) {
                    if (!(0, _constraints.satisfiesConstraint)(s2, constraint.constraint)) {
                        throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.createTypeError)(`Type ${(0, _helpers.typeToString)(s2, state.substitution)} does not satisfy constraint '${constraint.constraint}'. This error typically occurs when attempting to use a partial function (one that can fail) in an unsafe context like function composition. Consider using total functions that return Option or Result types instead.`, {}, location || {
                            line: 1,
                            column: 1
                        })));
                    }
                } else {
                    // Propagate the constraint recursively to all type variables inside s2
                    (0, _constraints.propagateConstraintToType)(s2, constraint);
                }
            } else {
                // For other constraint kinds, propagate recursively
                (0, _constraints.propagateConstraintToType)(s2, constraint);
            }
        }
    }
    return newState;
}
let functionUnifyCount = 0;
let functionUnifyPatterns = new Map();
function unifyFunction(s1, s2, state, location) {
    if (!(0, _helpers.isTypeKind)(s1, 'function') || !(0, _helpers.isTypeKind)(s2, 'function')) {
        throw new Error('unifyFunction called with non-function types');
    }
    functionUnifyCount++;
    const pattern = `${s1.params.length}p_${s2.params.length}p`;
    functionUnifyPatterns.set(pattern, (functionUnifyPatterns.get(pattern) || 0) + 1);
    if (functionUnifyCount % 1000 === 0) {
        console.warn(`Function unify: ${functionUnifyCount} calls, top patterns:`, Array.from(functionUnifyPatterns.entries()).sort((a, b)=>b[1] - a[1]).slice(0, 3));
    }
    if (s1.params.length !== s2.params.length) throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.functionApplicationError)(s1, s2, 0, undefined, location || {
        line: 1,
        column: 1
    })));
    let currentState = state;
    // First, propagate function-level constraints to the relevant type variables
    if (s1.constraints) {
        for (const constraint of s1.constraints){
            // Propagate to all type variables in s1
            (0, _constraints.propagateConstraintToType)(s1, constraint);
        }
    }
    if (s2.constraints) {
        for (const constraint of s2.constraints){
            // Propagate to all type variables in s2
            (0, _constraints.propagateConstraintToType)(s2, constraint);
        }
    }
    // Then unify parameters and return types
    for(let i = 0; i < s1.params.length; i++){
        // Skip expensive constraint propagation for non-variables
        const s1var = s1.params[i];
        const s2var = s2.params[i];
        if ((0, _helpers.isTypeKind)(s1var, 'variable') && (0, _helpers.isTypeKind)(s2var, 'variable') && (s1var.constraints?.length || s2var.constraints?.length)) {
            s1var.constraints = s1var.constraints || [];
            s2var.constraints = s2var.constraints || [];
            // Optimized constraint merging using efficient comparison
            // Propagate s1 -> s2
            for (const c of s1var.constraints){
                if (!s2var.constraints.some((existing)=>(0, _helpers.constraintsEqual)(c, existing))) {
                    s2var.constraints.push(c);
                }
            }
            // Propagate s2 -> s1
            for (const c of s2var.constraints){
                if (!s1var.constraints.some((existing)=>(0, _helpers.constraintsEqual)(c, existing))) {
                    s1var.constraints.push(c);
                }
            }
        }
        currentState = unify(s1.params[i], s2.params[i], currentState, location);
    }
    currentState = unify(s1.return, s2.return, currentState, location);
    return currentState;
}
function unifyList(s1, s2, state, location) {
    if (!(0, _helpers.isTypeKind)(s1, 'list') || !(0, _helpers.isTypeKind)(s2, 'list')) {
        throw new Error('unifyList called with non-list types');
    }
    return unify(s1.element, s2.element, state, location);
}
function unifyTuple(s1, s2, state, location) {
    if (!(0, _helpers.isTypeKind)(s1, 'tuple') || !(0, _helpers.isTypeKind)(s2, 'tuple')) {
        throw new Error('unifyTuple called with non-tuple types');
    }
    if (s1.elements.length !== s2.elements.length) throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.createTypeError)(`Tuple length mismatch: ${s1.elements.length} vs ${s2.elements.length}`, {}, location || {
        line: 1,
        column: 1
    })));
    let currentState = state;
    for(let i = 0; i < s1.elements.length; i++){
        currentState = unify(s1.elements[i], s2.elements[i], currentState, location);
    }
    return currentState;
}
function unifyVariant(s1, s2, state, location) {
    if (!(0, _helpers.isTypeKind)(s1, 'variant') || !(0, _helpers.isTypeKind)(s2, 'variant')) {
        throw new Error('unifyVariant called with non-variant types');
    }
    // Variant types must have the same name (e.g., both "Option")
    if (s1.name !== s2.name) {
        throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.createTypeError)(`Variant name mismatch: ${s1.name} vs ${s2.name}`, {}, location || {
            line: 1,
            column: 1
        })));
    }
    // Variant types must have the same number of type arguments
    if (s1.args.length !== s2.args.length) {
        throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.createTypeError)(`Variant arity mismatch: ${s1.name} has ${s1.args.length} vs ${s2.args.length} type arguments`, {}, location || {
            line: 1,
            column: 1
        })));
    }
    // Unify corresponding type arguments
    let currentState = state;
    for(let i = 0; i < s1.args.length; i++){
        currentState = unify(s1.args[i], s2.args[i], currentState, location);
    }
    return currentState;
}
function unifyRecord(s1, s2, state, location) {
    if (!(0, _helpers.isTypeKind)(s1, 'record') || !(0, _helpers.isTypeKind)(s2, 'record')) {
        throw new Error('unifyRecord called with non-record types');
    }
    const keys1 = Object.keys(s1.fields);
    let currentState = state;
    for (const key of keys1){
        if (!(key in s2.fields)) throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.createTypeError)(`Required field missing: ${key}`, {}, location || {
            line: 1,
            column: 1
        })));
        currentState = unify(s1.fields[key], s2.fields[key], currentState, location);
    }
    return currentState;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Uvc3JjL3R5cGVyL3VuaWZ5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFR5cGUgfSBmcm9tICcuLi9hc3QnO1xuaW1wb3J0IHsgc3Vic3RpdHV0ZSB9IGZyb20gJy4vc3Vic3RpdHV0ZSc7XG5pbXBvcnQgeyBUeXBlU3RhdGUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGlzVHlwZUtpbmQsIHR5cGVzRXF1YWwsIGNvbnN0cmFpbnRzRXF1YWwgfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHtcblx0Zm9ybWF0VHlwZUVycm9yLFxuXHRjcmVhdGVUeXBlRXJyb3IsXG5cdG9wZXJhdG9yVHlwZUVycm9yLFxuXHR1bmlmaWNhdGlvbkVycm9yLFxufSBmcm9tICcuL3R5cGUtZXJyb3JzJztcbmltcG9ydCB7IENvbnN0cmFpbnQgfSBmcm9tICcuLi9hc3QnO1xuaW1wb3J0IHsgbWFwU2V0LCB0eXBlVG9TdHJpbmcsIG9jY3Vyc0luIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IHNhdGlzZmllc0NvbnN0cmFpbnQsIHByb3BhZ2F0ZUNvbnN0cmFpbnRUb1R5cGUgfSBmcm9tICcuL2NvbnN0cmFpbnRzJztcbmltcG9ydCB7IGZ1bmN0aW9uQXBwbGljYXRpb25FcnJvciB9IGZyb20gJy4vdHlwZS1lcnJvcnMnO1xuXG4vLyBQZXJmb3JtYW5jZSB0cmFja2luZ1xubGV0IHVuaWZ5Q2FsbENvdW50ID0gMDtcbmxldCB0b3RhbFVuaWZ5VGltZSA9IDA7XG5sZXQgc2xvd1VuaWZ5Q2FsbHM6IEFycmF5PHt0eXBlMTogc3RyaW5nLCB0eXBlMjogc3RyaW5nLCB0aW1lOiBudW1iZXJ9PiA9IFtdO1xubGV0IHVuaWZ5Q2FsbFNvdXJjZXMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpOyAvLyBUcmFjayB3aGVyZSB1bmlmeSBjYWxscyBjb21lIGZyb21cbmxldCB1bmlmeVR5cGVQYXR0ZXJucyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7IC8vIFRyYWNrIHdoYXQgdHlwZXMgYXJlIGJlaW5nIHVuaWZpZWRcblxuY29uc3QgdHlwZVRvUGF0dGVybiA9ICh0OiBUeXBlKTogc3RyaW5nID0+IHtcblx0c3dpdGNoICh0LmtpbmQpIHtcblx0XHRjYXNlICd2YXJpYWJsZSc6IHJldHVybiBgdmFyOiR7dC5uYW1lfWA7XG5cdFx0Y2FzZSAncHJpbWl0aXZlJzogcmV0dXJuIGBwcmltOiR7dC5uYW1lfWA7XG5cdFx0Y2FzZSAnZnVuY3Rpb24nOiByZXR1cm4gYGZuOiR7dC5wYXJhbXMubGVuZ3RofXBgO1xuXHRcdGNhc2UgJ2xpc3QnOiByZXR1cm4gYGxpc3RgO1xuXHRcdGNhc2UgJ3JlY29yZCc6IHJldHVybiBgcmVjOiR7T2JqZWN0LmtleXModC5maWVsZHMpLmxlbmd0aH1mYDtcblx0XHRjYXNlICd0dXBsZSc6IHJldHVybiBgdHVwOiR7dC5lbGVtZW50cy5sZW5ndGh9ZWA7XG5cdFx0Y2FzZSAndmFyaWFudCc6IHJldHVybiBgdmFyOiR7dC5uYW1lfToke3QuYXJncy5sZW5ndGh9YWA7XG5cdFx0ZGVmYXVsdDogcmV0dXJuIHQua2luZDtcblx0fVxufTtcblxuLy8gQ2FjaGUgZm9yIHVuaWZpY2F0aW9uIHJlc3VsdHMgdG8gYXZvaWQgcmVwZWF0ZWQgd29ya1xuY29uc3QgdW5pZnlDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBUeXBlU3RhdGU+KCk7XG5cbmNvbnN0IHVuaWZ5SW50ZXJuYWwgPSAoXG5cdHQxOiBUeXBlLFxuXHR0MjogVHlwZSxcblx0c3RhdGU6IFR5cGVTdGF0ZSxcblx0bG9jYXRpb24/OiB7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfSxcblx0Y29udGV4dD86IHtcblx0XHRyZWFzb24/OiBzdHJpbmc7XG5cdFx0b3BlcmF0aW9uPzogc3RyaW5nO1xuXHRcdGhpbnQ/OiBzdHJpbmc7XG5cdH1cbik6IFR5cGVTdGF0ZSA9PiB7XG5cdC8vIEVhcmx5IGVxdWFsaXR5IGNoZWNrIGJlZm9yZSBzdWJzdGl0dXRpb24gZm9yIHBlcmZvcm1hbmNlXG5cdGlmICh0MSA9PT0gdDIpIHJldHVybiBzdGF0ZTtcblxuXHRjb25zdCBzMSA9IHN1YnN0aXR1dGUodDEsIHN0YXRlLnN1YnN0aXR1dGlvbik7XG5cdGNvbnN0IHMyID0gc3Vic3RpdHV0ZSh0Miwgc3RhdGUuc3Vic3RpdHV0aW9uKTtcblxuXHRpZiAodHlwZXNFcXVhbChzMSwgczIpKSByZXR1cm4gc3RhdGU7XG5cblx0Ly8gSGFuZGxlIHZhcmlhYmxlcyAoZWl0aGVyIG9yZGVyKVxuXHRpZiAoaXNUeXBlS2luZChzMSwgJ3ZhcmlhYmxlJykpIHJldHVybiB1bmlmeVZhcmlhYmxlKHMxLCBzMiwgc3RhdGUsIGxvY2F0aW9uKTtcblx0aWYgKGlzVHlwZUtpbmQoczIsICd2YXJpYWJsZScpKSByZXR1cm4gdW5pZnlWYXJpYWJsZShzMiwgczEsIHN0YXRlLCBsb2NhdGlvbik7XG5cblx0Ly8gSGFuZGxlIGZ1bmN0aW9uIHR5cGVzXG5cdGlmIChpc1R5cGVLaW5kKHMxLCAnZnVuY3Rpb24nKSAmJiBpc1R5cGVLaW5kKHMyLCAnZnVuY3Rpb24nKSkge1xuXHRcdHJldHVybiB1bmlmeUZ1bmN0aW9uKHMxLCBzMiwgc3RhdGUsIGxvY2F0aW9uKTtcblx0fVxuXG5cdC8vIEhhbmRsZSBsaXN0IHR5cGVzXG5cdGlmIChpc1R5cGVLaW5kKHMxLCAnbGlzdCcpICYmIGlzVHlwZUtpbmQoczIsICdsaXN0JykpIHtcblx0XHRyZXR1cm4gdW5pZnlMaXN0KHMxLCBzMiwgc3RhdGUsIGxvY2F0aW9uKTtcblx0fVxuXG5cdC8vIEhhbmRsZSB0dXBsZSB0eXBlc1xuXHRpZiAoaXNUeXBlS2luZChzMSwgJ3R1cGxlJykgJiYgaXNUeXBlS2luZChzMiwgJ3R1cGxlJykpIHtcblx0XHRyZXR1cm4gdW5pZnlUdXBsZShzMSwgczIsIHN0YXRlLCBsb2NhdGlvbik7XG5cdH1cblxuXHQvLyBIYW5kbGUgcmVjb3JkIHR5cGVzXG5cdGlmIChpc1R5cGVLaW5kKHMxLCAncmVjb3JkJykgJiYgaXNUeXBlS2luZChzMiwgJ3JlY29yZCcpKSB7XG5cdFx0cmV0dXJuIHVuaWZ5UmVjb3JkKHMxLCBzMiwgc3RhdGUsIGxvY2F0aW9uKTtcblx0fVxuXG5cdC8vIEhhbmRsZSB1bmlvbiB0eXBlc1xuXHRpZiAoaXNUeXBlS2luZChzMSwgJ3VuaW9uJykgJiYgaXNUeXBlS2luZChzMiwgJ3VuaW9uJykpIHtcblx0XHRyZXR1cm4gdW5pZnlVbmlvbihzMSwgczIsIHN0YXRlLCBsb2NhdGlvbik7XG5cdH1cblxuXHQvLyBIYW5kbGUgcHJpbWl0aXZlIHR5cGVzXG5cdGlmIChpc1R5cGVLaW5kKHMxLCAncHJpbWl0aXZlJykgJiYgaXNUeXBlS2luZChzMiwgJ3ByaW1pdGl2ZScpKSB7XG5cdFx0cmV0dXJuIHVuaWZ5UHJpbWl0aXZlKHMxLCBzMiwgc3RhdGUsIGxvY2F0aW9uKTtcblx0fVxuXG5cdC8vIEhhbmRsZSB1bml0IHR5cGVzXG5cdGlmIChpc1R5cGVLaW5kKHMxLCAndW5pdCcpICYmIGlzVHlwZUtpbmQoczIsICd1bml0JykpIHtcblx0XHRyZXR1cm4gdW5pZnlVbml0KHMxLCBzMiwgc3RhdGUsIGxvY2F0aW9uKTtcblx0fVxuXG5cdC8vIEhhbmRsZSB2YXJpYW50IHR5cGVzIChBRFRzIGxpa2UgT3B0aW9uLCBSZXN1bHQsIGV0Yy4pXG5cdGlmIChpc1R5cGVLaW5kKHMxLCAndmFyaWFudCcpICYmIGlzVHlwZUtpbmQoczIsICd2YXJpYW50JykpIHtcblx0XHRyZXR1cm4gdW5pZnlWYXJpYW50KHMxLCBzMiwgc3RhdGUsIGxvY2F0aW9uKTtcblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB0aGUgdHlwZXMgY2Fubm90IGJlIHVuaWZpZWRcblx0Ly8gQWRkIGRlYnVnIGluZm8gZm9yIGRpZmZpY3VsdCBjYXNlc1xuXHRjb25zdCBkZWJ1Z0NvbnRleHQgPSBjb250ZXh0IHx8IHt9O1xuXHRpZiAoXG5cdFx0czEua2luZCA9PT0gczIua2luZCAmJlxuXHRcdHMxLmtpbmQgPT09ICdwcmltaXRpdmUnICYmXG5cdFx0KHMxIGFzIGFueSkubmFtZSA9PT0gKHMyIGFzIGFueSkubmFtZVxuXHQpIHtcblx0XHRkZWJ1Z0NvbnRleHQucmVhc29uID0gJ2NvbmNyZXRlX3ZzX3ZhcmlhYmxlJztcblx0XHRkZWJ1Z0NvbnRleHQuaGludCA9IGBCb3RoIHR5cGVzIGFwcGVhciB0byBiZSAke1xuXHRcdFx0KHMxIGFzIGFueSkubmFtZVxuXHRcdH0gYnV0IHRoZXkgYXJlIG5vdCB1bmlmeWluZy4gVGhpcyBzdWdnZXN0cyB0aGUgdHlwZSBlcXVhbGl0eSBjaGVjayBpcyBmYWlsaW5nLiBUeXBlIDE6ICR7SlNPTi5zdHJpbmdpZnkoXG5cdFx0XHRzMVxuXHRcdCl9LCBUeXBlIDI6ICR7SlNPTi5zdHJpbmdpZnkoXG5cdFx0XHRzMlxuXHRcdCl9LiBDaGVjayBpZiB0aGVyZSBhcmUgZXh0cmEgcHJvcGVydGllcyBvciBjb25zdHJhaW50cyBjYXVzaW5nIGluZXF1YWxpdHkuYDtcblx0fVxuXG5cdHRocm93IG5ldyBFcnJvcihcblx0XHRmb3JtYXRUeXBlRXJyb3IoXG5cdFx0XHR1bmlmaWNhdGlvbkVycm9yKHMxLCBzMiwgZGVidWdDb250ZXh0LCBsb2NhdGlvbiB8fCB7IGxpbmU6IDEsIGNvbHVtbjogMSB9KVxuXHRcdClcblx0KTtcbn07XG5cbmV4cG9ydCBjb25zdCB1bmlmeSA9IChcblx0dDE6IFR5cGUsXG5cdHQyOiBUeXBlLFxuXHRzdGF0ZTogVHlwZVN0YXRlLFxuXHRsb2NhdGlvbj86IHsgbGluZTogbnVtYmVyOyBjb2x1bW46IG51bWJlciB9LFxuXHRjb250ZXh0Pzoge1xuXHRcdHJlYXNvbj86IHN0cmluZztcblx0XHRvcGVyYXRpb24/OiBzdHJpbmc7XG5cdFx0aGludD86IHN0cmluZztcblx0fVxuKTogVHlwZVN0YXRlID0+IHtcblx0Y29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuXHR1bmlmeUNhbGxDb3VudCsrO1xuXHRcblx0Ly8gVHJhY2sgY2FsbCBzb3VyY2VzIHVzaW5nIHN0YWNrIHRyYWNlXG5cdGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2sgfHwgJyc7XG5cdGNvbnN0IGNhbGxlciA9IHN0YWNrLnNwbGl0KCdcXG4nKVsyXSB8fCAndW5rbm93bic7XG5cdGNvbnN0IHNvdXJjZSA9IGNhbGxlci5pbmNsdWRlcygnYXQgJykgPyBjYWxsZXIuc3BsaXQoJ2F0ICcpWzFdLnNwbGl0KCcgJylbMF0gOiAndW5rbm93bic7XG5cdHVuaWZ5Q2FsbFNvdXJjZXMuc2V0KHNvdXJjZSwgKHVuaWZ5Q2FsbFNvdXJjZXMuZ2V0KHNvdXJjZSkgfHwgMCkgKyAxKTtcblx0XG5cdC8vIFRyYWNrIHR5cGUgcGF0dGVybnMgYmVpbmcgdW5pZmllZFxuXHRjb25zdCBwYXR0ZXJuID0gYCR7dHlwZVRvUGF0dGVybih0MSl9ID0gJHt0eXBlVG9QYXR0ZXJuKHQyKX1gO1xuXHR1bmlmeVR5cGVQYXR0ZXJucy5zZXQocGF0dGVybiwgKHVuaWZ5VHlwZVBhdHRlcm5zLmdldChwYXR0ZXJuKSB8fCAwKSArIDEpO1xuXHRcblx0Y29uc3QgcmVzdWx0ID0gdW5pZnlJbnRlcm5hbCh0MSwgdDIsIHN0YXRlLCBsb2NhdGlvbiwgY29udGV4dCk7XG5cdFxuXHRjb25zdCB0aW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0O1xuXHR0b3RhbFVuaWZ5VGltZSArPSB0aW1lO1xuXHRcblx0aWYgKHRpbWUgPiAxMCkge1xuXHRcdHNsb3dVbmlmeUNhbGxzLnB1c2goe1xuXHRcdFx0dHlwZTE6IGAke3QxLmtpbmR9OiR7dDEua2luZCA9PT0gJ3ZhcmlhYmxlJyA/IHQxLm5hbWUgOiAnPyd9YCxcblx0XHRcdHR5cGUyOiBgJHt0Mi5raW5kfToke3QyLmtpbmQgPT09ICd2YXJpYWJsZScgPyB0Mi5uYW1lIDogJz8nfWAsXG5cdFx0XHR0aW1lXG5cdFx0fSk7XG5cdH1cblx0XG5cdGlmICh1bmlmeUNhbGxDb3VudCAlIDUwMDAgPT09IDApIHtcblx0XHRjb25zb2xlLndhcm4oYFVuaWZ5OiAke3VuaWZ5Q2FsbENvdW50fSBjYWxscywgJHt0b3RhbFVuaWZ5VGltZX1tcyB0b3RhbCwgJHtzbG93VW5pZnlDYWxscy5sZW5ndGh9IHNsb3cgY2FsbHNgKTtcblx0XHRcblx0XHQvLyBTaG93IHRvcCBjYWxsIHNvdXJjZXNcblx0XHRjb25zdCB0b3BTb3VyY2VzID0gQXJyYXkuZnJvbSh1bmlmeUNhbGxTb3VyY2VzLmVudHJpZXMoKSlcblx0XHRcdC5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSlcblx0XHRcdC5zbGljZSgwLCA1KTtcblx0XHRjb25zb2xlLndhcm4oJ1RvcCB1bmlmeSBjYWxsIHNvdXJjZXM6JywgdG9wU291cmNlcyk7XG5cdFx0XG5cdFx0Ly8gU2hvdyBtb3N0IHJlcGVhdGVkIHR5cGUgcGF0dGVybnNcblx0XHRjb25zdCB0b3BQYXR0ZXJucyA9IEFycmF5LmZyb20odW5pZnlUeXBlUGF0dGVybnMuZW50cmllcygpKVxuXHRcdFx0LnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKVxuXHRcdFx0LnNsaWNlKDAsIDUpO1xuXHRcdGNvbnNvbGUud2FybignTW9zdCByZXBlYXRlZCB1bmlmaWNhdGlvbnM6JywgdG9wUGF0dGVybnMpO1xuXHR9XG5cdFxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gdW5pZnlVbmlvbihcblx0czE6IFR5cGUsXG5cdHMyOiBUeXBlLFxuXHRzdGF0ZTogVHlwZVN0YXRlLFxuXHRsb2NhdGlvbj86IHsgbGluZTogbnVtYmVyOyBjb2x1bW46IG51bWJlciB9XG4pOiBUeXBlU3RhdGUge1xuXHRpZiAoIWlzVHlwZUtpbmQoczEsICd1bmlvbicpIHx8ICFpc1R5cGVLaW5kKHMyLCAndW5pb24nKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcigndW5pZnlVbmlvbiBjYWxsZWQgd2l0aCBub24tdW5pb24gdHlwZXMnKTtcblx0fVxuXHQvLyBGb3Igbm93LCByZXF1aXJlIGV4YWN0IG1hdGNoIG9mIHVuaW9uIHR5cGVzXG5cdGlmIChzMS50eXBlcy5sZW5ndGggIT09IHMyLnR5cGVzLmxlbmd0aClcblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRmb3JtYXRUeXBlRXJyb3IoXG5cdFx0XHRcdGNyZWF0ZVR5cGVFcnJvcihcblx0XHRcdFx0XHRgVW5pb24gdHlwZSBtaXNtYXRjaDogJHtzMS50eXBlcy5sZW5ndGh9IHZzICR7czIudHlwZXMubGVuZ3RofSB0eXBlc2AsXG5cdFx0XHRcdFx0e30sXG5cdFx0XHRcdFx0bG9jYXRpb24gfHwgeyBsaW5lOiAxLCBjb2x1bW46IDEgfVxuXHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0KTtcblx0bGV0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHMxLnR5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y3VycmVudFN0YXRlID0gdW5pZnkoczEudHlwZXNbaV0sIHMyLnR5cGVzW2ldLCBjdXJyZW50U3RhdGUsIGxvY2F0aW9uKTtcblx0fVxuXHRyZXR1cm4gY3VycmVudFN0YXRlO1xufVxuXG5mdW5jdGlvbiB1bmlmeVByaW1pdGl2ZShcblx0czE6IFR5cGUsXG5cdHMyOiBUeXBlLFxuXHRzdGF0ZTogVHlwZVN0YXRlLFxuXHRsb2NhdGlvbj86IHsgbGluZTogbnVtYmVyOyBjb2x1bW46IG51bWJlciB9XG4pOiBUeXBlU3RhdGUge1xuXHRpZiAoIWlzVHlwZUtpbmQoczEsICdwcmltaXRpdmUnKSB8fCAhaXNUeXBlS2luZChzMiwgJ3ByaW1pdGl2ZScpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCd1bmlmeVByaW1pdGl2ZSBjYWxsZWQgd2l0aCBub24tcHJpbWl0aXZlIHR5cGVzJyk7XG5cdH1cblx0aWYgKHMxLm5hbWUgIT09IHMyLm5hbWUpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0Zm9ybWF0VHlwZUVycm9yKFxuXHRcdFx0XHRvcGVyYXRvclR5cGVFcnJvcignJywgczEsIHMyLCBsb2NhdGlvbiB8fCB7IGxpbmU6IDEsIGNvbHVtbjogMSB9KVxuXHRcdFx0KVxuXHRcdCk7XG5cdHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gdW5pZnlVbml0KFxuXHRzMTogVHlwZSxcblx0czI6IFR5cGUsXG5cdHN0YXRlOiBUeXBlU3RhdGUsXG5cdGxvY2F0aW9uPzogeyBsaW5lOiBudW1iZXI7IGNvbHVtbjogbnVtYmVyIH1cbik6IFR5cGVTdGF0ZSB7XG5cdGlmICghaXNUeXBlS2luZChzMSwgJ3VuaXQnKSB8fCAhaXNUeXBlS2luZChzMiwgJ3VuaXQnKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcigndW5pZnlVbml0IGNhbGxlZCB3aXRoIG5vbi11bml0IHR5cGVzJyk7XG5cdH1cblx0cmV0dXJuIHN0YXRlO1xufVxuXG4vLyAtLS0gVW5pZmljYXRpb24gaGVscGVycyAtLS1cbmZ1bmN0aW9uIHVuaWZ5VmFyaWFibGUoXG5cdHMxOiBUeXBlLFxuXHRzMjogVHlwZSxcblx0c3RhdGU6IFR5cGVTdGF0ZSxcblx0bG9jYXRpb24/OiB7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfVxuKTogVHlwZVN0YXRlIHtcblx0aWYgKCFpc1R5cGVLaW5kKHMxLCAndmFyaWFibGUnKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcigndW5pZnlWYXJpYWJsZSBjYWxsZWQgd2l0aCBub24tdmFyaWFibGUgczEnKTtcblx0fVxuXHQvLyBPcHRpbWl6ZWQgY29uc3RyYWludCBjb2xsZWN0aW9uIC0gYXZvaWQgYXJyYXkgc3ByZWFkaW5nXG5cdGxldCBjb25zdHJhaW50c1RvQ2hlY2s6IENvbnN0cmFpbnRbXSA9IFtdO1xuXHRsZXQgc2VlblZhcnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblx0bGV0IGN1cnJlbnRWYXI6IFR5cGUgPSBzMTtcblx0d2hpbGUgKGlzVHlwZUtpbmQoY3VycmVudFZhciwgJ3ZhcmlhYmxlJykpIHtcblx0XHRpZiAoc2VlblZhcnMuaGFzKGN1cnJlbnRWYXIubmFtZSkpIGJyZWFrO1xuXHRcdHNlZW5WYXJzLmFkZChjdXJyZW50VmFyLm5hbWUpO1xuXHRcdGlmIChjdXJyZW50VmFyLmNvbnN0cmFpbnRzKSB7XG5cdFx0XHQvLyBVc2UgZm9yRWFjaCBpbnN0ZWFkIG9mIHNwcmVhZCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG5cdFx0XHRjdXJyZW50VmFyLmNvbnN0cmFpbnRzLmZvckVhY2goYyA9PiBjb25zdHJhaW50c1RvQ2hlY2sucHVzaChjKSk7XG5cdFx0fVxuXHRcdGNvbnN0IG5leHQgPSBzdGF0ZS5zdWJzdGl0dXRpb24uZ2V0KGN1cnJlbnRWYXIubmFtZSk7XG5cdFx0aWYgKCFuZXh0KSBicmVhaztcblx0XHRjdXJyZW50VmFyID0gbmV4dDtcblx0fVxuXHQvLyBJZiBzMiBpcyBhIHZhcmlhYmxlLCBtZXJnZSBhbGwgY29uc3RyYWludHMgaW50byBpdFxuXHRpZiAoaXNUeXBlS2luZChzMiwgJ3ZhcmlhYmxlJykpIHtcblx0XHRzMi5jb25zdHJhaW50cyA9IHMyLmNvbnN0cmFpbnRzIHx8IFtdO1xuXHRcdC8vIE9wdGltaXplZCBjb25zdHJhaW50IG1lcmdpbmcgLSB1c2UgZWZmaWNpZW50IGNvbnN0cmFpbnQgY29tcGFyaXNvblxuXHRcdGZvciAoY29uc3QgYyBvZiBjb25zdHJhaW50c1RvQ2hlY2spIHtcblx0XHRcdGlmICghczIuY29uc3RyYWludHMuc29tZShleGlzdGluZyA9PiBjb25zdHJhaW50c0VxdWFsKGMsIGV4aXN0aW5nKSkpIHtcblx0XHRcdFx0czIuY29uc3RyYWludHMucHVzaChjKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gT2NjdXJzIGNoZWNrXG5cdGlmIChvY2N1cnNJbihzMS5uYW1lLCBzMikpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0Zm9ybWF0VHlwZUVycm9yKFxuXHRcdFx0XHRjcmVhdGVUeXBlRXJyb3IoXG5cdFx0XHRcdFx0YE9jY3VycyBjaGVjayBmYWlsZWQ6ICR7czEubmFtZX0gb2NjdXJzIGluICR7dHlwZVRvU3RyaW5nKFxuXHRcdFx0XHRcdFx0czIsXG5cdFx0XHRcdFx0XHRzdGF0ZS5zdWJzdGl0dXRpb25cblx0XHRcdFx0XHQpfWAsXG5cdFx0XHRcdFx0e30sXG5cdFx0XHRcdFx0bG9jYXRpb24gfHwgeyBsaW5lOiAxLCBjb2x1bW46IDEgfVxuXHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0KTtcblx0bGV0IG5ld1N0YXRlID0ge1xuXHRcdC4uLnN0YXRlLFxuXHRcdHN1YnN0aXR1dGlvbjogbWFwU2V0KHN0YXRlLnN1YnN0aXR1dGlvbiwgczEubmFtZSwgczIpLFxuXHR9O1xuXHQvLyBJZiBzMiBpcyBub3QgYSB2YXJpYWJsZSwgcHJvcGFnYXRlIG9yIGNoZWNrIGNvbnN0cmFpbnRzXG5cdGlmICghaXNUeXBlS2luZChzMiwgJ3ZhcmlhYmxlJykpIHtcblx0XHRmb3IgKGNvbnN0IGNvbnN0cmFpbnQgb2YgY29uc3RyYWludHNUb0NoZWNrKSB7XG5cdFx0XHRpZiAoY29uc3RyYWludC5raW5kID09PSAnaGFzRmllbGQnICYmIGlzVHlwZUtpbmQoczIsICdyZWNvcmQnKSkge1xuXHRcdFx0XHRuZXdTdGF0ZSA9IHVuaWZ5KFxuXHRcdFx0XHRcdHMyLmZpZWxkc1tjb25zdHJhaW50LmZpZWxkXSxcblx0XHRcdFx0XHRjb25zdHJhaW50LmZpZWxkVHlwZSxcblx0XHRcdFx0XHRuZXdTdGF0ZSxcblx0XHRcdFx0XHRsb2NhdGlvblxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIGlmIChjb25zdHJhaW50LmtpbmQgPT09ICdpcycpIHtcblx0XHRcdFx0aWYgKGlzVHlwZUtpbmQoczIsICdwcmltaXRpdmUnKSkge1xuXHRcdFx0XHRcdGlmICghc2F0aXNmaWVzQ29uc3RyYWludChzMiwgY29uc3RyYWludC5jb25zdHJhaW50KSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHRmb3JtYXRUeXBlRXJyb3IoXG5cdFx0XHRcdFx0XHRcdFx0Y3JlYXRlVHlwZUVycm9yKFxuXHRcdFx0XHRcdFx0XHRcdFx0YFR5cGUgJHt0eXBlVG9TdHJpbmcoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHMyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5zdWJzdGl0dXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdCl9IGRvZXMgbm90IHNhdGlzZnkgY29uc3RyYWludCAnJHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc3RyYWludC5jb25zdHJhaW50XG5cdFx0XHRcdFx0XHRcdFx0XHR9Jy4gVGhpcyBlcnJvciB0eXBpY2FsbHkgb2NjdXJzIHdoZW4gYXR0ZW1wdGluZyB0byB1c2UgYSBwYXJ0aWFsIGZ1bmN0aW9uIChvbmUgdGhhdCBjYW4gZmFpbCkgaW4gYW4gdW5zYWZlIGNvbnRleHQgbGlrZSBmdW5jdGlvbiBjb21wb3NpdGlvbi4gQ29uc2lkZXIgdXNpbmcgdG90YWwgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIE9wdGlvbiBvciBSZXN1bHQgdHlwZXMgaW5zdGVhZC5gLFxuXHRcdFx0XHRcdFx0XHRcdFx0e30sXG5cdFx0XHRcdFx0XHRcdFx0XHRsb2NhdGlvbiB8fCB7IGxpbmU6IDEsIGNvbHVtbjogMSB9XG5cdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBQcm9wYWdhdGUgdGhlIGNvbnN0cmFpbnQgcmVjdXJzaXZlbHkgdG8gYWxsIHR5cGUgdmFyaWFibGVzIGluc2lkZSBzMlxuXHRcdFx0XHRcdHByb3BhZ2F0ZUNvbnN0cmFpbnRUb1R5cGUoczIsIGNvbnN0cmFpbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBGb3Igb3RoZXIgY29uc3RyYWludCBraW5kcywgcHJvcGFnYXRlIHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdHByb3BhZ2F0ZUNvbnN0cmFpbnRUb1R5cGUoczIsIGNvbnN0cmFpbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gbmV3U3RhdGU7XG59XG5cbmxldCBmdW5jdGlvblVuaWZ5Q291bnQgPSAwO1xubGV0IGZ1bmN0aW9uVW5pZnlQYXR0ZXJucyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cbmZ1bmN0aW9uIHVuaWZ5RnVuY3Rpb24oXG5cdHMxOiBUeXBlLFxuXHRzMjogVHlwZSxcblx0c3RhdGU6IFR5cGVTdGF0ZSxcblx0bG9jYXRpb24/OiB7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfVxuKTogVHlwZVN0YXRlIHtcblx0aWYgKCFpc1R5cGVLaW5kKHMxLCAnZnVuY3Rpb24nKSB8fCAhaXNUeXBlS2luZChzMiwgJ2Z1bmN0aW9uJykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3VuaWZ5RnVuY3Rpb24gY2FsbGVkIHdpdGggbm9uLWZ1bmN0aW9uIHR5cGVzJyk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uVW5pZnlDb3VudCsrO1xuXHRjb25zdCBwYXR0ZXJuID0gYCR7czEucGFyYW1zLmxlbmd0aH1wXyR7czIucGFyYW1zLmxlbmd0aH1wYDtcblx0ZnVuY3Rpb25VbmlmeVBhdHRlcm5zLnNldChwYXR0ZXJuLCAoZnVuY3Rpb25VbmlmeVBhdHRlcm5zLmdldChwYXR0ZXJuKSB8fCAwKSArIDEpO1xuXHRcblx0aWYgKGZ1bmN0aW9uVW5pZnlDb3VudCAlIDEwMDAgPT09IDApIHtcblx0XHRjb25zb2xlLndhcm4oYEZ1bmN0aW9uIHVuaWZ5OiAke2Z1bmN0aW9uVW5pZnlDb3VudH0gY2FsbHMsIHRvcCBwYXR0ZXJuczpgLCBcblx0XHRcdEFycmF5LmZyb20oZnVuY3Rpb25VbmlmeVBhdHRlcm5zLmVudHJpZXMoKSkuc29ydCgoYSxiKSA9PiBiWzFdIC0gYVsxXSkuc2xpY2UoMCwzKSk7XG5cdH1cblxuXHRpZiAoczEucGFyYW1zLmxlbmd0aCAhPT0gczIucGFyYW1zLmxlbmd0aClcblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRmb3JtYXRUeXBlRXJyb3IoXG5cdFx0XHRcdGZ1bmN0aW9uQXBwbGljYXRpb25FcnJvcihcblx0XHRcdFx0XHRzMSxcblx0XHRcdFx0XHRzMixcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdHVuZGVmaW5lZCxcblx0XHRcdFx0XHRsb2NhdGlvbiB8fCB7IGxpbmU6IDEsIGNvbHVtbjogMSB9XG5cdFx0XHRcdClcblx0XHRcdClcblx0XHQpO1xuXG5cdGxldCBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblxuXHQvLyBGaXJzdCwgcHJvcGFnYXRlIGZ1bmN0aW9uLWxldmVsIGNvbnN0cmFpbnRzIHRvIHRoZSByZWxldmFudCB0eXBlIHZhcmlhYmxlc1xuXHRpZiAoczEuY29uc3RyYWludHMpIHtcblx0XHRmb3IgKGNvbnN0IGNvbnN0cmFpbnQgb2YgczEuY29uc3RyYWludHMpIHtcblx0XHRcdC8vIFByb3BhZ2F0ZSB0byBhbGwgdHlwZSB2YXJpYWJsZXMgaW4gczFcblx0XHRcdHByb3BhZ2F0ZUNvbnN0cmFpbnRUb1R5cGUoczEsIGNvbnN0cmFpbnQpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChzMi5jb25zdHJhaW50cykge1xuXHRcdGZvciAoY29uc3QgY29uc3RyYWludCBvZiBzMi5jb25zdHJhaW50cykge1xuXHRcdFx0Ly8gUHJvcGFnYXRlIHRvIGFsbCB0eXBlIHZhcmlhYmxlcyBpbiBzMlxuXHRcdFx0cHJvcGFnYXRlQ29uc3RyYWludFRvVHlwZShzMiwgY29uc3RyYWludCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gVGhlbiB1bmlmeSBwYXJhbWV0ZXJzIGFuZCByZXR1cm4gdHlwZXNcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzMS5wYXJhbXMubGVuZ3RoOyBpKyspIHtcblx0XHQvLyBTa2lwIGV4cGVuc2l2ZSBjb25zdHJhaW50IHByb3BhZ2F0aW9uIGZvciBub24tdmFyaWFibGVzXG5cdFx0Y29uc3QgczF2YXIgPSBzMS5wYXJhbXNbaV07XG5cdFx0Y29uc3QgczJ2YXIgPSBzMi5wYXJhbXNbaV07XG5cdFx0aWYgKGlzVHlwZUtpbmQoczF2YXIsICd2YXJpYWJsZScpICYmIGlzVHlwZUtpbmQoczJ2YXIsICd2YXJpYWJsZScpICYmIFxuXHRcdCAgICAoczF2YXIuY29uc3RyYWludHM/Lmxlbmd0aCB8fCBzMnZhci5jb25zdHJhaW50cz8ubGVuZ3RoKSkge1xuXHRcdFx0czF2YXIuY29uc3RyYWludHMgPSBzMXZhci5jb25zdHJhaW50cyB8fCBbXTtcblx0XHRcdHMydmFyLmNvbnN0cmFpbnRzID0gczJ2YXIuY29uc3RyYWludHMgfHwgW107XG5cdFx0XHQvLyBPcHRpbWl6ZWQgY29uc3RyYWludCBtZXJnaW5nIHVzaW5nIGVmZmljaWVudCBjb21wYXJpc29uXG5cdFx0XHQvLyBQcm9wYWdhdGUgczEgLT4gczJcblx0XHRcdGZvciAoY29uc3QgYyBvZiBzMXZhci5jb25zdHJhaW50cykge1xuXHRcdFx0XHRpZiAoIXMydmFyLmNvbnN0cmFpbnRzLnNvbWUoZXhpc3RpbmcgPT4gY29uc3RyYWludHNFcXVhbChjLCBleGlzdGluZykpKSB7XG5cdFx0XHRcdFx0czJ2YXIuY29uc3RyYWludHMucHVzaChjKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gUHJvcGFnYXRlIHMyIC0+IHMxXG5cdFx0XHRmb3IgKGNvbnN0IGMgb2YgczJ2YXIuY29uc3RyYWludHMpIHtcblx0XHRcdFx0aWYgKCFzMXZhci5jb25zdHJhaW50cy5zb21lKGV4aXN0aW5nID0+IGNvbnN0cmFpbnRzRXF1YWwoYywgZXhpc3RpbmcpKSkge1xuXHRcdFx0XHRcdHMxdmFyLmNvbnN0cmFpbnRzLnB1c2goYyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Y3VycmVudFN0YXRlID0gdW5pZnkoczEucGFyYW1zW2ldLCBzMi5wYXJhbXNbaV0sIGN1cnJlbnRTdGF0ZSwgbG9jYXRpb24pO1xuXHR9XG5cdGN1cnJlbnRTdGF0ZSA9IHVuaWZ5KHMxLnJldHVybiwgczIucmV0dXJuLCBjdXJyZW50U3RhdGUsIGxvY2F0aW9uKTtcblxuXHRyZXR1cm4gY3VycmVudFN0YXRlO1xufVxuXG5mdW5jdGlvbiB1bmlmeUxpc3QoXG5cdHMxOiBUeXBlLFxuXHRzMjogVHlwZSxcblx0c3RhdGU6IFR5cGVTdGF0ZSxcblx0bG9jYXRpb24/OiB7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfVxuKTogVHlwZVN0YXRlIHtcblx0aWYgKCFpc1R5cGVLaW5kKHMxLCAnbGlzdCcpIHx8ICFpc1R5cGVLaW5kKHMyLCAnbGlzdCcpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCd1bmlmeUxpc3QgY2FsbGVkIHdpdGggbm9uLWxpc3QgdHlwZXMnKTtcblx0fVxuXHRyZXR1cm4gdW5pZnkoczEuZWxlbWVudCwgczIuZWxlbWVudCwgc3RhdGUsIGxvY2F0aW9uKTtcbn1cblxuZnVuY3Rpb24gdW5pZnlUdXBsZShcblx0czE6IFR5cGUsXG5cdHMyOiBUeXBlLFxuXHRzdGF0ZTogVHlwZVN0YXRlLFxuXHRsb2NhdGlvbj86IHsgbGluZTogbnVtYmVyOyBjb2x1bW46IG51bWJlciB9XG4pOiBUeXBlU3RhdGUge1xuXHRpZiAoIWlzVHlwZUtpbmQoczEsICd0dXBsZScpIHx8ICFpc1R5cGVLaW5kKHMyLCAndHVwbGUnKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcigndW5pZnlUdXBsZSBjYWxsZWQgd2l0aCBub24tdHVwbGUgdHlwZXMnKTtcblx0fVxuXHRpZiAoczEuZWxlbWVudHMubGVuZ3RoICE9PSBzMi5lbGVtZW50cy5sZW5ndGgpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0Zm9ybWF0VHlwZUVycm9yKFxuXHRcdFx0XHRjcmVhdGVUeXBlRXJyb3IoXG5cdFx0XHRcdFx0YFR1cGxlIGxlbmd0aCBtaXNtYXRjaDogJHtzMS5lbGVtZW50cy5sZW5ndGh9IHZzICR7czIuZWxlbWVudHMubGVuZ3RofWAsXG5cdFx0XHRcdFx0e30sXG5cdFx0XHRcdFx0bG9jYXRpb24gfHwgeyBsaW5lOiAxLCBjb2x1bW46IDEgfVxuXHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0KTtcblx0bGV0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHMxLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y3VycmVudFN0YXRlID0gdW5pZnkoXG5cdFx0XHRzMS5lbGVtZW50c1tpXSxcblx0XHRcdHMyLmVsZW1lbnRzW2ldLFxuXHRcdFx0Y3VycmVudFN0YXRlLFxuXHRcdFx0bG9jYXRpb25cblx0XHQpO1xuXHR9XG5cdHJldHVybiBjdXJyZW50U3RhdGU7XG59XG5cbmZ1bmN0aW9uIHVuaWZ5VmFyaWFudChcblx0czE6IFR5cGUsXG5cdHMyOiBUeXBlLFxuXHRzdGF0ZTogVHlwZVN0YXRlLFxuXHRsb2NhdGlvbj86IHsgbGluZTogbnVtYmVyOyBjb2x1bW46IG51bWJlciB9XG4pOiBUeXBlU3RhdGUge1xuXHRpZiAoIWlzVHlwZUtpbmQoczEsICd2YXJpYW50JykgfHwgIWlzVHlwZUtpbmQoczIsICd2YXJpYW50JykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3VuaWZ5VmFyaWFudCBjYWxsZWQgd2l0aCBub24tdmFyaWFudCB0eXBlcycpO1xuXHR9XG5cblx0Ly8gVmFyaWFudCB0eXBlcyBtdXN0IGhhdmUgdGhlIHNhbWUgbmFtZSAoZS5nLiwgYm90aCBcIk9wdGlvblwiKVxuXHRpZiAoczEubmFtZSAhPT0gczIubmFtZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGZvcm1hdFR5cGVFcnJvcihcblx0XHRcdFx0Y3JlYXRlVHlwZUVycm9yKFxuXHRcdFx0XHRcdGBWYXJpYW50IG5hbWUgbWlzbWF0Y2g6ICR7czEubmFtZX0gdnMgJHtzMi5uYW1lfWAsXG5cdFx0XHRcdFx0e30sXG5cdFx0XHRcdFx0bG9jYXRpb24gfHwgeyBsaW5lOiAxLCBjb2x1bW46IDEgfVxuXHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0KTtcblx0fVxuXG5cdC8vIFZhcmlhbnQgdHlwZXMgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiB0eXBlIGFyZ3VtZW50c1xuXHRpZiAoczEuYXJncy5sZW5ndGggIT09IHMyLmFyZ3MubGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0Zm9ybWF0VHlwZUVycm9yKFxuXHRcdFx0XHRjcmVhdGVUeXBlRXJyb3IoXG5cdFx0XHRcdFx0YFZhcmlhbnQgYXJpdHkgbWlzbWF0Y2g6ICR7czEubmFtZX0gaGFzICR7czEuYXJncy5sZW5ndGh9IHZzICR7czIuYXJncy5sZW5ndGh9IHR5cGUgYXJndW1lbnRzYCxcblx0XHRcdFx0XHR7fSxcblx0XHRcdFx0XHRsb2NhdGlvbiB8fCB7IGxpbmU6IDEsIGNvbHVtbjogMSB9XG5cdFx0XHRcdClcblx0XHRcdClcblx0XHQpO1xuXHR9XG5cblx0Ly8gVW5pZnkgY29ycmVzcG9uZGluZyB0eXBlIGFyZ3VtZW50c1xuXHRsZXQgY3VycmVudFN0YXRlID0gc3RhdGU7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgczEuYXJncy5sZW5ndGg7IGkrKykge1xuXHRcdGN1cnJlbnRTdGF0ZSA9IHVuaWZ5KHMxLmFyZ3NbaV0sIHMyLmFyZ3NbaV0sIGN1cnJlbnRTdGF0ZSwgbG9jYXRpb24pO1xuXHR9XG5cdHJldHVybiBjdXJyZW50U3RhdGU7XG59XG5cbmZ1bmN0aW9uIHVuaWZ5UmVjb3JkKFxuXHRzMTogVHlwZSxcblx0czI6IFR5cGUsXG5cdHN0YXRlOiBUeXBlU3RhdGUsXG5cdGxvY2F0aW9uPzogeyBsaW5lOiBudW1iZXI7IGNvbHVtbjogbnVtYmVyIH1cbik6IFR5cGVTdGF0ZSB7XG5cdGlmICghaXNUeXBlS2luZChzMSwgJ3JlY29yZCcpIHx8ICFpc1R5cGVLaW5kKHMyLCAncmVjb3JkJykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3VuaWZ5UmVjb3JkIGNhbGxlZCB3aXRoIG5vbi1yZWNvcmQgdHlwZXMnKTtcblx0fVxuXHRjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKHMxLmZpZWxkcyk7XG5cdGxldCBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblx0Zm9yIChjb25zdCBrZXkgb2Yga2V5czEpIHtcblx0XHRpZiAoIShrZXkgaW4gczIuZmllbGRzKSlcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0Zm9ybWF0VHlwZUVycm9yKFxuXHRcdFx0XHRcdGNyZWF0ZVR5cGVFcnJvcihcblx0XHRcdFx0XHRcdGBSZXF1aXJlZCBmaWVsZCBtaXNzaW5nOiAke2tleX1gLFxuXHRcdFx0XHRcdFx0e30sXG5cdFx0XHRcdFx0XHRsb2NhdGlvbiB8fCB7IGxpbmU6IDEsIGNvbHVtbjogMSB9XG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpXG5cdFx0XHQpO1xuXHRcdGN1cnJlbnRTdGF0ZSA9IHVuaWZ5KFxuXHRcdFx0czEuZmllbGRzW2tleV0sXG5cdFx0XHRzMi5maWVsZHNba2V5XSxcblx0XHRcdGN1cnJlbnRTdGF0ZSxcblx0XHRcdGxvY2F0aW9uXG5cdFx0KTtcblx0fVxuXHRyZXR1cm4gY3VycmVudFN0YXRlO1xufVxuIl0sIm5hbWVzIjpbInVuaWZ5IiwidW5pZnlDYWxsQ291bnQiLCJ0b3RhbFVuaWZ5VGltZSIsInNsb3dVbmlmeUNhbGxzIiwidW5pZnlDYWxsU291cmNlcyIsIk1hcCIsInVuaWZ5VHlwZVBhdHRlcm5zIiwidHlwZVRvUGF0dGVybiIsInQiLCJraW5kIiwibmFtZSIsInBhcmFtcyIsImxlbmd0aCIsIk9iamVjdCIsImtleXMiLCJmaWVsZHMiLCJlbGVtZW50cyIsImFyZ3MiLCJ1bmlmeUNhY2hlIiwidW5pZnlJbnRlcm5hbCIsInQxIiwidDIiLCJzdGF0ZSIsImxvY2F0aW9uIiwiY29udGV4dCIsInMxIiwic3Vic3RpdHV0ZSIsInN1YnN0aXR1dGlvbiIsInMyIiwidHlwZXNFcXVhbCIsImlzVHlwZUtpbmQiLCJ1bmlmeVZhcmlhYmxlIiwidW5pZnlGdW5jdGlvbiIsInVuaWZ5TGlzdCIsInVuaWZ5VHVwbGUiLCJ1bmlmeVJlY29yZCIsInVuaWZ5VW5pb24iLCJ1bmlmeVByaW1pdGl2ZSIsInVuaWZ5VW5pdCIsInVuaWZ5VmFyaWFudCIsImRlYnVnQ29udGV4dCIsInJlYXNvbiIsImhpbnQiLCJKU09OIiwic3RyaW5naWZ5IiwiRXJyb3IiLCJmb3JtYXRUeXBlRXJyb3IiLCJ1bmlmaWNhdGlvbkVycm9yIiwibGluZSIsImNvbHVtbiIsInN0YXJ0IiwiRGF0ZSIsIm5vdyIsInN0YWNrIiwiY2FsbGVyIiwic3BsaXQiLCJzb3VyY2UiLCJpbmNsdWRlcyIsInNldCIsImdldCIsInBhdHRlcm4iLCJyZXN1bHQiLCJ0aW1lIiwicHVzaCIsInR5cGUxIiwidHlwZTIiLCJjb25zb2xlIiwid2FybiIsInRvcFNvdXJjZXMiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwic29ydCIsImEiLCJiIiwic2xpY2UiLCJ0b3BQYXR0ZXJucyIsInR5cGVzIiwiY3JlYXRlVHlwZUVycm9yIiwiY3VycmVudFN0YXRlIiwiaSIsIm9wZXJhdG9yVHlwZUVycm9yIiwiY29uc3RyYWludHNUb0NoZWNrIiwic2VlblZhcnMiLCJTZXQiLCJjdXJyZW50VmFyIiwiaGFzIiwiYWRkIiwiY29uc3RyYWludHMiLCJmb3JFYWNoIiwiYyIsIm5leHQiLCJzb21lIiwiZXhpc3RpbmciLCJjb25zdHJhaW50c0VxdWFsIiwib2NjdXJzSW4iLCJ0eXBlVG9TdHJpbmciLCJuZXdTdGF0ZSIsIm1hcFNldCIsImNvbnN0cmFpbnQiLCJmaWVsZCIsImZpZWxkVHlwZSIsInNhdGlzZmllc0NvbnN0cmFpbnQiLCJwcm9wYWdhdGVDb25zdHJhaW50VG9UeXBlIiwiZnVuY3Rpb25VbmlmeUNvdW50IiwiZnVuY3Rpb25VbmlmeVBhdHRlcm5zIiwiZnVuY3Rpb25BcHBsaWNhdGlvbkVycm9yIiwidW5kZWZpbmVkIiwiczF2YXIiLCJzMnZhciIsInJldHVybiIsImVsZW1lbnQiLCJrZXlzMSIsImtleSJdLCJtYXBwaW5ncyI6Ijs7OzsrQkE4SGFBOzs7ZUFBQUE7Ozs0QkE3SGM7eUJBRThCOzRCQU1sRDs2QkFHd0Q7QUFHL0QsdUJBQXVCO0FBQ3ZCLElBQUlDLGlCQUFpQjtBQUNyQixJQUFJQyxpQkFBaUI7QUFDckIsSUFBSUMsaUJBQXNFLEVBQUU7QUFDNUUsSUFBSUMsbUJBQW1CLElBQUlDLE9BQXVCLG9DQUFvQztBQUN0RixJQUFJQyxvQkFBb0IsSUFBSUQsT0FBdUIscUNB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