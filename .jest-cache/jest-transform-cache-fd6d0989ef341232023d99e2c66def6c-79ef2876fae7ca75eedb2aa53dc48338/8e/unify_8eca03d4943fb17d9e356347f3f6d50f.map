{"version":3,"sources":["/workspace/src/typer/unify.ts"],"sourcesContent":["import { Type } from '../ast';\nimport { substitute } from './substitute';\nimport { TypeState } from './types';\nimport { isTypeKind, typesEqual, constraintsEqual } from './helpers';\nimport {\n\tformatTypeError,\n\tcreateTypeError,\n\toperatorTypeError,\n\tunificationError,\n} from './type-errors';\nimport { Constraint } from '../ast';\nimport { mapSet, typeToString, occursIn } from './helpers';\nimport { satisfiesConstraint, propagateConstraintToType } from './constraints';\nimport { functionApplicationError } from './type-errors';\n\n// Performance tracking\nlet unifyCallCount = 0;\nlet totalUnifyTime = 0;\nlet slowUnifyCalls: Array<{type1: string, type2: string, time: number}> = [];\nlet unifyCallSources = new Map<string, number>(); // Track where unify calls come from\nlet unifyTypePatterns = new Map<string, number>(); // Track what types are being unified\n\nconst typeToPattern = (t: Type): string => {\n\tswitch (t.kind) {\n\t\tcase 'variable': return `var:${t.name}`;\n\t\tcase 'primitive': return `prim:${t.name}`;\n\t\tcase 'function': return `fn:${t.params.length}p`;\n\t\tcase 'list': return `list`;\n\t\tcase 'record': return `rec:${Object.keys(t.fields).length}f`;\n\t\tcase 'tuple': return `tup:${t.elements.length}e`;\n\t\tcase 'variant': return `var:${t.name}:${t.args.length}a`;\n\t\tdefault: return t.kind;\n\t}\n};\n\n// Cache for unification results to avoid repeated work\nconst unifyCache = new Map<string, TypeState>();\n\nconst unifyInternal = (\n\tt1: Type,\n\tt2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n\tcontext?: {\n\t\treason?: string;\n\t\toperation?: string;\n\t\thint?: string;\n\t}\n): TypeState => {\n\t// Early equality check before substitution for performance\n\tif (t1 === t2) return state;\n\n\tconst s1 = substitute(t1, state.substitution);\n\tconst s2 = substitute(t2, state.substitution);\n\n\tif (typesEqual(s1, s2)) return state;\n\n\t// Handle variables (either order)\n\tif (isTypeKind(s1, 'variable')) return unifyVariable(s1, s2, state, location);\n\tif (isTypeKind(s2, 'variable')) return unifyVariable(s2, s1, state, location);\n\n\t// Handle function types\n\tif (isTypeKind(s1, 'function') && isTypeKind(s2, 'function')) {\n\t\treturn unifyFunction(s1, s2, state, location);\n\t}\n\n\t// Handle list types\n\tif (isTypeKind(s1, 'list') && isTypeKind(s2, 'list')) {\n\t\treturn unifyList(s1, s2, state, location);\n\t}\n\n\t// Handle tuple types\n\tif (isTypeKind(s1, 'tuple') && isTypeKind(s2, 'tuple')) {\n\t\treturn unifyTuple(s1, s2, state, location);\n\t}\n\n\t// Handle record types\n\tif (isTypeKind(s1, 'record') && isTypeKind(s2, 'record')) {\n\t\treturn unifyRecord(s1, s2, state, location);\n\t}\n\n\t// Handle union types\n\tif (isTypeKind(s1, 'union') && isTypeKind(s2, 'union')) {\n\t\treturn unifyUnion(s1, s2, state, location);\n\t}\n\n\t// Handle primitive types\n\tif (isTypeKind(s1, 'primitive') && isTypeKind(s2, 'primitive')) {\n\t\treturn unifyPrimitive(s1, s2, state, location);\n\t}\n\n\t// Handle unit types\n\tif (isTypeKind(s1, 'unit') && isTypeKind(s2, 'unit')) {\n\t\treturn unifyUnit(s1, s2, state, location);\n\t}\n\n\t// Handle variant types (ADTs like Option, Result, etc.)\n\tif (isTypeKind(s1, 'variant') && isTypeKind(s2, 'variant')) {\n\t\treturn unifyVariant(s1, s2, state, location);\n\t}\n\n\t// If we get here, the types cannot be unified\n\t// Add debug info for difficult cases\n\tconst debugContext = context || {};\n\tif (\n\t\ts1.kind === s2.kind &&\n\t\ts1.kind === 'primitive' &&\n\t\t(s1 as any).name === (s2 as any).name\n\t) {\n\t\tdebugContext.reason = 'concrete_vs_variable';\n\t\tdebugContext.hint = `Both types appear to be ${\n\t\t\t(s1 as any).name\n\t\t} but they are not unifying. This suggests the type equality check is failing. Type 1: ${JSON.stringify(\n\t\t\ts1\n\t\t)}, Type 2: ${JSON.stringify(\n\t\t\ts2\n\t\t)}. Check if there are extra properties or constraints causing inequality.`;\n\t}\n\n\tthrow new Error(\n\t\tformatTypeError(\n\t\t\tunificationError(s1, s2, debugContext, location || { line: 1, column: 1 })\n\t\t)\n\t);\n};\n\nexport const unify = (\n\tt1: Type,\n\tt2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n\tcontext?: {\n\t\treason?: string;\n\t\toperation?: string;\n\t\thint?: string;\n\t}\n): TypeState => {\n\tconst start = Date.now();\n\tunifyCallCount++;\n\t\n\t// Track call sources using stack trace\n\tconst stack = new Error().stack || '';\n\tconst caller = stack.split('\\n')[2] || 'unknown';\n\tconst source = caller.includes('at ') ? caller.split('at ')[1].split(' ')[0] : 'unknown';\n\tunifyCallSources.set(source, (unifyCallSources.get(source) || 0) + 1);\n\t\n\t// Track type patterns being unified\n\tconst pattern = `${typeToPattern(t1)} = ${typeToPattern(t2)}`;\n\tunifyTypePatterns.set(pattern, (unifyTypePatterns.get(pattern) || 0) + 1);\n\t\n\tconst result = unifyInternal(t1, t2, state, location, context);\n\t\n\tconst time = Date.now() - start;\n\ttotalUnifyTime += time;\n\t\n\tif (time > 10) {\n\t\tslowUnifyCalls.push({\n\t\t\ttype1: `${t1.kind}:${t1.kind === 'variable' ? t1.name : '?'}`,\n\t\t\ttype2: `${t2.kind}:${t2.kind === 'variable' ? t2.name : '?'}`,\n\t\t\ttime\n\t\t});\n\t}\n\t\n\tif (unifyCallCount % 5000 === 0) {\n\t\tconsole.warn(`Unify: ${unifyCallCount} calls, ${totalUnifyTime}ms total, ${slowUnifyCalls.length} slow calls`);\n\t\t\n\t\t// Show top call sources\n\t\tconst topSources = Array.from(unifyCallSources.entries())\n\t\t\t.sort((a, b) => b[1] - a[1])\n\t\t\t.slice(0, 5);\n\t\tconsole.warn('Top unify call sources:', topSources);\n\t\t\n\t\t// Show most repeated type patterns\n\t\tconst topPatterns = Array.from(unifyTypePatterns.entries())\n\t\t\t.sort((a, b) => b[1] - a[1])\n\t\t\t.slice(0, 5);\n\t\tconsole.warn('Most repeated unifications:', topPatterns);\n\t}\n\t\n\treturn result;\n};\n\nfunction unifyUnion(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'union') || !isTypeKind(s2, 'union')) {\n\t\tthrow new Error('unifyUnion called with non-union types');\n\t}\n\t// For now, require exact match of union types\n\tif (s1.types.length !== s2.types.length)\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tcreateTypeError(\n\t\t\t\t\t`Union type mismatch: ${s1.types.length} vs ${s2.types.length} types`,\n\t\t\t\t\t{},\n\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\tlet currentState = state;\n\tfor (let i = 0; i < s1.types.length; i++) {\n\t\tcurrentState = unify(s1.types[i], s2.types[i], currentState, location);\n\t}\n\treturn currentState;\n}\n\nfunction unifyPrimitive(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'primitive') || !isTypeKind(s2, 'primitive')) {\n\t\tthrow new Error('unifyPrimitive called with non-primitive types');\n\t}\n\tif (s1.name !== s2.name)\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\toperatorTypeError('', s1, s2, location || { line: 1, column: 1 })\n\t\t\t)\n\t\t);\n\treturn state;\n}\n\nfunction unifyUnit(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'unit') || !isTypeKind(s2, 'unit')) {\n\t\tthrow new Error('unifyUnit called with non-unit types');\n\t}\n\treturn state;\n}\n\n// --- Unification helpers ---\nfunction unifyVariable(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'variable')) {\n\t\tthrow new Error('unifyVariable called with non-variable s1');\n\t}\n\t// Optimized constraint collection - avoid array spreading\n\tlet constraintsToCheck: Constraint[] = [];\n\tlet seenVars = new Set<string>();\n\tlet currentVar: Type = s1;\n\twhile (isTypeKind(currentVar, 'variable')) {\n\t\tif (seenVars.has(currentVar.name)) break;\n\t\tseenVars.add(currentVar.name);\n\t\tif (currentVar.constraints) {\n\t\t\t// Use forEach instead of spread for better performance\n\t\t\tcurrentVar.constraints.forEach(c => constraintsToCheck.push(c));\n\t\t}\n\t\tconst next = state.substitution.get(currentVar.name);\n\t\tif (!next) break;\n\t\tcurrentVar = next;\n\t}\n\t// If s2 is a variable, merge all constraints into it\n\tif (isTypeKind(s2, 'variable')) {\n\t\ts2.constraints = s2.constraints || [];\n\t\t// Optimized constraint merging - use efficient constraint comparison\n\t\tfor (const c of constraintsToCheck) {\n\t\t\tif (!s2.constraints.some(existing => constraintsEqual(c, existing))) {\n\t\t\t\ts2.constraints.push(c);\n\t\t\t}\n\t\t}\n\t}\n\t// Occurs check\n\tif (occursIn(s1.name, s2))\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tcreateTypeError(\n\t\t\t\t\t`Occurs check failed: ${s1.name} occurs in ${typeToString(\n\t\t\t\t\t\ts2,\n\t\t\t\t\t\tstate.substitution\n\t\t\t\t\t)}`,\n\t\t\t\t\t{},\n\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\tlet newState = {\n\t\t...state,\n\t\tsubstitution: mapSet(state.substitution, s1.name, s2),\n\t};\n\t// If s2 is not a variable, propagate or check constraints\n\tif (!isTypeKind(s2, 'variable')) {\n\t\tfor (const constraint of constraintsToCheck) {\n\t\t\tif (constraint.kind === 'hasField' && isTypeKind(s2, 'record')) {\n\t\t\t\tnewState = unify(\n\t\t\t\t\ts2.fields[constraint.field],\n\t\t\t\t\tconstraint.fieldType,\n\t\t\t\t\tnewState,\n\t\t\t\t\tlocation\n\t\t\t\t);\n\t\t\t} else if (constraint.kind === 'is') {\n\t\t\t\tif (isTypeKind(s2, 'primitive')) {\n\t\t\t\t\tif (!satisfiesConstraint(s2, constraint.constraint)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\tformatTypeError(\n\t\t\t\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t\t\t\t`Type ${typeToString(\n\t\t\t\t\t\t\t\t\t\ts2,\n\t\t\t\t\t\t\t\t\t\tstate.substitution\n\t\t\t\t\t\t\t\t\t)} does not satisfy constraint '${\n\t\t\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t\t\t}'. This error typically occurs when attempting to use a partial function (one that can fail) in an unsafe context like function composition. Consider using total functions that return Option or Result types instead.`,\n\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Propagate the constraint recursively to all type variables inside s2\n\t\t\t\t\tpropagateConstraintToType(s2, constraint);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For other constraint kinds, propagate recursively\n\t\t\t\tpropagateConstraintToType(s2, constraint);\n\t\t\t}\n\t\t}\n\t}\n\treturn newState;\n}\n\nlet functionUnifyCount = 0;\nlet functionUnifyPatterns = new Map<string, number>();\n\nfunction unifyFunction(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'function') || !isTypeKind(s2, 'function')) {\n\t\tthrow new Error('unifyFunction called with non-function types');\n\t}\n\t\n\tfunctionUnifyCount++;\n\tconst pattern = `${s1.params.length}p_${s2.params.length}p`;\n\tfunctionUnifyPatterns.set(pattern, (functionUnifyPatterns.get(pattern) || 0) + 1);\n\t\n\tif (functionUnifyCount % 1000 === 0) {\n\t\tconsole.warn(`Function unify: ${functionUnifyCount} calls, top patterns:`, \n\t\t\tArray.from(functionUnifyPatterns.entries()).sort((a,b) => b[1] - a[1]).slice(0,3));\n\t}\n\n\tif (s1.params.length !== s2.params.length)\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tfunctionApplicationError(\n\t\t\t\t\ts1,\n\t\t\t\t\ts2,\n\t\t\t\t\t0,\n\t\t\t\t\tundefined,\n\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\tlet currentState = state;\n\n\t// First, propagate function-level constraints to the relevant type variables\n\tif (s1.constraints) {\n\t\tfor (const constraint of s1.constraints) {\n\t\t\t// Propagate to all type variables in s1\n\t\t\tpropagateConstraintToType(s1, constraint);\n\t\t}\n\t}\n\n\tif (s2.constraints) {\n\t\tfor (const constraint of s2.constraints) {\n\t\t\t// Propagate to all type variables in s2\n\t\t\tpropagateConstraintToType(s2, constraint);\n\t\t}\n\t}\n\n\t// Then unify parameters and return types\n\tfor (let i = 0; i < s1.params.length; i++) {\n\t\t// Skip expensive constraint propagation for non-variables\n\t\tconst s1var = s1.params[i];\n\t\tconst s2var = s2.params[i];\n\t\tif (isTypeKind(s1var, 'variable') && isTypeKind(s2var, 'variable') && \n\t\t    (s1var.constraints?.length || s2var.constraints?.length)) {\n\t\t\ts1var.constraints = s1var.constraints || [];\n\t\t\ts2var.constraints = s2var.constraints || [];\n\t\t\t// Optimized constraint merging using efficient comparison\n\t\t\t// Propagate s1 -> s2\n\t\t\tfor (const c of s1var.constraints) {\n\t\t\t\tif (!s2var.constraints.some(existing => constraintsEqual(c, existing))) {\n\t\t\t\t\ts2var.constraints.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Propagate s2 -> s1\n\t\t\tfor (const c of s2var.constraints) {\n\t\t\t\tif (!s1var.constraints.some(existing => constraintsEqual(c, existing))) {\n\t\t\t\t\ts1var.constraints.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcurrentState = unify(s1.params[i], s2.params[i], currentState, location);\n\t}\n\tcurrentState = unify(s1.return, s2.return, currentState, location);\n\n\treturn currentState;\n}\n\nfunction unifyList(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'list') || !isTypeKind(s2, 'list')) {\n\t\tthrow new Error('unifyList called with non-list types');\n\t}\n\treturn unify(s1.element, s2.element, state, location);\n}\n\nfunction unifyTuple(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'tuple') || !isTypeKind(s2, 'tuple')) {\n\t\tthrow new Error('unifyTuple called with non-tuple types');\n\t}\n\tif (s1.elements.length !== s2.elements.length)\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tcreateTypeError(\n\t\t\t\t\t`Tuple length mismatch: ${s1.elements.length} vs ${s2.elements.length}`,\n\t\t\t\t\t{},\n\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\tlet currentState = state;\n\tfor (let i = 0; i < s1.elements.length; i++) {\n\t\tcurrentState = unify(\n\t\t\ts1.elements[i],\n\t\t\ts2.elements[i],\n\t\t\tcurrentState,\n\t\t\tlocation\n\t\t);\n\t}\n\treturn currentState;\n}\n\nfunction unifyVariant(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'variant') || !isTypeKind(s2, 'variant')) {\n\t\tthrow new Error('unifyVariant called with non-variant types');\n\t}\n\n\t// Variant types must have the same name (e.g., both \"Option\")\n\tif (s1.name !== s2.name) {\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tcreateTypeError(\n\t\t\t\t\t`Variant name mismatch: ${s1.name} vs ${s2.name}`,\n\t\t\t\t\t{},\n\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n\t// Variant types must have the same number of type arguments\n\tif (s1.args.length !== s2.args.length) {\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tcreateTypeError(\n\t\t\t\t\t`Variant arity mismatch: ${s1.name} has ${s1.args.length} vs ${s2.args.length} type arguments`,\n\t\t\t\t\t{},\n\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n\t// Unify corresponding type arguments\n\tlet currentState = state;\n\tfor (let i = 0; i < s1.args.length; i++) {\n\t\tcurrentState = unify(s1.args[i], s2.args[i], currentState, location);\n\t}\n\treturn currentState;\n}\n\nfunction unifyRecord(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'record') || !isTypeKind(s2, 'record')) {\n\t\tthrow new Error('unifyRecord called with non-record types');\n\t}\n\tconst keys1 = Object.keys(s1.fields);\n\tlet currentState = state;\n\tfor (const key of keys1) {\n\t\tif (!(key in s2.fields))\n\t\t\tthrow new Error(\n\t\t\t\tformatTypeError(\n\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t`Required field missing: ${key}`,\n\t\t\t\t\t\t{},\n\t\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\tcurrentState = unify(\n\t\t\ts1.fields[key],\n\t\t\ts2.fields[key],\n\t\t\tcurrentState,\n\t\t\tlocation\n\t\t);\n\t}\n\treturn currentState;\n}\n"],"names":["unify","unifyCallCount","totalUnifyTime","slowUnifyCalls","unifyCallSources","Map","unifyTypePatterns","typeToPattern","t","kind","name","params","length","Object","keys","fields","elements","args","unifyCache","unifyInternal","t1","t2","state","location","context","s1","substitute","substitution","s2","typesEqual","isTypeKind","unifyVariable","unifyFunction","unifyList","unifyTuple","unifyRecord","unifyUnion","unifyPrimitive","unifyUnit","unifyVariant","debugContext","reason","hint","JSON","stringify","Error","formatTypeError","unificationError","line","column","start","Date","now","stack","caller","split","source","includes","set","get","pattern","result","time","push","type1","type2","console","warn","topSources","Array","from","entries","sort","a","b","slice","topPatterns","types","createTypeError","currentState","i","operatorTypeError","constraintsToCheck","seenVars","Set","currentVar","has","add","constraints","forEach","c","next","some","existing","constraintsEqual","occursIn","typeToString","newState","mapSet","constraint","field","fieldType","satisfiesConstraint","propagateConstraintToType","functionUnifyCount","functionUnifyPatterns","functionApplicationError","undefined","s1var","s2var","return","element","keys1","key"],"mappings":";;;;+BA8HaA;;;eAAAA;;;4BA7Hc;yBAE8B;4BAMlD;6BAGwD;AAG/D,uBAAuB;AACvB,IAAIC,iBAAiB;AACrB,IAAIC,iBAAiB;AACrB,IAAIC,iBAAsE,EAAE;AAC5E,IAAIC,mBAAmB,IAAIC,OAAuB,oCAAoC;AACtF,IAAIC,oBAAoB,IAAID,OAAuB,qCAAqC;AAExF,MAAME,gBAAgB,CAACC;IACtB,OAAQA,EAAEC,IAAI;QACb,KAAK;YAAY,OAAO,CAAC,IAAI,EAAED,EAAEE,IAAI,EAAE;QACvC,KAAK;YAAa,OAAO,CAAC,KAAK,EAAEF,EAAEE,IAAI,EAAE;QACzC,KAAK;YAAY,OAAO,CAAC,GAAG,EAAEF,EAAEG,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC;QAChD,KAAK;YAAQ,OAAO,CAAC,IAAI,CAAC;QAC1B,KAAK;YAAU,OAAO,CAAC,IAAI,EAAEC,OAAOC,IAAI,CAACN,EAAEO,MAAM,EAAEH,MAAM,CAAC,CAAC,CAAC;QAC5D,KAAK;YAAS,OAAO,CAAC,IAAI,EAAEJ,EAAEQ,QAAQ,CAACJ,MAAM,CAAC,CAAC,CAAC;QAChD,KAAK;YAAW,OAAO,CAAC,IAAI,EAAEJ,EAAEE,IAAI,CAAC,CAAC,EAAEF,EAAES,IAAI,CAACL,MAAM,CAAC,CAAC,CAAC;QACxD;YAAS,OAAOJ,EAAEC,IAAI;IACvB;AACD;AAEA,uDAAuD;AACvD,MAAMS,aAAa,IAAIb;AAEvB,MAAMc,gBAAgB,CACrBC,IACAC,IACAC,OACAC,UACAC;IAMA,2DAA2D;IAC3D,IAAIJ,OAAOC,IAAI,OAAOC;IAEtB,MAAMG,KAAKC,IAAAA,sBAAU,EAACN,IAAIE,MAAMK,YAAY;IAC5C,MAAMC,KAAKF,IAAAA,sBAAU,EAACL,IAAIC,MAAMK,YAAY;IAE5C,IAAIE,IAAAA,mBAAU,EAACJ,IAAIG,KAAK,OAAON;IAE/B,kCAAkC;IAClC,IAAIQ,IAAAA,mBAAU,EAACL,IAAI,aAAa,OAAOM,cAAcN,IAAIG,IAAIN,OAAOC;IACpE,IAAIO,IAAAA,mBAAU,EAACF,IAAI,aAAa,OAAOG,cAAcH,IAAIH,IAAIH,OAAOC;IAEpE,wBAAwB;IACxB,IAAIO,IAAAA,mBAAU,EAACL,IAAI,eAAeK,IAAAA,mBAAU,EAACF,IAAI,aAAa;QAC7D,OAAOI,cAAcP,IAAIG,IAAIN,OAAOC;IACrC;IAEA,oBAAoB;IACpB,IAAIO,IAAAA,mBAAU,EAACL,IAAI,WAAWK,IAAAA,mBAAU,EAACF,IAAI,SAAS;QACrD,OAAOK,UAAUR,IAAIG,IAAIN,OAAOC;IACjC;IAEA,qBAAqB;IACrB,IAAIO,IAAAA,mBAAU,EAACL,IAAI,YAAYK,IAAAA,mBAAU,EAACF,IAAI,UAAU;QACvD,OAAOM,WAAWT,IAAIG,IAAIN,OAAOC;IAClC;IAEA,sBAAsB;IACtB,IAAIO,IAAAA,mBAAU,EAACL,IAAI,aAAaK,IAAAA,mBAAU,EAACF,IAAI,WAAW;QACzD,OAAOO,YAAYV,IAAIG,IAAIN,OAAOC;IACnC;IAEA,qBAAqB;IACrB,IAAIO,IAAAA,mBAAU,EAACL,IAAI,YAAYK,IAAAA,mBAAU,EAACF,IAAI,UAAU;QACvD,OAAOQ,WAAWX,IAAIG,IAAIN,OAAOC;IAClC;IAEA,yBAAyB;IACzB,IAAIO,IAAAA,mBAAU,EAACL,IAAI,gBAAgBK,IAAAA,mBAAU,EAACF,IAAI,cAAc;QAC/D,OAAOS,eAAeZ,IAAIG,IAAIN,OAAOC;IACtC;IAEA,oBAAoB;IACpB,IAAIO,IAAAA,mBAAU,EAACL,IAAI,WAAWK,IAAAA,mBAAU,EAACF,IAAI,SAAS;QACrD,OAAOU,UAAUb,IAAIG,IAAIN,OAAOC;IACjC;IAEA,wDAAwD;IACxD,IAAIO,IAAAA,mBAAU,EAACL,IAAI,cAAcK,IAAAA,mBAAU,EAACF,IAAI,YAAY;QAC3D,OAAOW,aAAad,IAAIG,IAAIN,OAAOC;IACpC;IAEA,8CAA8C;IAC9C,qCAAqC;IACrC,MAAMiB,eAAehB,WAAW,CAAC;IACjC,IACCC,GAAGhB,IAAI,KAAKmB,GAAGnB,IAAI,IACnBgB,GAAGhB,IAAI,KAAK,eACZ,AAACgB,GAAWf,IAAI,KAAK,AAACkB,GAAWlB,IAAI,EACpC;QACD8B,aAAaC,MAAM,GAAG;QACtBD,aAAaE,IAAI,GAAG,CAAC,wBAAwB,EAC5C,AAACjB,GAAWf,IAAI,CAChB,sFAAsF,EAAEiC,KAAKC,SAAS,CACtGnB,IACC,UAAU,EAAEkB,KAAKC,SAAS,CAC3BhB,IACC,wEAAwE,CAAC;IAC5E;IAEA,MAAM,IAAIiB,MACTC,IAAAA,2BAAe,EACdC,IAAAA,4BAAgB,EAACtB,IAAIG,IAAIY,cAAcjB,YAAY;QAAEyB,MAAM;QAAGC,QAAQ;IAAE;AAG3E;AAEO,MAAMjD,QAAQ,CACpBoB,IACAC,IACAC,OACAC,UACAC;IAMA,MAAM0B,QAAQC,KAAKC,GAAG;IACtBnD;IAEA,uCAAuC;IACvC,MAAMoD,QAAQ,IAAIR,QAAQQ,KAAK,IAAI;IACnC,MAAMC,SAASD,MAAME,KAAK,CAAC,KAAK,CAAC,EAAE,IAAI;IACvC,MAAMC,SAASF,OAAOG,QAAQ,CAAC,SAASH,OAAOC,KAAK,CAAC,MAAM,CAAC,EAAE,CAACA,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG;IAC/EnD,iBAAiBsD,GAAG,CAACF,QAAQ,AAACpD,CAAAA,iBAAiBuD,GAAG,CAACH,WAAW,CAAA,IAAK;IAEnE,oCAAoC;IACpC,MAAMI,UAAU,GAAGrD,cAAca,IAAI,GAAG,EAAEb,cAAcc,KAAK;IAC7Df,kBAAkBoD,GAAG,CAACE,SAAS,AAACtD,CAAAA,kBAAkBqD,GAAG,CAACC,YAAY,CAAA,IAAK;IAEvE,MAAMC,SAAS1C,cAAcC,IAAIC,IAAIC,OAAOC,UAAUC;IAEtD,MAAMsC,OAAOX,KAAKC,GAAG,KAAKF;IAC1BhD,kBAAkB4D;IAElB,IAAIA,OAAO,IAAI;QACd3D,eAAe4D,IAAI,CAAC;YACnBC,OAAO,GAAG5C,GAAGX,IAAI,CAAC,CAAC,EAAEW,GAAGX,IAAI,KAAK,aAAaW,GAAGV,IAAI,GAAG,KAAK;YAC7DuD,OAAO,GAAG5C,GAAGZ,IAAI,CAAC,CAAC,EAAEY,GAAGZ,IAAI,KAAK,aAAaY,GAAGX,IAAI,GAAG,KAAK;YAC7DoD;QACD;IACD;IAEA,IAAI7D,iBAAiB,SAAS,GAAG;QAChCiE,QAAQC,IAAI,CAAC,CAAC,OAAO,EAAElE,eAAe,QAAQ,EAAEC,eAAe,UAAU,EAAEC,eAAeS,MAAM,CAAC,WAAW,CAAC;QAE7G,wBAAwB;QACxB,MAAMwD,aAAaC,MAAMC,IAAI,CAAClE,iBAAiBmE,OAAO,IACpDC,IAAI,CAAC,CAACC,GAAGC,IAAMA,CAAC,CAAC,EAAE,GAAGD,CAAC,CAAC,EAAE,EAC1BE,KAAK,CAAC,GAAG;QACXT,QAAQC,IAAI,CAAC,2BAA2BC;QAExC,mCAAmC;QACnC,MAAMQ,cAAcP,MAAMC,IAAI,CAAChE,kBAAkBiE,OAAO,IACtDC,IAAI,CAAC,CAACC,GAAGC,IAAMA,CAAC,CAAC,EAAE,GAAGD,CAAC,CAAC,EAAE,EAC1BE,KAAK,CAAC,GAAG;QACXT,QAAQC,IAAI,CAAC,+BAA+BS;IAC7C;IAEA,OAAOf;AACR;AAEA,SAASzB,WACRX,EAAQ,EACRG,EAAQ,EACRN,KAAgB,EAChBC,QAA2C;IAE3C,IAAI,CAACO,IAAAA,mBAAU,EAACL,IAAI,YAAY,CAACK,IAAAA,mBAAU,EAACF,IAAI,UAAU;QACzD,MAAM,IAAIiB,MAAM;IACjB;IACA,8CAA8C;IAC9C,IAAIpB,GAAGoD,KAAK,CAACjE,MAAM,KAAKgB,GAAGiD,KAAK,CAACjE,MAAM,EACtC,MAAM,IAAIiC,MACTC,IAAAA,2BAAe,EACdgC,IAAAA,2BAAe,EACd,CAAC,qBAAqB,EAAErD,GAAGoD,KAAK,CAACjE,MAAM,CAAC,IAAI,EAAEgB,GAAGiD,KAAK,CAACjE,MAAM,CAAC,MAAM,CAAC,EACrE,CAAC,GACDW,YAAY;QAAEyB,MAAM;QAAGC,QAAQ;IAAE;IAIrC,IAAI8B,eAAezD;IACnB,IAAK,IAAI0D,IAAI,GAAGA,IAAIvD,GAAGoD,KAAK,CAACjE,MAAM,EAAEoE,IAAK;QACzCD,eAAe/E,MAAMyB,GAAGoD,KAAK,CAACG,EAAE,EAAEpD,GAAGiD,KAAK,CAACG,EAAE,EAAED,cAAcxD;IAC9D;IACA,OAAOwD;AACR;AAEA,SAAS1C,eACRZ,EAAQ,EACRG,EAAQ,EACRN,KAAgB,EAChBC,QAA2C;IAE3C,IAAI,CAACO,IAAAA,mBAAU,EAACL,IAAI,gBAAgB,CAACK,IAAAA,mBAAU,EAACF,IAAI,cAAc;QACjE,MAAM,IAAIiB,MAAM;IACjB;IACA,IAAIpB,GAAGf,IAAI,KAAKkB,GAAGlB,IAAI,EACtB,MAAM,IAAImC,MACTC,IAAAA,2BAAe,EACdmC,IAAAA,6BAAiB,EAAC,IAAIxD,IAAIG,IAAIL,YAAY;QAAEyB,MAAM;QAAGC,QAAQ;IAAE;IAGlE,OAAO3B;AACR;AAEA,SAASgB,UACRb,EAAQ,EACRG,EAAQ,EACRN,KAAgB,EAChBC,QAA2C;IAE3C,IAAI,CAACO,IAAAA,mBAAU,EAACL,IAAI,WAAW,CAACK,IAAAA,mBAAU,EAACF,IAAI,SAAS;QACvD,MAAM,IAAIiB,MAAM;IACjB;IACA,OAAOvB;AACR;AAEA,8BAA8B;AAC9B,SAASS,cACRN,EAAQ,EACRG,EAAQ,EACRN,KAAgB,EAChBC,QAA2C;IAE3C,IAAI,CAACO,IAAAA,mBAAU,EAACL,IAAI,aAAa;QAChC,MAAM,IAAIoB,MAAM;IACjB;IACA,0DAA0D;IAC1D,IAAIqC,qBAAmC,EAAE;IACzC,IAAIC,WAAW,IAAIC;IACnB,IAAIC,aAAmB5D;IACvB,MAAOK,IAAAA,mBAAU,EAACuD,YAAY,YAAa;QAC1C,IAAIF,SAASG,GAAG,CAACD,WAAW3E,IAAI,GAAG;QACnCyE,SAASI,GAAG,CAACF,WAAW3E,IAAI;QAC5B,IAAI2E,WAAWG,WAAW,EAAE;YAC3B,uDAAuD;YACvDH,WAAWG,WAAW,CAACC,OAAO,CAACC,CAAAA,IAAKR,mBAAmBnB,IAAI,CAAC2B;QAC7D;QACA,MAAMC,OAAOrE,MAAMK,YAAY,CAACgC,GAAG,CAAC0B,WAAW3E,IAAI;QACnD,IAAI,CAACiF,MAAM;QACXN,aAAaM;IACd;IACA,qDAAqD;IACrD,IAAI7D,IAAAA,mBAAU,EAACF,IAAI,aAAa;QAC/BA,GAAG4D,WAAW,GAAG5D,GAAG4D,WAAW,IAAI,EAAE;QACrC,qEAAqE;QACrE,KAAK,MAAME,KAAKR,mBAAoB;YACnC,IAAI,CAACtD,GAAG4D,WAAW,CAACI,IAAI,CAACC,CAAAA,WAAYC,IAAAA,yBAAgB,EAACJ,GAAGG,YAAY;gBACpEjE,GAAG4D,WAAW,CAACzB,IAAI,CAAC2B;YACrB;QACD;IACD;IACA,eAAe;IACf,IAAIK,IAAAA,iBAAQ,EAACtE,GAAGf,IAAI,EAAEkB,KACrB,MAAM,IAAIiB,MACTC,IAAAA,2BAAe,EACdgC,IAAAA,2BAAe,EACd,CAAC,qBAAqB,EAAErD,GAAGf,IAAI,CAAC,WAAW,EAAEsF,IAAAA,qBAAY,EACxDpE,IACAN,MAAMK,YAAY,GAChB,EACH,CAAC,GACDJ,YAAY;QAAEyB,MAAM;QAAGC,QAAQ;IAAE;IAIrC,IAAIgD,WAAW;QACd,GAAG3E,KAAK;QACRK,cAAcuE,IAAAA,eAAM,EAAC5E,MAAMK,YAAY,EAAEF,GAAGf,IAAI,EAAEkB;IACnD;IACA,0DAA0D;IAC1D,IAAI,CAACE,IAAAA,mBAAU,EAACF,IAAI,aAAa;QAChC,KAAK,MAAMuE,cAAcjB,mBAAoB;YAC5C,IAAIiB,WAAW1F,IAAI,KAAK,cAAcqB,IAAAA,mBAAU,EAACF,IAAI,WAAW;gBAC/DqE,WAAWjG,MACV4B,GAAGb,MAAM,CAACoF,WAAWC,KAAK,CAAC,EAC3BD,WAAWE,SAAS,EACpBJ,UACA1E;YAEF,OAAO,IAAI4E,WAAW1F,IAAI,KAAK,MAAM;gBACpC,IAAIqB,IAAAA,mBAAU,EAACF,IAAI,cAAc;oBAChC,IAAI,CAAC0E,IAAAA,gCAAmB,EAAC1E,IAAIuE,WAAWA,UAAU,GAAG;wBACpD,MAAM,IAAItD,MACTC,IAAAA,2BAAe,EACdgC,IAAAA,2BAAe,EACd,CAAC,KAAK,EAAEkB,IAAAA,qBAAY,EACnBpE,IACAN,MAAMK,YAAY,EACjB,8BAA8B,EAC/BwE,WAAWA,UAAU,CACrB,uNAAuN,CAAC,EACzN,CAAC,GACD5E,YAAY;4BAAEyB,MAAM;4BAAGC,QAAQ;wBAAE;oBAIrC;gBACD,OAAO;oBACN,uEAAuE;oBACvEsD,IAAAA,sCAAyB,EAAC3E,IAAIuE;gBAC/B;YACD,OAAO;gBACN,oDAAoD;gBACpDI,IAAAA,sCAAyB,EAAC3E,IAAIuE;YAC/B;QACD;IACD;IACA,OAAOF;AACR;AAEA,IAAIO,qBAAqB;AACzB,IAAIC,wBAAwB,IAAIpG;AAEhC,SAAS2B,cACRP,EAAQ,EACRG,EAAQ,EACRN,KAAgB,EAChBC,QAA2C;IAE3C,IAAI,CAACO,IAAAA,mBAAU,EAACL,IAAI,eAAe,CAACK,IAAAA,mBAAU,EAACF,IAAI,aAAa;QAC/D,MAAM,IAAIiB,MAAM;IACjB;IAEA2D;IACA,MAAM5C,UAAU,GAAGnC,GAAGd,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEgB,GAAGjB,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC;IAC3D6F,sBAAsB/C,GAAG,CAACE,SAAS,AAAC6C,CAAAA,sBAAsB9C,GAAG,CAACC,YAAY,CAAA,IAAK;IAE/E,IAAI4C,qBAAqB,SAAS,GAAG;QACpCtC,QAAQC,IAAI,CAAC,CAAC,gBAAgB,EAAEqC,mBAAmB,qBAAqB,CAAC,EACxEnC,MAAMC,IAAI,CAACmC,sBAAsBlC,OAAO,IAAIC,IAAI,CAAC,CAACC,GAAEC,IAAMA,CAAC,CAAC,EAAE,GAAGD,CAAC,CAAC,EAAE,EAAEE,KAAK,CAAC,GAAE;IACjF;IAEA,IAAIlD,GAAGd,MAAM,CAACC,MAAM,KAAKgB,GAAGjB,MAAM,CAACC,MAAM,EACxC,MAAM,IAAIiC,MACTC,IAAAA,2BAAe,EACd4D,IAAAA,oCAAwB,EACvBjF,IACAG,IACA,GACA+E,WACApF,YAAY;QAAEyB,MAAM;QAAGC,QAAQ;IAAE;IAKrC,IAAI8B,eAAezD;IAEnB,6EAA6E;IAC7E,IAAIG,GAAG+D,WAAW,EAAE;QACnB,KAAK,MAAMW,cAAc1E,GAAG+D,WAAW,CAAE;YACxC,wCAAwC;YACxCe,IAAAA,sCAAyB,EAAC9E,IAAI0E;QAC/B;IACD;IAEA,IAAIvE,GAAG4D,WAAW,EAAE;QACnB,KAAK,MAAMW,cAAcvE,GAAG4D,WAAW,CAAE;YACxC,wCAAwC;YACxCe,IAAAA,sCAAyB,EAAC3E,IAAIuE;QAC/B;IACD;IAEA,yCAAyC;IACzC,IAAK,IAAInB,IAAI,GAAGA,IAAIvD,GAAGd,MAAM,CAACC,MAAM,EAAEoE,IAAK;QAC1C,0DAA0D;QAC1D,MAAM4B,QAAQnF,GAAGd,MAAM,CAACqE,EAAE;QAC1B,MAAM6B,QAAQjF,GAAGjB,MAAM,CAACqE,EAAE;QAC1B,IAAIlD,IAAAA,mBAAU,EAAC8E,OAAO,eAAe9E,IAAAA,mBAAU,EAAC+E,OAAO,eAClDD,CAAAA,MAAMpB,WAAW,EAAE5E,UAAUiG,MAAMrB,WAAW,EAAE5E,MAAK,GAAI;YAC7DgG,MAAMpB,WAAW,GAAGoB,MAAMpB,WAAW,IAAI,EAAE;YAC3CqB,MAAMrB,WAAW,GAAGqB,MAAMrB,WAAW,IAAI,EAAE;YAC3C,0DAA0D;YAC1D,qBAAqB;YACrB,KAAK,MAAME,KAAKkB,MAAMpB,WAAW,CAAE;gBAClC,IAAI,CAACqB,MAAMrB,WAAW,CAACI,IAAI,CAACC,CAAAA,WAAYC,IAAAA,yBAAgB,EAACJ,GAAGG,YAAY;oBACvEgB,MAAMrB,WAAW,CAACzB,IAAI,CAAC2B;gBACxB;YACD;YACA,qBAAqB;YACrB,KAAK,MAAMA,KAAKmB,MAAMrB,WAAW,CAAE;gBAClC,IAAI,CAACoB,MAAMpB,WAAW,CAACI,IAAI,CAACC,CAAAA,WAAYC,IAAAA,yBAAgB,EAACJ,GAAGG,YAAY;oBACvEe,MAAMpB,WAAW,CAACzB,IAAI,CAAC2B;gBACxB;YACD;QACD;QACAX,eAAe/E,MAAMyB,GAAGd,MAAM,CAACqE,EAAE,EAAEpD,GAAGjB,MAAM,CAACqE,EAAE,EAAED,cAAcxD;IAChE;IACAwD,eAAe/E,MAAMyB,GAAGqF,MAAM,EAAElF,GAAGkF,MAAM,EAAE/B,cAAcxD;IAEzD,OAAOwD;AACR;AAEA,SAAS9C,UACRR,EAAQ,EACRG,EAAQ,EACRN,KAAgB,EAChBC,QAA2C;IAE3C,IAAI,CAACO,IAAAA,mBAAU,EAACL,IAAI,WAAW,CAACK,IAAAA,mBAAU,EAACF,IAAI,SAAS;QACvD,MAAM,IAAIiB,MAAM;IACjB;IACA,OAAO7C,MAAMyB,GAAGsF,OAAO,EAAEnF,GAAGmF,OAAO,EAAEzF,OAAOC;AAC7C;AAEA,SAASW,WACRT,EAAQ,EACRG,EAAQ,EACRN,KAAgB,EAChBC,QAA2C;IAE3C,IAAI,CAACO,IAAAA,mBAAU,EAACL,IAAI,YAAY,CAACK,IAAAA,mBAAU,EAACF,IAAI,UAAU;QACzD,MAAM,IAAIiB,MAAM;IACjB;IACA,IAAIpB,GAAGT,QAAQ,CAACJ,MAAM,KAAKgB,GAAGZ,QAAQ,CAACJ,MAAM,EAC5C,MAAM,IAAIiC,MACTC,IAAAA,2BAAe,EACdgC,IAAAA,2BAAe,EACd,CAAC,uBAAuB,EAAErD,GAAGT,QAAQ,CAACJ,MAAM,CAAC,IAAI,EAAEgB,GAAGZ,QAAQ,CAACJ,MAAM,EAAE,EACvE,CAAC,GACDW,YAAY;QAAEyB,MAAM;QAAGC,QAAQ;IAAE;IAIrC,IAAI8B,eAAezD;IACnB,IAAK,IAAI0D,IAAI,GAAGA,IAAIvD,GAAGT,QAAQ,CAACJ,MAAM,EAAEoE,IAAK;QAC5CD,eAAe/E,MACdyB,GAAGT,QAAQ,CAACgE,EAAE,EACdpD,GAAGZ,QAAQ,CAACgE,EAAE,EACdD,cACAxD;IAEF;IACA,OAAOwD;AACR;AAEA,SAASxC,aACRd,EAAQ,EACRG,EAAQ,EACRN,KAAgB,EAChBC,QAA2C;IAE3C,IAAI,CAACO,IAAAA,mBAAU,EAACL,IAAI,cAAc,CAACK,IAAAA,mBAAU,EAACF,IAAI,YAAY;QAC7D,MAAM,IAAIiB,MAAM;IACjB;IAEA,8DAA8D;IAC9D,IAAIpB,GAAGf,IAAI,KAAKkB,GAAGlB,IAAI,EAAE;QACxB,MAAM,IAAImC,MACTC,IAAAA,2BAAe,EACdgC,IAAAA,2BAAe,EACd,CAAC,uBAAuB,EAAErD,GAAGf,IAAI,CAAC,IAAI,EAAEkB,GAAGlB,IAAI,EAAE,EACjD,CAAC,GACDa,YAAY;YAAEyB,MAAM;YAAGC,QAAQ;QAAE;IAIrC;IAEA,4DAA4D;IAC5D,IAAIxB,GAAGR,IAAI,CAACL,MAAM,KAAKgB,GAAGX,IAAI,CAACL,MAAM,EAAE;QACtC,MAAM,IAAIiC,MACTC,IAAAA,2BAAe,EACdgC,IAAAA,2BAAe,EACd,CAAC,wBAAwB,EAAErD,GAAGf,IAAI,CAAC,KAAK,EAAEe,GAAGR,IAAI,CAACL,MAAM,CAAC,IAAI,EAAEgB,GAAGX,IAAI,CAACL,MAAM,CAAC,eAAe,CAAC,EAC9F,CAAC,GACDW,YAAY;YAAEyB,MAAM;YAAGC,QAAQ;QAAE;IAIrC;IAEA,qCAAqC;IACrC,IAAI8B,eAAezD;IACnB,IAAK,IAAI0D,IAAI,GAAGA,IAAIvD,GAAGR,IAAI,CAACL,MAAM,EAAEoE,IAAK;QACxCD,eAAe/E,MAAMyB,GAAGR,IAAI,CAAC+D,EAAE,EAAEpD,GAAGX,IAAI,CAAC+D,EAAE,EAAED,cAAcxD;IAC5D;IACA,OAAOwD;AACR;AAEA,SAAS5C,YACRV,EAAQ,EACRG,EAAQ,EACRN,KAAgB,EAChBC,QAA2C;IAE3C,IAAI,CAACO,IAAAA,mBAAU,EAACL,IAAI,aAAa,CAACK,IAAAA,mBAAU,EAACF,IAAI,WAAW;QAC3D,MAAM,IAAIiB,MAAM;IACjB;IACA,MAAMmE,QAAQnG,OAAOC,IAAI,CAACW,GAAGV,MAAM;IACnC,IAAIgE,eAAezD;IACnB,KAAK,MAAM2F,OAAOD,MAAO;QACxB,IAAI,CAAEC,CAAAA,OAAOrF,GAAGb,MAAM,AAAD,GACpB,MAAM,IAAI8B,MACTC,IAAAA,2BAAe,EACdgC,IAAAA,2BAAe,EACd,CAAC,wBAAwB,EAAEmC,KAAK,EAChC,CAAC,GACD1F,YAAY;YAAEyB,MAAM;YAAGC,QAAQ;QAAE;QAIrC8B,eAAe/E,MACdyB,GAAGV,MAAM,CAACkG,IAAI,EACdrF,GAAGb,MAAM,CAACkG,IAAI,EACdlC,cACAxD;IAEF;IACA,OAAOwD;AACR"}