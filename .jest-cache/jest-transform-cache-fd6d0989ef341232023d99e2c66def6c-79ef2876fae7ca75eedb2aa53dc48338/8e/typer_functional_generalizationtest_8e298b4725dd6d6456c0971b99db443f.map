{"version":3,"sources":["/workspace/src/typer/__tests__/typer_functional_generalization.test.ts"],"sourcesContent":["import { describe, it, expect } from '@jest/globals';\nimport { Lexer } from '../../lexer';\nimport { parse } from '../../parser/parser';\nimport { typeProgram } from '../index';\nimport { typeToString } from '../helpers';\n\n// Helper function to parse a string into a program\nconst parseProgram = (source: string) => {\n\tconst lexer = new Lexer(source);\n\tconst tokens = lexer.tokenize();\n\treturn parse(tokens);\n};\n\ndescribe('Functional Typer - Let-Polymorphism', () => {\n\tdescribe('Core Let-Polymorphism', () => {\n\t\tit('should generalize polymorphic identity function', () => {\n\t\t\tconst program = parseProgram('id = fn x => x');\n\t\t\tconst result = typeProgram(program);\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe(\n\t\t\t\t'(α) -> α'\n\t\t\t);\n\t\t});\n\n\t\tit('should allow polymorphic function to be used with different types', () => {\n\t\t\tconst program = parseProgram(`\n        id = fn x => x;\n        num = id 42;\n        str = id \"hello\";\n        bool = id True\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\t// The sequence returns the type of the rightmost expression\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe('Bool');\n\t\t});\n\n\t\tit('should handle higher-order functions with generalization', () => {\n\t\t\tconst program = parseProgram(`\n        apply = fn f x => f x;\n        double = fn x => x * 2;\n        result = apply double 5\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\t// The sequence returns the type of the rightmost expression\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe('Int');\n\t\t});\n\t});\n\n\tdescribe('Let-Polymorphism Edge Cases', () => {\n\t\tit('should handle nested function definitions', () => {\n\t\t\tconst program = parseProgram(`\n        outer = fn x => (\n          inner = fn y => x;\n          inner 42\n        )\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\t// This should work with proper generalization\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe(\n\t\t\t\t'(α) -> α'\n\t\t\t);\n\t\t});\n\n\t\tit('should handle curried polymorphic functions', () => {\n\t\t\tconst program = parseProgram(`\n        add = fn x y => x + y;\n        addFive = add 5;\n        result = addFive 3\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe('Int');\n\t\t});\n\n\t\tit('should handle multiple polymorphic functions in sequence', () => {\n\t\t\tconst program = parseProgram(`\n        id = fn x => x;\n        const = fn x y => x;\n        result1 = id 42;\n        result2 = const \"hello\" 123;\n        result3 = id True\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe('Bool');\n\t\t});\n\t});\n\n\tdescribe('Type Environment Consistency', () => {\n\t\tit('should properly instantiate polymorphic functions in single program', () => {\n\t\t\tconst program = parseProgram(`\n        id = fn x => x;\n        numResult = id 42;\n        strResult = id \"hello\";\n        boolResult = id True;\n        numResult\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe('Int');\n\t\t});\n\n\t\tit('should handle polymorphic function with multiple instantiations', () => {\n\t\t\tconst program = parseProgram(`\n        id = fn x => x;\n        id 42;\n        id \"hello\";\n        id True\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe('Bool');\n\t\t});\n\t});\n});\n"],"names":["parseProgram","source","lexer","Lexer","tokens","tokenize","parse","describe","it","program","result","typeProgram","expect","typeToString","type","state","substitution","toBe"],"mappings":";;;;yBAAqC;uBACf;wBACA;uBACM;yBACC;AAE7B,mDAAmD;AACnD,MAAMA,eAAe,CAACC;IACrB,MAAMC,QAAQ,IAAIC,YAAK,CAACF;IACxB,MAAMG,SAASF,MAAMG,QAAQ;IAC7B,OAAOC,IAAAA,aAAK,EAACF;AACd;AAEAG,IAAAA,iBAAQ,EAAC,uCAAuC;IAC/CA,IAAAA,iBAAQ,EAAC,yBAAyB;QACjCC,IAAAA,WAAE,EAAC,mDAAmD;YACrD,MAAMC,UAAUT,aAAa;YAC7B,MAAMU,SAASC,IAAAA,kBAAW,EAACF;YAC3BG,IAAAA,eAAM,EAACC,IAAAA,qBAAY,EAACH,OAAOI,IAAI,EAAEJ,OAAOK,KAAK,CAACC,YAAY,GAAGC,IAAI,CAChE;QAEF;QAEAT,IAAAA,WAAE,EAAC,qEAAqE;YACvE,MAAMC,UAAUT,aAAa,CAAC;;;;;MAK3B,CAAC;YACJ,MAAMU,SAASC,IAAAA,kBAAW,EAACF;YAC3B,4DAA4D;YAC5DG,IAAAA,eAAM,EAACC,IAAAA,qBAAY,EAACH,OAAOI,IAAI,EAAEJ,OAAOK,KAAK,CAACC,YAAY,GAAGC,IAAI,CAAC;QACnE;QAEAT,IAAAA,WAAE,EAAC,4DAA4D;YAC9D,MAAMC,UAAUT,aAAa,CAAC;;;;MAI3B,CAAC;YACJ,MAAMU,SAASC,IAAAA,kBAAW,EAACF;YAC3B,4DAA4D;YAC5DG,IAAAA,eAAM,EAACC,IAAAA,qBAAY,EAACH,OAAOI,IAAI,EAAEJ,OAAOK,KAAK,CAACC,YAAY,GAAGC,IAAI,CAAC;QACnE;IACD;IAEAV,IAAAA,iBAAQ,EAAC,+BAA+B;QACvCC,IAAAA,WAAE,EAAC,6CAA6C;YAC/C,MAAMC,UAAUT,aAAa,CAAC;;;;;MAK3B,CAAC;YACJ,MAAMU,SAASC,IAAAA,kBAAW,EAACF;YAC3B,8CAA8C;YAC9CG,IAAAA,eAAM,EAACC,IAAAA,qBAAY,EAACH,OAAOI,IAAI,EAAEJ,OAAOK,KAAK,CAACC,YAAY,GAAGC,IAAI,CAChE;QAEF;QAEAT,IAAAA,WAAE,EAAC,+CAA+C;YACjD,MAAMC,UAAUT,aAAa,CAAC;;;;MAI3B,CAAC;YACJ,MAAMU,SAASC,IAAAA,kBAAW,EAACF;YAC3BG,IAAAA,eAAM,EAACC,IAAAA,qBAAY,EAACH,OAAOI,IAAI,EAAEJ,OAAOK,KAAK,CAACC,YAAY,GAAGC,IAAI,CAAC;QACnE;QAEAT,IAAAA,WAAE,EAAC,4DAA4D;YAC9D,MAAMC,UAAUT,aAAa,CAAC;;;;;;MAM3B,CAAC;YACJ,MAAMU,SAASC,IAAAA,kBAAW,EAACF;YAC3BG,IAAAA,eAAM,EAACC,IAAAA,qBAAY,EAACH,OAAOI,IAAI,EAAEJ,OAAOK,KAAK,CAACC,YAAY,GAAGC,IAAI,CAAC;QACnE;IACD;IAEAV,IAAAA,iBAAQ,EAAC,gCAAgC;QACxCC,IAAAA,WAAE,EAAC,uEAAuE;YACzE,MAAMC,UAAUT,aAAa,CAAC;;;;;;MAM3B,CAAC;YACJ,MAAMU,SAASC,IAAAA,kBAAW,EAACF;YAC3BG,IAAAA,eAAM,EAACC,IAAAA,qBAAY,EAACH,OAAOI,IAAI,EAAEJ,OAAOK,KAAK,CAACC,YAAY,GAAGC,IAAI,CAAC;QACnE;QAEAT,IAAAA,WAAE,EAAC,mEAAmE;YACrE,MAAMC,UAAUT,aAAa,CAAC;;;;;MAK3B,CAAC;YACJ,MAAMU,SAASC,IAAAA,kBAAW,EAACF;YAC3BG,IAAAA,eAAM,EAACC,IAAAA,qBAAY,EAACH,OAAOI,IAAI,EAAEJ,OAAOK,KAAK,CAACC,YAAY,GAAGC,IAAI,CAAC;QACnE;IACD;AACD"}