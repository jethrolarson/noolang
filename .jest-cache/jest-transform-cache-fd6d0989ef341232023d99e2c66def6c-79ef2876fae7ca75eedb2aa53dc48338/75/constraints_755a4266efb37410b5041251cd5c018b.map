{"version":3,"sources":["/workspace/src/typer/constraints.ts"],"sourcesContent":["import {typeVariable, Constraint, Type, HasFieldConstraint, IsConstraint, ImplementsConstraint, CustomConstraint} from \"../ast\"\nimport { TypeState } from \"./types\";\nimport { formatTypeError, createTypeError } from \"./type-errors\";\nimport { substitute } from \"./substitute\";\nimport { constraintsEqual, isTypeKind, typeToString } from \"./helpers\";\nimport { unify } from \"./unify\";\n\n// Constraint solving functions\nexport const solveConstraints = (\n\tconstraints: Constraint[],\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n): TypeState => {\n\tlet currentState = state;\n\n\tfor (const constraint of constraints) {\n\t\tcurrentState = solveConstraint(constraint, currentState, location);\n\t}\n\n\treturn currentState;\n};\n\nexport const solveConstraint = (\n\tconstraint: Constraint,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n): TypeState => {\n\tswitch (constraint.kind) {\n\t\tcase \"is\":\n\t\t\treturn solveIsConstraint(constraint, state, location);\n\t\tcase \"hasField\":\n\t\t\treturn solveHasFieldConstraint(constraint, state, location);\n\t\tcase \"implements\":\n\t\t\treturn solveImplementsConstraint(constraint, state, location);\n\t\tcase \"custom\":\n\t\t\treturn solveCustomConstraint(constraint, state, location);\n\t\tdefault:\n\t\t\treturn state;\n\t}\n};\n\nconst solveIsConstraint = (\n\tconstraint: { kind: \"is\"; typeVar: string; constraint: string },\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n): TypeState => {\n\t// Validate constraint name first\n\tvalidateConstraintName(constraint.constraint);\n\n\tconst typeVar = substitute(\n\t\ttypeVariable(constraint.typeVar),\n\t\tstate.substitution,\n\t);\n\n\t// If the type variable has been unified to a concrete type, check if it satisfies the constraint\n\tif (typeVar.kind !== \"variable\") {\n\t\t// Check if the concrete type satisfies the constraint\n\t\tif (!satisfiesConstraint(typeVar, constraint.constraint)) {\n\t\t\tthrow new Error(\n\t\t\t\tformatTypeError(\n\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t`Type ${typeToString(\n\t\t\t\t\t\t\ttypeVar,\n\t\t\t\t\t\t\tstate.substitution,\n\t\t\t\t\t\t)} does not satisfy constraint '${\n\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t}'. This often occurs when trying to use a partial function (one that can fail) in an unsafe context like function composition. Consider using total functions that return Option or Result types instead.`,\n\t\t\t\t\t\t{},\n\t\t\t\t\t\tlocation || { line: 1, column: 1 },\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t} else {\n\t\t// For type variables, we need to track the constraint for later solving\n\t\t// Add the constraint to the type variable if it doesn't already have it\n\t\tif (!typeVar.constraints) {\n\t\t\ttypeVar.constraints = [];\n\t\t}\n\n\t\t// Check if this constraint is already present\n\t\tconst existingConstraint = typeVar.constraints.find(\n\t\t\t(c) =>\n\t\t\t\tc.kind === \"is\" &&\n\t\t\t\tc.typeVar === constraint.typeVar &&\n\t\t\t\tc.constraint === constraint.constraint,\n\t\t);\n\n\t\tif (!existingConstraint) {\n\t\t\ttypeVar.constraints.push(constraint);\n\t\t}\n\t}\n\n\treturn state;\n};\n\nconst solveHasFieldConstraint = (\n\tconstraint: {\n\t\tkind: \"hasField\";\n\t\ttypeVar: string;\n\t\tfield: string;\n\t\tfieldType: Type;\n\t},\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n): TypeState => {\n\tconst typeVar = substitute(\n\t\ttypeVariable(constraint.typeVar),\n\t\tstate.substitution,\n\t);\n\n\tif (typeVar.kind === \"record\") {\n\t\t// Check if the record has the required field with the right type\n\t\tif (!(constraint.field in typeVar.fields)) {\n\t\t\tthrow new Error(\n\t\t\t\tformatTypeError(\n\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t`Record type missing required field '${constraint.field}'`,\n\t\t\t\t\t\t{},\n\t\t\t\t\t\tlocation || { line: 1, column: 1 },\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t// Unify the field type\n\t\tlet newState = state;\n\t\tnewState = unify(\n\t\t\ttypeVar.fields[constraint.field],\n\t\t\tconstraint.fieldType,\n\t\t\tnewState,\n\t\t\tlocation,\n\t\t);\n\n\t\treturn newState;\n\t} else if (typeVar.kind === \"variable\") {\n\t\t// For type variables, we'll track the constraint for later solving\n\t\treturn state;\n\t} else {\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tcreateTypeError(\n\t\t\t\t\t`Type ${typeToString(\n\t\t\t\t\t\ttypeVar,\n\t\t\t\t\t\tstate.substitution,\n\t\t\t\t\t)} cannot have fields`,\n\t\t\t\t\t{},\n\t\t\t\t\tlocation || { line: 1, column: 1 },\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n};\n\nconst solveImplementsConstraint = (\n\tconstraint: { kind: \"implements\"; typeVar: string; interfaceName: string },\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n): TypeState => {\n\t// For now, we'll just track the constraint\n\t// In a full implementation, we'd check if the type implements the interface\n\treturn state;\n};\n\nconst solveCustomConstraint = (\n\tconstraint: {\n\t\tkind: \"custom\";\n\t\ttypeVar: string;\n\t\tconstraint: string;\n\t\targs: Type[];\n\t},\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n): TypeState => {\n\t// For now, we'll just track the constraint\n\t// In a full implementation, we'd call the custom constraint solver\n\treturn state;\n};\n\n// Validate that a constraint name is valid\nexport const validateConstraintName = (constraint: string): void => {\n\t// All constraints are now meaningless type checks, so reject them all\n\tthrow new Error(\n\t\t`Constraint '${constraint}' is not supported. Use hasField constraints for record typing instead.`,\n\t);\n};\n\nexport const satisfiesConstraint = (type: Type, constraint: string): boolean => {\n\t// All non-hasField constraints are meaningless, so they're not supported\n\treturn false;\n};\n\n\n\n\n// Helper: Recursively push a constraint to all type variables inside a type\nexport function propagateConstraintToType(type: Type, constraint: Constraint) {\n\tswitch (type.kind) {\n\t\tcase \"variable\":\n\t\t\ttype.constraints = type.constraints || [];\n\t\t\tif (!type.constraints.some((c) => constraintsEqual(c, constraint))) {\n\t\t\t\ttype.constraints.push(constraint);\n\t\t\t} else {\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"function\":\n\t\t\tfor (const param of type.params) {\n\t\t\t\tpropagateConstraintToType(param, constraint);\n\t\t\t}\n\t\t\tpropagateConstraintToType(type.return, constraint);\n\t\t\tbreak;\n\t\tcase \"list\":\n\t\t\tpropagateConstraintToType(type.element, constraint);\n\t\t\tbreak;\n\t\tcase \"tuple\":\n\t\t\tfor (const el of type.elements) {\n\t\t\t\tpropagateConstraintToType(el, constraint);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"record\":\n\t\t\tfor (const fieldType of Object.values(type.fields)) {\n\t\t\t\tpropagateConstraintToType(fieldType, constraint);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"union\":\n\t\t\tfor (const t of type.types) {\n\t\t\t\tpropagateConstraintToType(t, constraint);\n\t\t\t}\n\t\t\tbreak;\n\t\t// For primitives, unit, unknown: do nothing\n\t}\n}\n\n// Collect all constraints for a variable, following the substitution chain\nexport function collectAllConstraintsForVar(\n\tvarName: string,\n\tsubstitution: Map<string, Type>,\n): Constraint[] {\n\tconst seen = new Set<string>();\n\tlet constraints: Constraint[] = [];\n\tlet currentVarName = varName;\n\tlet currentType = substitution.get(currentVarName);\n\n\twhile (currentType && isTypeKind(currentType, \"variable\")) {\n\t\tif (seen.has(currentVarName)) {\n\t\t\tbreak; // Prevent cycles\n\t\t}\n\t\tseen.add(currentVarName);\n\n\t\tif (currentType.constraints) {\n\t\t\tconstraints = constraints.concat(currentType.constraints);\n\t\t}\n\n\t\tcurrentVarName = currentType.name;\n\t\tcurrentType = substitution.get(currentVarName);\n\t}\n\n\t// Also check the original variable\n\tconst origType = substitution.get(varName);\n\tif (origType && isTypeKind(origType, \"variable\") && origType.constraints) {\n\t\tconstraints = constraints.concat(origType.constraints);\n\t}\n\n\treturn constraints;\n}\n\n \n// After type inference, validate all constraints in the substitution map\nexport function validateAllSubstitutionConstraints(state: TypeState) {\n\tfor (const [varName, concreteType] of state.substitution.entries()) {\n\t\t// Only check if the concreteType is not a variable\n\t\tif (concreteType.kind !== \"variable\") {\n\t\t\t// Collect all constraints from the substitution chain\n\t\t\tconst constraintsToCheck = collectAllConstraintsForVar(\n\t\t\t\tvarName,\n\t\t\t\tstate.substitution,\n\t\t\t);\n\t\t\tfor (const constraint of constraintsToCheck) {\n\t\t\t\tif (\n\t\t\t\t\tconstraint.kind === \"hasField\" &&\n\t\t\t\t\tisTypeKind(concreteType, \"record\")\n\t\t\t\t) {\n\t\t\t\t\tif (!(constraint.field in concreteType.fields)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Record type missing required field '${constraint.field}'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t// Optionally, unify field types here if needed\n\t\t\t\t} else if (constraint.kind === \"is\") {\n\t\t\t\t\tif (!satisfiesConstraint(concreteType, constraint.constraint)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Type variable '${varName}' was unified to ${typeToString(\n\t\t\t\t\t\t\t\tconcreteType,\n\t\t\t\t\t\t\t)} but does not satisfy constraint '${\n\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t}'. This typically means a partial function is being used in an unsafe context. Consider using total functions that return Option or Result types instead of partial functions with constraints.`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"],"names":["collectAllConstraintsForVar","propagateConstraintToType","satisfiesConstraint","solveConstraint","solveConstraints","validateAllSubstitutionConstraints","validateConstraintName","constraints","state","location","currentState","constraint","kind","solveIsConstraint","solveHasFieldConstraint","solveImplementsConstraint","solveCustomConstraint","typeVar","substitute","typeVariable","substitution","Error","formatTypeError","createTypeError","typeToString","line","column","existingConstraint","find","c","push","field","fields","newState","unify","fieldType","type","some","constraintsEqual","param","params","return","element","el","elements","Object","values","t","types","varName","seen","Set","currentVarName","currentType","get","isTypeKind","has","add","concat","name","origType","concreteType","entries","constraintsToCheck"],"mappings":"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"}