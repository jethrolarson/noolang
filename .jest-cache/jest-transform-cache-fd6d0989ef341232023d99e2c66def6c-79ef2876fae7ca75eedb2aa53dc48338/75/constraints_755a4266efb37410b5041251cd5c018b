96449491710953c73a1b78b01d0a521d
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get collectAllConstraintsForVar () {
        return collectAllConstraintsForVar;
    },
    get propagateConstraintToType () {
        return propagateConstraintToType;
    },
    get satisfiesConstraint () {
        return satisfiesConstraint;
    },
    get solveConstraint () {
        return solveConstraint;
    },
    get solveConstraints () {
        return solveConstraints;
    },
    get validateAllSubstitutionConstraints () {
        return validateAllSubstitutionConstraints;
    },
    get validateConstraintName () {
        return validateConstraintName;
    }
});
const _ast = require("../ast");
const _typeerrors = require("./type-errors");
const _substitute = require("./substitute");
const _helpers = require("./helpers");
const _unify = require("./unify");
const solveConstraints = (constraints, state, location)=>{
    let currentState = state;
    for (const constraint of constraints){
        currentState = solveConstraint(constraint, currentState, location);
    }
    return currentState;
};
const solveConstraint = (constraint, state, location)=>{
    switch(constraint.kind){
        case "is":
            return solveIsConstraint(constraint, state, location);
        case "hasField":
            return solveHasFieldConstraint(constraint, state, location);
        case "implements":
            return solveImplementsConstraint(constraint, state, location);
        case "custom":
            return solveCustomConstraint(constraint, state, location);
        default:
            return state;
    }
};
const solveIsConstraint = (constraint, state, location)=>{
    // Validate constraint name first
    validateConstraintName(constraint.constraint);
    const typeVar = (0, _substitute.substitute)((0, _ast.typeVariable)(constraint.typeVar), state.substitution);
    // If the type variable has been unified to a concrete type, check if it satisfies the constraint
    if (typeVar.kind !== "variable") {
        // Check if the concrete type satisfies the constraint
        if (!satisfiesConstraint(typeVar, constraint.constraint)) {
            throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.createTypeError)(`Type ${(0, _helpers.typeToString)(typeVar, state.substitution)} does not satisfy constraint '${constraint.constraint}'. This often occurs when trying to use a partial function (one that can fail) in an unsafe context like function composition. Consider using total functions that return Option or Result types instead.`, {}, location || {
                line: 1,
                column: 1
            })));
        }
    } else {
        // For type variables, we need to track the constraint for later solving
        // Add the constraint to the type variable if it doesn't already have it
        if (!typeVar.constraints) {
            typeVar.constraints = [];
        }
        // Check if this constraint is already present
        const existingConstraint = typeVar.constraints.find((c)=>c.kind === "is" && c.typeVar === constraint.typeVar && c.constraint === constraint.constraint);
        if (!existingConstraint) {
            typeVar.constraints.push(constraint);
        }
    }
    return state;
};
const solveHasFieldConstraint = (constraint, state, location)=>{
    const typeVar = (0, _substitute.substitute)((0, _ast.typeVariable)(constraint.typeVar), state.substitution);
    if (typeVar.kind === "record") {
        // Check if the record has the required field with the right type
        if (!(constraint.field in typeVar.fields)) {
            throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.createTypeError)(`Record type missing required field '${constraint.field}'`, {}, location || {
                line: 1,
                column: 1
            })));
        }
        // Unify the field type
        let newState = state;
        newState = (0, _unify.unify)(typeVar.fields[constraint.field], constraint.fieldType, newState, location);
        return newState;
    } else if (typeVar.kind === "variable") {
        // For type variables, we'll track the constraint for later solving
        return state;
    } else {
        throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.createTypeError)(`Type ${(0, _helpers.typeToString)(typeVar, state.substitution)} cannot have fields`, {}, location || {
            line: 1,
            column: 1
        })));
    }
};
const solveImplementsConstraint = (constraint, state, location)=>{
    // For now, we'll just track the constraint
    // In a full implementation, we'd check if the type implements the interface
    return state;
};
const solveCustomConstraint = (constraint, state, location)=>{
    // For now, we'll just track the constraint
    // In a full implementation, we'd call the custom constraint solver
    return state;
};
const validateConstraintName = (constraint)=>{
    // All constraints are now meaningless type checks, so reject them all
    throw new Error(`Constraint '${constraint}' is not supported. Use hasField constraints for record typing instead.`);
};
const satisfiesConstraint = (type, constraint)=>{
    // All non-hasField constraints are meaningless, so they're not supported
    return false;
};
function propagateConstraintToType(type, constraint) {
    switch(type.kind){
        case "variable":
            type.constraints = type.constraints || [];
            if (!type.constraints.some((c)=>(0, _helpers.constraintsEqual)(c, constraint))) {
                type.constraints.push(constraint);
            } else {}
            break;
        case "function":
            for (const param of type.params){
                propagateConstraintToType(param, constraint);
            }
            propagateConstraintToType(type.return, constraint);
            break;
        case "list":
            propagateConstraintToType(type.element, constraint);
            break;
        case "tuple":
            for (const el of type.elements){
                propagateConstraintToType(el, constraint);
            }
            break;
        case "record":
            for (const fieldType of Object.values(type.fields)){
                propagateConstraintToType(fieldType, constraint);
            }
            break;
        case "union":
            for (const t of type.types){
                propagateConstraintToType(t, constraint);
            }
            break;
    }
}
function collectAllConstraintsForVar(varName, substitution) {
    const seen = new Set();
    let constraints = [];
    let currentVarName = varName;
    let currentType = substitution.get(currentVarName);
    while(currentType && (0, _helpers.isTypeKind)(currentType, "variable")){
        if (seen.has(currentVarName)) {
            break; // Prevent cycles
        }
        seen.add(currentVarName);
        if (currentType.constraints) {
            constraints = constraints.concat(currentType.constraints);
        }
        currentVarName = currentType.name;
        currentType = substitution.get(currentVarName);
    }
    // Also check the original variable
    const origType = substitution.get(varName);
    if (origType && (0, _helpers.isTypeKind)(origType, "variable") && origType.constraints) {
        constraints = constraints.concat(origType.constraints);
    }
    return constraints;
}
function validateAllSubstitutionConstraints(state) {
    for (const [varName, concreteType] of state.substitution.entries()){
        // Only check if the concreteType is not a variable
        if (concreteType.kind !== "variable") {
            // Collect all constraints from the substitution chain
            const constraintsToCheck = collectAllConstraintsForVar(varName, state.substitution);
            for (const constraint of constraintsToCheck){
                if (constraint.kind === "hasField" && (0, _helpers.isTypeKind)(concreteType, "record")) {
                    if (!(constraint.field in concreteType.fields)) {
                        throw new Error(`Record type missing required field '${constraint.field}'`);
                    }
                // Optionally, unify field types here if needed
                } else if (constraint.kind === "is") {
                    if (!satisfiesConstraint(concreteType, constraint.constraint)) {
                        throw new Error(`Type variable '${varName}' was unified to ${(0, _helpers.typeToString)(concreteType)} but does not satisfy constraint '${constraint.constraint}'. This typically means a partial function is being used in an unsafe context. Consider using total functions that return Option or Result types instead of partial functions with constraints.`);
                    }
                }
            }
        }
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Uvc3JjL3R5cGVyL2NvbnN0cmFpbnRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dHlwZVZhcmlhYmxlLCBDb25zdHJhaW50LCBUeXBlLCBIYXNGaWVsZENvbnN0cmFpbnQsIElzQ29uc3RyYWludCwgSW1wbGVtZW50c0NvbnN0cmFpbnQsIEN1c3RvbUNvbnN0cmFpbnR9IGZyb20gXCIuLi9hc3RcIlxuaW1wb3J0IHsgVHlwZVN0YXRlIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGZvcm1hdFR5cGVFcnJvciwgY3JlYXRlVHlwZUVycm9yIH0gZnJvbSBcIi4vdHlwZS1lcnJvcnNcIjtcbmltcG9ydCB7IHN1YnN0aXR1dGUgfSBmcm9tIFwiLi9zdWJzdGl0dXRlXCI7XG5pbXBvcnQgeyBjb25zdHJhaW50c0VxdWFsLCBpc1R5cGVLaW5kLCB0eXBlVG9TdHJpbmcgfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG5pbXBvcnQgeyB1bmlmeSB9IGZyb20gXCIuL3VuaWZ5XCI7XG5cbi8vIENvbnN0cmFpbnQgc29sdmluZyBmdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBzb2x2ZUNvbnN0cmFpbnRzID0gKFxuXHRjb25zdHJhaW50czogQ29uc3RyYWludFtdLFxuXHRzdGF0ZTogVHlwZVN0YXRlLFxuXHRsb2NhdGlvbj86IHsgbGluZTogbnVtYmVyOyBjb2x1bW46IG51bWJlciB9LFxuKTogVHlwZVN0YXRlID0+IHtcblx0bGV0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuXG5cdGZvciAoY29uc3QgY29uc3RyYWludCBvZiBjb25zdHJhaW50cykge1xuXHRcdGN1cnJlbnRTdGF0ZSA9IHNvbHZlQ29uc3RyYWludChjb25zdHJhaW50LCBjdXJyZW50U3RhdGUsIGxvY2F0aW9uKTtcblx0fVxuXG5cdHJldHVybiBjdXJyZW50U3RhdGU7XG59O1xuXG5leHBvcnQgY29uc3Qgc29sdmVDb25zdHJhaW50ID0gKFxuXHRjb25zdHJhaW50OiBDb25zdHJhaW50LFxuXHRzdGF0ZTogVHlwZVN0YXRlLFxuXHRsb2NhdGlvbj86IHsgbGluZTogbnVtYmVyOyBjb2x1bW46IG51bWJlciB9LFxuKTogVHlwZVN0YXRlID0+IHtcblx0c3dpdGNoIChjb25zdHJhaW50LmtpbmQpIHtcblx0XHRjYXNlIFwiaXNcIjpcblx0XHRcdHJldHVybiBzb2x2ZUlzQ29uc3RyYWludChjb25zdHJhaW50LCBzdGF0ZSwgbG9jYXRpb24pO1xuXHRcdGNhc2UgXCJoYXNGaWVsZFwiOlxuXHRcdFx0cmV0dXJuIHNvbHZlSGFzRmllbGRDb25zdHJhaW50KGNvbnN0cmFpbnQsIHN0YXRlLCBsb2NhdGlvbik7XG5cdFx0Y2FzZSBcImltcGxlbWVudHNcIjpcblx0XHRcdHJldHVybiBzb2x2ZUltcGxlbWVudHNDb25zdHJhaW50KGNvbnN0cmFpbnQsIHN0YXRlLCBsb2NhdGlvbik7XG5cdFx0Y2FzZSBcImN1c3RvbVwiOlxuXHRcdFx0cmV0dXJuIHNvbHZlQ3VzdG9tQ29uc3RyYWludChjb25zdHJhaW50LCBzdGF0ZSwgbG9jYXRpb24pO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gc3RhdGU7XG5cdH1cbn07XG5cbmNvbnN0IHNvbHZlSXNDb25zdHJhaW50ID0gKFxuXHRjb25zdHJhaW50OiB7IGtpbmQ6IFwiaXNcIjsgdHlwZVZhcjogc3RyaW5nOyBjb25zdHJhaW50OiBzdHJpbmcgfSxcblx0c3RhdGU6IFR5cGVTdGF0ZSxcblx0bG9jYXRpb24/OiB7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfSxcbik6IFR5cGVTdGF0ZSA9PiB7XG5cdC8vIFZhbGlkYXRlIGNvbnN0cmFpbnQgbmFtZSBmaXJzdFxuXHR2YWxpZGF0ZUNvbnN0cmFpbnROYW1lKGNvbnN0cmFpbnQuY29uc3RyYWludCk7XG5cblx0Y29uc3QgdHlwZVZhciA9IHN1YnN0aXR1dGUoXG5cdFx0dHlwZVZhcmlhYmxlKGNvbnN0cmFpbnQudHlwZVZhciksXG5cdFx0c3RhdGUuc3Vic3RpdHV0aW9uLFxuXHQpO1xuXG5cdC8vIElmIHRoZSB0eXBlIHZhcmlhYmxlIGhhcyBiZWVuIHVuaWZpZWQgdG8gYSBjb25jcmV0ZSB0eXBlLCBjaGVjayBpZiBpdCBzYXRpc2ZpZXMgdGhlIGNvbnN0cmFpbnRcblx0aWYgKHR5cGVWYXIua2luZCAhPT0gXCJ2YXJpYWJsZVwiKSB7XG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIGNvbmNyZXRlIHR5cGUgc2F0aXNmaWVzIHRoZSBjb25zdHJhaW50XG5cdFx0aWYgKCFzYXRpc2ZpZXNDb25zdHJhaW50KHR5cGVWYXIsIGNvbnN0cmFpbnQuY29uc3RyYWludCkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0Zm9ybWF0VHlwZUVycm9yKFxuXHRcdFx0XHRcdGNyZWF0ZVR5cGVFcnJvcihcblx0XHRcdFx0XHRcdGBUeXBlICR7dHlwZVRvU3RyaW5nKFxuXHRcdFx0XHRcdFx0XHR0eXBlVmFyLFxuXHRcdFx0XHRcdFx0XHRzdGF0ZS5zdWJzdGl0dXRpb24sXG5cdFx0XHRcdFx0XHQpfSBkb2VzIG5vdCBzYXRpc2Z5IGNvbnN0cmFpbnQgJyR7XG5cdFx0XHRcdFx0XHRcdGNvbnN0cmFpbnQuY29uc3RyYWludFxuXHRcdFx0XHRcdFx0fScuIFRoaXMgb2Z0ZW4gb2NjdXJzIHdoZW4gdHJ5aW5nIHRvIHVzZSBhIHBhcnRpYWwgZnVuY3Rpb24gKG9uZSB0aGF0IGNhbiBmYWlsKSBpbiBhbiB1bnNhZmUgY29udGV4dCBsaWtlIGZ1bmN0aW9uIGNvbXBvc2l0aW9uLiBDb25zaWRlciB1c2luZyB0b3RhbCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gT3B0aW9uIG9yIFJlc3VsdCB0eXBlcyBpbnN0ZWFkLmAsXG5cdFx0XHRcdFx0XHR7fSxcblx0XHRcdFx0XHRcdGxvY2F0aW9uIHx8IHsgbGluZTogMSwgY29sdW1uOiAxIH0sXG5cdFx0XHRcdFx0KSxcblx0XHRcdFx0KSxcblx0XHRcdCk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIEZvciB0eXBlIHZhcmlhYmxlcywgd2UgbmVlZCB0byB0cmFjayB0aGUgY29uc3RyYWludCBmb3IgbGF0ZXIgc29sdmluZ1xuXHRcdC8vIEFkZCB0aGUgY29uc3RyYWludCB0byB0aGUgdHlwZSB2YXJpYWJsZSBpZiBpdCBkb2Vzbid0IGFscmVhZHkgaGF2ZSBpdFxuXHRcdGlmICghdHlwZVZhci5jb25zdHJhaW50cykge1xuXHRcdFx0dHlwZVZhci5jb25zdHJhaW50cyA9IFtdO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHRoaXMgY29uc3RyYWludCBpcyBhbHJlYWR5IHByZXNlbnRcblx0XHRjb25zdCBleGlzdGluZ0NvbnN0cmFpbnQgPSB0eXBlVmFyLmNvbnN0cmFpbnRzLmZpbmQoXG5cdFx0XHQoYykgPT5cblx0XHRcdFx0Yy5raW5kID09PSBcImlzXCIgJiZcblx0XHRcdFx0Yy50eXBlVmFyID09PSBjb25zdHJhaW50LnR5cGVWYXIgJiZcblx0XHRcdFx0Yy5jb25zdHJhaW50ID09PSBjb25zdHJhaW50LmNvbnN0cmFpbnQsXG5cdFx0KTtcblxuXHRcdGlmICghZXhpc3RpbmdDb25zdHJhaW50KSB7XG5cdFx0XHR0eXBlVmFyLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHN0YXRlO1xufTtcblxuY29uc3Qgc29sdmVIYXNGaWVsZENvbnN0cmFpbnQgPSAoXG5cdGNvbnN0cmFpbnQ6IHtcblx0XHRraW5kOiBcImhhc0ZpZWxkXCI7XG5cdFx0dHlwZVZhcjogc3RyaW5nO1xuXHRcdGZpZWxkOiBzdHJpbmc7XG5cdFx0ZmllbGRUeXBlOiBUeXBlO1xuXHR9LFxuXHRzdGF0ZTogVHlwZVN0YXRlLFxuXHRsb2NhdGlvbj86IHsgbGluZTogbnVtYmVyOyBjb2x1bW46IG51bWJlciB9LFxuKTogVHlwZVN0YXRlID0+IHtcblx0Y29uc3QgdHlwZVZhciA9IHN1YnN0aXR1dGUoXG5cdFx0dHlwZVZhcmlhYmxlKGNvbnN0cmFpbnQudHlwZVZhciksXG5cdFx0c3RhdGUuc3Vic3RpdHV0aW9uLFxuXHQpO1xuXG5cdGlmICh0eXBlVmFyLmtpbmQgPT09IFwicmVjb3JkXCIpIHtcblx0XHQvLyBDaGVjayBpZiB0aGUgcmVjb3JkIGhhcyB0aGUgcmVxdWlyZWQgZmllbGQgd2l0aCB0aGUgcmlnaHQgdHlwZVxuXHRcdGlmICghKGNvbnN0cmFpbnQuZmllbGQgaW4gdHlwZVZhci5maWVsZHMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdGZvcm1hdFR5cGVFcnJvcihcblx0XHRcdFx0XHRjcmVhdGVUeXBlRXJyb3IoXG5cdFx0XHRcdFx0XHRgUmVjb3JkIHR5cGUgbWlzc2luZyByZXF1aXJlZCBmaWVsZCAnJHtjb25zdHJhaW50LmZpZWxkfSdgLFxuXHRcdFx0XHRcdFx0e30sXG5cdFx0XHRcdFx0XHRsb2NhdGlvbiB8fCB7IGxpbmU6IDEsIGNvbHVtbjogMSB9LFxuXHRcdFx0XHRcdCksXG5cdFx0XHRcdCksXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIFVuaWZ5IHRoZSBmaWVsZCB0eXBlXG5cdFx0bGV0IG5ld1N0YXRlID0gc3RhdGU7XG5cdFx0bmV3U3RhdGUgPSB1bmlmeShcblx0XHRcdHR5cGVWYXIuZmllbGRzW2NvbnN0cmFpbnQuZmllbGRdLFxuXHRcdFx0Y29uc3RyYWludC5maWVsZFR5cGUsXG5cdFx0XHRuZXdTdGF0ZSxcblx0XHRcdGxvY2F0aW9uLFxuXHRcdCk7XG5cblx0XHRyZXR1cm4gbmV3U3RhdGU7XG5cdH0gZWxzZSBpZiAodHlwZVZhci5raW5kID09PSBcInZhcmlhYmxlXCIpIHtcblx0XHQvLyBGb3IgdHlwZSB2YXJpYWJsZXMsIHdlJ2xsIHRyYWNrIHRoZSBjb25zdHJhaW50IGZvciBsYXRlciBzb2x2aW5nXG5cdFx0cmV0dXJuIHN0YXRlO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGZvcm1hdFR5cGVFcnJvcihcblx0XHRcdFx0Y3JlYXRlVHlwZUVycm9yKFxuXHRcdFx0XHRcdGBUeXBlICR7dHlwZVRvU3RyaW5nKFxuXHRcdFx0XHRcdFx0dHlwZVZhcixcblx0XHRcdFx0XHRcdHN0YXRlLnN1YnN0aXR1dGlvbixcblx0XHRcdFx0XHQpfSBjYW5ub3QgaGF2ZSBmaWVsZHNgLFxuXHRcdFx0XHRcdHt9LFxuXHRcdFx0XHRcdGxvY2F0aW9uIHx8IHsgbGluZTogMSwgY29sdW1uOiAxIH0sXG5cdFx0XHRcdCksXG5cdFx0XHQpLFxuXHRcdCk7XG5cdH1cbn07XG5cbmNvbnN0IHNvbHZlSW1wbGVtZW50c0NvbnN0cmFpbnQgPSAoXG5cdGNvbnN0cmFpbnQ6IHsga2luZDogXCJpbXBsZW1lbnRzXCI7IHR5cGVWYXI6IHN0cmluZzsgaW50ZXJmYWNlTmFtZTogc3RyaW5nIH0sXG5cdHN0YXRlOiBUeXBlU3RhdGUsXG5cdGxvY2F0aW9uPzogeyBsaW5lOiBudW1iZXI7IGNvbHVtbjogbnVtYmVyIH0sXG4pOiBUeXBlU3RhdGUgPT4ge1xuXHQvLyBGb3Igbm93LCB3ZSdsbCBqdXN0IHRyYWNrIHRoZSBjb25zdHJhaW50XG5cdC8vIEluIGEgZnVsbCBpbXBsZW1lbnRhdGlvbiwgd2UnZCBjaGVjayBpZiB0aGUgdHlwZSBpbXBsZW1lbnRzIHRoZSBpbnRlcmZhY2Vcblx0cmV0dXJuIHN0YXRlO1xufTtcblxuY29uc3Qgc29sdmVDdXN0b21Db25zdHJhaW50ID0gKFxuXHRjb25zdHJhaW50OiB7XG5cdFx0a2luZDogXCJjdXN0b21cIjtcblx0XHR0eXBlVmFyOiBzdHJpbmc7XG5cdFx0Y29uc3RyYWludDogc3RyaW5nO1xuXHRcdGFyZ3M6IFR5cGVbXTtcblx0fSxcblx0c3RhdGU6IFR5cGVTdGF0ZSxcblx0bG9jYXRpb24/OiB7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfSxcbik6IFR5cGVTdGF0ZSA9PiB7XG5cdC8vIEZvciBub3csIHdlJ2xsIGp1c3QgdHJhY2sgdGhlIGNvbnN0cmFpbnRcblx0Ly8gSW4gYSBmdWxsIGltcGxlbWVudGF0aW9uLCB3ZSdkIGNhbGwgdGhlIGN1c3RvbSBjb25zdHJhaW50IHNvbHZlclxuXHRyZXR1cm4gc3RhdGU7XG59O1xuXG4vLyBWYWxpZGF0ZSB0aGF0IGEgY29uc3RyYWludCBuYW1lIGlzIHZhbGlkXG5leHBvcnQgY29uc3QgdmFsaWRhdGVDb25zdHJhaW50TmFtZSA9IChjb25zdHJhaW50OiBzdHJpbmcpOiB2b2lkID0+IHtcblx0Ly8gQWxsIGNvbnN0cmFpbnRzIGFyZSBub3cgbWVhbmluZ2xlc3MgdHlwZSBjaGVja3MsIHNvIHJlamVjdCB0aGVtIGFsbFxuXHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0YENvbnN0cmFpbnQgJyR7Y29uc3RyYWludH0nIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBoYXNGaWVsZCBjb25zdHJhaW50cyBmb3IgcmVjb3JkIHR5cGluZyBpbnN0ZWFkLmAsXG5cdCk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2F0aXNmaWVzQ29uc3RyYWludCA9ICh0eXBlOiBUeXBlLCBjb25zdHJhaW50OiBzdHJpbmcpOiBib29sZWFuID0+IHtcblx0Ly8gQWxsIG5vbi1oYXNGaWVsZCBjb25zdHJhaW50cyBhcmUgbWVhbmluZ2xlc3MsIHNvIHRoZXkncmUgbm90IHN1cHBvcnRlZFxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5cblxuXG4vLyBIZWxwZXI6IFJlY3Vyc2l2ZWx5IHB1c2ggYSBjb25zdHJhaW50IHRvIGFsbCB0eXBlIHZhcmlhYmxlcyBpbnNpZGUgYSB0eXBlXG5leHBvcnQgZnVuY3Rpb24gcHJvcGFnYXRlQ29uc3RyYWludFRvVHlwZSh0eXBlOiBUeXBlLCBjb25zdHJhaW50OiBDb25zdHJhaW50KSB7XG5cdHN3aXRjaCAodHlwZS5raW5kKSB7XG5cdFx0Y2FzZSBcInZhcmlhYmxlXCI6XG5cdFx0XHR0eXBlLmNvbnN0cmFpbnRzID0gdHlwZS5jb25zdHJhaW50cyB8fCBbXTtcblx0XHRcdGlmICghdHlwZS5jb25zdHJhaW50cy5zb21lKChjKSA9PiBjb25zdHJhaW50c0VxdWFsKGMsIGNvbnN0cmFpbnQpKSkge1xuXHRcdFx0XHR0eXBlLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcImZ1bmN0aW9uXCI6XG5cdFx0XHRmb3IgKGNvbnN0IHBhcmFtIG9mIHR5cGUucGFyYW1zKSB7XG5cdFx0XHRcdHByb3BhZ2F0ZUNvbnN0cmFpbnRUb1R5cGUocGFyYW0sIGNvbnN0cmFpbnQpO1xuXHRcdFx0fVxuXHRcdFx0cHJvcGFnYXRlQ29uc3RyYWludFRvVHlwZSh0eXBlLnJldHVybiwgY29uc3RyYWludCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwibGlzdFwiOlxuXHRcdFx0cHJvcGFnYXRlQ29uc3RyYWludFRvVHlwZSh0eXBlLmVsZW1lbnQsIGNvbnN0cmFpbnQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcInR1cGxlXCI6XG5cdFx0XHRmb3IgKGNvbnN0IGVsIG9mIHR5cGUuZWxlbWVudHMpIHtcblx0XHRcdFx0cHJvcGFnYXRlQ29uc3RyYWludFRvVHlwZShlbCwgY29uc3RyYWludCk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwicmVjb3JkXCI6XG5cdFx0XHRmb3IgKGNvbnN0IGZpZWxkVHlwZSBvZiBPYmplY3QudmFsdWVzKHR5cGUuZmllbGRzKSkge1xuXHRcdFx0XHRwcm9wYWdhdGVDb25zdHJhaW50VG9UeXBlKGZpZWxkVHlwZSwgY29uc3RyYWludCk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFwidW5pb25cIjpcblx0XHRcdGZvciAoY29uc3QgdCBvZiB0eXBlLnR5cGVzKSB7XG5cdFx0XHRcdHByb3BhZ2F0ZUNvbnN0cmFpbnRUb1R5cGUodCwgY29uc3RyYWludCk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHQvLyBGb3IgcHJpbWl0aXZlcywgdW5pdCwgdW5rbm93bjogZG8gbm90aGluZ1xuXHR9XG59XG5cbi8vIENvbGxlY3QgYWxsIGNvbnN0cmFpbnRzIGZvciBhIHZhcmlhYmxlLCBmb2xsb3dpbmcgdGhlIHN1YnN0aXR1dGlvbiBjaGFpblxuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RBbGxDb25zdHJhaW50c0ZvclZhcihcblx0dmFyTmFtZTogc3RyaW5nLFxuXHRzdWJzdGl0dXRpb246IE1hcDxzdHJpbmcsIFR5cGU+LFxuKTogQ29uc3RyYWludFtdIHtcblx0Y29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRsZXQgY29uc3RyYWludHM6IENvbnN0cmFpbnRbXSA9IFtdO1xuXHRsZXQgY3VycmVudFZhck5hbWUgPSB2YXJOYW1lO1xuXHRsZXQgY3VycmVudFR5cGUgPSBzdWJzdGl0dXRpb24uZ2V0KGN1cnJlbnRWYXJOYW1lKTtcblxuXHR3aGlsZSAoY3VycmVudFR5cGUgJiYgaXNUeXBlS2luZChjdXJyZW50VHlwZSwgXCJ2YXJpYWJsZVwiKSkge1xuXHRcdGlmIChzZWVuLmhhcyhjdXJyZW50VmFyTmFtZSkpIHtcblx0XHRcdGJyZWFrOyAvLyBQcmV2ZW50IGN5Y2xlc1xuXHRcdH1cblx0XHRzZWVuLmFkZChjdXJyZW50VmFyTmFtZSk7XG5cblx0XHRpZiAoY3VycmVudFR5cGUuY29uc3RyYWludHMpIHtcblx0XHRcdGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMuY29uY2F0KGN1cnJlbnRUeXBlLmNvbnN0cmFpbnRzKTtcblx0XHR9XG5cblx0XHRjdXJyZW50VmFyTmFtZSA9IGN1cnJlbnRUeXBlLm5hbWU7XG5cdFx0Y3VycmVudFR5cGUgPSBzdWJzdGl0dXRpb24uZ2V0KGN1cnJlbnRWYXJOYW1lKTtcblx0fVxuXG5cdC8vIEFsc28gY2hlY2sgdGhlIG9yaWdpbmFsIHZhcmlhYmxlXG5cdGNvbnN0IG9yaWdUeXBlID0gc3Vic3RpdHV0aW9uLmdldCh2YXJOYW1lKTtcblx0aWYgKG9yaWdUeXBlICYmIGlzVHlwZUtpbmQob3JpZ1R5cGUsIFwidmFyaWFibGVcIikgJiYgb3JpZ1R5cGUuY29uc3RyYWludHMpIHtcblx0XHRjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmNvbmNhdChvcmlnVHlwZS5jb25zdHJhaW50cyk7XG5cdH1cblxuXHRyZXR1cm4gY29uc3RyYWludHM7XG59XG5cbiBcbi8vIEFmdGVyIHR5cGUgaW5mZXJlbmNlLCB2YWxpZGF0ZSBhbGwgY29uc3RyYWludHMgaW4gdGhlIHN1YnN0aXR1dGlvbiBtYXBcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFsbFN1YnN0aXR1dGlvbkNvbnN0cmFpbnRzKHN0YXRlOiBUeXBlU3RhdGUpIHtcblx0Zm9yIChjb25zdCBbdmFyTmFtZSwgY29uY3JldGVUeXBlXSBvZiBzdGF0ZS5zdWJzdGl0dXRpb24uZW50cmllcygpKSB7XG5cdFx0Ly8gT25seSBjaGVjayBpZiB0aGUgY29uY3JldGVUeXBlIGlzIG5vdCBhIHZhcmlhYmxlXG5cdFx0aWYgKGNvbmNyZXRlVHlwZS5raW5kICE9PSBcInZhcmlhYmxlXCIpIHtcblx0XHRcdC8vIENvbGxlY3QgYWxsIGNvbnN0cmFpbnRzIGZyb20gdGhlIHN1YnN0aXR1dGlvbiBjaGFpblxuXHRcdFx0Y29uc3QgY29uc3RyYWludHNUb0NoZWNrID0gY29sbGVjdEFsbENvbnN0cmFpbnRzRm9yVmFyKFxuXHRcdFx0XHR2YXJOYW1lLFxuXHRcdFx0XHRzdGF0ZS5zdWJzdGl0dXRpb24sXG5cdFx0XHQpO1xuXHRcdFx0Zm9yIChjb25zdCBjb25zdHJhaW50IG9mIGNvbnN0cmFpbnRzVG9DaGVjaykge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0Y29uc3RyYWludC5raW5kID09PSBcImhhc0ZpZWxkXCIgJiZcblx0XHRcdFx0XHRpc1R5cGVLaW5kKGNvbmNyZXRlVHlwZSwgXCJyZWNvcmRcIilcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0aWYgKCEoY29uc3RyYWludC5maWVsZCBpbiBjb25jcmV0ZVR5cGUuZmllbGRzKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHRgUmVjb3JkIHR5cGUgbWlzc2luZyByZXF1aXJlZCBmaWVsZCAnJHtjb25zdHJhaW50LmZpZWxkfSdgLFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gT3B0aW9uYWxseSwgdW5pZnkgZmllbGQgdHlwZXMgaGVyZSBpZiBuZWVkZWRcblx0XHRcdFx0fSBlbHNlIGlmIChjb25zdHJhaW50LmtpbmQgPT09IFwiaXNcIikge1xuXHRcdFx0XHRcdGlmICghc2F0aXNmaWVzQ29uc3RyYWludChjb25jcmV0ZVR5cGUsIGNvbnN0cmFpbnQuY29uc3RyYWludCkpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0YFR5cGUgdmFyaWFibGUgJyR7dmFyTmFtZX0nIHdhcyB1bmlmaWVkIHRvICR7dHlwZVRvU3RyaW5nKFxuXHRcdFx0XHRcdFx0XHRcdGNvbmNyZXRlVHlwZSxcblx0XHRcdFx0XHRcdFx0KX0gYnV0IGRvZXMgbm90IHNhdGlzZnkgY29uc3RyYWludCAnJHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdHJhaW50LmNvbnN0cmFpbnRcblx0XHRcdFx0XHRcdFx0fScuIFRoaXMgdHlwaWNhbGx5IG1lYW5zIGEgcGFydGlhbCBmdW5jdGlvbiBpcyBiZWluZyB1c2VkIGluIGFuIHVuc2FmZSBjb250ZXh0LiBDb25zaWRlciB1c2luZyB0b3RhbCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gT3B0aW9uIG9yIFJlc3VsdCB0eXBlcyBpbnN0ZWFkIG9mIHBhcnRpYWwgZnVuY3Rpb25zIHdpdGggY29uc3RyYWludHMuYCxcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59Il0sIm5hbWVzIjpbImNvbGxlY3RBbGxDb25zdHJhaW50c0ZvclZhciIsInByb3BhZ2F0ZUNvbnN0cmFpbnRUb1R5cGUiLCJzYXRpc2ZpZXNDb25zdHJhaW50Iiwic29sdmVDb25zdHJhaW50Iiwic29sdmVDb25zdHJhaW50cyIsInZhbGlkYXRlQWxsU3Vic3RpdHV0aW9uQ29uc3RyYWludHMiLCJ2YWxpZGF0ZUNvbnN0cmFpbnROYW1lIiwiY29uc3RyYWludHMiLCJzdGF0ZSIsImxvY2F0aW9uIiwiY3VycmVudFN0YXRlIiwiY29uc3RyYWludCIsImtpbmQiLCJzb2x2ZUlzQ29uc3RyYWludCIsInNvbHZlSGFzRmllbGRDb25zdHJhaW50Iiwic29sdmVJbXBsZW1lbnRzQ29uc3RyYWludCIsInNvbHZlQ3VzdG9tQ29uc3RyYWludCIsInR5cGVWYXIiLCJzdWJzdGl0dXRlIiwidHlwZVZhcmlhYmxlIiwic3Vic3RpdHV0aW9uIiwiRXJyb3IiLCJmb3JtYXRUeXBlRXJyb3IiLCJjcmVhdGVUeXBlRXJyb3IiLCJ0eXBlVG9TdHJpbmciLCJsaW5lIiwiY29sdW1uIiwiZXhpc3RpbmdDb25zdHJhaW50IiwiZmluZCIsImMiLCJwdXNoIiwiZmllbGQiLCJmaWVsZHMiLCJuZXdTdGF0ZSIsInVuaWZ5IiwiZmllbGRUeXBlIiwidHlwZSIsInNvbWUiLCJjb25zdHJhaW50c0VxdWFsIiwicGFyYW0iLCJwYXJhbXMiLCJyZXR1cm4iLCJlbGVtZW50IiwiZWwiLCJlbGVtZW50cyIsIk9iamVjdCIsInZhbHVlcyIsInQiLCJ0eXBlcyIsInZhck5hbWUiLCJzZWVuIiwiU2V0IiwiY3VycmVudFZhck5hbWUiLCJjdXJyZW50VHlwZSIsImdldCIsImlzVHlwZUtpbmQiLCJoYXMiLCJhZGQiLCJjb25jYXQiLCJuYW1lIiwib3JpZ1R5cGUiLCJjb25jcmV0ZVR5cGUiLCJlbnRyaWVzIiwiY29uc3RyYWludHNUb0NoZWNrIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztRQTBPZ0JBO2VBQUFBOztRQXRDQUM7ZUFBQUE7O1FBVEhDO2VBQUFBOztRQXJLQUM7ZUFBQUE7O1FBZEFDO2VBQUFBOztRQW9RR0M7ZUFBQUE7O1FBeEZIQztlQUFBQTs7O3FCQXBMMEc7NEJBRXRFOzRCQUN0Qjt5QkFDZ0M7dUJBQ3JDO0FBR2YsTUFBTUYsbUJBQW1CLENBQy9CRyxhQUNBQyxPQUNBQztJQUVBLElBQUlDLGVBQWVGO0lBRW5CLEtBQUssTUFB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