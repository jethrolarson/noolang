{"version":3,"sources":["/workspace/src/parser/combinators.ts"],"sourcesContent":["import type { Token, TokenType } from \"../lexer\";\n\nexport type ParseError = {\n  success: false;\n  error: string;\n  position: number;\n};\n\nexport type ParseSuccess<T> = {\n  success: true;\n  value: T;\n  remaining: Token[];\n};\n\nexport type ParseResult<T> = ParseSuccess<T> | ParseError;\n\nexport type Parser<T> = (tokens: Token[]) => ParseResult<T>;\n\n// Basic token matching\nexport const token =\n  (type: TokenType, value?: string): Parser<Token> =>\n  (tokens: Token[]) => {\n    if (tokens.length === 0) {\n      return {\n        success: false,\n        error: `Expected ${type}${\n          value ? ` '${value}'` : \"\"\n        }, but got end of input`,\n        position: 0,\n      };\n    }\n\n    const [first, ...rest] = tokens;\n    if (first.type === type && (value === undefined || first.value === value)) {\n      return {\n        success: true,\n        value: first,\n        remaining: rest,\n      };\n    }\n\n    return {\n      success: false,\n      error: `Expected ${type}${value ? ` '${value}'` : \"\"}, but got ${\n        first.type\n      } '${first.value}'`,\n      position: first.location.start.line,\n    };\n  };\n\n// Match any token\nexport const anyToken = (): Parser<Token> => (tokens: Token[]) => {\n  if (tokens.length === 0) {\n    return {\n      success: false,\n      error: \"Expected any token, but got end of input\",\n      position: 0,\n    };\n  }\n\n  const [first, ...rest] = tokens;\n  return {\n    success: true,\n    value: first,\n    remaining: rest,\n  };\n};\n\n// Sequence of parsers\nexport const seq =\n  <T extends any[]>(...parsers: { [K in keyof T]: Parser<T[K]> }): Parser<T> =>\n  (tokens: Token[]) => {\n    const results: T[] = [];\n    let remaining = tokens;\n\n    for (const parser of parsers) {\n      const result = parser(remaining);\n      if (!result.success) {\n        return result;\n      }\n      results.push(result.value);\n      remaining = result.remaining;\n    }\n\n    return {\n      success: true,\n      value: results as T,\n      remaining,\n    };\n  };\n\n// Choice between parsers (try each until one succeeds)\nexport const choice =\n  <T>(...parsers: Parser<T>[]): Parser<T> =>\n  (tokens: Token[]) => {\n    let lastError: string = \"\";\n    let lastPosition: number = 0;\n\n    for (const parser of parsers) {\n      const result = parser(tokens);\n      if (result.success) {\n        return result;\n      }\n      // Keep track of the error from the parser that got furthest\n      if (result.position > lastPosition) {\n        lastError = result.error;\n        lastPosition = result.position;\n      }\n    }\n\n    return {\n      success: false,\n      error: lastError,\n      position: lastPosition,\n    };\n  };\n\n// Zero or more repetitions\nexport const many =\n  <T>(parser: Parser<T>): Parser<T[]> =>\n  (tokens: Token[]) => {\n    const results: T[] = [];\n    let remaining = tokens;\n\n    while (remaining.length > 0) {\n      const result = parser(remaining);\n      if (!result.success) {\n        break;\n      }\n      results.push(result.value);\n      remaining = result.remaining;\n    }\n\n    return {\n      success: true,\n      value: results,\n      remaining,\n    };\n  };\n\n// One or more repetitions\nexport const many1 =\n  <T>(parser: Parser<T>): Parser<T[]> =>\n  (tokens: Token[]) => {\n    const manyResult = many(parser)(tokens);\n    if (!manyResult.success || manyResult.value.length === 0) {\n      return {\n        success: false,\n        error: \"Expected at least one occurrence\",\n        position: tokens[0]?.location.start.line || 0,\n      };\n    }\n    return manyResult;\n  };\n\n// Optional parser (zero or one)\nexport const optional =\n  <T>(parser: Parser<T>): Parser<T | null> =>\n  (tokens: Token[]) => {\n    const result = parser(tokens);\n    return result.success\n\t\t\t\t\t? result\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\t\tvalue: null,\n\t\t\t\t\t\t\tremaining: tokens,\n\t\t\t\t\t\t};\n  };\n\n// Transform parse result\nexport const map =\n  <T, U>(parser: Parser<T>, fn: (value: T) => U): Parser<U> =>\n  (tokens: Token[]) => {\n    const result = parser(tokens);\n    return result.success\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\t\tvalue: fn(result.value),\n\t\t\t\t\t\t\tremaining: result.remaining,\n\t\t\t\t\t\t}\n\t\t\t\t\t: result;\n  };\n\n// Lazy parser for recursive grammars\nexport const lazy =\n  <T>(parserFn: () => Parser<T>): Parser<T> =>\n  (tokens: Token[]) =>\n    parserFn()(tokens);\n\n// Separated by something\nexport const sepBy = <T, S>(\n  parser: Parser<T>,\n  separator: Parser<S>,\n): Parser<T[]> => {\n  return (tokens: Token[]) => {\n    const results: T[] = [];\n    let remaining = tokens;\n\n    // Parse first element\n    const firstResult = parser(remaining);\n    if (!firstResult.success) {\n      return {\n        success: true,\n        value: [],\n        remaining,\n      };\n    }\n\n    results.push(firstResult.value);\n    remaining = firstResult.remaining;\n\n    // Parse subsequent elements separated by separator\n    while (remaining.length > 0) {\n      const sepResult = separator(remaining);\n      if (!sepResult.success) {\n        break;\n      }\n\n      const elemResult = parser(sepResult.remaining);\n      if (!elemResult.success) {\n        break;\n      }\n\n      results.push(elemResult.value);\n      remaining = elemResult.remaining;\n    }\n\n    return {\n      success: true,\n      value: results,\n      remaining,\n    };\n  };\n};\n\n// Parse until end of input\nexport const parseAll =\n\t<T>(parser: Parser<T>): Parser<T> =>\n\t(tokens: Token[]) => {\n\t\tconst result = parser(tokens);\n\t\tif (!result.success || !result.remaining.length) {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst unexpected = result.remaining[0];\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: `Unexpected ${unexpected.type} '${unexpected.value}' at end of input`,\n\t\t\tposition: unexpected.location.start.line,\n\t\t};\n\t};\n\n// Convenience parsers for common token types\nexport const identifier = (): Parser<Token> => token(\"IDENTIFIER\");\nexport const number = (): Parser<Token> => token(\"NUMBER\");\nexport const string = (): Parser<Token> => token(\"STRING\");\nexport const keyword = (value: string): Parser<Token> =>\n\ttoken(\"KEYWORD\", value);\nexport const operator = (value: string): Parser<Token> =>\n\ttoken(\"OPERATOR\", value);\nexport const punctuation = (value: string): Parser<Token> =>\n\ttoken(\"PUNCTUATION\", value);\nexport const accessor = (): Parser<Token> => token(\"ACCESSOR\");"],"names":["accessor","anyToken","choice","identifier","keyword","lazy","many","many1","map","number","operator","optional","parseAll","punctuation","sepBy","seq","string","token","type","value","tokens","length","success","error","position","first","rest","undefined","remaining","location","start","line","parsers","results","parser","result","push","lastError","lastPosition","manyResult","fn","parserFn","separator","firstResult","sepResult","elemResult","unexpected"],"mappings":"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"}