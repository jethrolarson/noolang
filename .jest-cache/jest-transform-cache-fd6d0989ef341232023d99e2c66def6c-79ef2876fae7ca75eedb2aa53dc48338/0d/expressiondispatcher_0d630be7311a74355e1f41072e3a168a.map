{"version":3,"sources":["/workspace/src/typer/expression-dispatcher.ts"],"sourcesContent":["// Type expression dispatcher with proper error handling\nimport { \n\ttype Expression, \n\ttype Type,\n\ttype Effect,\n\tunitType\n} from '../ast';\nimport { TypeState, TypeResult, createPureTypeResult } from './types';\nimport {\n\ttypeLiteral,\n\ttypeVariableExpr,\n\ttypeFunction,\n\ttypeBinary,\n\ttypeIf,\n\ttypeList,\n\ttypeRecord,\n\ttypeTuple,\n\ttypeAccessor,\n\ttypeDefinition,\n\ttypeConstraintDefinition,\n\ttypeImplementDefinition,\n} from './type-inference';\nimport { typeApplication, typePipeline } from './function-application';\nimport { typeMatch, typeTypeDefinition } from './pattern-matching';\n\n// Main type inference dispatcher\nexport const typeExpression = (\n\texpr: Expression,\n\tstate: TypeState\n): TypeResult => {\n\tswitch (expr.kind) {\n\t\tcase 'literal':\n\t\t\treturn typeLiteral(expr, state);\n\n\t\tcase 'variable':\n\t\t\treturn typeVariableExpr(expr, state);\n\n\t\tcase 'function':\n\t\t\treturn typeFunction(expr, state);\n\n\t\tcase 'application':\n\t\t\treturn typeApplication(expr, state);\n\n\t\tcase 'binary':\n\t\t\treturn typeBinary(expr, state);\n\n\t\tcase 'if':\n\t\t\treturn typeIf(expr, state);\n\n\t\tcase 'list':\n\t\t\treturn typeList(expr, state);\n\n\t\tcase 'record':\n\t\t\treturn typeRecord(expr, state);\n\n\t\tcase 'tuple':\n\t\t\treturn typeTuple(expr, state);\n\n\t\tcase 'accessor':\n\t\t\treturn typeAccessor(expr, state);\n\n\t\tcase 'definition':\n\t\t\treturn typeDefinition(expr, state);\n\n\t\tcase 'unit':\n\t\t\treturn createPureTypeResult(unitType(), state);\n\n\t\tcase 'type-definition':\n\t\t\treturn typeTypeDefinition(expr, state);\n\n\t\tcase 'constraint-definition':\n\t\t\treturn typeConstraintDefinition(expr, state);\n\n\t\tcase 'implement-definition':\n\t\t\treturn typeImplementDefinition(expr, state);\n\n\t\tcase 'match':\n\t\t\treturn typeMatch(expr, state);\n\n\t\tcase 'pipeline':\n\t\t\treturn typePipeline(expr, state);\n\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown expression kind: ${(expr as any).kind}`);\n\t}\n};"],"names":["typeExpression","expr","state","kind","typeLiteral","typeVariableExpr","typeFunction","typeApplication","typeBinary","typeIf","typeList","typeRecord","typeTuple","typeAccessor","typeDefinition","createPureTypeResult","unitType","typeTypeDefinition","typeConstraintDefinition","typeImplementDefinition","typeMatch","typePipeline","Error"],"mappings":"AAAA,wDAAwD;;;;;+BA0B3CA;;;eAAAA;;;qBApBN;uBACqD;+BAcrD;qCACuC;iCACA;AAGvC,MAAMA,iBAAiB,CAC7BC,MACAC;IAEA,OAAQD,KAAKE,IAAI;QAChB,KAAK;YACJ,OAAOC,IAAAA,0BAAW,EAACH,MAAMC;QAE1B,KAAK;YACJ,OAAOG,IAAAA,+BAAgB,EAACJ,MAAMC;QAE/B,KAAK;YACJ,OAAOI,IAAAA,2BAAY,EAACL,MAAMC;QAE3B,KAAK;YACJ,OAAOK,IAAAA,oCAAe,EAACN,MAAMC;QAE9B,KAAK;YACJ,OAAOM,IAAAA,yBAAU,EAACP,MAAMC;QAEzB,KAAK;YACJ,OAAOO,IAAAA,qBAAM,EAACR,MAAMC;QAErB,KAAK;YACJ,OAAOQ,IAAAA,uBAAQ,EAACT,MAAMC;QAEvB,KAAK;YACJ,OAAOS,IAAAA,yBAAU,EAACV,MAAMC;QAEzB,KAAK;YACJ,OAAOU,IAAAA,wBAAS,EAACX,MAAMC;QAExB,KAAK;YACJ,OAAOW,IAAAA,2BAAY,EAACZ,MAAMC;QAE3B,KAAK;YACJ,OAAOY,IAAAA,6BAAc,EAACb,MAAMC;QAE7B,KAAK;YACJ,OAAOa,IAAAA,2BAAoB,EAACC,IAAAA,aAAQ,KAAId;QAEzC,KAAK;YACJ,OAAOe,IAAAA,mCAAkB,EAAChB,MAAMC;QAEjC,KAAK;YACJ,OAAOgB,IAAAA,uCAAwB,EAACjB,MAAMC;QAEvC,KAAK;YACJ,OAAOiB,IAAAA,sCAAuB,EAAClB,MAAMC;QAEtC,KAAK;YACJ,OAAOkB,IAAAA,0BAAS,EAACnB,MAAMC;QAExB,KAAK;YACJ,OAAOmB,IAAAA,iCAAY,EAACpB,MAAMC;QAE3B;YACC,MAAM,IAAIoB,MAAM,CAAC,yBAAyB,EAAE,AAACrB,KAAaE,IAAI,EAAE;IAClE;AACD"}