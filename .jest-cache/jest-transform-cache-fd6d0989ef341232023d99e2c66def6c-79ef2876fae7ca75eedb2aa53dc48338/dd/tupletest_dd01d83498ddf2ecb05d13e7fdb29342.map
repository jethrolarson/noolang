{"version":3,"sources":["/workspace/test/tuple.test.ts"],"sourcesContent":["import { Evaluator, Value } from \"../src/evaluator\";\nimport { parse } from \"../src/parser/parser\";\nimport { Lexer } from \"../src/lexer\";\n\nfunction unwrapValue(val: Value): any {\n  if (val === null) return null;\n  if (typeof val !== \"object\") return val;\n  switch (val.tag) {\n    case \"number\":\n      return val.value;\n    case \"string\":\n      return val.value;\n    case \"constructor\":\n      if (val.name === \"True\") return true;\n      if (val.name === \"False\") return false;\n      return val;\n    case \"list\":\n      return val.values.map(unwrapValue);\n    case \"tuple\":\n      return val.values.map(unwrapValue);\n    case \"record\": {\n      const obj: any = {};\n      for (const k in val.fields) obj[k] = unwrapValue(val.fields[k]);\n      return obj;\n    }\n    default:\n      return val;\n  }\n}\n\ndescribe(\"Tuple Native Functions\", () => {\n  const evaluateSource = (source: string) => {\n    const evaluator = new Evaluator();\n    const lexer = new Lexer(source);\n    return evaluator.evaluateProgram(parse(lexer.tokenize()));\n  };\n\n  describe(\"tupleLength\", () => {\n    test(\"length of empty tuple\", () => {\n      const source = \"tuple = {}; tupleLength tuple\";\n      // { } is now unit, not an empty tuple, so this should throw an error\n      expect(() => evaluateSource(source)).toThrow(\n        \"tupleLength requires a tuple\",\n      );\n    });\n    test(\"length of singleton tuple\", () => {\n      const source = \"tuple = { 1 }; tupleLength tuple\";\n      const result = evaluateSource(source);\n      expect(unwrapValue(result.finalResult)).toBe(1);\n    });\n    test(\"length of pair tuple\", () => {\n      const source = \"tuple = { 1, 2 }; tupleLength tuple\";\n      const result = evaluateSource(source);\n      expect(unwrapValue(result.finalResult)).toBe(2);\n    });\n  });\n\n  describe(\"tupleIsEmpty\", () => {\n    test(\"returns true for empty tuple\", () => {\n      const source = \"tuple = {}; tupleIsEmpty tuple\";\n      // { } is now unit, not an empty tuple, so this should throw an error\n      expect(() => evaluateSource(source)).toThrow(\n        \"tupleIsEmpty requires a tuple\",\n      );\n    });\n    test(\"returns false for non-empty tuple\", () => {\n      const source = \"tuple = { 1, 2, 3 }; tupleIsEmpty tuple\";\n      const result = evaluateSource(source);\n      expect(unwrapValue(result.finalResult)).toBe(false);\n    });\n  });\n});\n"],"names":["unwrapValue","val","tag","value","name","values","map","obj","k","fields","describe","evaluateSource","source","evaluator","Evaluator","lexer","Lexer","evaluateProgram","parse","tokenize","test","expect","toThrow","result","finalResult","toBe"],"mappings":";;;;2BAAiC;wBACX;uBACA;AAEtB,SAASA,YAAYC,GAAU;IAC7B,IAAIA,QAAQ,MAAM,OAAO;IACzB,IAAI,OAAOA,QAAQ,UAAU,OAAOA;IACpC,OAAQA,IAAIC,GAAG;QACb,KAAK;YACH,OAAOD,IAAIE,KAAK;QAClB,KAAK;YACH,OAAOF,IAAIE,KAAK;QAClB,KAAK;YACH,IAAIF,IAAIG,IAAI,KAAK,QAAQ,OAAO;YAChC,IAAIH,IAAIG,IAAI,KAAK,SAAS,OAAO;YACjC,OAAOH;QACT,KAAK;YACH,OAAOA,IAAII,MAAM,CAACC,GAAG,CAACN;QACxB,KAAK;YACH,OAAOC,IAAII,MAAM,CAACC,GAAG,CAACN;QACxB,KAAK;YAAU;gBACb,MAAMO,MAAW,CAAC;gBAClB,IAAK,MAAMC,KAAKP,IAAIQ,MAAM,CAAEF,GAAG,CAACC,EAAE,GAAGR,YAAYC,IAAIQ,MAAM,CAACD,EAAE;gBAC9D,OAAOD;YACT;QACA;YACE,OAAON;IACX;AACF;AAEAS,SAAS,0BAA0B;IACjC,MAAMC,iBAAiB,CAACC;QACtB,MAAMC,YAAY,IAAIC,oBAAS;QAC/B,MAAMC,QAAQ,IAAIC,YAAK,CAACJ;QACxB,OAAOC,UAAUI,eAAe,CAACC,IAAAA,aAAK,EAACH,MAAMI,QAAQ;IACvD;IAEAT,SAAS,eAAe;QACtBU,KAAK,yBAAyB;YAC5B,MAAMR,SAAS;YACf,qEAAqE;YACrES,OAAO,IAAMV,eAAeC,SAASU,OAAO,CAC1C;QAEJ;QACAF,KAAK,6BAA6B;YAChC,MAAMR,SAAS;YACf,MAAMW,SAASZ,eAAeC;YAC9BS,OAAOrB,YAAYuB,OAAOC,WAAW,GAAGC,IAAI,CAAC;QAC/C;QACAL,KAAK,wBAAwB;YAC3B,MAAMR,SAAS;YACf,MAAMW,SAASZ,eAAeC;YAC9BS,OAAOrB,YAAYuB,OAAOC,WAAW,GAAGC,IAAI,CAAC;QAC/C;IACF;IAEAf,SAAS,gBAAgB;QACvBU,KAAK,gCAAgC;YACnC,MAAMR,SAAS;YACf,qEAAqE;YACrES,OAAO,IAAMV,eAAeC,SAASU,OAAO,CAC1C;QAEJ;QACAF,KAAK,qCAAqC;YACxC,MAAMR,SAAS;YACf,MAAMW,SAASZ,eAAeC;YAC9BS,OAAOrB,YAAYuB,OAAOC,WAAW,GAAGC,IAAI,CAAC;QAC/C;IACF;AACF"}