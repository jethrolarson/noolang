9503dfdf7f0077a69dd6144b6badce64
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get substitute () {
        return substitute;
    },
    get substituteConstraint () {
        return substituteConstraint;
    }
});
const _helpers = require("./helpers");
// Performance tracking for substitute
let substituteCallCount = 0;
let totalSubstituteTime = 0;
// Cache for substitution results to avoid repeated work
const substituteCache = new Map();
const substitute = (type, substitution)=>{
    const startTime = Date.now();
    substituteCallCount++;
    let result;
    // Generate cache key - only for type variables as they're most common
    if (type.kind === 'variable' && substitution.size < 20) {
        const cacheKey = `${type.name}:${Array.from(substitution.entries()).map(([k, v])=>`${k}=${v.kind}`).join(',')}`;
        const cached = substituteCache.get(cacheKey);
        if (cached) {
            result = cached;
        } else {
            result = substituteWithCache(type, substitution, new Set());
            if (substituteCache.size < 1000) {
                substituteCache.set(cacheKey, result);
            }
        }
    } else {
        result = substituteWithCache(type, substitution, new Set());
    }
    const elapsed = Date.now() - startTime;
    totalSubstituteTime += elapsed;
    // Stats tracking (disabled for clean output)
    return result;
};
const substituteWithCache = (type, substitution, seen)=>{
    switch(type.kind){
        case "variable":
            {
                if (seen.has(type.name)) {
                    // Cycle detected, return original variable
                    return type;
                }
                const sub = substitution.get(type.name);
                if (sub) {
                    seen.add(type.name);
                    const result = substituteWithCache(sub, substitution, seen);
                    seen.delete(type.name);
                    return result;
                }
                return type;
            }
        case "function":
            return {
                ...type,
                params: type.params.map((param)=>substituteWithCache(param, substitution, seen)),
                return: substituteWithCache(type.return, substitution, seen),
                constraints: type.constraints?.map((c)=>substituteConstraint(c, substitution))
            };
        case "list":
            return {
                ...type,
                element: substituteWithCache(type.element, substitution, seen)
            };
        case "tuple":
            return {
                ...type,
                elements: type.elements.map((el)=>substituteWithCache(el, substitution, seen))
            };
        case "record":
            return {
                ...type,
                fields: (0, _helpers.mapObject)(type.fields, (v, k)=>substituteWithCache(v, substitution, seen))
            };
        case "union":
            return {
                ...type,
                types: type.types.map((t)=>substituteWithCache(t, substitution, seen))
            };
        case "variant":
            return {
                ...type,
                args: type.args.map((arg)=>substituteWithCache(arg, substitution, seen))
            };
        default:
            return type;
    }
};
const substituteConstraint = (constraint, substitution)=>{
    switch(constraint.kind){
        case "is":
            return constraint; // No substitution needed for is constraints
        case "hasField":
            return {
                ...constraint,
                fieldType: substitute(constraint.fieldType, substitution)
            };
        case "implements":
            return constraint; // No substitution needed for implements constraints
        case "custom":
            return {
                ...constraint,
                args: constraint.args.map((arg)=>substitute(arg, substitution))
            };
        default:
            return constraint;
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Uvc3JjL3R5cGVyL3N1YnN0aXR1dGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHlwZSBUeXBlLCB0eXBlIENvbnN0cmFpbnQgfSBmcm9tIFwiLi4vYXN0XCI7XG5pbXBvcnQgeyBtYXBPYmplY3QgfSBmcm9tIFwiLi9oZWxwZXJzXCI7XG5cbi8vIFBlcmZvcm1hbmNlIHRyYWNraW5nIGZvciBzdWJzdGl0dXRlXG5sZXQgc3Vic3RpdHV0ZUNhbGxDb3VudCA9IDA7XG5sZXQgdG90YWxTdWJzdGl0dXRlVGltZSA9IDA7XG5cbi8vIENhY2hlIGZvciBzdWJzdGl0dXRpb24gcmVzdWx0cyB0byBhdm9pZCByZXBlYXRlZCB3b3JrXG5jb25zdCBzdWJzdGl0dXRlQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgVHlwZT4oKTtcblxuLy8gQXBwbHkgc3Vic3RpdHV0aW9uIHRvIGEgdHlwZVxuZXhwb3J0IGNvbnN0IHN1YnN0aXR1dGUgPSAoXG5cdHR5cGU6IFR5cGUsXG5cdHN1YnN0aXR1dGlvbjogTWFwPHN0cmluZywgVHlwZT4sXG4pOiBUeXBlID0+IHtcblx0Y29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0c3Vic3RpdHV0ZUNhbGxDb3VudCsrO1xuXHRcblx0bGV0IHJlc3VsdDogVHlwZTtcblx0Ly8gR2VuZXJhdGUgY2FjaGUga2V5IC0gb25seSBmb3IgdHlwZSB2YXJpYWJsZXMgYXMgdGhleSdyZSBtb3N0IGNvbW1vblxuXHRpZiAodHlwZS5raW5kID09PSAndmFyaWFibGUnICYmIHN1YnN0aXR1dGlvbi5zaXplIDwgMjApIHtcblx0XHRjb25zdCBjYWNoZUtleSA9IGAke3R5cGUubmFtZX06JHtBcnJheS5mcm9tKHN1YnN0aXR1dGlvbi5lbnRyaWVzKCkpLm1hcCgoW2ssdl0pID0+IGAke2t9PSR7di5raW5kfWApLmpvaW4oJywnKX1gO1xuXHRcdGNvbnN0IGNhY2hlZCA9IHN1YnN0aXR1dGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xuXHRcdGlmIChjYWNoZWQpIHtcblx0XHRcdHJlc3VsdCA9IGNhY2hlZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gc3Vic3RpdHV0ZVdpdGhDYWNoZSh0eXBlLCBzdWJzdGl0dXRpb24sIG5ldyBTZXQoKSk7XG5cdFx0XHRpZiAoc3Vic3RpdHV0ZUNhY2hlLnNpemUgPCAxMDAwKSB7IC8vIFByZXZlbnQgdW5ib3VuZGVkIGNhY2hlIGdyb3d0aFxuXHRcdFx0XHRzdWJzdGl0dXRlQ2FjaGUuc2V0KGNhY2hlS2V5LCByZXN1bHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSBzdWJzdGl0dXRlV2l0aENhY2hlKHR5cGUsIHN1YnN0aXR1dGlvbiwgbmV3IFNldCgpKTtcblx0fVxuXHRcblx0Y29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cdHRvdGFsU3Vic3RpdHV0ZVRpbWUgKz0gZWxhcHNlZDtcblx0XG5cdC8vIFN0YXRzIHRyYWNraW5nIChkaXNhYmxlZCBmb3IgY2xlYW4gb3V0cHV0KVxuXHRcblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHN1YnN0aXR1dGVXaXRoQ2FjaGUgPSAoXG5cdHR5cGU6IFR5cGUsXG5cdHN1YnN0aXR1dGlvbjogTWFwPHN0cmluZywgVHlwZT4sXG5cdHNlZW46IFNldDxzdHJpbmc+LFxuKTogVHlwZSA9PiB7XG5cdHN3aXRjaCAodHlwZS5raW5kKSB7XG5cdFx0Y2FzZSBcInZhcmlhYmxlXCI6IHtcblx0XHRcdGlmIChzZWVuLmhhcyh0eXBlLm5hbWUpKSB7XG5cdFx0XHRcdC8vIEN5Y2xlIGRldGVjdGVkLCByZXR1cm4gb3JpZ2luYWwgdmFyaWFibGVcblx0XHRcdFx0cmV0dXJuIHR5cGU7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBzdWIgPSBzdWJzdGl0dXRpb24uZ2V0KHR5cGUubmFtZSk7XG5cdFx0XHRpZiAoc3ViKSB7XG5cdFx0XHRcdHNlZW4uYWRkKHR5cGUubmFtZSk7XG5cdFx0XHRcdGNvbnN0IHJlc3VsdCA9IHN1YnN0aXR1dGVXaXRoQ2FjaGUoc3ViLCBzdWJzdGl0dXRpb24sIHNlZW4pO1xuXHRcdFx0XHRzZWVuLmRlbGV0ZSh0eXBlLm5hbWUpO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHR5cGU7XG5cdFx0fVxuXHRcdGNhc2UgXCJmdW5jdGlvblwiOlxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Li4udHlwZSxcblx0XHRcdFx0cGFyYW1zOiB0eXBlLnBhcmFtcy5tYXAoKHBhcmFtKSA9PlxuXHRcdFx0XHRcdHN1YnN0aXR1dGVXaXRoQ2FjaGUocGFyYW0sIHN1YnN0aXR1dGlvbiwgc2VlbiksXG5cdFx0XHRcdCksXG5cdFx0XHRcdHJldHVybjogc3Vic3RpdHV0ZVdpdGhDYWNoZSh0eXBlLnJldHVybiwgc3Vic3RpdHV0aW9uLCBzZWVuKSxcblx0XHRcdFx0Y29uc3RyYWludHM6IHR5cGUuY29uc3RyYWludHM/Lm1hcCgoYykgPT5cblx0XHRcdFx0XHRzdWJzdGl0dXRlQ29uc3RyYWludChjLCBzdWJzdGl0dXRpb24pLFxuXHRcdFx0XHQpLFxuXHRcdFx0fTtcblx0XHRjYXNlIFwibGlzdFwiOlxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Li4udHlwZSxcblx0XHRcdFx0ZWxlbWVudDogc3Vic3RpdHV0ZVdpdGhDYWNoZSh0eXBlLmVsZW1lbnQsIHN1YnN0aXR1dGlvbiwgc2VlbiksXG5cdFx0XHR9O1xuXHRcdGNhc2UgXCJ0dXBsZVwiOlxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Li4udHlwZSxcblx0XHRcdFx0ZWxlbWVudHM6IHR5cGUuZWxlbWVudHMubWFwKChlbCkgPT5cblx0XHRcdFx0XHRzdWJzdGl0dXRlV2l0aENhY2hlKGVsLCBzdWJzdGl0dXRpb24sIHNlZW4pLFxuXHRcdFx0XHQpLFxuXHRcdFx0fTtcblx0XHRjYXNlIFwicmVjb3JkXCI6XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQuLi50eXBlLFxuXHRcdFx0XHRmaWVsZHM6IG1hcE9iamVjdCh0eXBlLmZpZWxkcywgKHYsIGspID0+XG5cdFx0XHRcdFx0c3Vic3RpdHV0ZVdpdGhDYWNoZSh2LCBzdWJzdGl0dXRpb24sIHNlZW4pLFxuXHRcdFx0XHQpLFxuXHRcdFx0fTtcblx0XHRjYXNlIFwidW5pb25cIjpcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdC4uLnR5cGUsXG5cdFx0XHRcdHR5cGVzOiB0eXBlLnR5cGVzLm1hcCgodCkgPT5cblx0XHRcdFx0XHRzdWJzdGl0dXRlV2l0aENhY2hlKHQsIHN1YnN0aXR1dGlvbiwgc2VlbiksXG5cdFx0XHRcdCksXG5cdFx0XHR9O1xuXHRcdGNhc2UgXCJ2YXJpYW50XCI6XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQuLi50eXBlLFxuXHRcdFx0XHRhcmdzOiB0eXBlLmFyZ3MubWFwKChhcmcpID0+XG5cdFx0XHRcdFx0c3Vic3RpdHV0ZVdpdGhDYWNoZShhcmcsIHN1YnN0aXR1dGlvbiwgc2VlbiksXG5cdFx0XHRcdCksXG5cdFx0XHR9O1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gdHlwZTtcblx0fVxufTtcblxuLy8gQXBwbHkgc3Vic3RpdHV0aW9uIHRvIGEgY29uc3RyYWludFxuZXhwb3J0IGNvbnN0IHN1YnN0aXR1dGVDb25zdHJhaW50ID0gKFxuXHRjb25zdHJhaW50OiBDb25zdHJhaW50LFxuXHRzdWJzdGl0dXRpb246IE1hcDxzdHJpbmcsIFR5cGU+LFxuKTogQ29uc3RyYWludCA9PiB7XG5cdHN3aXRjaCAoY29uc3RyYWludC5raW5kKSB7XG5cdFx0Y2FzZSBcImlzXCI6XG5cdFx0XHRyZXR1cm4gY29uc3RyYWludDsgLy8gTm8gc3Vic3RpdHV0aW9uIG5lZWRlZCBmb3IgaXMgY29uc3RyYWludHNcblx0XHRjYXNlIFwiaGFzRmllbGRcIjpcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdC4uLmNvbnN0cmFpbnQsXG5cdFx0XHRcdGZpZWxkVHlwZTogc3Vic3RpdHV0ZShjb25zdHJhaW50LmZpZWxkVHlwZSwgc3Vic3RpdHV0aW9uKSxcblx0XHRcdH07XG5cdFx0Y2FzZSBcImltcGxlbWVudHNcIjpcblx0XHRcdHJldHVybiBjb25zdHJhaW50OyAvLyBObyBzdWJzdGl0dXRpb24gbmVlZGVkIGZvciBpbXBsZW1lbnRzIGNvbnN0cmFpbnRzXG5cdFx0Y2FzZSBcImN1c3RvbVwiOlxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Li4uY29uc3RyYWludCxcblx0XHRcdFx0YXJnczogY29uc3RyYWludC5hcmdzLm1hcCgoYXJnKSA9PiBzdWJzdGl0dXRlKGFyZywgc3Vic3RpdHV0aW9uKSksXG5cdFx0XHR9O1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gY29uc3RyYWludDtcblx0fVxufTsiXSwibmFtZXMiOlsic3Vic3RpdHV0ZSIsInN1YnN0aXR1dGVDb25zdHJhaW50Iiwic3Vic3RpdHV0ZUNhbGxDb3VudCIsInRvdGFsU3Vic3RpdHV0ZVRpbWUiLCJzdWJzdGl0dXRlQ2FjaGUiLCJNYXAiLCJ0eXBlIiwic3Vic3RpdHV0aW9uIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJlc3VsdCIsImtpbmQiLCJzaXplIiwiY2FjaGVLZXkiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwiZW50cmllcyIsIm1hcCIsImsiLCJ2Iiwiam9pbiIsImNhY2hlZCIsImdldCIsInN1YnN0aXR1dGVXaXRoQ2FjaGUiLCJTZXQiLCJzZXQiLCJlbGFwc2VkIiwic2VlbiIsImhhcyIsInN1YiIsImFkZCIsImRlbGV0ZSIsInBhcmFtcyIsInBhcmFtIiwicmV0dXJuIiwiY29uc3RyYWludHMiLCJjIiwiZWxlbWVudCIsImVsZW1lbnRzIiwiZWwiLCJmaWVsZHMiLCJtYXBPYmplY3QiLCJ0eXBlcyIsInQiLCJhcmdzIiwiYXJnIiwiY29uc3RyYWludCIsImZpZWxkVHlwZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7UUFXYUE7ZUFBQUE7O1FBc0dBQztlQUFBQTs7O3lCQWhIYTtBQUUxQixzQ0FBc0M7QUFD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