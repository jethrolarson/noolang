{"version":3,"sources":["/workspace/src/typer/type-operations.ts"],"sourcesContent":["import * as fs from \"node:fs\";\nimport * as path from \"node:path\";\nimport {\n\ttype Type,\n\ttype Expression,\n\ttype Program,\n\ttypeVariable,\n\tunitType,\n} from '../ast';\nimport { parse } from '../parser/parser';\nimport { Lexer } from '../lexer';\nimport { type TypeState, type TypeEnvironment, type TypeScheme, createConstraintRegistry } from './types';\nimport { substitute } from './substitute';\nimport { typeExpression } from './expression-dispatcher';\nimport { constraintsEqual } from './helpers';\n\n// Fresh type variable generation - optimized to avoid string concatenation\nexport const freshTypeVariable = (state: TypeState): [Type, TypeState] => {\n\tconst newCounter = state.counter + 1;\n\tconst newType = typeVariable(`Î±${newCounter}`);\n\t// Avoid spreading the entire state object for better performance\n\treturn [newType, { \n\t\t...state, \n\t\tcounter: newCounter \n\t}];\n};\n\n// Collect all free type variables in a type\nexport const freeTypeVars = (\n\ttype: Type,\n\tacc: Set<string> = new Set()\n): Set<string> => {\n\tswitch (type.kind) {\n\t\tcase 'variable':\n\t\t\tacc.add(type.name);\n\t\t\tbreak;\n\t\tcase 'function':\n\t\t\tfor (const param of type.params) freeTypeVars(param, acc);\n\t\t\tfreeTypeVars(type.return, acc);\n\t\t\tbreak;\n\t\tcase 'list':\n\t\t\tfreeTypeVars(type.element, acc);\n\t\t\tbreak;\n\t\tcase 'tuple':\n\t\t\tfor (const el of type.elements) freeTypeVars(el, acc);\n\t\t\tbreak;\n\t\tcase 'record':\n\t\t\tObject.values(type.fields).forEach(v => freeTypeVars(v, acc));\n\t\t\tbreak;\n\t\tcase 'union':\n\t\t\ttype.types.forEach(t => freeTypeVars(t, acc));\n\t\t\tbreak;\n\t\tcase 'variant':\n\t\t\ttype.args.forEach(arg => freeTypeVars(arg, acc));\n\t\t\tbreak;\n\t}\n\treturn acc;\n};\n\n// Collect all free type variables in the environment\nexport const freeTypeVarsEnv = (env: TypeEnvironment): Set<string> => {\n\tconst acc = new Set<string>();\n\tfor (const scheme of env.values()) {\n\t\tfreeTypeVars(scheme.type, acc);\n\t}\n\treturn acc;\n};\n\n// Generalize a type with respect to the environment\nexport const generalize = (\n\ttype: Type,\n\tenv: TypeEnvironment,\n\tsubstitution: Map<string, Type>\n): TypeScheme => {\n\t// Apply current substitution to the type before generalizing\n\tconst substitutedType = substitute(type, substitution);\n\tconst typeVars = freeTypeVars(substitutedType);\n\tconst envVars = freeTypeVarsEnv(env);\n\tconst quantifiedVars: string[] = [];\n\n\tfor (const varName of typeVars) {\n\t\tif (!envVars.has(varName)) {\n\t\t\tquantifiedVars.push(varName);\n\t\t}\n\t}\n\treturn { type: substitutedType, quantifiedVars };\n};\n\n// Instantiate a type scheme by freshening all quantified variables (threading state)\nexport const instantiate = (\n\tscheme: TypeScheme,\n\tstate: TypeState\n): [Type, TypeState] => {\n\tconst mapping = new Map<string, Type>();\n\tlet currentState = state;\n\tfor (const varName of scheme.quantifiedVars) {\n\t\tconst [freshVar, newState] = freshTypeVariable(currentState);\n\t\tmapping.set(varName, freshVar);\n\t\tcurrentState = newState;\n\t}\n\n\tconst [instantiatedType, finalState] = freshenTypeVariables(\n\t\tscheme.type,\n\t\tmapping,\n\t\tcurrentState\n\t);\n\n\treturn [instantiatedType, finalState];\n};\n\n// Replace type variables with fresh ones, threading state\nexport const freshenTypeVariables = (\n\ttype: Type,\n\tmapping: Map<string, Type> = new Map(),\n\tstate: TypeState\n): [Type, TypeState] => {\n\tswitch (type.kind) {\n\t\tcase 'variable': {\n\t\t\tconst freshVar = mapping.get(type.name);\n\t\t\tif (freshVar) {\n\t\t\t\t// Copy constraints from the original variable to the fresh one\n\t\t\t\tif (freshVar.kind === 'variable') {\n\t\t\t\t\tfreshVar.constraints = freshVar.constraints || [];\n\t\t\t\t\tif (type.constraints) {\n\t\t\t\t\t\tfor (const c of type.constraints) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!freshVar.constraints.some(\n\t\t\t\t\t\t\t\t\texisting => constraintsEqual(existing, c)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tfreshVar.constraints.push(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [freshVar, state];\n\t\t\t}\n\t\t\treturn [type, state];\n\t\t}\n\t\tcase 'function': {\n\t\t\tlet currentState = state;\n\t\t\tconst newParams: Type[] = [];\n\t\t\tfor (const param of type.params) {\n\t\t\t\tconst [newParam, nextState] = freshenTypeVariables(\n\t\t\t\t\tparam,\n\t\t\t\t\tmapping,\n\t\t\t\t\tcurrentState\n\t\t\t\t);\n\t\t\t\tnewParams.push(newParam);\n\t\t\t\tcurrentState = nextState;\n\t\t\t}\n\t\t\tconst [newReturn, finalState] = freshenTypeVariables(\n\t\t\t\ttype.return,\n\t\t\t\tmapping,\n\t\t\t\tcurrentState\n\t\t\t);\n\t\t\treturn [{ ...type, params: newParams, return: newReturn }, finalState];\n\t\t}\n\t\tcase 'list': {\n\t\t\tconst [newElem, nextState] = freshenTypeVariables(\n\t\t\t\ttype.element,\n\t\t\t\tmapping,\n\t\t\t\tstate\n\t\t\t);\n\t\t\treturn [{ ...type, element: newElem }, nextState];\n\t\t}\n\t\tcase 'tuple': {\n\t\t\tlet currentState = state;\n\t\t\tconst newElems: Type[] = [];\n\t\t\tfor (const el of type.elements) {\n\t\t\t\tconst [newEl, nextState] = freshenTypeVariables(\n\t\t\t\t\tel,\n\t\t\t\t\tmapping,\n\t\t\t\t\tcurrentState\n\t\t\t\t);\n\t\t\t\tnewElems.push(newEl);\n\t\t\t\tcurrentState = nextState;\n\t\t\t}\n\t\t\treturn [{ ...type, elements: newElems }, currentState];\n\t\t}\n\t\tcase 'record': {\n\t\t\tlet currentState = state;\n\t\t\tconst newFields: { [key: string]: Type } = {};\n\t\t\tfor (const [key, fieldType] of Object.entries(type.fields)) {\n\t\t\t\tconst [newField, nextState] = freshenTypeVariables(\n\t\t\t\t\tfieldType,\n\t\t\t\t\tmapping,\n\t\t\t\t\tcurrentState\n\t\t\t\t);\n\t\t\t\tnewFields[key] = newField;\n\t\t\t\tcurrentState = nextState;\n\t\t\t}\n\t\t\treturn [{ ...type, fields: newFields }, currentState];\n\t\t}\n\t\tcase 'union': {\n\t\t\tlet currentState = state;\n\t\t\tconst newTypes: Type[] = [];\n\t\t\tfor (const t of type.types) {\n\t\t\t\tconst [newType, nextState] = freshenTypeVariables(\n\t\t\t\t\tt,\n\t\t\t\t\tmapping,\n\t\t\t\t\tcurrentState\n\t\t\t\t);\n\t\t\t\tnewTypes.push(newType);\n\t\t\t\tcurrentState = nextState;\n\t\t\t}\n\t\t\treturn [{ ...type, types: newTypes }, currentState];\n\t\t}\n\t\tcase 'variant': {\n\t\t\tlet currentState = state;\n\t\t\tconst newArgs: Type[] = [];\n\t\t\tfor (const arg of type.args) {\n\t\t\t\tconst [newArg, nextState] = freshenTypeVariables(\n\t\t\t\t\targ,\n\t\t\t\t\tmapping,\n\t\t\t\t\tcurrentState\n\t\t\t\t);\n\t\t\t\tnewArgs.push(newArg);\n\t\t\t\tcurrentState = nextState;\n\t\t\t}\n\t\t\treturn [{ ...type, args: newArgs }, currentState];\n\t\t}\n\t\tdefault:\n\t\t\treturn [type, state];\n\t}\n};\n\n// Helper to flatten semicolon-separated binary expressions into individual statements\nexport const flattenStatements = (expr: Expression): Expression[] => {\n\tif (expr.kind === 'binary' && expr.operator === ';') {\n\t\treturn [...flattenStatements(expr.left), ...flattenStatements(expr.right)];\n\t}\n\treturn [expr];\n};\n\n// Load standard library from stdlib.noo\nexport const loadStdlib = (state: TypeState): TypeState => {\n\ttry {\n\t\t// Find stdlib.noo relative to this file\n\t\tconst stdlibPath = path.join(__dirname, '..', '..', 'stdlib.noo');\n\n\t\tif (!fs.existsSync(stdlibPath)) {\n\t\t\tconsole.warn(`Warning: stdlib.noo not found at ${stdlibPath}`);\n\t\t\treturn state;\n\t\t}\n\n\t\tconst stdlibContent = fs.readFileSync(stdlibPath, 'utf-8');\n\t\tconst lexer = new Lexer(stdlibContent);\n\t\tconst tokens = lexer.tokenize();\n\t\tconst stdlibProgram = parse(tokens);\n\n\t\t// Flatten any semicolon-separated statements\n\t\tconst allStatements: Expression[] = [];\n\t\tfor (const statement of stdlibProgram.statements) {\n\t\t\tallStatements.push(...flattenStatements(statement));\n\t\t}\n\n\t\tlet currentState = state;\n\t\tfor (const statement of allStatements) {\n\t\t\tconst result = typeExpression(statement, currentState);\n\t\t\tcurrentState = result.state;\n\t\t}\n\n\t\treturn currentState;\n\t} catch (error) {\n\t\tconsole.warn(`Warning: Failed to load stdlib.noo:`, error);\n\t\treturn state;\n\t}\n};\n\n// Initialize type state\nexport const createTypeState = (): TypeState => ({\n\tenvironment: new Map(),\n\tsubstitution: new Map(),\n\tcounter: 0,\n\tconstraints: [],\n\tadtRegistry: new Map(),\n\taccessorCache: new Map(),\n\tconstraintRegistry: createConstraintRegistry(),\n});\n\n// Clean substitutions from type state while preserving environment and other state\n// This is used in REPL to prevent type pollution between evaluations\nexport const cleanSubstitutions = (state: TypeState): TypeState => ({\n\t...state,\n\tsubstitution: new Map(), // Clear substitutions but keep environment\n\tconstraints: [], // Clear constraints as well\n});"],"names":["cleanSubstitutions","createTypeState","flattenStatements","freeTypeVars","freeTypeVarsEnv","freshTypeVariable","freshenTypeVariables","generalize","instantiate","loadStdlib","state","newCounter","counter","newType","typeVariable","type","acc","Set","kind","add","name","param","params","return","element","el","elements","Object","values","fields","forEach","v","types","t","args","arg","env","scheme","substitution","substitutedType","substitute","typeVars","envVars","quantifiedVars","varName","has","push","mapping","Map","currentState","freshVar","newState","set","instantiatedType","finalState","get","constraints","c","some","existing","constraintsEqual","newParams","newParam","nextState","newReturn","newElem","newElems","newEl","newFields","key","fieldType","entries","newField","newTypes","newArgs","newArg","expr","operator","left","right","stdlibPath","path","join","__dirname","fs","existsSync","console","warn","stdlibContent","readFileSync","lexer","Lexer","tokens","tokenize","stdlibProgram","parse","allStatements","statement","statements","result","typeExpression","error","environment","adtRegistry","accessorCache","constraintRegistry","createConstraintRegistry"],"mappings":"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"}