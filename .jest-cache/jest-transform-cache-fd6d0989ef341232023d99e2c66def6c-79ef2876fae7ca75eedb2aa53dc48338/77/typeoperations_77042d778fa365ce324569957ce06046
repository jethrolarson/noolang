96ed79cfc9f61046fb91fe75856c1b8c
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get cleanSubstitutions () {
        return cleanSubstitutions;
    },
    get createTypeState () {
        return createTypeState;
    },
    get flattenStatements () {
        return flattenStatements;
    },
    get freeTypeVars () {
        return freeTypeVars;
    },
    get freeTypeVarsEnv () {
        return freeTypeVarsEnv;
    },
    get freshTypeVariable () {
        return freshTypeVariable;
    },
    get freshenTypeVariables () {
        return freshenTypeVariables;
    },
    get generalize () {
        return generalize;
    },
    get instantiate () {
        return instantiate;
    },
    get loadStdlib () {
        return loadStdlib;
    }
});
const _nodefs = /*#__PURE__*/ _interop_require_wildcard(require("node:fs"));
const _nodepath = /*#__PURE__*/ _interop_require_wildcard(require("node:path"));
const _ast = require("../ast");
const _parser = require("../parser/parser");
const _lexer = require("../lexer");
const _types = require("./types");
const _substitute = require("./substitute");
const _expressiondispatcher = require("./expression-dispatcher");
const _helpers = require("./helpers");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const freshTypeVariable = (state)=>{
    const newCounter = state.counter + 1;
    const newType = (0, _ast.typeVariable)(`Î±${newCounter}`);
    // Avoid spreading the entire state object for better performance
    return [
        newType,
        {
            ...state,
            counter: newCounter
        }
    ];
};
const freeTypeVars = (type, acc = new Set())=>{
    switch(type.kind){
        case 'variable':
            acc.add(type.name);
            break;
        case 'function':
            for (const param of type.params)freeTypeVars(param, acc);
            freeTypeVars(type.return, acc);
            break;
        case 'list':
            freeTypeVars(type.element, acc);
            break;
        case 'tuple':
            for (const el of type.elements)freeTypeVars(el, acc);
            break;
        case 'record':
            Object.values(type.fields).forEach((v)=>freeTypeVars(v, acc));
            break;
        case 'union':
            type.types.forEach((t)=>freeTypeVars(t, acc));
            break;
        case 'variant':
            type.args.forEach((arg)=>freeTypeVars(arg, acc));
            break;
    }
    return acc;
};
const freeTypeVarsEnv = (env)=>{
    const acc = new Set();
    for (const scheme of env.values()){
        freeTypeVars(scheme.type, acc);
    }
    return acc;
};
const generalize = (type, env, substitution)=>{
    // Apply current substitution to the type before generalizing
    const substitutedType = (0, _substitute.substitute)(type, substitution);
    const typeVars = freeTypeVars(substitutedType);
    const envVars = freeTypeVarsEnv(env);
    const quantifiedVars = [];
    for (const varName of typeVars){
        if (!envVars.has(varName)) {
            quantifiedVars.push(varName);
        }
    }
    return {
        type: substitutedType,
        quantifiedVars
    };
};
const instantiate = (scheme, state)=>{
    const mapping = new Map();
    let currentState = state;
    for (const varName of scheme.quantifiedVars){
        const [freshVar, newState] = freshTypeVariable(currentState);
        mapping.set(varName, freshVar);
        currentState = newState;
    }
    const [instantiatedType, finalState] = freshenTypeVariables(scheme.type, mapping, currentState);
    return [
        instantiatedType,
        finalState
    ];
};
const freshenTypeVariables = (type, mapping = new Map(), state)=>{
    switch(type.kind){
        case 'variable':
            {
                const freshVar = mapping.get(type.name);
                if (freshVar) {
                    // Copy constraints from the original variable to the fresh one
                    if (freshVar.kind === 'variable') {
                        freshVar.constraints = freshVar.constraints || [];
                        if (type.constraints) {
                            for (const c of type.constraints){
                                if (!freshVar.constraints.some((existing)=>(0, _helpers.constraintsEqual)(existing, c))) {
                                    freshVar.constraints.push(c);
                                }
                            }
                        }
                    }
                    return [
                        freshVar,
                        state
                    ];
                }
                return [
                    type,
                    state
                ];
            }
        case 'function':
            {
                let currentState = state;
                const newParams = [];
                for (const param of type.params){
                    const [newParam, nextState] = freshenTypeVariables(param, mapping, currentState);
                    newParams.push(newParam);
                    currentState = nextState;
                }
                const [newReturn, finalState] = freshenTypeVariables(type.return, mapping, currentState);
                return [
                    {
                        ...type,
                        params: newParams,
                        return: newReturn
                    },
                    finalState
                ];
            }
        case 'list':
            {
                const [newElem, nextState] = freshenTypeVariables(type.element, mapping, state);
                return [
                    {
                        ...type,
                        element: newElem
                    },
                    nextState
                ];
            }
        case 'tuple':
            {
                let currentState = state;
                const newElems = [];
                for (const el of type.elements){
                    const [newEl, nextState] = freshenTypeVariables(el, mapping, currentState);
                    newElems.push(newEl);
                    currentState = nextState;
                }
                return [
                    {
                        ...type,
                        elements: newElems
                    },
                    currentState
                ];
            }
        case 'record':
            {
                let currentState = state;
                const newFields = {};
                for (const [key, fieldType] of Object.entries(type.fields)){
                    const [newField, nextState] = freshenTypeVariables(fieldType, mapping, currentState);
                    newFields[key] = newField;
                    currentState = nextState;
                }
                return [
                    {
                        ...type,
                        fields: newFields
                    },
                    currentState
                ];
            }
        case 'union':
            {
                let currentState = state;
                const newTypes = [];
                for (const t of type.types){
                    const [newType, nextState] = freshenTypeVariables(t, mapping, currentState);
                    newTypes.push(newType);
                    currentState = nextState;
                }
                return [
                    {
                        ...type,
                        types: newTypes
                    },
                    currentState
                ];
            }
        case 'variant':
            {
                let currentState = state;
                const newArgs = [];
                for (const arg of type.args){
                    const [newArg, nextState] = freshenTypeVariables(arg, mapping, currentState);
                    newArgs.push(newArg);
                    currentState = nextState;
                }
                return [
                    {
                        ...type,
                        args: newArgs
                    },
                    currentState
                ];
            }
        default:
            return [
                type,
                state
            ];
    }
};
const flattenStatements = (expr)=>{
    if (expr.kind === 'binary' && expr.operator === ';') {
        return [
            ...flattenStatements(expr.left),
            ...flattenStatements(expr.right)
        ];
    }
    return [
        expr
    ];
};
const loadStdlib = (state)=>{
    try {
        // Find stdlib.noo relative to this file
        const stdlibPath = _nodepath.join(__dirname, '..', '..', 'stdlib.noo');
        if (!_nodefs.existsSync(stdlibPath)) {
            console.warn(`Warning: stdlib.noo not found at ${stdlibPath}`);
            return state;
        }
        const stdlibContent = _nodefs.readFileSync(stdlibPath, 'utf-8');
        const lexer = new _lexer.Lexer(stdlibContent);
        const tokens = lexer.tokenize();
        const stdlibProgram = (0, _parser.parse)(tokens);
        // Flatten any semicolon-separated statements
        const allStatements = [];
        for (const statement of stdlibProgram.statements){
            allStatements.push(...flattenStatements(statement));
        }
        let currentState = state;
        for (const statement of allStatements){
            const result = (0, _expressiondispatcher.typeExpression)(statement, currentState);
            currentState = result.state;
        }
        return currentState;
    } catch (error) {
        console.warn(`Warning: Failed to load stdlib.noo:`, error);
        return state;
    }
};
const createTypeState = ()=>({
        environment: new Map(),
        substitution: new Map(),
        counter: 0,
        constraints: [],
        adtRegistry: new Map(),
        accessorCache: new Map(),
        constraintRegistry: (0, _types.createConstraintRegistry)()
    });
const cleanSubstitutions = (state)=>({
        ...state,
        substitution: new Map(),
        constraints: []
    });

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Uvc3JjL3R5cGVyL3R5cGUtb3BlcmF0aW9ucy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tIFwibm9kZTpmc1wiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwibm9kZTpwYXRoXCI7XG5pbXBvcnQge1xuXHR0eXBlIFR5cGUsXG5cdHR5cGUgRXhwcmVzc2lvbixcblx0dHlwZSBQcm9ncmFtLFxuXHR0eXBlVmFyaWFibGUsXG5cdHVuaXRUeXBlLFxufSBmcm9tICcuLi9hc3QnO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICcuLi9wYXJzZXIvcGFyc2VyJztcbmltcG9ydCB7IExleGVyIH0gZnJvbSAnLi4vbGV4ZXInO1xuaW1wb3J0IHsgdHlwZSBUeXBlU3RhdGUsIHR5cGUgVHlwZUVudmlyb25tZW50LCB0eXBlIFR5cGVTY2hlbWUsIGNyZWF0ZUNvbnN0cmFpbnRSZWdpc3RyeSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgc3Vic3RpdHV0ZSB9IGZyb20gJy4vc3Vic3RpdHV0ZSc7XG5pbXBvcnQgeyB0eXBlRXhwcmVzc2lvbiB9IGZyb20gJy4vZXhwcmVzc2lvbi1kaXNwYXRjaGVyJztcbmltcG9ydCB7IGNvbnN0cmFpbnRzRXF1YWwgfSBmcm9tICcuL2hlbHBlcnMnO1xuXG4vLyBGcmVzaCB0eXBlIHZhcmlhYmxlIGdlbmVyYXRpb24gLSBvcHRpbWl6ZWQgdG8gYXZvaWQgc3RyaW5nIGNvbmNhdGVuYXRpb25cbmV4cG9ydCBjb25zdCBmcmVzaFR5cGVWYXJpYWJsZSA9IChzdGF0ZTogVHlwZVN0YXRlKTogW1R5cGUsIFR5cGVTdGF0ZV0gPT4ge1xuXHRjb25zdCBuZXdDb3VudGVyID0gc3RhdGUuY291bnRlciArIDE7XG5cdGNvbnN0IG5ld1R5cGUgPSB0eXBlVmFyaWFibGUoYM6xJHtuZXdDb3VudGVyfWApO1xuXHQvLyBBdm9pZCBzcHJlYWRpbmcgdGhlIGVudGlyZSBzdGF0ZSBvYmplY3QgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuXHRyZXR1cm4gW25ld1R5cGUsIHsgXG5cdFx0Li4uc3RhdGUsIFxuXHRcdGNvdW50ZXI6IG5ld0NvdW50ZXIgXG5cdH1dO1xufTtcblxuLy8gQ29sbGVjdCBhbGwgZnJlZSB0eXBlIHZhcmlhYmxlcyBpbiBhIHR5cGVcbmV4cG9ydCBjb25zdCBmcmVlVHlwZVZhcnMgPSAoXG5cdHR5cGU6IFR5cGUsXG5cdGFjYzogU2V0PHN0cmluZz4gPSBuZXcgU2V0KClcbik6IFNldDxzdHJpbmc+ID0+IHtcblx0c3dpdGNoICh0eXBlLmtpbmQpIHtcblx0XHRjYXNlICd2YXJpYWJsZSc6XG5cdFx0XHRhY2MuYWRkKHR5cGUubmFtZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdmdW5jdGlvbic6XG5cdFx0XHRmb3IgKGNvbnN0IHBhcmFtIG9mIHR5cGUucGFyYW1zKSBmcmVlVHlwZVZhcnMocGFyYW0sIGFjYyk7XG5cdFx0XHRmcmVlVHlwZVZhcnModHlwZS5yZXR1cm4sIGFjYyk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsaXN0Jzpcblx0XHRcdGZyZWVUeXBlVmFycyh0eXBlLmVsZW1lbnQsIGFjYyk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICd0dXBsZSc6XG5cdFx0XHRmb3IgKGNvbnN0IGVsIG9mIHR5cGUuZWxlbWVudHMpIGZyZWVUeXBlVmFycyhlbCwgYWNjKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3JlY29yZCc6XG5cdFx0XHRPYmplY3QudmFsdWVzKHR5cGUuZmllbGRzKS5mb3JFYWNoKHYgPT4gZnJlZVR5cGVWYXJzKHYsIGFjYykpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAndW5pb24nOlxuXHRcdFx0dHlwZS50eXBlcy5mb3JFYWNoKHQgPT4gZnJlZVR5cGVWYXJzKHQsIGFjYykpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAndmFyaWFudCc6XG5cdFx0XHR0eXBlLmFyZ3MuZm9yRWFjaChhcmcgPT4gZnJlZVR5cGVWYXJzKGFyZywgYWNjKSk7XG5cdFx0XHRicmVhaztcblx0fVxuXHRyZXR1cm4gYWNjO1xufTtcblxuLy8gQ29sbGVjdCBhbGwgZnJlZSB0eXBlIHZhcmlhYmxlcyBpbiB0aGUgZW52aXJvbm1lbnRcbmV4cG9ydCBjb25zdCBmcmVlVHlwZVZhcnNFbnYgPSAoZW52OiBUeXBlRW52aXJvbm1lbnQpOiBTZXQ8c3RyaW5nPiA9PiB7XG5cdGNvbnN0IGFjYyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRmb3IgKGNvbnN0IHNjaGVtZSBvZiBlbnYudmFsdWVzKCkpIHtcblx0XHRmcmVlVHlwZVZhcnMoc2NoZW1lLnR5cGUsIGFjYyk7XG5cdH1cblx0cmV0dXJuIGFjYztcbn07XG5cbi8vIEdlbmVyYWxpemUgYSB0eXBlIHdpdGggcmVzcGVjdCB0byB0aGUgZW52aXJvbm1lbnRcbmV4cG9ydCBjb25zdCBnZW5lcmFsaXplID0gKFxuXHR0eXBlOiBUeXBlLFxuXHRlbnY6IFR5cGVFbnZpcm9ubWVudCxcblx0c3Vic3RpdHV0aW9uOiBNYXA8c3RyaW5nLCBUeXBlPlxuKTogVHlwZVNjaGVtZSA9PiB7XG5cdC8vIEFwcGx5IGN1cnJlbnQgc3Vic3RpdHV0aW9uIHRvIHRoZSB0eXBlIGJlZm9yZSBnZW5lcmFsaXppbmdcblx0Y29uc3Qgc3Vic3RpdHV0ZWRUeXBlID0gc3Vic3RpdHV0ZSh0eXBlLCBzdWJzdGl0dXRpb24pO1xuXHRjb25zdCB0eXBlVmFycyA9IGZyZWVUeXBlVmFycyhzdWJzdGl0dXRlZFR5cGUpO1xuXHRjb25zdCBlbnZWYXJzID0gZnJlZVR5cGVWYXJzRW52KGVudik7XG5cdGNvbnN0IHF1YW50aWZpZWRWYXJzOiBzdHJpbmdbXSA9IFtdO1xuXG5cdGZvciAoY29uc3QgdmFyTmFtZSBvZiB0eXBlVmFycykge1xuXHRcdGlmICghZW52VmFycy5oYXModmFyTmFtZSkpIHtcblx0XHRcdHF1YW50aWZpZWRWYXJzLnB1c2godmFyTmFtZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB7IHR5cGU6IHN1YnN0aXR1dGVkVHlwZSwgcXVhbnRpZmllZFZhcnMgfTtcbn07XG5cbi8vIEluc3RhbnRpYXRlIGEgdHlwZSBzY2hlbWUgYnkgZnJlc2hlbmluZyBhbGwgcXVhbnRpZmllZCB2YXJpYWJsZXMgKHRocmVhZGluZyBzdGF0ZSlcbmV4cG9ydCBjb25zdCBpbnN0YW50aWF0ZSA9IChcblx0c2NoZW1lOiBUeXBlU2NoZW1lLFxuXHRzdGF0ZTogVHlwZVN0YXRlXG4pOiBbVHlwZSwgVHlwZVN0YXRlXSA9PiB7XG5cdGNvbnN0IG1hcHBpbmcgPSBuZXcgTWFwPHN0cmluZywgVHlwZT4oKTtcblx0bGV0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuXHRmb3IgKGNvbnN0IHZhck5hbWUgb2Ygc2NoZW1lLnF1YW50aWZpZWRWYXJzKSB7XG5cdFx0Y29uc3QgW2ZyZXNoVmFyLCBuZXdTdGF0ZV0gPSBmcmVzaFR5cGVWYXJpYWJsZShjdXJyZW50U3RhdGUpO1xuXHRcdG1hcHBpbmcuc2V0KHZhck5hbWUsIGZyZXNoVmFyKTtcblx0XHRjdXJyZW50U3RhdGUgPSBuZXdTdGF0ZTtcblx0fVxuXG5cdGNvbnN0IFtpbnN0YW50aWF0ZWRUeXBlLCBmaW5hbFN0YXRlXSA9IGZyZXNoZW5UeXBlVmFyaWFibGVzKFxuXHRcdHNjaGVtZS50eXBlLFxuXHRcdG1hcHBpbmcsXG5cdFx0Y3VycmVudFN0YXRlXG5cdCk7XG5cblx0cmV0dXJuIFtpbnN0YW50aWF0ZWRUeXBlLCBmaW5hbFN0YXRlXTtcbn07XG5cbi8vIFJlcGxhY2UgdHlwZSB2YXJpYWJsZXMgd2l0aCBmcmVzaCBvbmVzLCB0aHJlYWRpbmcgc3RhdGVcbmV4cG9ydCBjb25zdCBmcmVzaGVuVHlwZVZhcmlhYmxlcyA9IChcblx0dHlwZTogVHlwZSxcblx0bWFwcGluZzogTWFwPHN0cmluZywgVHlwZT4gPSBuZXcgTWFwKCksXG5cdHN0YXRlOiBUeXBlU3RhdGVcbik6IFtUeXBlLCBUeXBlU3RhdGVdID0+IHtcblx0c3dpdGNoICh0eXBlLmtpbmQpIHtcblx0XHRjYXNlICd2YXJpYWJsZSc6IHtcblx0XHRcdGNvbnN0IGZyZXNoVmFyID0gbWFwcGluZy5nZXQodHlwZS5uYW1lKTtcblx0XHRcdGlmIChmcmVzaFZhcikge1xuXHRcdFx0XHQvLyBDb3B5IGNvbnN0cmFpbnRzIGZyb20gdGhlIG9yaWdpbmFsIHZhcmlhYmxlIHRvIHRoZSBmcmVzaCBvbmVcblx0XHRcdFx0aWYgKGZyZXNoVmFyLmtpbmQgPT09ICd2YXJpYWJsZScpIHtcblx0XHRcdFx0XHRmcmVzaFZhci5jb25zdHJhaW50cyA9IGZyZXNoVmFyLmNvbnN0cmFpbnRzIHx8IFtdO1xuXHRcdFx0XHRcdGlmICh0eXBlLmNvbnN0cmFpbnRzKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGMgb2YgdHlwZS5jb25zdHJhaW50cykge1xuXHRcdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdFx0IWZyZXNoVmFyLmNvbnN0cmFpbnRzLnNvbWUoXG5cdFx0XHRcdFx0XHRcdFx0XHRleGlzdGluZyA9PiBjb25zdHJhaW50c0VxdWFsKGV4aXN0aW5nLCBjKVxuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0ZnJlc2hWYXIuY29uc3RyYWludHMucHVzaChjKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gW2ZyZXNoVmFyLCBzdGF0ZV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gW3R5cGUsIHN0YXRlXTtcblx0XHR9XG5cdFx0Y2FzZSAnZnVuY3Rpb24nOiB7XG5cdFx0XHRsZXQgY3VycmVudFN0YXRlID0gc3RhdGU7XG5cdFx0XHRjb25zdCBuZXdQYXJhbXM6IFR5cGVbXSA9IFtdO1xuXHRcdFx0Zm9yIChjb25zdCBwYXJhbSBvZiB0eXBlLnBhcmFtcykge1xuXHRcdFx0XHRjb25zdCBbbmV3UGFyYW0sIG5leHRTdGF0ZV0gPSBmcmVzaGVuVHlwZVZhcmlhYmxlcyhcblx0XHRcdFx0XHRwYXJhbSxcblx0XHRcdFx0XHRtYXBwaW5nLFxuXHRcdFx0XHRcdGN1cnJlbnRTdGF0ZVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRuZXdQYXJhbXMucHVzaChuZXdQYXJhbSk7XG5cdFx0XHRcdGN1cnJlbnRTdGF0ZSA9IG5leHRTdGF0ZTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IFtuZXdSZXR1cm4sIGZpbmFsU3RhdGVdID0gZnJlc2hlblR5cGVWYXJpYWJsZXMoXG5cdFx0XHRcdHR5cGUucmV0dXJuLFxuXHRcdFx0XHRtYXBwaW5nLFxuXHRcdFx0XHRjdXJyZW50U3RhdGVcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gW3sgLi4udHlwZSwgcGFyYW1zOiBuZXdQYXJhbXMsIHJldHVybjogbmV3UmV0dXJuIH0sIGZpbmFsU3RhdGVdO1xuXHRcdH1cblx0XHRjYXNlICdsaXN0Jzoge1xuXHRcdFx0Y29uc3QgW25ld0VsZW0sIG5leHRTdGF0ZV0gPSBmcmVzaGVuVHlwZVZhcmlhYmxlcyhcblx0XHRcdFx0dHlwZS5lbGVtZW50LFxuXHRcdFx0XHRtYXBwaW5nLFxuXHRcdFx0XHRzdGF0ZVxuXHRcdFx0KTtcblx0XHRcdHJldHVybiBbeyAuLi50eXBlLCBlbGVtZW50OiBuZXdFbGVtIH0sIG5leHRTdGF0ZV07XG5cdFx0fVxuXHRcdGNhc2UgJ3R1cGxlJzoge1xuXHRcdFx0bGV0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuXHRcdFx0Y29uc3QgbmV3RWxlbXM6IFR5cGVbXSA9IFtdO1xuXHRcdFx0Zm9yIChjb25zdCBlbCBvZiB0eXBlLmVsZW1lbnRzKSB7XG5cdFx0XHRcdGNvbnN0IFtuZXdFbCwgbmV4dFN0YXRlXSA9IGZyZXNoZW5UeXBlVmFyaWFibGVzKFxuXHRcdFx0XHRcdGVsLFxuXHRcdFx0XHRcdG1hcHBpbmcsXG5cdFx0XHRcdFx0Y3VycmVudFN0YXRlXG5cdFx0XHRcdCk7XG5cdFx0XHRcdG5ld0VsZW1zLnB1c2gobmV3RWwpO1xuXHRcdFx0XHRjdXJyZW50U3RhdGUgPSBuZXh0U3RhdGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gW3sgLi4udHlwZSwgZWxlbWVudHM6IG5ld0VsZW1zIH0sIGN1cnJlbnRTdGF0ZV07XG5cdFx0fVxuXHRcdGNhc2UgJ3JlY29yZCc6IHtcblx0XHRcdGxldCBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblx0XHRcdGNvbnN0IG5ld0ZpZWxkczogeyBba2V5OiBzdHJpbmddOiBUeXBlIH0gPSB7fTtcblx0XHRcdGZvciAoY29uc3QgW2tleSwgZmllbGRUeXBlXSBvZiBPYmplY3QuZW50cmllcyh0eXBlLmZpZWxkcykpIHtcblx0XHRcdFx0Y29uc3QgW25ld0ZpZWxkLCBuZXh0U3RhdGVdID0gZnJlc2hlblR5cGVWYXJpYWJsZXMoXG5cdFx0XHRcdFx0ZmllbGRUeXBlLFxuXHRcdFx0XHRcdG1hcHBpbmcsXG5cdFx0XHRcdFx0Y3VycmVudFN0YXRlXG5cdFx0XHRcdCk7XG5cdFx0XHRcdG5ld0ZpZWxkc1trZXldID0gbmV3RmllbGQ7XG5cdFx0XHRcdGN1cnJlbnRTdGF0ZSA9IG5leHRTdGF0ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBbeyAuLi50eXBlLCBmaWVsZHM6IG5ld0ZpZWxkcyB9LCBjdXJyZW50U3RhdGVdO1xuXHRcdH1cblx0XHRjYXNlICd1bmlvbic6IHtcblx0XHRcdGxldCBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblx0XHRcdGNvbnN0IG5ld1R5cGVzOiBUeXBlW10gPSBbXTtcblx0XHRcdGZvciAoY29uc3QgdCBvZiB0eXBlLnR5cGVzKSB7XG5cdFx0XHRcdGNvbnN0IFtuZXdUeXBlLCBuZXh0U3RhdGVdID0gZnJlc2hlblR5cGVWYXJpYWJsZXMoXG5cdFx0XHRcdFx0dCxcblx0XHRcdFx0XHRtYXBwaW5nLFxuXHRcdFx0XHRcdGN1cnJlbnRTdGF0ZVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRuZXdUeXBlcy5wdXNoKG5ld1R5cGUpO1xuXHRcdFx0XHRjdXJyZW50U3RhdGUgPSBuZXh0U3RhdGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gW3sgLi4udHlwZSwgdHlwZXM6IG5ld1R5cGVzIH0sIGN1cnJlbnRTdGF0ZV07XG5cdFx0fVxuXHRcdGNhc2UgJ3ZhcmlhbnQnOiB7XG5cdFx0XHRsZXQgY3VycmVudFN0YXRlID0gc3RhdGU7XG5cdFx0XHRjb25zdCBuZXdBcmdzOiBUeXBlW10gPSBbXTtcblx0XHRcdGZvciAoY29uc3QgYXJnIG9mIHR5cGUuYXJncykge1xuXHRcdFx0XHRjb25zdCBbbmV3QXJnLCBuZXh0U3RhdGVdID0gZnJlc2hlblR5cGVWYXJpYWJsZXMoXG5cdFx0XHRcdFx0YXJnLFxuXHRcdFx0XHRcdG1hcHBpbmcsXG5cdFx0XHRcdFx0Y3VycmVudFN0YXRlXG5cdFx0XHRcdCk7XG5cdFx0XHRcdG5ld0FyZ3MucHVzaChuZXdBcmcpO1xuXHRcdFx0XHRjdXJyZW50U3RhdGUgPSBuZXh0U3RhdGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gW3sgLi4udHlwZSwgYXJnczogbmV3QXJncyB9LCBjdXJyZW50U3RhdGVdO1xuXHRcdH1cblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIFt0eXBlLCBzdGF0ZV07XG5cdH1cbn07XG5cbi8vIEhlbHBlciB0byBmbGF0dGVuIHNlbWljb2xvbi1zZXBhcmF0ZWQgYmluYXJ5IGV4cHJlc3Npb25zIGludG8gaW5kaXZpZHVhbCBzdGF0ZW1lbnRzXG5leHBvcnQgY29uc3QgZmxhdHRlblN0YXRlbWVudHMgPSAoZXhwcjogRXhwcmVzc2lvbik6IEV4cHJlc3Npb25bXSA9PiB7XG5cdGlmIChleHByLmtpbmQgPT09ICdiaW5hcnknICYmIGV4cHIub3BlcmF0b3IgPT09ICc7Jykge1xuXHRcdHJldHVybiBbLi4uZmxhdHRlblN0YXRlbWVudHMoZXhwci5sZWZ0KSwgLi4uZmxhdHRlblN0YXRlbWVudHMoZXhwci5yaWdodCldO1xuXHR9XG5cdHJldHVybiBbZXhwcl07XG59O1xuXG4vLyBMb2FkIHN0YW5kYXJkIGxpYnJhcnkgZnJvbSBzdGRsaWIubm9vXG5leHBvcnQgY29uc3QgbG9hZFN0ZGxpYiA9IChzdGF0ZTogVHlwZVN0YXRlKTogVHlwZVN0YXRlID0+IHtcblx0dHJ5IHtcblx0XHQvLyBGaW5kIHN0ZGxpYi5ub28gcmVsYXRpdmUgdG8gdGhpcyBmaWxlXG5cdFx0Y29uc3Qgc3RkbGliUGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsICcuLicsICcuLicsICdzdGRsaWIubm9vJyk7XG5cblx0XHRpZiAoIWZzLmV4aXN0c1N5bmMoc3RkbGliUGF0aCkpIHtcblx0XHRcdGNvbnNvbGUud2FybihgV2FybmluZzogc3RkbGliLm5vbyBub3QgZm91bmQgYXQgJHtzdGRsaWJQYXRofWApO1xuXHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdH1cblxuXHRcdGNvbnN0IHN0ZGxpYkNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoc3RkbGliUGF0aCwgJ3V0Zi04Jyk7XG5cdFx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoc3RkbGliQ29udGVudCk7XG5cdFx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0XHRjb25zdCBzdGRsaWJQcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblxuXHRcdC8vIEZsYXR0ZW4gYW55IHNlbWljb2xvbi1zZXBhcmF0ZWQgc3RhdGVtZW50c1xuXHRcdGNvbnN0IGFsbFN0YXRlbWVudHM6IEV4cHJlc3Npb25bXSA9IFtdO1xuXHRcdGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIHN0ZGxpYlByb2dyYW0uc3RhdGVtZW50cykge1xuXHRcdFx0YWxsU3RhdGVtZW50cy5wdXNoKC4uLmZsYXR0ZW5TdGF0ZW1lbnRzKHN0YXRlbWVudCkpO1xuXHRcdH1cblxuXHRcdGxldCBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblx0XHRmb3IgKGNvbnN0IHN0YXRlbWVudCBvZiBhbGxTdGF0ZW1lbnRzKSB7XG5cdFx0XHRjb25zdCByZXN1bHQgPSB0eXBlRXhwcmVzc2lvbihzdGF0ZW1lbnQsIGN1cnJlbnRTdGF0ZSk7XG5cdFx0XHRjdXJyZW50U3RhdGUgPSByZXN1bHQuc3RhdGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGN1cnJlbnRTdGF0ZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRjb25zb2xlLndhcm4oYFdhcm5pbmc6IEZhaWxlZCB0byBsb2FkIHN0ZGxpYi5ub286YCwgZXJyb3IpO1xuXHRcdHJldHVybiBzdGF0ZTtcblx0fVxufTtcblxuLy8gSW5pdGlhbGl6ZSB0eXBlIHN0YXRlXG5leHBvcnQgY29uc3QgY3JlYXRlVHlwZVN0YXRlID0gKCk6IFR5cGVTdGF0ZSA9PiAoe1xuXHRlbnZpcm9ubWVudDogbmV3IE1hcCgpLFxuXHRzdWJzdGl0dXRpb246IG5ldyBNYXAoKSxcblx0Y291bnRlcjogMCxcblx0Y29uc3RyYWludHM6IFtdLFxuXHRhZHRSZWdpc3RyeTogbmV3IE1hcCgpLFxuXHRhY2Nlc3NvckNhY2hlOiBuZXcgTWFwKCksXG5cdGNvbnN0cmFpbnRSZWdpc3RyeTogY3JlYXRlQ29uc3RyYWludFJlZ2lzdHJ5KCksXG59KTtcblxuLy8gQ2xlYW4gc3Vic3RpdHV0aW9ucyBmcm9tIHR5cGUgc3RhdGUgd2hpbGUgcHJlc2VydmluZyBlbnZpcm9ubWVudCBhbmQgb3RoZXIgc3RhdGVcbi8vIFRoaXMgaXMgdXNlZCBpbiBSRVBMIHRvIHByZXZlbnQgdHlwZSBwb2xsdXRpb24gYmV0d2VlbiBldmFsdWF0aW9uc1xuZXhwb3J0IGNvbnN0IGNsZWFuU3Vic3RpdHV0aW9ucyA9IChzdGF0ZTogVHlwZVN0YXRlKTogVHlwZVN0YXRlID0+ICh7XG5cdC4uLnN0YXRlLFxuXHRzdWJzdGl0dXRpb246IG5ldyBNYXAoKSwgLy8gQ2xlYXIgc3Vic3RpdHV0aW9ucyBidXQga2VlcCBlbnZpcm9ubWVudFxuXHRjb25zdHJhaW50czogW10sIC8vIENsZWFyIGNvbnN0cmFpbnRzIGFzIHdlbGxcbn0pOyJdLCJuYW1lcyI6WyJjbGVhblN1YnN0aXR1dGlvbnMiLCJjcmVhdGVUeXBlU3RhdGUiLCJmbGF0dGVuU3RhdGVtZW50cyIsImZyZWVUeXBlVmFycyIsImZyZWVUeXBlVmFyc0VudiIsImZyZXNoVHlwZVZhcmlhYmxlIiwiZnJlc2hlblR5cGVWYXJpYWJsZXMiLCJnZW5lcmFsaXplIiwiaW5zdGFudGlhdGUiLCJsb2FkU3RkbGliIiwic3RhdGUiLCJuZXdDb3VudGVyIiwiY291bnRlciIsIm5ld1R5cGUiLCJ0eXBlVmFyaWFibGUiLCJ0eXBlIiwiYWNjIiwiU2V0Iiwia2luZCIsImFkZCIsIm5hbWUiLCJwYXJhbSIsInBhcmFtcyIsInJldHVybiIsImVsZW1lbnQiLCJlbCIsImVsZW1lbnRzIiwiT2JqZWN0IiwidmFsdWVzIiwiZmllbGRzIiwiZm9yRWFjaCIsInYiLCJ0eXBlcyIsInQiLCJhcmdzIiwiYXJnIiwiZW52Iiwic2NoZW1lIiwic3Vic3RpdHV0aW9uIiwic3Vic3RpdHV0ZWRUeXBlIiwic3Vic3RpdHV0ZSIsInR5cGVWYXJzIiwiZW52VmFycyIsInF1YW50aWZpZWRWYXJzIiwidmFyTmFtZSIsImhhcyIsInB1c2giLCJtYXBwaW5nIiwiTWFwIiwiY3VycmVudFN0YXRlIiwiZnJlc2hWYXIiLCJuZXdTdGF0ZSIsInNldCIsImluc3RhbnRpYXRlZFR5cGUiLCJmaW5hbFN0YXRlIiwiZ2V0IiwiY29uc3RyYWludHMiLCJjIiwic29tZSIsImV4aXN0aW5nIiwiY29uc3RyYWludHNFcXVhbCIsIm5ld1BhcmFtcyIsIm5ld1BhcmFtIiwibmV4dFN0YXRlIiwibmV3UmV0dXJuIiwibmV3RWxlbSIsIm5ld0VsZW1zIiwibmV3RWwiLCJuZXdGaWVsZHMiLCJrZXkiLCJmaWVsZFR5cGUiLCJlbnRyaWVzIiwibmV3RmllbGQiLCJuZXdUeXBlcyIsIm5ld0FyZ3MiLCJuZXdBcmciLCJleHByIiwib3BlcmF0b3IiLCJsZWZ0IiwicmlnaHQiLCJzdGRsaWJQYXRoIiwicGF0aCIsImpvaW4iLCJfX2Rpcm5hbWUiLCJmcyIsImV4aXN0c1N5bmMiLCJjb25zb2xlIiwid2FybiIsInN0ZGxpYkNvbnRlbnQiLCJyZWFkRmlsZVN5bmMiLCJsZXhlciIsIkxleGVyIiwidG9rZW5zIiwidG9rZW5pemUiLCJzdGRsaWJQcm9ncmFtIiwicGFyc2UiLCJhbGxTdGF0ZW1lbnRzIiwic3RhdGVtZW50Iiwic3RhdGVtZW50cyIsInJlc3VsdCIsInR5cGVFeHByZXNzaW9uIiwiZXJyb3IiLCJlbnZpcm9ubWVudCIsImFkdFJlZ2lzdHJ5IiwiYWNjZXNzb3JDYWNoZSIsImNvbnN0cmFpbnRSZWdpc3RyeSIsImNyZWF0ZUNvbnN0cmFpbnRSZWdpc3RyeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7UUEyUmFBO2VBQUFBOztRQVpBQztlQUFBQTs7UUEzQ0FDO2VBQUFBOztRQXhNQUM7ZUFBQUE7O1FBZ0NBQztlQUFBQTs7UUEzQ0FDO2VBQUFBOztRQThGQUM7ZUFBQUE7O1FBMUNBQztlQUFBQTs7UUFvQkFDO2VBQUFBOztRQW1KQUM7ZUFBQUE7OztnRUE1T087a0VBQ0U7cUJBT2Y7d0JBQ2U7dUJBQ0E7dUJBQzBFOzRCQUNyRTtzQ0FDSTt5QkFDRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRzFCLE1BQU1KLG9CQUFvQixDQUFDSztJQUNqQyxNQUFNQyxhQUFhRCxNQUFNRSxPQUFPLEdBQUc7SUFDbkMsTUFBTUMsVUFBVUMsSUFBQUEsaUJBQVksRUFBQyxDQUFDLENBQUMsRUFBRUgsWUFBWTtJQUM3QyxpRUFBaUU7SUFDakUsT0FBTztRQUFDRTtRQUFTO1lBQ2hCLEdBQUdILEtBQUs7WUFDUkUsU0FBU0Q7UUFDVjtLQUFFO0FBQ0g7QUFHTyxNQUFNUixlQUFlLENBQzNCWSxNQUNBQyxNQUFtQixJQUFJQyxLQUFLO0lBRTVCLE9BQVFGLEtBQUtHLElBQUk7UUFDaEIsS0FBSztZQUNKRixJQUFJRyxHQUFHLENBQUNKLEtBQUtLLElBQUk7WUFDakI7UUFDRCxLQUFLO1lBQ0osS0FBSyxNQUFNQyxTQUFTTixLQUFLTyxNQUFNLENBQUVuQixhQUFha0IsT0FBT0w7WUFDckRiLGFBQWFZLEtBQUtRLE1BQU0sRUFBRVA7WUFDMUI7UUFDRCxLQUFLO1lBQ0piLGFBQWFZLEtBQUtTLE9BQU8sRUFBRVI7WUFDM0I7UUFDRCxLQUFL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