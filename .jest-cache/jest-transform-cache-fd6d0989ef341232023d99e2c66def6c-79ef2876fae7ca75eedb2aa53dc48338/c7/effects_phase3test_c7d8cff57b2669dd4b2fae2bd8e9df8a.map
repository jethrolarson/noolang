{"version":3,"sources":["/workspace/test/effects_phase3.test.ts"],"sourcesContent":["// Phase 3 Effects System Tests\n// Testing effect validation, propagation, and built-in effectful functions\n\nimport { Lexer } from '../src/lexer';\nimport { parse } from '../src/parser/parser';\nimport { typeProgram } from '../src/typer';\nimport type { Effect } from '../src/ast';\n\nconst runNoolang = (code: string) => {\n\tconst lexer = new Lexer(code);\n\tconst tokens = lexer.tokenize();\n\tconst program = parse(tokens);\n\t\n\treturn typeProgram(program);\n};\n\nconst expectEffects = (code: string, expectedEffects: Effect[]) => {\n\tconst result = runNoolang(code);\n\tconst actualEffects = Array.from(result.effects).sort();\n\tconst expected = expectedEffects.sort();\n\texpect(actualEffects).toEqual(expected);\n\treturn result;\n};\n\nconst expectPure = (code: string) => {\n\tconst result = runNoolang(code);\n\texpect(result.effects.size).toBe(0);\n\treturn result;\n};\n\nconst expectError = (code: string, errorMessage?: string) => {\n\texpect(() => runNoolang(code)).toThrow(errorMessage);\n};\n\ndescribe('Effects Phase 3: Effect Validation and Built-in Functions', () => {\n\tdescribe('Built-in Effectful Functions', () => {\n\t\ttest('print function has write effect', () => {\n\t\t\texpectEffects('print 42', ['write']);\n\t\t});\n\n\t\ttest('println function has write effect', () => {\n\t\t\texpectEffects('println \"hello\"', ['write']);\n\t\t});\n\n\t\ttest('log function has log effect', () => {\n\t\t\texpectEffects('log \"debug message\"', ['log']);\n\t\t});\n\n\t\ttest('readFile function has read effect', () => {\n\t\t\texpectEffects('readFile \"test.txt\"', ['read']);\n\t\t});\n\n\t\ttest('writeFile function has write effect', () => {\n\t\t\texpectEffects('writeFile \"test.txt\" \"content\"', ['write']);\n\t\t});\n\n\t\ttest('random function has rand effect', () => {\n\t\t\texpectEffects('random', ['rand']);\n\t\t});\n\n\t\ttest('randomRange function has rand effect', () => {\n\t\t\texpectEffects('randomRange 1 10', ['rand']);\n\t\t});\n\n\t\ttest('mutSet function has state effect', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tref = \"someRef\";\n\t\t\t\tmutSet ref 42\n\t\t\t`,\n\t\t\t\t['state']\n\t\t\t);\n\t\t});\n\n\t\ttest('mutGet function has state effect', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tref = \"someRef\";\n\t\t\t\tmutGet ref\n\t\t\t`,\n\t\t\t\t['state']\n\t\t\t);\n\t\t});\n\t});\n\n\tdescribe('Effect Propagation in Function Composition', () => {\n\t\ttest('function calling effectful function inherits effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tlogAndReturn = fn x => print x;\n\t\t\t\tlogAndReturn 42\n\t\t\t`,\n\t\t\t\t['write']\n\t\t\t);\n\t\t});\n\n\t\ttest('multiple effectful calls accumulate effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tlogAndRead = fn filename => (\n\t\t\t\t\tlog \"Reading file\";\n\t\t\t\t\treadFile filename\n\t\t\t\t);\n\t\t\t\tlogAndRead \"test.txt\"\n\t\t\t`,\n\t\t\t\t['log', 'read']\n\t\t\t);\n\t\t});\n\n\t\ttest('nested function calls propagate effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\thelper = fn x => print x;\n\t\t\t\twrapper = fn x => helper (x + 1);\n\t\t\t\twrapper 5\n\t\t\t`,\n\t\t\t\t['write']\n\t\t\t);\n\t\t});\n\n\t\ttest('pipeline operations propagate effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tlogger = fn x => print x;\n\t\t\t\t42 | logger\n\t\t\t`,\n\t\t\t\t['write']\n\t\t\t);\n\t\t});\n\n\t\ttest('composed functions merge effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tprinter = fn x => print x;\n\t\t\t\trandomizer = fn _ => random;\n\t\t\t\tcompose = fn f => fn g => fn x => f (g x);\n\t\t\t\trandomPrint = compose printer randomizer;\n\t\t\t\trandomPrint 0\n\t\t\t`,\n\t\t\t\t['rand', 'write']\n\t\t\t);\n\t\t});\n\t});\n\n\tdescribe('Effect Propagation in Data Structures', () => {\n\t\ttest('lists with effectful elements propagate effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\t[print 1, print 2, print 3]\n\t\t\t`,\n\t\t\t\t['write']\n\t\t\t);\n\t\t});\n\n\t\ttest('records with effectful field values propagate effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\t{ @logged print 42, @random random }\n\t\t\t`,\n\t\t\t\t['rand', 'write']\n\t\t\t);\n\t\t});\n\n\t\ttest('tuples with effectful elements propagate effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\t{print 1, random, readFile \"test.txt\"}\n\t\t\t`,\n\t\t\t\t['rand', 'read', 'write']\n\t\t\t);\n\t\t});\n\t});\n\n\tdescribe('Effect Propagation in Control Flow', () => {\n\t\ttest('conditionals with effectful branches propagate effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tcondition = True;\n\t\t\t\tif condition then (print \"yes\"; {}) else (log \"no\"; {})\n\t\t\t`,\n\t\t\t\t['log', 'write']\n\t\t\t);\n\t\t});\n\n\t\ttest('conditionals merge effects from both branches', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tx = 5;\n\t\t\t\tif x > 0 then (print x; {}) else (random; {})\n\t\t\t`,\n\t\t\t\t['rand', 'write']\n\t\t\t);\n\t\t});\n\n\t\ttest('nested conditionals accumulate effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tx = 5;\n\t\t\t\tif x > 0 then (\n\t\t\t\t\tif x > 10 then (readFile \"big.txt\"; {}) else (print x; {})\n\t\t\t\t) else (log \"negative\"; {})\n\t\t\t`,\n\t\t\t\t['log', 'read', 'write']\n\t\t\t);\n\t\t});\n\t});\n\n\tdescribe('Effect Propagation in Pattern Matching', () => {\n\t\ttest('pattern matching with effectful cases propagates effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\ttype Option a = Some a | None;\n\t\t\t\topt = Some 42;\n\t\t\t\tmatch opt with (\n\t\t\t\t\tSome x => (print x; {});\n\t\t\t\t\tNone => (log \"empty\"; {})\n\t\t\t\t)\n\t\t\t`,\n\t\t\t\t['log', 'write']\n\t\t\t);\n\t\t});\n\n\t\ttest('pattern matching merges effects from all cases', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\ttype Result a b = Ok a | Err b;\n\t\t\t\tresult = Ok 42;\n\t\t\t\tmatch result with (\n\t\t\t\t\tOk value => print value;\n\t\t\t\t\tErr msg => (log msg; random)\n\t\t\t\t)\n\t\t\t`,\n\t\t\t\t['log', 'rand', 'write']\n\t\t\t);\n\t\t});\n\t});\n\n\tdescribe('Higher-order Functions with Effects', () => {\n\t\ttest('map with effectful function propagates effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tnumbers = [1, 2, 3];\n\t\t\t\tlogger = fn x => print x;\n\t\t\t\tmap logger numbers\n\t\t\t`,\n\t\t\t\t['write']\n\t\t\t);\n\t\t});\n\n\t\ttest('filter with effectful predicate propagates effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tnumbers = [1, 2, 3, 4, 5];\n\t\t\t\teffectfulPred = fn x => (print x; x > 2);\n\t\t\t\tfilter effectfulPred numbers\n\t\t\t`,\n\t\t\t\t['write']\n\t\t\t);\n\t\t});\n\n\t\ttest('reduce with effectful function propagates effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tnumbers = [1, 2, 3];\n\t\t\t\teffectfulSum = fn acc => fn x => (\n\t\t\t\t\tprint x;\n\t\t\t\t\tacc + x\n\t\t\t\t);\n\t\t\t\treduce effectfulSum 0 numbers\n\t\t\t`,\n\t\t\t\t['write']\n\t\t\t);\n\t\t});\n\t});\n\n\tdescribe('Complex Effect Combinations', () => {\n\t\ttest('function with multiple effect types', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tcomplexFunction = fn filename => (\n\t\t\t\t\tnum = random;\n\t\t\t\t\tlog (concat \"Processing: \" filename);\n\t\t\t\t\tcontent = readFile filename;\n\t\t\t\t\tprint content;\n\t\t\t\t\tnum\n\t\t\t\t);\n\t\t\t\tcomplexFunction \"data.txt\"\n\t\t\t`,\n\t\t\t\t['log', 'rand', 'read', 'write']\n\t\t\t);\n\t\t});\n\n\t\ttest('recursive function with effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tlogCount = fn n => (\n\t\t\t\t\tprint n;\n\t\t\t\t\tif n > 0 then logCount (n - 1) else 0\n\t\t\t\t);\n\t\t\t\tlogCount 3\n\t\t\t`,\n\t\t\t\t['write']\n\t\t\t);\n\t\t});\n\n\t\ttest('recursive functions with different effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\thelper = fn n effect => (\n\t\t\t\t\tif effect == \"log\" then (log \"message\"; {}) else (print \"message\"; {});\n\t\t\t\t\tif n > 0 then helper (n - 1) \"log\" else {}\n\t\t\t\t);\n\t\t\t\thelper 2 \"print\"\n\t\t\t`,\n\t\t\t\t['log', 'write']\n\t\t\t);\n\t\t});\n\t});\n\n\tdescribe('Effect System Architecture Validation', () => {\n\t\ttest('pure functions have no effects', () => {\n\t\t\texpectPure('fn x => x + 1');\n\t\t});\n\n\t\ttest('pure function application has no effects', () => {\n\t\t\texpectPure(`\n\t\t\t\tadd = fn x => fn y => x + y;\n\t\t\t\tadd 2 3\n\t\t\t`);\n\t\t});\n\n\t\ttest('effect propagation is transitive', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tlevel1 = fn x => print x;\n\t\t\t\tlevel2 = fn x => level1 (x * 2);\n\t\t\t\tlevel3 = fn x => level2 (x + 1);\n\t\t\t\tlevel3 5\n\t\t\t`,\n\t\t\t\t['write']\n\t\t\t);\n\t\t});\n\n\t\ttest('effects are properly unioned across expressions', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\ta = print 1;     # write\n\t\t\t\tb = random;      # rand\n\t\t\t\tc = readFile \"test\"; # read\n\t\t\t\t{a, b, c}\n\t\t\t`,\n\t\t\t\t['rand', 'read', 'write']\n\t\t\t);\n\t\t});\n\n\t\ttest('function returning function preserves effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\tmakePrinter = fn prefix => fn x => print (concat prefix x);\n\t\t\t\tlogger = makePrinter \"LOG: \";\n\t\t\t\tlogger \"message\"\n\t\t\t`,\n\t\t\t\t['write']\n\t\t\t);\n\t\t});\n\t});\n\n\tdescribe('Effect Type System Integration', () => {\n\t\ttest('TypeResult includes effects field for effectful expressions', () => {\n\t\t\tconst result = runNoolang('print 42');\n\t\t\texpect(result).toHaveProperty('type');\n\t\t\texpect(result).toHaveProperty('effects');\n\t\t\texpect(result).toHaveProperty('state');\n\t\t\texpect(result.effects).toBeInstanceOf(Set);\n\t\t\texpect(result.effects.has('write')).toBe(true);\n\t\t});\n\n\t\ttest('TypeResult includes effects field for pure expressions', () => {\n\t\t\tconst result = runNoolang('42');\n\t\t\texpect(result).toHaveProperty('type');\n\t\t\texpect(result).toHaveProperty('effects');\n\t\t\texpect(result).toHaveProperty('state');\n\t\t\texpect(result.effects).toBeInstanceOf(Set);\n\t\t\texpect(result.effects.size).toBe(0);\n\t\t});\n\n\t\ttest('complex expressions have proper effect composition', () => {\n\t\t\tconst result = runNoolang(`\n\t\t\t\tloggedRandom = fn seed => (\n\t\t\t\t\tlog \"generating random\";\n\t\t\t\t\trandomRange seed (seed + 10)\n\t\t\t\t);\n\t\t\t\tloggedRandom 5\n\t\t\t`);\n\t\t\texpect(result.effects.has('log')).toBe(true);\n\t\t\texpect(result.effects.has('rand')).toBe(true);\n\t\t\texpect(result.effects.size).toBe(2);\n\t\t});\n\t});\n\n\tdescribe('Effect Validation Edge Cases', () => {\n\t\ttest('empty function has no effects', () => {\n\t\t\texpectPure('fn _ => 42');\n\t\t});\n\n\t\ttest('function with multiple pure operations has no effects', () => {\n\t\t\texpectPure(`\n\t\t\t\tcompute = fn x => (\n\t\t\t\t\ta = x + 1;\n\t\t\t\t\tb = a * 2;\n\t\t\t\t\tc = b - 3;\n\t\t\t\t\tc\n\t\t\t\t);\n\t\t\t\tcompute 5\n\t\t\t`);\n\t\t});\n\n\t\ttest('partially applied effectful function preserves effects', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\twritePartial = writeFile \"output.txt\";\n\t\t\t\twritePartial \"hello world\"\n\t\t\t`,\n\t\t\t\t['write']\n\t\t\t);\n\t\t});\n\n\t\ttest('curried effectful function composition', () => {\n\t\t\texpectEffects(\n\t\t\t\t`\n\t\t\t\twriter = writeFile \"output.txt\";\n\t\t\t\twriter \"content\"\n\t\t\t`,\n\t\t\t\t['write']\n\t\t\t);\n\t\t});\n\t});\n});"],"names":["runNoolang","code","lexer","Lexer","tokens","tokenize","program","parse","typeProgram","expectEffects","expectedEffects","result","actualEffects","Array","from","effects","sort","expected","expect","toEqual","expectPure","size","toBe","expectError","errorMessage","toThrow","describe","test","toHaveProperty","toBeInstanceOf","Set","has"],"mappings":"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"}