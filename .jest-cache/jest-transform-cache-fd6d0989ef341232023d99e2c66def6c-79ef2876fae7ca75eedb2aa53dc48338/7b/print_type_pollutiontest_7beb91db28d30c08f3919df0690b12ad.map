{"version":3,"sources":["/workspace/test/print_type_pollution.test.ts"],"sourcesContent":["import { Lexer } from '../src/lexer';\nimport { parse } from '../src/parser/parser';\nimport { typeAndDecorate } from '../src/typer';\nimport { createTypeState } from '../src/typer/type-operations';\nimport { initializeBuiltins } from '../src/typer/builtins';\n\ndescribe('Polymorphic Function Type Pollution', () => {\n\ttest('print should remain polymorphic between uses', () => {\n\t\t// Initialize fresh type state for each test\n\t\tlet state = createTypeState();\n\t\tstate = initializeBuiltins(state);\n\n\t\t// First, use print with integer\n\t\tconst lexer1 = new Lexer('print 1');\n\t\tconst tokens1 = lexer1.tokenize();\n\t\tconst program1 = parse(tokens1);\n\n\t\tconst result1 = typeAndDecorate(program1, state);\n\t\tstate = result1.state;\n\t\t\n\t\t// Print should work with Int - check if this succeeds\n\t\texpect(() => result1).not.toThrow();\n\n\t\t// Now use print with string - this should also work\n\t\tconst lexer2 = new Lexer('print \"hello\"');\n\t\tconst tokens2 = lexer2.tokenize();\n\t\tconst program2 = parse(tokens2);\n\n\t\t// This should not throw - print should be polymorphic\n\t\texpect(() => {\n\t\t\tconst result2 = typeAndDecorate(program2, state);\n\t\t}).not.toThrow();\n\t});\n\n\ttest('simulate REPL behavior - alternating print types', () => {\n\t\t// Simulate REPL state persistence\n\t\tlet state = createTypeState();\n\t\tstate = initializeBuiltins(state);\n\n\t\t// First REPL input: print 1\n\t\tconst lexer1 = new Lexer('print 1');\n\t\tconst tokens1 = lexer1.tokenize();\n\t\tconst program1 = parse(tokens1);\n\t\tconst result1 = typeAndDecorate(program1, state);\n\t\tstate = result1.state; // Persist state like REPL does\n\n\t\t// Second REPL input: print \"hi\" - this should work\n\t\tconst lexer2 = new Lexer('print \"hi\"');\n\t\tconst tokens2 = lexer2.tokenize();\n\t\tconst program2 = parse(tokens2);\n\t\t\n\t\t// This is where the bug manifests - print gets \"stuck\" on Int type\n\t\texpect(() => {\n\t\t\tconst result2 = typeAndDecorate(program2, state);\n\t\t\tstate = result2.state;\n\t\t}).not.toThrow();\n\n\t\t// Third REPL input: print 42 - should work again\n\t\tconst lexer3 = new Lexer('print 42');\n\t\tconst tokens3 = lexer3.tokenize();\n\t\tconst program3 = parse(tokens3);\n\t\t\n\t\texpect(() => {\n\t\t\tconst result3 = typeAndDecorate(program3, state);\n\t\t}).not.toThrow();\n\t});\n\n\ttest('other polymorphic functions should not have type pollution', () => {\n\t\tlet state = createTypeState();\n\t\tstate = initializeBuiltins(state);\n\n\t\t// Test == operator with different types\n\t\tconst eq1 = typeAndDecorate(parse(new Lexer('1 == 1').tokenize()), state);\n\t\tstate = eq1.state;\n\t\t\n\t\texpect(() => {\n\t\t\tconst eq2 = typeAndDecorate(parse(new Lexer('\"a\" == \"b\"').tokenize()), state);\n\t\t\tstate = eq2.state;\n\t\t}).not.toThrow();\n\n\t\t// Test toString with different types\n\t\texpect(() => {\n\t\t\tconst toString1 = typeAndDecorate(parse(new Lexer('toString 42').tokenize()), state);\n\t\t\tstate = toString1.state;\n\t\t}).not.toThrow();\n\n\t\texpect(() => {\n\t\t\tconst toString2 = typeAndDecorate(parse(new Lexer('toString \"hello\"').tokenize()), state);\n\t\t}).not.toThrow();\n\t});\n\n\ttest('list functions should remain polymorphic', () => {\n\t\tlet state = createTypeState();\n\t\tstate = initializeBuiltins(state);\n\n\t\t// Test with list of integers (using cons to build lists)\n\t\tconst list1 = typeAndDecorate(parse(new Lexer('cons 1 (cons 2 (cons 3 []))').tokenize()), state);\n\t\tstate = list1.state;\n\n\t\t// Test toString with different input again - should work  \n\t\texpect(() => {\n\t\t\tconst toString3 = typeAndDecorate(parse(new Lexer('toString 100').tokenize()), state);\n\t\t}).not.toThrow();\n\t});\n});"],"names":["describe","test","state","createTypeState","initializeBuiltins","lexer1","Lexer","tokens1","tokenize","program1","parse","result1","typeAndDecorate","expect","not","toThrow","lexer2","tokens2","program2","result2","lexer3","tokens3","program3","result3","eq1","eq2","toString1","toString2","list1","toString3"],"mappings":"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"}