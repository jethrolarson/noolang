{"version":3,"sources":["/workspace/test/constraint_toplevel.test.ts"],"sourcesContent":["import { Lexer } from \"../src/lexer\";\nimport { parse } from \"../src/parser/parser\";\nimport { typeAndDecorate } from \"../src/typer/decoration\";\n\ndescribe(\"Top-level Constraint and Implement Definitions\", () => {\n  const runConstraintCode = (code: string) => {\n    const lexer = new Lexer(code);\n    const tokens = lexer.tokenize();\n    const ast = parse(tokens);\n    const typedResult = typeAndDecorate(ast);\n    return typedResult;\n  };\n\n  test(\"should parse constraint definition at top level\", () => {\n    const code = `constraint Show a ( show : a -> String )`;\n    const result = runConstraintCode(code);\n    \n    expect(result.program.statements).toHaveLength(1);\n    expect(result.program.statements[0].kind).toBe(\"constraint-definition\");\n    \n    const constraintDef = result.program.statements[0] as any;\n    expect(constraintDef.name).toBe(\"Show\");\n    expect(constraintDef.typeParam).toBe(\"a\");\n    expect(constraintDef.functions).toHaveLength(1);\n    expect(constraintDef.functions[0].name).toBe(\"show\");\n  });\n\n  test(\"should parse implement definition at top level\", () => {\n    const code = `\n      constraint Show a ( show : a -> String );\n      implement Show Int ( show = toString )\n    `;\n    const result = runConstraintCode(code);\n    \n    expect(result.program.statements).toHaveLength(1);\n    expect(result.program.statements[0].kind).toBe(\"binary\");\n    \n    // Navigate the binary expression tree: constraint ; implement\n    const binaryExpr = result.program.statements[0] as any;\n    expect(binaryExpr.operator).toBe(\";\");\n    expect(binaryExpr.left.kind).toBe(\"constraint-definition\");\n    expect(binaryExpr.right.kind).toBe(\"implement-definition\");\n    \n    const constraintDef = binaryExpr.left;\n    expect(constraintDef.name).toBe(\"Show\");\n    \n    const implementDef = binaryExpr.right;\n    expect(implementDef.constraintName).toBe(\"Show\");\n    expect(implementDef.typeName).toBe(\"Int\");\n    expect(implementDef.implementations).toHaveLength(1);\n    expect(implementDef.implementations[0].name).toBe(\"show\");\n  });\n\n  test(\"should resolve constraint functions from implementations\", () => {\n    const code = `\n      constraint Show a ( show : a -> String );\n      implement Show Int ( show = toString );\n      x = show 42\n    `;\n    const result = runConstraintCode(code);\n    \n    expect(result.program.statements).toHaveLength(1);\n    expect(result.program.statements[0].kind).toBe(\"binary\");\n    \n    // Navigate the binary expression tree: (constraint ; implement) ; definition\n    const outerBinary = result.program.statements[0] as any;\n    expect(outerBinary.operator).toBe(\";\");\n    expect(outerBinary.left.kind).toBe(\"binary\"); // constraint ; implement\n    expect(outerBinary.right.kind).toBe(\"definition\"); // x = show 42\n    \n    const definition = outerBinary.right;\n    expect(definition.name).toBe(\"x\");\n  });\n\n  test(\"should support multiple constraint functions\", () => {\n    const code = `\n      constraint Eq a ( \n        equals : a -> a -> Bool; \n        notEquals : a -> a -> Bool \n      );\n      implement Eq Int ( \n        equals = fn a b => a == b;\n        notEquals = fn a b => a != b\n      );\n      result = equals 1 2\n    `;\n    const result = runConstraintCode(code);\n    \n    expect(result.program.statements).toHaveLength(1);\n    expect(result.program.statements[0].kind).toBe(\"binary\");\n    \n    // Navigate the binary expression tree: (constraint ; implement) ; definition\n    const outerBinary = result.program.statements[0] as any;\n    const innerBinary = outerBinary.left; // constraint ; implement\n    \n    const constraintDef = innerBinary.left;\n    expect(constraintDef.kind).toBe(\"constraint-definition\");\n    expect(constraintDef.functions).toHaveLength(2);\n    expect(constraintDef.functions[0].name).toBe(\"equals\");\n    expect(constraintDef.functions[1].name).toBe(\"notEquals\");\n    \n    const implementDef = innerBinary.right;\n    expect(implementDef.kind).toBe(\"implement-definition\");\n    expect(implementDef.implementations).toHaveLength(2);\n    expect(implementDef.implementations[0].name).toBe(\"equals\");\n    expect(implementDef.implementations[1].name).toBe(\"notEquals\");\n  });\n});"],"names":["describe","runConstraintCode","code","lexer","Lexer","tokens","tokenize","ast","parse","typedResult","typeAndDecorate","test","result","expect","program","statements","toHaveLength","kind","toBe","constraintDef","name","typeParam","functions","binaryExpr","operator","left","right","implementDef","constraintName","typeName","implementations","outerBinary","definition","innerBinary"],"mappings":"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"}