46bc0f4467a18d10e56e1c7f4e540338
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _types = require("../types");
const _typeoperations = require("../type-operations");
const _constraintresolution = require("../constraint-resolution");
const _ast = require("../../ast");
describe('Constraint Resolution', ()=>{
    test('should resolve constraint function calls', ()=>{
        const state = (0, _typeoperations.createTypeState)();
        // Add Show constraint
        const showSignature = {
            name: 'Show',
            typeParam: 'a',
            functions: new Map([
                [
                    'show',
                    (0, _ast.functionType)([
                        (0, _ast.intType)()
                    ], (0, _ast.stringType)())
                ]
            ])
        };
        (0, _types.addConstraintDefinition)(state.constraintRegistry, 'Show', showSignature);
        // Add Int implementation
        const intImpl = {
            functions: new Map([
                [
                    'show',
                    {
                        type: (0, _ast.functionType)([
                            (0, _ast.intType)()
                        ], (0, _ast.stringType)()),
                        quantifiedVars: [],
                        effects: new Set()
                    }
                ]
            ])
        };
        (0, _types.addConstraintImplementation)(state.constraintRegistry, 'Show', 'Int', intImpl);
        // Try to resolve a constraint function call
        const argTypes = [
            (0, _ast.intType)()
        ];
        const resolution = (0, _constraintresolution.tryResolveConstraintFunction)('show', [], argTypes, state);
        expect(resolution.resolved).toBe(true);
        expect(resolution.specializedName).toBe('__Show_show_Int');
        expect(resolution.typeScheme).toBeTruthy();
    });
    test('should detect constraint variables', ()=>{
        const state = (0, _typeoperations.createTypeState)();
        // Add Show constraint
        const showSignature = {
            name: 'Show',
            typeParam: 'a',
            functions: new Map([
                [
                    'show',
                    (0, _ast.functionType)([
                        (0, _ast.intType)()
                    ], (0, _ast.stringType)())
                ]
            ])
        };
        (0, _types.addConstraintDefinition)(state.constraintRegistry, 'Show', showSignature);
        // Test constraint variable detection
        const resolution = (0, _constraintresolution.resolveConstraintVariable)('show', state);
        expect(resolution.resolved).toBe(true);
        expect(resolution.needsResolution).toBe(true);
        expect(resolution.constraintName).toBe('Show');
        expect(resolution.functionName).toBe('show');
    });
    test('should create constraint function types', ()=>{
        const state = (0, _typeoperations.createTypeState)();
        // Add Show constraint
        const showSignature = {
            name: 'Show',
            typeParam: 'a',
            functions: new Map([
                [
                    'show',
                    (0, _ast.functionType)([
                        (0, _ast.intType)()
                    ], (0, _ast.stringType)())
                ]
            ])
        };
        (0, _types.addConstraintDefinition)(state.constraintRegistry, 'Show', showSignature);
        // Create constraint function type
        const constraintType = (0, _constraintresolution.createConstraintFunctionType)('Show', 'show', state);
        expect(constraintType.kind).toBe('function');
        if (constraintType.kind === 'function') {
            expect(constraintType.params).toHaveLength(1);
            expect(constraintType.params[0]).toEqual((0, _ast.intType)());
            expect(constraintType.return).toEqual((0, _ast.stringType)());
        }
    });
    test('should decorate environment with specialized functions', ()=>{
        const state = (0, _typeoperations.createTypeState)();
        // Add Show constraint and implementation
        const showSignature = {
            name: 'Show',
            typeParam: 'a',
            functions: new Map([
                [
                    'show',
                    (0, _ast.functionType)([
                        (0, _ast.intType)()
                    ], (0, _ast.stringType)())
                ]
            ])
        };
        (0, _types.addConstraintDefinition)(state.constraintRegistry, 'Show', showSignature);
        const intImpl = {
            functions: new Map([
                [
                    'show',
                    {
                        type: (0, _ast.functionType)([
                            (0, _ast.intType)()
                        ], (0, _ast.stringType)()),
                        quantifiedVars: [],
                        effects: new Set()
                    }
                ]
            ])
        };
        (0, _types.addConstraintImplementation)(state.constraintRegistry, 'Show', 'Int', intImpl);
        // Decorate environment
        const decoratedState = (0, _constraintresolution.decorateEnvironmentWithConstraintFunctions)(state);
        // Check that specialized function was added
        const specializedName = '__Show_show_Int';
        expect(decoratedState.environment.has(specializedName)).toBe(true);
        const specializedScheme = decoratedState.environment.get(specializedName);
        expect(specializedScheme).toBeTruthy();
        expect(specializedScheme?.type.kind).toBe('function');
    });
    test('should handle multiple constraints and implementations', ()=>{
        const state = (0, _typeoperations.createTypeState)();
        // Add Show constraint
        const showSignature = {
            name: 'Show',
            typeParam: 'a',
            functions: new Map([
                [
                    'show',
                    (0, _ast.functionType)([
                        (0, _ast.intType)()
                    ], (0, _ast.stringType)())
                ]
            ])
        };
        (0, _types.addConstraintDefinition)(state.constraintRegistry, 'Show', showSignature);
        // Add Eq constraint
        const eqSignature = {
            name: 'Eq',
            typeParam: 'a',
            functions: new Map([
                [
                    'equals',
                    (0, _ast.functionType)([
                        (0, _ast.intType)(),
                        (0, _ast.intType)()
                    ], (0, _ast.stringType)())
                ]
            ])
        };
        (0, _types.addConstraintDefinition)(state.constraintRegistry, 'Eq', eqSignature);
        // Add implementations for both
        const showImpl = {
            functions: new Map([
                [
                    'show',
                    {
                        type: (0, _ast.functionType)([
                            (0, _ast.intType)()
                        ], (0, _ast.stringType)()),
                        quantifiedVars: [],
                        effects: new Set()
                    }
                ]
            ])
        };
        (0, _types.addConstraintImplementation)(state.constraintRegistry, 'Show', 'Int', showImpl);
        const eqImpl = {
            functions: new Map([
                [
                    'equals',
                    {
                        type: (0, _ast.functionType)([
                            (0, _ast.intType)(),
                            (0, _ast.intType)()
                        ], (0, _ast.stringType)()),
                        quantifiedVars: [],
                        effects: new Set()
                    }
                ]
            ])
        };
        (0, _types.addConstraintImplementation)(state.constraintRegistry, 'Eq', 'Int', eqImpl);
        // Test resolution for both
        const showResolution = (0, _constraintresolution.tryResolveConstraintFunction)('show', [], [
            (0, _ast.intType)()
        ], state);
        const eqResolution = (0, _constraintresolution.tryResolveConstraintFunction)('equals', [], [
            (0, _ast.intType)(),
            (0, _ast.intType)()
        ], state);
        expect(showResolution.resolved).toBe(true);
        expect(showResolution.specializedName).toBe('__Show_show_Int');
        expect(eqResolution.resolved).toBe(true);
        expect(eqResolution.specializedName).toBe('__Eq_equals_Int');
    });
    test('should fail to resolve when no implementation exists', ()=>{
        const state = (0, _typeoperations.createTypeState)();
        // Add Show constraint but no implementation
        const showSignature = {
            name: 'Show',
            typeParam: 'a',
            functions: new Map([
                [
                    'show',
                    (0, _ast.functionType)([
                        (0, _ast.intType)()
                    ], (0, _ast.stringType)())
                ]
            ])
        };
        (0, _types.addConstraintDefinition)(state.constraintRegistry, 'Show', showSignature);
        // Try to resolve without implementation
        const resolution = (0, _constraintresolution.tryResolveConstraintFunction)('show', [], [
            (0, _ast.intType)()
        ], state);
        expect(resolution.resolved).toBe(false);
        expect(resolution.specializedName).toBeUndefined();
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Uvc3JjL3R5cGVyL19fdGVzdHNfXy9jb25zdHJhaW50LXJlc29sdXRpb24udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBcbiAgY3JlYXRlQ29uc3RyYWludFJlZ2lzdHJ5LCBcbiAgYWRkQ29uc3RyYWludERlZmluaXRpb24sIFxuICBhZGRDb25zdHJhaW50SW1wbGVtZW50YXRpb24sXG4gIHR5cGUgQ29uc3RyYWludFNpZ25hdHVyZSxcbiAgdHlwZSBDb25zdHJhaW50SW1wbGVtZW50YXRpb25cbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlVHlwZVN0YXRlIH0gZnJvbSAnLi4vdHlwZS1vcGVyYXRpb25zJztcbmltcG9ydCB7IFxuICB0cnlSZXNvbHZlQ29uc3RyYWludEZ1bmN0aW9uLFxuICBkZWNvcmF0ZUVudmlyb25tZW50V2l0aENvbnN0cmFpbnRGdW5jdGlvbnMsXG4gIHJlc29sdmVDb25zdHJhaW50VmFyaWFibGUsXG4gIGNyZWF0ZUNvbnN0cmFpbnRGdW5jdGlvblR5cGVcbn0gZnJvbSAnLi4vY29uc3RyYWludC1yZXNvbHV0aW9uJztcbmltcG9ydCB7IGludFR5cGUsIHN0cmluZ1R5cGUsIGZ1bmN0aW9uVHlwZSwgbGlzdFR5cGVXaXRoRWxlbWVudCB9IGZyb20gJy4uLy4uL2FzdCc7XG5cbmRlc2NyaWJlKCdDb25zdHJhaW50IFJlc29sdXRpb24nLCAoKSA9PiB7XG4gIHRlc3QoJ3Nob3VsZCByZXNvbHZlIGNvbnN0cmFpbnQgZnVuY3Rpb24gY2FsbHMnLCAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVUeXBlU3RhdGUoKTtcbiAgICBcbiAgICAvLyBBZGQgU2hvdyBjb25zdHJhaW50XG4gICAgY29uc3Qgc2hvd1NpZ25hdHVyZTogQ29uc3RyYWludFNpZ25hdHVyZSA9IHtcbiAgICAgIG5hbWU6ICdTaG93JyxcbiAgICAgIHR5cGVQYXJhbTogJ2EnLFxuICAgICAgZnVuY3Rpb25zOiBuZXcgTWFwKFtcbiAgICAgICAgWydzaG93JywgZnVuY3Rpb25UeXBlKFtpbnRUeXBlKCldLCBzdHJpbmdUeXBlKCkpXVxuICAgICAgXSlcbiAgICB9O1xuICAgIGFkZENvbnN0cmFpbnREZWZpbml0aW9uKHN0YXRlLmNvbnN0cmFpbnRSZWdpc3RyeSwgJ1Nob3cnLCBzaG93U2lnbmF0dXJlKTtcbiAgICBcbiAgICAvLyBBZGQgSW50IGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgaW50SW1wbDogQ29uc3RyYWludEltcGxlbWVudGF0aW9uID0ge1xuICAgICAgZnVuY3Rpb25zOiBuZXcgTWFwKFtcbiAgICAgICAgWydzaG93Jywge1xuICAgICAgICAgIHR5cGU6IGZ1bmN0aW9uVHlwZShbaW50VHlwZSgpXSwgc3RyaW5nVHlwZSgpKSxcbiAgICAgICAgICBxdWFudGlmaWVkVmFyczogW10sXG4gICAgICAgICAgZWZmZWN0czogbmV3IFNldCgpXG4gICAgICAgIH1dXG4gICAgICBdKVxuICAgIH07XG4gICAgYWRkQ29uc3RyYWludEltcGxlbWVudGF0aW9uKHN0YXRlLmNvbnN0cmFpbnRSZWdpc3RyeSwgJ1Nob3cnLCAnSW50JywgaW50SW1wbCk7XG4gICAgXG4gICAgLy8gVHJ5IHRvIHJlc29sdmUgYSBjb25zdHJhaW50IGZ1bmN0aW9uIGNhbGxcbiAgICBjb25zdCBhcmdUeXBlcyA9IFtpbnRUeXBlKCldO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0cnlSZXNvbHZlQ29uc3RyYWludEZ1bmN0aW9uKFxuICAgICAgJ3Nob3cnLFxuICAgICAgW10sIC8vIGFyZ3MgZXhwcmVzc2lvbnMgKG5vdCB1c2VkIGluIGN1cnJlbnQgaW1wbGVtZW50YXRpb24pXG4gICAgICBhcmdUeXBlcyxcbiAgICAgIHN0YXRlXG4gICAgKTtcbiAgICBcbiAgICBleHBlY3QocmVzb2x1dGlvbi5yZXNvbHZlZCkudG9CZSh0cnVlKTtcbiAgICBleHBlY3QocmVzb2x1dGlvbi5zcGVjaWFsaXplZE5hbWUpLnRvQmUoJ19fU2hvd19zaG93X0ludCcpO1xuICAgIGV4cGVjdChyZXNvbHV0aW9uLnR5cGVTY2hlbWUpLnRvQmVUcnV0aHkoKTtcbiAgfSk7XG5cbiAgdGVzdCgnc2hvdWxkIGRldGVjdCBjb25zdHJhaW50IHZhcmlhYmxlcycsICgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZVR5cGVTdGF0ZSgpO1xuICAgIFxuICAgIC8vIEFkZCBTaG93IGNvbnN0cmFpbnRcbiAgICBjb25zdCBzaG93U2lnbmF0dXJlOiBDb25zdHJhaW50U2lnbmF0dXJlID0ge1xuICAgICAgbmFtZTogJ1Nob3cnLFxuICAgICAgdHlwZVBhcmFtOiAnYScsXG4gICAgICBmdW5jdGlvbnM6IG5ldyBNYXAoW1xuICAgICAgICBbJ3Nob3cnLCBmdW5jdGlvblR5cGUoW2ludFR5cGUoKV0sIHN0cmluZ1R5cGUoKSldXG4gICAgICBdKVxuICAgIH07XG4gICAgYWRkQ29uc3RyYWludERlZmluaXRpb24oc3RhdGUuY29uc3RyYWludFJlZ2lzdHJ5LCAnU2hvdycsIHNob3dTaWduYXR1cmUpO1xuICAgIFxuICAgIC8vIFRlc3QgY29uc3RyYWludCB2YXJpYWJsZSBkZXRlY3Rpb25cbiAgICBjb25zdCByZXNvbHV0aW9uID0gcmVzb2x2ZUNvbnN0cmFpbnRWYXJpYWJsZSgnc2hvdycsIHN0YXRlKTtcbiAgICBcbiAgICBleHBlY3QocmVzb2x1dGlvbi5yZXNvbHZlZCkudG9CZSh0cnVlKTtcbiAgICBleHBlY3QocmVzb2x1dGlvbi5uZWVkc1Jlc29sdXRpb24pLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KHJlc29sdXRpb24uY29uc3RyYWludE5hbWUpLnRvQmUoJ1Nob3cnKTtcbiAgICBleHBlY3QocmVzb2x1dGlvbi5mdW5jdGlvbk5hbWUpLnRvQmUoJ3Nob3cnKTtcbiAgfSk7XG5cbiAgdGVzdCgnc2hvdWxkIGNyZWF0ZSBjb25zdHJhaW50IGZ1bmN0aW9uIHR5cGVzJywgKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlVHlwZVN0YXRlKCk7XG4gICAgXG4gICAgLy8gQWRkIFNob3cgY29uc3RyYWludFxuICAgIGNvbnN0IHNob3dTaWduYXR1cmU6IENvbnN0cmFpbnRTaWduYXR1cmUgPSB7XG4gICAgICBuYW1lOiAnU2hvdycsXG4gICAgICB0eXBlUGFyYW06ICdhJyxcbiAgICAgIGZ1bmN0aW9uczogbmV3IE1hcChbXG4gICAgICAgIFsnc2hvdycsIGZ1bmN0aW9uVHlwZShbaW50VHlwZSgpXSwgc3RyaW5nVHlwZSgpKV1cbiAgICAgIF0pXG4gICAgfTtcbiAgICBhZGRDb25zdHJhaW50RGVmaW5pdGlvbihzdGF0ZS5jb25zdHJhaW50UmVnaXN0cnksICdTaG93Jywgc2hvd1NpZ25hdHVyZSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGNvbnN0cmFpbnQgZnVuY3Rpb24gdHlwZVxuICAgIGNvbnN0IGNvbnN0cmFpbnRUeXBlID0gY3JlYXRlQ29uc3RyYWludEZ1bmN0aW9uVHlwZSgnU2hvdycsICdzaG93Jywgc3RhdGUpO1xuICAgIFxuICAgIGV4cGVjdChjb25zdHJhaW50VHlwZS5raW5kKS50b0JlKCdmdW5jdGlvbicpO1xuICAgIGlmIChjb25zdHJhaW50VHlwZS5raW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBleHBlY3QoY29uc3RyYWludFR5cGUucGFyYW1zKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QoY29uc3RyYWludFR5cGUucGFyYW1zWzBdKS50b0VxdWFsKGludFR5cGUoKSk7XG4gICAgICBleHBlY3QoY29uc3RyYWludFR5cGUucmV0dXJuKS50b0VxdWFsKHN0cmluZ1R5cGUoKSk7XG4gICAgfVxuICB9KTtcblxuICB0ZXN0KCdzaG91bGQgZGVjb3JhdGUgZW52aXJvbm1lbnQgd2l0aCBzcGVjaWFsaXplZCBmdW5jdGlvbnMnLCAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVUeXBlU3RhdGUoKTtcbiAgICBcbiAgICAvLyBBZGQgU2hvdyBjb25zdHJhaW50IGFuZCBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHNob3dTaWduYXR1cmU6IENvbnN0cmFpbnRTaWduYXR1cmUgPSB7XG4gICAgICBuYW1lOiAnU2hvdycsXG4gICAgICB0eXBlUGFyYW06ICdhJyxcbiAgICAgIGZ1bmN0aW9uczogbmV3IE1hcChbXG4gICAgICAgIFsnc2hvdycsIGZ1bmN0aW9uVHlwZShbaW50VHlwZSgpXSwgc3RyaW5nVHlwZSgpKV1cbiAgICAgIF0pXG4gICAgfTtcbiAgICBhZGRDb25zdHJhaW50RGVmaW5pdGlvbihzdGF0ZS5jb25zdHJhaW50UmVnaXN0cnksICdTaG93Jywgc2hvd1NpZ25hdHVyZSk7XG4gICAgXG4gICAgY29uc3QgaW50SW1wbDogQ29uc3RyYWludEltcGxlbWVudGF0aW9uID0ge1xuICAgICAgZnVuY3Rpb25zOiBuZXcgTWFwKFtcbiAgICAgICAgWydzaG93Jywge1xuICAgICAgICAgIHR5cGU6IGZ1bmN0aW9uVHlwZShbaW50VHlwZSgpXSwgc3RyaW5nVHlwZSgpKSxcbiAgICAgICAgICBxdWFudGlmaWVkVmFyczogW10sXG4gICAgICAgICAgZWZmZWN0czogbmV3IFNldCgpXG4gICAgICAgIH1dXG4gICAgICBdKVxuICAgIH07XG4gICAgYWRkQ29uc3RyYWludEltcGxlbWVudGF0aW9uKHN0YXRlLmNvbnN0cmFpbnRSZWdpc3RyeSwgJ1Nob3cnLCAnSW50JywgaW50SW1wbCk7XG4gICAgXG4gICAgLy8gRGVjb3JhdGUgZW52aXJvbm1lbnRcbiAgICBjb25zdCBkZWNvcmF0ZWRTdGF0ZSA9IGRlY29yYXRlRW52aXJvbm1lbnRXaXRoQ29uc3RyYWludEZ1bmN0aW9ucyhzdGF0ZSk7XG4gICAgXG4gICAgLy8gQ2hlY2sgdGhhdCBzcGVjaWFsaXplZCBmdW5jdGlvbiB3YXMgYWRkZWRcbiAgICBjb25zdCBzcGVjaWFsaXplZE5hbWUgPSAnX19TaG93X3Nob3dfSW50JztcbiAgICBleHBlY3QoZGVjb3JhdGVkU3RhdGUuZW52aXJvbm1lbnQuaGFzKHNwZWNpYWxpemVkTmFtZSkpLnRvQmUodHJ1ZSk7XG4gICAgXG4gICAgY29uc3Qgc3BlY2lhbGl6ZWRTY2hlbWUgPSBkZWNvcmF0ZWRTdGF0ZS5lbnZpcm9ubWVudC5nZXQoc3BlY2lhbGl6ZWROYW1lKTtcbiAgICBleHBlY3Qoc3BlY2lhbGl6ZWRTY2hlbWUpLnRvQmVUcnV0aHkoKTtcbiAgICBleHBlY3Qoc3BlY2lhbGl6ZWRTY2hlbWU/LnR5cGUua2luZCkudG9CZSgnZnVuY3Rpb24nKTtcbiAgfSk7XG5cbiAgdGVzdCgnc2hvdWxkIGhhbmRsZSBtdWx0aXBsZSBjb25zdHJhaW50cyBhbmQgaW1wbGVtZW50YXRpb25zJywgKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlVHlwZVN0YXRlKCk7XG4gICAgXG4gICAgLy8gQWRkIFNob3cgY29uc3RyYWludFxuICAgIGNvbnN0IHNob3dTaWduYXR1cmU6IENvbnN0cmFpbnRTaWduYXR1cmUgPSB7XG4gICAgICBuYW1lOiAnU2hvdycsXG4gICAgICB0eXBlUGFyYW06ICdhJyxcbiAgICAgIGZ1bmN0aW9uczogbmV3IE1hcChbXG4gICAgICAgIFsnc2hvdycsIGZ1bmN0aW9uVHlwZShbaW50VHlwZSgpXSwgc3RyaW5nVHlwZSgpKV1cbiAgICAgIF0pXG4gICAgfTtcbiAgICBhZGRDb25zdHJhaW50RGVmaW5pdGlvbihzdGF0ZS5jb25zdHJhaW50UmVnaXN0cnksICdTaG93Jywgc2hvd1NpZ25hdHVyZSk7XG4gICAgXG4gICAgLy8gQWRkIEVxIGNvbnN0cmFpbnRcbiAgICBjb25zdCBlcVNpZ25hdHVyZTogQ29uc3RyYWludFNpZ25hdHVyZSA9IHtcbiAgICAgIG5hbWU6ICdFcScsXG4gICAgICB0eXBlUGFyYW06ICdhJyxcbiAgICAgIGZ1bmN0aW9uczogbmV3IE1hcChbXG4gICAgICAgIFsnZXF1YWxzJywgZnVuY3Rpb25UeXBlKFtpbnRUeXBlKCksIGludFR5cGUoKV0sIHN0cmluZ1R5cGUoKSldXG4gICAgICBdKVxuICAgIH07XG4gICAgYWRkQ29uc3RyYWludERlZmluaXRpb24oc3RhdGUuY29uc3RyYWludFJlZ2lzdHJ5LCAnRXEnLCBlcVNpZ25hdHVyZSk7XG4gICAgXG4gICAgLy8gQWRkIGltcGxlbWVudGF0aW9ucyBmb3IgYm90aFxuICAgIGNvbnN0IHNob3dJbXBsOiBDb25zdHJhaW50SW1wbGVtZW50YXRpb24gPSB7XG4gICAgICBmdW5jdGlvbnM6IG5ldyBNYXAoW1xuICAgICAgICBbJ3Nob3cnLCB7XG4gICAgICAgICAgdHlwZTogZnVuY3Rpb25UeXBlKFtpbnRUeXBlKCldLCBzdHJpbmdUeXBlKCkpLFxuICAgICAgICAgIHF1YW50aWZpZWRWYXJzOiBbXSxcbiAgICAgICAgICBlZmZlY3RzOiBuZXcgU2V0KClcbiAgICAgICAgfV1cbiAgICAgIF0pXG4gICAgfTtcbiAgICBhZGRDb25zdHJhaW50SW1wbGVtZW50YXRpb24oc3RhdGUuY29uc3RyYWludFJlZ2lzdHJ5LCAnU2hvdycsICdJbnQnLCBzaG93SW1wbCk7XG4gICAgXG4gICAgY29uc3QgZXFJbXBsOiBDb25zdHJhaW50SW1wbGVtZW50YXRpb24gPSB7XG4gICAgICBmdW5jdGlvbnM6IG5ldyBNYXAoW1xuICAgICAgICBbJ2VxdWFscycsIHtcbiAgICAgICAgICB0eXBlOiBmdW5jdGlvblR5cGUoW2ludFR5cGUoKSwgaW50VHlwZSgpXSwgc3RyaW5nVHlwZSgpKSxcbiAgICAgICAgICBxdWFudGlmaWVkVmFyczogW10sXG4gICAgICAgICAgZWZmZWN0czogbmV3IFNldCgpXG4gICAgICAgIH1dXG4gICAgICBdKVxuICAgIH07XG4gICAgYWRkQ29uc3RyYWludEltcGxlbWVudGF0aW9uKHN0YXRlLmNvbnN0cmFpbnRSZWdpc3RyeSwgJ0VxJywgJ0ludCcsIGVxSW1wbCk7XG4gICAgXG4gICAgLy8gVGVzdCByZXNvbHV0aW9uIGZvciBib3RoXG4gICAgY29uc3Qgc2hvd1Jlc29sdXRpb24gPSB0cnlSZXNvbHZlQ29uc3RyYWludEZ1bmN0aW9uKCdzaG93JywgW10sIFtpbnRUeXBlKCldLCBzdGF0ZSk7XG4gICAgY29uc3QgZXFSZXNvbHV0aW9uID0gdHJ5UmVzb2x2ZUNvbnN0cmFpbnRGdW5jdGlvbignZXF1YWxzJywgW10sIFtpbnRUeXBlKCksIGludFR5cGUoKV0sIHN0YXRlKTtcbiAgICBcbiAgICBleHBlY3Qoc2hvd1Jlc29sdXRpb24ucmVzb2x2ZWQpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KHNob3dSZXNvbHV0aW9uLnNwZWNpYWxpemVkTmFtZSkudG9CZSgnX19TaG93X3Nob3dfSW50Jyk7XG4gICAgXG4gICAgZXhwZWN0KGVxUmVzb2x1dGlvbi5yZXNvbHZlZCkudG9CZSh0cnVlKTtcbiAgICBleHBlY3QoZXFSZXNvbHV0aW9uLnNwZWNpYWxpemVkTmFtZSkudG9CZSgnX19FcV9lcXVhbHNfSW50Jyk7XG4gIH0pO1xuXG4gIHRlc3QoJ3Nob3VsZCBmYWlsIHRvIHJlc29sdmUgd2hlbiBubyBpbXBsZW1lbnRhdGlvbiBleGlzdHMnLCAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVUeXBlU3RhdGUoKTtcbiAgICBcbiAgICAvLyBBZGQgU2hvdyBjb25zdHJhaW50IGJ1dCBubyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHNob3dTaWduYXR1cmU6IENvbnN0cmFpbnRTaWduYXR1cmUgPSB7XG4gICAgICBuYW1lOiAnU2hvdycsXG4gICAgICB0eXBlUGFyYW06ICdhJyxcbiAgICAgIGZ1bmN0aW9uczogbmV3IE1hcChbXG4gICAgICAgIFsnc2hvdycsIGZ1bmN0aW9uVHlwZShbaW50VHlwZSgpXSwgc3RyaW5nVHlwZSgpKV1cbiAgICAgIF0pXG4gICAgfTtcbiAgICBhZGRDb25zdHJhaW50RGVmaW5pdGlvbihzdGF0ZS5jb25zdHJhaW50UmVnaXN0cnksICdTaG93Jywgc2hvd1NpZ25hdHVyZSk7XG4gICAgXG4gICAgLy8gVHJ5IHRvIHJlc29sdmUgd2l0aG91dCBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0cnlSZXNvbHZlQ29uc3RyYWludEZ1bmN0aW9uKCdzaG93JywgW10sIFtpbnRUeXBlKCldLCBzdGF0ZSk7XG4gICAgXG4gICAgZXhwZWN0KHJlc29sdXRpb24ucmVzb2x2ZWQpLnRvQmUoZmFsc2UpO1xuICAgIGV4cGVjdChyZXNvbHV0aW9uLnNwZWNpYWxpemVkTmFtZSkudG9CZVVuZGVmaW5lZCgpO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJkZXNjcmliZSIsInRlc3QiLCJzdGF0ZSIsImNyZWF0ZVR5cGVTdGF0ZSIsInNob3dTaWduYXR1cmUiLCJuYW1lIiwidHlwZVBhcmFtIiwiZnVuY3Rpb25zIiwiTWFwIiwiZnVuY3Rpb25UeXBlIiwiaW50VHlwZSIsInN0cmluZ1R5cGUiLCJhZGRDb25zdHJhaW50RGVmaW5pdGlvbiIsImNvbnN0cmFpbnRSZWdpc3RyeSIsImludEltcGwiLCJ0eXBlIiwicXVhbnRpZmllZFZhcnMiLCJlZmZlY3RzIiwiU2V0IiwiYWRkQ29uc3RyYWludEltcGxlbWVudGF0aW9uIiwiYXJnVHlwZXMiLCJyZXNvbHV0aW9uIiwidHJ5UmVzb2x2ZUNvbnN0cmFpbnRGdW5jdGlvbiIsImV4cGVjdCIsInJlc29sdmVkIiwidG9CZSIsInNwZWNpYWxpemVkTmFtZSIsInR5cGVTY2hlbWUiLCJ0b0JlVHJ1dGh5IiwicmVzb2x2ZUNvbnN0cmFpbnRWYXJpYWJsZSIsIm5lZWRzUmVzb2x1dGlvbiIsImNvbnN0cmFpbnROYW1lIiwiZnVuY3Rpb25OYW1lIiwiY29uc3RyYWludFR5cGUiLCJjcmVhdGVDb25zdHJhaW50RnVuY3Rpb25UeXBlIiwia2luZCIsInBhcmFtcyIsInRvSGF2ZUxlbmd0aCIsInRvRXF1YWwiLCJyZXR1cm4iLCJkZWNvcmF0ZWRTdGF0ZSIsImRlY29yYXRlRW52aXJvbm1lbnRXaXRoQ29uc3RyYWludEZ1bmN0aW9ucyIsImVudmlyb25tZW50IiwiaGFzIiwic3BlY2lhbGl6ZWRTY2hlbWUiLCJnZXQiLCJlcVNpZ25hdHVyZSIsInNob3dJbXBsIiwiZXFJbXBsIiwic2hvd1Jlc29sdXRpb24iLCJlcVJl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