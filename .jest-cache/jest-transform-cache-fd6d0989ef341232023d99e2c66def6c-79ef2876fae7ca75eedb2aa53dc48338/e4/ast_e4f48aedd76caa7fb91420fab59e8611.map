{"version":3,"sources":["/workspace/src/ast.ts"],"sourcesContent":["// AST types for Noolang\n\nexport type Position = {\n\tline: number;\n\tcolumn: number;\n};\n\nexport type Location = {\n\tstart: Position;\n\tend: Position;\n};\n\n// Type system\nexport type Effect =\n\t| 'log'\n\t| 'read'\n\t| 'write'\n\t| 'state'\n\t| 'time'\n\t| 'rand'\n\t| 'ffi'\n\t| 'async';\n\n// Type constraints for constrained polymorphism\nexport type Constraint =\n\t| { kind: 'is'; typeVar: string; constraint: string } // a is Collection\n\t| { kind: 'hasField'; typeVar: string; field: string; fieldType: Type } // a has field \"length\" of type Int\n\t| { kind: 'implements'; typeVar: string; interfaceName: string } // a implements Show\n\t| { kind: 'custom'; typeVar: string; constraint: string; args: Type[] }; // a satisfies MyConstraint T1 T2\n\nexport type ConstraintExpr =\n\t| Constraint\n\t| { kind: 'and'; left: ConstraintExpr; right: ConstraintExpr }\n\t| { kind: 'or'; left: ConstraintExpr; right: ConstraintExpr }\n\t| { kind: 'paren'; expr: ConstraintExpr };\n\n// Extracted type definitions\nexport type PrimitiveType = {\n\tkind: 'primitive';\n\tname: 'Int' | 'String' | 'Bool' | 'List';\n};\n\nexport type FunctionType = {\n\tkind: 'function';\n\tparams: Type[];\n\treturn: Type;\n\teffects: Set<Effect>;\n\tconstraints?: Constraint[];\n};\n\nexport type VariableType = {\n\tkind: 'variable';\n\tname: string;\n\tconstraints?: Constraint[];\n};\n\nexport type ListType = {\n\tkind: 'list';\n\telement: Type;\n};\n\nexport type UnionType = {\n\tkind: 'union';\n\ttypes: Type[];\n};\n\nexport type VariantType = {\n\tkind: 'variant';\n\tname: string;\n\targs: Type[];\n};\n\nexport type ADTType = {\n\tkind: 'adt';\n\tname: string;\n\ttypeParams: string[];\n\tconstructors: ConstructorDefinition[];\n};\n\nexport type UnitType = {\n\tkind: 'unit';\n};\n\nexport type UnknownType = {\n\tkind: 'unknown';\n};\n\nexport type Type =\n\t| PrimitiveType\n\t| FunctionType\n\t| VariableType\n\t| ListType\n\t| TupleType\n\t| RecordType\n\t| UnionType\n\t| VariantType\n\t| ADTType\n\t| UnitType\n\t| UnknownType;\n\n// Expressions\nexport type Expression =\n\t| LiteralExpression\n\t| VariableExpression\n\t| FunctionExpression\n\t| ApplicationExpression\n\t| PipelineExpression\n\t| BinaryExpression\n\t| IfExpression\n\t| DefinitionExpression\n\t| MutableDefinitionExpression\n\t| MutationExpression\n\t| ImportExpression\n\t| RecordExpression\n\t| TupleExpression\n\t| UnitExpression\n\t| AccessorExpression\n\t| TypedExpression\n\t| ConstrainedExpression\n\t| ListExpression\n\t| WhereExpression\n\t| TypeDefinitionExpression\n\t| MatchExpression\n\t| ConstraintDefinitionExpression\n\t| ImplementDefinitionExpression\n\t| FFIExpression;\n\nexport interface LiteralExpression {\n\tkind: 'literal';\n\tvalue: number | string | boolean | Expression[] | null; // null represents unit\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface VariableExpression {\n\tkind: 'variable';\n\tname: string;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface FunctionExpression {\n\tkind: 'function';\n\tparams: string[];\n\tbody: Expression;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface ApplicationExpression {\n\tkind: 'application';\n\tfunc: Expression;\n\targs: Expression[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface PipelineExpression {\n\tkind: 'pipeline';\n\tsteps: Expression[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface BinaryExpression {\n\tkind: 'binary';\n\toperator:\n\t\t| '+'\n\t\t| '-'\n\t\t| '*'\n\t\t| '/'\n\t\t| '=='\n\t\t| '!='\n\t\t| '<'\n\t\t| '>'\n\t\t| '<='\n\t\t| '>='\n\t\t| '|'\n\t\t| '|>'\n\t\t| '<|'\n\t\t| ';'\n\t\t| '$';\n\tleft: Expression;\n\tright: Expression;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface IfExpression {\n\tkind: 'if';\n\tcondition: Expression;\n\tthen: Expression;\n\telse: Expression;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface DefinitionExpression {\n\tkind: 'definition';\n\tname: string;\n\tvalue: Expression;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface MutableDefinitionExpression {\n\tkind: 'mutable-definition';\n\tname: string;\n\tvalue: Expression;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface MutationExpression {\n\tkind: 'mutation';\n\ttarget: string;\n\tvalue: Expression;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface ImportExpression {\n\tkind: 'import';\n\tpath: string;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport type RecordExpression = {\n\tkind: 'record';\n\tfields: FieldExpression[];\n\ttype?: Type;\n\tlocation: Location;\n};\n\nexport interface FieldExpression {\n\tname: string;\n\tvalue: Expression;\n}\n\nexport interface AccessorExpression {\n\tkind: 'accessor';\n\tfield: string;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface FFIExpression {\n\tkind: 'ffi';\n\tmodule: string;\n\tfunctionName: string;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface TupleExpression {\n\tkind: 'tuple';\n\telements: Expression[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface UnitExpression {\n\tkind: 'unit';\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface TypedExpression {\n\tkind: 'typed';\n\texpression: Expression;\n\ttype: Type;\n\tlocation: Location;\n}\n\nexport interface ConstrainedExpression {\n\tkind: 'constrained';\n\texpression: Expression;\n\ttype: Type;\n\tconstraint: ConstraintExpr;\n\tlocation: Location;\n}\n\nexport interface ListExpression {\n\tkind: 'list';\n\telements: Expression[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface WhereExpression {\n\tkind: 'where';\n\tmain: Expression;\n\tdefinitions: (DefinitionExpression | MutableDefinitionExpression)[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\n// ADT Constructor definition\nexport interface ConstructorDefinition {\n\tname: string;\n\targs: Type[];\n\tlocation: Location;\n}\n\n// ADT Type definition\nexport interface TypeDefinitionExpression {\n\tkind: 'type-definition';\n\tname: string;\n\ttypeParams: string[]; // Type parameters like 'a' in Option a\n\tconstructors: ConstructorDefinition[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\n// Pattern in pattern matching\nexport type Pattern =\n\t| { kind: 'constructor'; name: string; args: Pattern[]; location: Location }\n\t| { kind: 'variable'; name: string; location: Location }\n\t| { kind: 'literal'; value: number | string | boolean; location: Location }\n\t| { kind: 'wildcard'; location: Location };\n\n// Pattern matching case\nexport interface MatchCase {\n\tpattern: Pattern;\n\texpression: Expression;\n\tlocation: Location;\n}\n\n// Match expression\nexport interface MatchExpression {\n\tkind: 'match';\n\texpression: Expression;\n\tcases: MatchCase[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\n// Constraint definition for trait system\nexport interface ConstraintDefinitionExpression {\n\tkind: 'constraint-definition';\n\tname: string;\n\ttypeParam: string;\n\tfunctions: ConstraintFunction[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface ConstraintFunction {\n\tname: string;\n\ttypeParams: string[];\n\ttype: Type;\n\tlocation: Location;\n}\n\n// Implement definition for trait system\nexport interface ImplementDefinitionExpression {\n\tkind: 'implement-definition';\n\tconstraintName: string;\n\ttypeName: string;\n\timplementations: ImplementationFunction[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface ImplementationFunction {\n\tname: string;\n\tvalue: Expression;\n\tlocation: Location;\n}\n\n// Program\nexport interface Program {\n\tstatements: Expression[];\n\tlocation: Location;\n}\n\n// Utility functions\nexport const createLocation = (start: Position, end: Position): Location => ({\n\tstart,\n\tend,\n});\n\nexport const createPosition = (line: number, column: number): Position => ({\n\tline,\n\tcolumn,\n});\n\n// Type constructors\nexport const intType = (): PrimitiveType => ({\n\tkind: 'primitive',\n\tname: 'Int',\n});\nexport const numberType = (): PrimitiveType => ({\n\tkind: 'primitive',\n\tname: 'Int',\n}); // Alias for backwards compatibility\nexport const stringType = (): PrimitiveType => ({\n\tkind: 'primitive',\n\tname: 'String',\n});\nexport const boolType = (): VariantType => ({\n\tkind: 'variant',\n\tname: 'Bool',\n\targs: [],\n});\nexport const listType = (): PrimitiveType => ({\n\tkind: 'primitive',\n\tname: 'List',\n});\nexport const functionType = (\n\tparams: Type[],\n\treturnType: Type,\n\teffects: Set<Effect> = new Set()\n): FunctionType => ({\n\tkind: 'function',\n\tparams,\n\treturn: returnType,\n\teffects,\n});\nexport const typeVariable = (name: string): VariableType => ({\n\tkind: 'variable',\n\tname,\n});\nexport const unknownType = (): UnknownType => ({ kind: 'unknown' });\n\n// New type constructors\nexport const listTypeWithElement = (element: Type): ListType => ({\n\tkind: 'list',\n\telement,\n});\n\nexport type TupleType = {\n\tkind: 'tuple';\n\telements: Type[];\n};\n\nexport const tupleType = (elements: Type[]): TupleType => ({\n\tkind: 'tuple',\n\telements,\n});\n\n// Add tuple type constructor for Tuple T1 T2 syntax\nexport const tupleTypeConstructor = (elementTypes: Type[]): TupleType => ({\n\tkind: 'tuple',\n\telements: elementTypes,\n});\n\nexport type RecordType = {\n\tkind: 'record';\n\tfields: { [key: string]: Type };\n};\n\nexport const recordType = (fields: { [key: string]: Type }): RecordType => ({\n\tkind: 'record',\n\tfields,\n});\n\n// Constructor functions for new types\nexport const primitiveType = (\n\tname: 'Int' | 'String' | 'Bool' | 'List'\n): PrimitiveType => ({\n\tkind: 'primitive',\n\tname,\n});\n\nexport const variableType = (\n\tname: string,\n\tconstraints?: Constraint[]\n): VariableType => ({\n\tkind: 'variable',\n\tname,\n\tconstraints,\n});\n\nexport const unionType = (types: Type[]): UnionType => ({\n\tkind: 'union',\n\ttypes,\n});\n\nexport const variantType = (name: string, args: Type[]): VariantType => ({\n\tkind: 'variant',\n\tname,\n\targs,\n});\n\nexport const adtType = (\n\tname: string,\n\ttypeParams: string[],\n\tconstructors: ConstructorDefinition[]\n): ADTType => ({\n\tkind: 'adt',\n\tname,\n\ttypeParams,\n\tconstructors,\n});\n\nexport const unitType = (): UnitType => ({ kind: 'unit' });\n\n// Helper functions to create ADT variant types\nexport const optionType = (element: Type): VariantType => ({\n\tkind: 'variant',\n\tname: 'Option',\n\targs: [element],\n});\n\nexport const resultType = (success: Type, error: Type): VariantType => ({\n\tkind: 'variant',\n\tname: 'Result',\n\targs: [success, error],\n});\n\n// Convenience functions for common types\nexport const optionInt = (): VariantType => optionType(intType());\nexport const resultString = (error: Type): VariantType =>\n\tresultType(stringType(), error);\n\nexport type HasFieldConstraint = {\n\tkind: 'hasField';\n\ttypeVar: string;\n\tfield: string;\n\tfieldType: Type;\n};\n\nexport type IsConstraint = {\n\tkind: 'is';\n\ttypeVar: string;\n\tconstraint: string;\n};\n\n// Constraint helper functions\nexport const isConstraint = (\n\ttypeVar: string,\n\tconstraint: string\n): IsConstraint => ({\n\tkind: 'is',\n\ttypeVar,\n\tconstraint,\n});\n\nexport const hasFieldConstraint = (\n\ttypeVar: string,\n\tfield: string,\n\tfieldType: Type\n): HasFieldConstraint => ({\n\tkind: 'hasField',\n\ttypeVar,\n\tfield,\n\tfieldType,\n});\n\nexport type ImplementsConstraint = {\n\tkind: 'implements';\n\ttypeVar: string;\n\tinterfaceName: string;\n};\n\nexport const implementsConstraint = (\n\ttypeVar: string,\n\tinterfaceName: string\n): ImplementsConstraint => ({\n\tkind: 'implements',\n\ttypeVar,\n\tinterfaceName,\n});\n\nexport type CustomConstraint = {\n\tkind: 'custom';\n\ttypeVar: string;\n\tconstraint: string;\n\targs: Type[];\n};\n\nexport const customConstraint = (\n\ttypeVar: string,\n\tconstraint: string,\n\targs: Type[]\n): CustomConstraint => ({\n\tkind: 'custom',\n\ttypeVar,\n\tconstraint,\n\targs,\n});\n\n// Constrained type variable\nexport const constrainedTypeVariable = (\n\tname: string,\n\tconstraints: Constraint[]\n): VariableType => ({\n\tkind: 'variable',\n\tname,\n\tconstraints,\n});\n\n// Constrained function type\nexport const constrainedFunctionType = (\n\tparams: Type[],\n\treturnType: Type,\n\teffects: Set<Effect> = new Set(),\n\tconstraints: Constraint[] = []\n): FunctionType => ({\n\tkind: 'function',\n\tparams,\n\treturn: returnType,\n\teffects,\n\tconstraints,\n});\n"],"names":["adtType","boolType","constrainedFunctionType","constrainedTypeVariable","createLocation","createPosition","customConstraint","functionType","hasFieldConstraint","implementsConstraint","intType","isConstraint","listType","listTypeWithElement","numberType","optionInt","optionType","primitiveType","recordType","resultString","resultType","stringType","tupleType","tupleTypeConstructor","typeVariable","unionType","unitType","unknownType","variableType","variantType","start","end","line","column","kind","name","args","params","returnType","effects","Set","return","element","elements","elementTypes","fields","constraints","types","typeParams","constructors","success","error","typeVar","constraint","field","fieldType","interfaceName"],"mappings":"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"}