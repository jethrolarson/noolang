{"version":3,"sources":["/workspace/src/typer/__tests__/trait-system.test.ts"],"sourcesContent":["import { \n  createConstraintRegistry, \n  addConstraintDefinition, \n  addConstraintImplementation, \n  resolveConstraintFunction,\n  getConstraintSignature,\n  type ConstraintSignature,\n  type ConstraintImplementation\n} from '../types';\nimport { intType, stringType, functionType, listTypeWithElement } from '../../ast';\n\ndescribe('Trait System Infrastructure', () => {\n  test('should create empty constraint registry', () => {\n    const registry = createConstraintRegistry();\n    expect(registry.size).toBe(0);\n  });\n\n  test('should add constraint definition', () => {\n    const registry = createConstraintRegistry();\n    \n    const showSignature: ConstraintSignature = {\n      name: 'Show',\n      typeParam: 'a',\n      functions: new Map([\n        ['show', functionType([intType()], stringType())]\n      ])\n    };\n\n    addConstraintDefinition(registry, 'Show', showSignature);\n    \n    expect(registry.size).toBe(1);\n    expect(registry.has('Show')).toBe(true);\n    \n    const constraint = registry.get('Show');\n    expect(constraint?.signature.name).toBe('Show');\n    expect(constraint?.signature.typeParam).toBe('a');\n    expect(constraint?.implementations.size).toBe(0);\n  });\n\n  test('should add constraint implementation', () => {\n    const registry = createConstraintRegistry();\n    \n    // Add constraint definition first\n    const showSignature: ConstraintSignature = {\n      name: 'Show',\n      typeParam: 'a', \n      functions: new Map([\n        ['show', functionType([intType()], stringType())]\n      ])\n    };\n    addConstraintDefinition(registry, 'Show', showSignature);\n\n    // Add implementation\n    const implementation: ConstraintImplementation = {\n      functions: new Map([\n        ['show', {\n          type: functionType([intType()], stringType()),\n          quantifiedVars: [],\n          effects: new Set()\n        }]\n      ])\n    };\n\n    const success = addConstraintImplementation(registry, 'Show', 'Int', implementation);\n    \n    expect(success).toBe(true);\n    \n    const constraint = registry.get('Show');\n    expect(constraint?.implementations.size).toBe(1);\n    expect(constraint?.implementations.has('Int')).toBe(true);\n  });\n\n  test('should fail to add implementation for non-existent constraint', () => {\n    const registry = createConstraintRegistry();\n    \n    const implementation: ConstraintImplementation = {\n      functions: new Map([\n        ['show', {\n          type: functionType([intType()], stringType()),\n          quantifiedVars: [],\n          effects: new Set()\n        }]\n      ])\n    };\n\n    const success = addConstraintImplementation(registry, 'NonExistent', 'Int', implementation);\n    \n    expect(success).toBe(false);\n  });\n\n  test('should resolve constraint function', () => {\n    const registry = createConstraintRegistry();\n    \n    // Set up constraint\n    const showSignature: ConstraintSignature = {\n      name: 'Show',\n      typeParam: 'a',\n      functions: new Map([\n        ['show', functionType([intType()], stringType())]\n      ])\n    };\n    addConstraintDefinition(registry, 'Show', showSignature);\n\n    // Add implementation  \n    const showImpl = {\n      type: functionType([intType()], stringType()),\n      quantifiedVars: [],\n      effects: new Set<import('../../ast').Effect>()\n    };\n    const implementation: ConstraintImplementation = {\n      functions: new Map([['show', showImpl]])\n    };\n    addConstraintImplementation(registry, 'Show', 'Int', implementation);\n\n    // Resolve function\n    const resolved = resolveConstraintFunction(registry, 'Show', 'show', intType());\n    \n    expect(resolved).toBeTruthy();\n    expect(resolved?.type).toEqual(functionType([intType()], stringType()));\n  });\n\n  test('should return null for unresolved constraint function', () => {\n    const registry = createConstraintRegistry();\n    \n    const resolved = resolveConstraintFunction(registry, 'NonExistent', 'show', intType());\n    \n    expect(resolved).toBeNull();\n  });\n\n  test('should get constraint signature', () => {\n    const registry = createConstraintRegistry();\n    \n    const showSignature: ConstraintSignature = {\n      name: 'Show',\n      typeParam: 'a',\n      functions: new Map([\n        ['show', functionType([intType()], stringType())]\n      ])\n    };\n    addConstraintDefinition(registry, 'Show', showSignature);\n\n    const retrieved = getConstraintSignature(registry, 'Show');\n    \n    expect(retrieved).toBeTruthy();\n    expect(retrieved?.name).toBe('Show');\n    expect(retrieved?.typeParam).toBe('a');\n    expect(retrieved?.functions.get('show')).toEqual(functionType([intType()], stringType()));\n  });\n\n  test('should handle complex constraint with multiple functions', () => {\n    const registry = createConstraintRegistry();\n    \n    // Define Monad constraint\n    const monadSignature: ConstraintSignature = {\n      name: 'Monad',\n      typeParam: 'm',\n      functions: new Map([\n        ['bind', functionType([\n          listTypeWithElement(intType()), \n          functionType([intType()], listTypeWithElement(intType()))\n        ], listTypeWithElement(intType()))],\n        ['pure', functionType([intType()], listTypeWithElement(intType()))]\n      ])\n    };\n    addConstraintDefinition(registry, 'Monad', monadSignature);\n\n    // Add List implementation\n    const listImpl: ConstraintImplementation = {\n      functions: new Map([\n        ['bind', {\n          type: functionType([\n            listTypeWithElement(intType()), \n            functionType([intType()], listTypeWithElement(intType()))\n          ], listTypeWithElement(intType())),\n          quantifiedVars: ['a', 'b'],\n          effects: new Set()\n        }],\n        ['pure', {\n          type: functionType([intType()], listTypeWithElement(intType())),\n          quantifiedVars: ['a'], \n          effects: new Set()\n        }]\n      ])\n    };\n    addConstraintImplementation(registry, 'Monad', 'List Int', listImpl);\n\n    // Test resolution\n    const bindResolved = resolveConstraintFunction(\n      registry, \n      'Monad', \n      'bind', \n      listTypeWithElement(intType())\n    );\n    const pureResolved = resolveConstraintFunction(\n      registry,\n      'Monad', \n      'pure',\n      listTypeWithElement(intType())\n    );\n\n    expect(bindResolved).toBeTruthy();\n    expect(pureResolved).toBeTruthy();\n    expect(bindResolved?.quantifiedVars).toEqual(['a', 'b']);\n    expect(pureResolved?.quantifiedVars).toEqual(['a']);\n  });\n});"],"names":["describe","test","registry","createConstraintRegistry","expect","size","toBe","showSignature","name","typeParam","functions","Map","functionType","intType","stringType","addConstraintDefinition","has","constraint","get","signature","implementations","implementation","type","quantifiedVars","effects","Set","success","addConstraintImplementation","showImpl","resolved","resolveConstraintFunction","toBeTruthy","toEqual","toBeNull","retrieved","getConstraintSignature","monadSignature","listTypeWithElement","listImpl","bindResolved","pureResolved"],"mappings":"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"}