{"version":3,"sources":["/workspace/src/typer/constraint-resolution.ts"],"sourcesContent":["// Constraint function resolution for trait system\nimport { \n  Type, \n  Expression, \n  VariableExpression, \n  ApplicationExpression,\n  typeVariable,\n  functionType\n} from '../ast';\nimport { \n  TypeState, \n  TypeResult, \n  TypeScheme,\n  resolveConstraintFunction,\n  createPureTypeResult,\n  createTypeResult\n} from './types';\nimport { substitute } from './substitute';\nimport { typeToString } from './helpers';\n\n/**\n * Check if a function call might be a constraint function and resolve it\n */\nexport function tryResolveConstraintFunction(\n  functionName: string,\n  args: Expression[],\n  argTypes: Type[],\n  state: TypeState\n): { resolved: boolean; specializedName?: string; typeScheme?: TypeScheme } {\n  \n  // Search through all constraints to see if this function name exists\n  for (const [constraintName, constraintInfo] of state.constraintRegistry) {\n    if (constraintInfo.signature.functions.has(functionName)) {\n      // This is potentially a constraint function call\n      \n      // Try to resolve based on the first argument's type (common pattern)\n      if (argTypes.length > 0) {\n        const firstArgType = substitute(argTypes[0], state.substitution);\n        \n        // Only resolve if we have a concrete type (not a type variable)\n        if (firstArgType.kind !== 'variable') {\n          const implementation = resolveConstraintFunction(\n            state.constraintRegistry,\n            constraintName,\n            functionName,\n            firstArgType\n          );\n          \n          if (implementation) {\n            // Generate specialized function name\n            const typeName = typeToString(firstArgType);\n            const specializedName = `__${constraintName}_${functionName}_${typeName}`;\n            \n            return {\n              resolved: true,\n              specializedName,\n              typeScheme: implementation\n            };\n          }\n        }\n      }\n    }\n  }\n  \n  return { resolved: false };\n}\n\n/**\n * Decorate the environment with specialized constraint functions\n */\nexport function decorateEnvironmentWithConstraintFunctions(state: TypeState): TypeState {\n  const newEnvironment = new Map(state.environment);\n  \n  // Add all available constraint implementations to the environment\n  for (const [constraintName, constraintInfo] of state.constraintRegistry) {\n    for (const [functionName, functionType] of constraintInfo.signature.functions) {\n      for (const [typeName, implementation] of constraintInfo.implementations) {\n        const specializedName = `__${constraintName}_${functionName}_${typeName}`;\n        \n        // Add the specialized function to the environment\n        for (const [implName, implScheme] of implementation.functions) {\n          if (implName === functionName) {\n            newEnvironment.set(specializedName, implScheme);\n          }\n        }\n      }\n    }\n  }\n  \n  return {\n    ...state,\n    environment: newEnvironment\n  };\n}\n\n/**\n * Check if a variable reference is a constraint function and needs resolution\n */\nexport function resolveConstraintVariable(\n  name: string,\n  state: TypeState\n): { resolved: boolean; needsResolution?: boolean; constraintName?: string; functionName?: string } {\n  \n  // Check if this is a constraint function name\n  for (const [constraintName, constraintInfo] of state.constraintRegistry) {\n    if (constraintInfo.signature.functions.has(name)) {\n      return {\n        resolved: true,\n        needsResolution: true,\n        constraintName,\n        functionName: name\n      };\n    }\n  }\n  \n  return { resolved: false };\n}\n\n/**\n * Create a constraint function type that includes information about needed resolution\n */\nexport function createConstraintFunctionType(\n  constraintName: string,\n  functionName: string,\n  state: TypeState\n): Type {\n  const constraintInfo = state.constraintRegistry.get(constraintName);\n  if (!constraintInfo) {\n    throw new Error(`Constraint '${constraintName}' not found`);\n  }\n  \n  const functionType = constraintInfo.signature.functions.get(functionName);\n  if (!functionType) {\n    throw new Error(`Function '${functionName}' not found in constraint '${constraintName}'`);\n  }\n  \n  // Return the function type with constraint information\n  // We'll handle the actual resolution during application\n  return functionType;\n}\n\n/**\n * Generate constraint qualification error when resolution fails\n */\nexport function generateConstraintError(\n  constraintName: string,\n  functionName: string,\n  attemptedType: Type,\n  state: TypeState\n): string {\n  const typeName = typeToString(attemptedType);\n  const availableImpls = state.constraintRegistry.get(constraintName)?.implementations;\n  const availableTypes = availableImpls ? Array.from(availableImpls.keys()) : [];\n  \n  let message = `No implementation of constraint '${constraintName}' found for type '${typeName}' when calling '${functionName}'.`;\n  \n  if (availableTypes.length > 0) {\n    message += `\\nAvailable implementations: ${availableTypes.join(', ')}`;\n  } else {\n    message += `\\nNo implementations of '${constraintName}' have been defined.`;\n  }\n  \n  message += `\\n\\nTo fix this, add an implementation:\\nimplement ${constraintName} ${typeName} (\\n  ${functionName} = ...\\n);`;\n  \n  return message;\n}"],"names":["createConstraintFunctionType","decorateEnvironmentWithConstraintFunctions","generateConstraintError","resolveConstraintVariable","tryResolveConstraintFunction","functionName","args","argTypes","state","constraintName","constraintInfo","constraintRegistry","signature","functions","has","length","firstArgType","substitute","substitution","kind","implementation","resolveConstraintFunction","typeName","typeToString","specializedName","resolved","typeScheme","newEnvironment","Map","environment","functionType","implementations","implName","implScheme","set","name","needsResolution","get","Error","attemptedType","availableImpls","availableTypes","Array","from","keys","message","join"],"mappings":"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"}