{"version":3,"sources":["/workspace/src/typer/type-inference.ts"],"sourcesContent":["import {\n\ttype Expression,\n\ttype LiteralExpression,\n\ttype VariableExpression,\n\ttype FunctionExpression,\n\ttype BinaryExpression,\n\ttype IfExpression,\n\ttype DefinitionExpression,\n\ttype MutableDefinitionExpression,\n\ttype MutationExpression,\n\ttype ImportExpression,\n\ttype RecordExpression,\n\ttype AccessorExpression,\n\ttype ListExpression,\n\ttype TupleExpression,\n\ttype WhereExpression,\n\ttype TypedExpression,\n\ttype ConstrainedExpression,\n\ttype ConstraintExpr,\n\ttype ConstraintDefinitionExpression,\n\ttype ImplementDefinitionExpression,\n\ttype Type,\n\ttype Constraint,\n\tintType,\n\tstringType,\n\tboolType,\n\tfunctionType,\n\ttypeVariable,\n\tunknownType,\n\tunitType,\n\tlistTypeWithElement,\n\ttupleType,\n\trecordType,\n\thasFieldConstraint,\n} from '../ast';\nimport {\n\tundefinedVariableError,\n\tnonFunctionApplicationError,\n} from './type-errors';\nimport {\n\tgetExprLocation,\n\tthrowTypeError,\n\tmapSet,\n\ttypeToString,\n\tpropagateConstraintToTypeVariable,\n} from './helpers';\nimport { unify } from './unify';\nimport { substitute } from './substitute';\nimport { typeExpression } from './expression-dispatcher';\nimport {\n\ttype TypeState,\n\ttype TypeResult,\n\tcreatePureTypeResult,\n\tcreateTypeResult,\n\tunionEffects,\n\temptyEffects,\n\taddConstraintDefinition,\n\taddConstraintImplementation,\n\tgetConstraintSignature,\n\ttype ConstraintSignature,\n\ttype ConstraintImplementation,\n\ttype TypeScheme,\n} from './types';\nimport { validateConstraintName } from './constraints';\nimport { freshTypeVariable, generalize, instantiate, freshenTypeVariables, flattenStatements } from './type-operations';\n\n// Note: Main typeExpression is now in expression-dispatcher.ts\n// This file only contains the individual type inference functions\n\n// Type inference for literals\nexport const typeLiteral = (\n\texpr: LiteralExpression,\n\tstate: TypeState\n): TypeResult => {\n\tconst value = expr.value;\n\n\tif (typeof value === 'number') {\n\t\treturn createPureTypeResult(intType(), state);\n\t} else if (typeof value === 'string') {\n\t\treturn createPureTypeResult(stringType(), state);\n\t} else {\n\t\treturn createPureTypeResult(unknownType(), state);\n\t}\n};\n\n// Type inference for variables\nexport const typeVariableExpr = (\n\texpr: VariableExpression,\n\tstate: TypeState\n): TypeResult => {\n\tconst scheme = state.environment.get(expr.name);\n\tif (!scheme) {\n\t\t// Check if this is a constraint function before throwing error\n\t\tconst { resolveConstraintVariable, createConstraintFunctionType } = require('./constraint-resolution');\n\t\tconst constraintResult = resolveConstraintVariable(expr.name, state);\n\t\t\n\t\tif (constraintResult.resolved && constraintResult.needsResolution) {\n\t\t\t// This is a constraint function - create its type\n\t\t\tconst constraintType = createConstraintFunctionType(\n\t\t\t\tconstraintResult.constraintName!,\n\t\t\t\tconstraintResult.functionName!,\n\t\t\t\tstate\n\t\t\t);\n\t\t\treturn createPureTypeResult(constraintType, state);\n\t\t}\n\t\t\n\t\tthrowTypeError(\n\t\t\tlocation => undefinedVariableError(expr.name, location),\n\t\t\tgetExprLocation(expr)\n\t\t);\n\t}\n\n\tconst [instantiatedType, newState] = instantiate(scheme, state);\n\n\t// Handle effects from TypeScheme\n\tconst effects = scheme.effects || emptyEffects();\n\treturn createTypeResult(instantiatedType, effects, newState);\n};\n\n// Helper function to count parameters in a function type\nconst countFunctionParams = (type: Type): number => {\n\tif (type.kind !== 'function') return 0;\n\treturn type.params.length + countFunctionParams(type.return);\n};\n\n// Flatten a constraint expression into a list of atomic constraints\nconst flattenConstraintExpr = (expr: ConstraintExpr): Constraint[] => {\n\tswitch (expr.kind) {\n\t\tcase 'is':\n\t\t\t// Validate constraint name\n\t\t\tvalidateConstraintName(expr.constraint);\n\t\t\treturn [expr];\n\t\tcase 'hasField':\n\t\tcase 'implements':\n\t\tcase 'custom':\n\t\t\treturn [expr];\n\t\tcase 'and':\n\t\t\treturn [\n\t\t\t\t...flattenConstraintExpr(expr.left),\n\t\t\t\t...flattenConstraintExpr(expr.right),\n\t\t\t];\n\t\tcase 'or':\n\t\t\treturn [\n\t\t\t\t...flattenConstraintExpr(expr.left),\n\t\t\t\t...flattenConstraintExpr(expr.right),\n\t\t\t];\n\t\tcase 'paren':\n\t\t\treturn flattenConstraintExpr(expr.expr);\n\t\tdefault:\n\t\t\treturn [];\n\t}\n};\n\n// Collect free variables used in an expression\nconst collectFreeVars = (expr: Expression, boundVars: Set<string> = new Set()): Set<string> => {\n\tconst freeVars = new Set<string>();\n\t\n\tconst walk = (e: Expression, bound: Set<string>) => {\n\t\tswitch (e.kind) {\n\t\t\tcase 'variable':\n\t\t\t\tif (!bound.has(e.name)) {\n\t\t\t\t\tfreeVars.add(e.name);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'function':\n\t\t\t\t// Parameters are bound in the function body\n\t\t\t\tconst newBound = new Set([...bound, ...e.params]);\n\t\t\t\twalk(e.body, newBound);\n\t\t\t\tbreak;\n\t\t\tcase 'definition':\n\t\t\t\t// The defined name is bound for the value expression\n\t\t\t\tconst defBound = new Set([...bound, e.name]);\n\t\t\t\twalk(e.value, defBound);\n\t\t\t\tbreak;\n\t\t\tcase 'application':\n\t\t\t\twalk(e.func, bound);\n\t\t\t\te.args.forEach(arg => walk(arg, bound));\n\t\t\t\tbreak;\n\t\t\tcase 'binary':\n\t\t\t\twalk(e.left, bound);\n\t\t\t\twalk(e.right, bound);\n\t\t\t\t// Operator is also a free variable\n\t\t\t\tif (!bound.has(e.operator)) {\n\t\t\t\t\tfreeVars.add(e.operator);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'if':\n\t\t\t\twalk(e.condition, bound);\n\t\t\t\twalk(e.then, bound);\n\t\t\t\twalk(e.else, bound);\n\t\t\t\tbreak;\n\t\t\t// Add other expression types as needed\n\t\t\tdefault:\n\t\t\t\t// For other types, recursively walk any sub-expressions\n\t\t\t\t// This is a simplified approach - in practice you'd handle each type\n\t\t\t\tbreak;\n\t\t}\n\t};\n\t\n\twalk(expr, boundVars);\n\treturn freeVars;\n};\n\n// Update typeFunction to use closure culling\nexport const typeFunction = (\n\texpr: FunctionExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// Collect free variables used in the function body\n\tconst boundParams = new Set(expr.params);\n\tconst freeVars = collectFreeVars(expr.body, boundParams);\n\t\n\t// Create a minimal environment with only what's needed\n\tconst functionEnv = new Map<string, any>();\n\t\n\t// Always include built-ins and stdlib essentials  \n\tconst essentials = [\n\t\t'+',\n\t\t'-',\n\t\t'*',\n\t\t'/',\n\t\t'==',\n\t\t'!=',\n\t\t'<',\n\t\t'>',\n\t\t'<=',\n\t\t'>=',\n\t\t'|',\n\t\t'|>',\n\t\t'<|',\n\t\t';',\n\t\t'$',\n\t\t'if',\n\t\t'length',\n\t\t'head',\n\t\t'tail',\n\t\t'map',\n\t\t'filter',\n\t\t'reduce',\n\t\t'isEmpty',\n\t\t'append',\n\t\t'concat',\n\t\t'toString',\n\t\t'abs',\n\t\t'max',\n\t\t'min',\n\t\t'print',\n\t\t'println',\n\t\t'readFile',\n\t\t'writeFile',\n\t\t'log',\n\t\t'random',\n\t\t'randomRange',\n\t\t'mutSet',\n\t\t'mutGet',\n\t\t'hasKey',\n\t\t'hasValue',\n\t\t'set',\n\t\t'tupleLength',\n\t\t'tupleIsEmpty',\n\t\t'list_get',\n\t\t'True',\n\t\t'False',\n\t\t'None',\n\t\t'Some',\n\t\t'Ok',\n\t\t'Err',\n\t\t'Bool',\n\t\t'Option',\n\t\t'Result',\n\t];\n\tfor (const essential of essentials) {\n\t\tif (state.environment.has(essential)) {\n\t\t\tfunctionEnv.set(essential, state.environment.get(essential)!);\n\t\t}\n\t}\n\t\n\t// Include only the free variables actually used\n\tfor (const freeVar of freeVars) {\n\t\tif (state.environment.has(freeVar)) {\n\t\t\tfunctionEnv.set(freeVar, state.environment.get(freeVar)!);\n\t\t}\n\t}\n\t\n\t// Closure optimization: using minimal environment\n\t\n\tlet currentState = { ...state, environment: functionEnv };\n\n\tconst paramTypes: Type[] = [];\n\tfor (const param of expr.params) {\n\t\tconst [paramType, nextState] = freshTypeVariable(currentState);\n\t\tfunctionEnv.set(param, { type: paramType, quantifiedVars: [] });\n\t\tparamTypes.push(paramType);\n\t\tcurrentState = { ...nextState, environment: functionEnv };\n\t}\n\n\t// Type the function body with the function-local environment\n\tconst bodyResult = typeExpression(expr.body, currentState);\n\tcurrentState = bodyResult.state;\n\n\t// Decorate the function body with its inferred type\n\texpr.body.type = bodyResult.type;\n\n\t// Restore the original environment for the outer scope\n\tcurrentState = { ...currentState, environment: state.environment };\n\n\t// Special handling for constrained function bodies\n\tlet funcType: Type;\n\n\tif (expr.body.kind === 'constrained') {\n\t\tconst constrainedBody = expr.body as ConstrainedExpression;\n\t\tconst constraints = flattenConstraintExpr(constrainedBody.constraint);\n\n\t\t// If the constrained body has an explicit function type, use it as the innermost type\n\t\tif (constrainedBody.type.kind === 'function') {\n\t\t\tfuncType = constrainedBody.type;\n\n\t\t\t// Apply constraints to this function type\n\t\t\tif (constraints.length > 0) {\n\t\t\t\tfuncType.constraints = constraints;\n\t\t\t\t// Store the original constraint expression for display purposes\n\t\t\t\t(funcType as any).originalConstraint = constrainedBody.constraint;\n\n\t\t\t\t// CRITICAL: Also propagate constraints to type variables in parameters\n\t\t\t\t// This ensures constraint validation works during function application\n\t\t\t\tfor (const constraint of constraints) {\n\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\tpropagateConstraintToTypeVariable(funcType, constraint);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we have more parameters than the explicit type accounts for, wrap it\n\t\t\tconst explicitParamCount = countFunctionParams(constrainedBody.type);\n\t\t\tconst actualParamCount = paramTypes.length;\n\t\t\tif (actualParamCount > explicitParamCount) {\n\t\t\t\t// Wrap the explicit function type with additional parameter layers\n\t\t\t\tfor (let i = actualParamCount - explicitParamCount - 1; i >= 0; i--) {\n\t\t\t\t\tfuncType = functionType([paramTypes[i]], funcType);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Build function type normally and apply constraints\n\t\t\tfuncType = bodyResult.type;\n\t\t\tfor (let i = paramTypes.length - 1; i >= 0; i--) {\n\t\t\t\tfuncType = functionType([paramTypes[i]], funcType);\n\t\t\t}\n\t\t\tif (constraints.length > 0 && funcType.kind === 'function') {\n\t\t\t\tfuncType.constraints = constraints;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Build the function type normally\n\t\tfuncType = bodyResult.type;\n\t\tfor (let i = paramTypes.length - 1; i >= 0; i--) {\n\t\t\tfuncType = functionType([paramTypes[i]], funcType);\n\t\t}\n\t}\n\n\treturn createTypeResult(funcType, bodyResult.effects, currentState);\n};\n\n// Type inference for definitions\nexport const typeDefinition = (\n\texpr: DefinitionExpression,\n\tstate: TypeState\n): TypeResult => {\n\tlet currentState = state;\n\n\t// Add placeholder for recursion before inferring the value\n\tconst [placeholderType, newState] = freshTypeVariable(currentState);\n\tcurrentState = newState;\n\n\tconst tempEnv = mapSet(currentState.environment, expr.name, {\n\t\ttype: placeholderType,\n\t\tquantifiedVars: [],\n\t});\n\tcurrentState = { ...currentState, environment: tempEnv };\n\n\t// Type the value\n\tconst valueResult = typeExpression(expr.value, currentState);\n\tcurrentState = valueResult.state;\n\n\t// Decorate the value with its inferred type\n\texpr.value.type = valueResult.type;\n\n\t// Unify placeholder with actual type for recursion\n\tcurrentState = unify(\n\t\tplaceholderType,\n\t\tvalueResult.type,\n\t\tcurrentState,\n\t\tgetExprLocation(expr)\n\t);\n\n\t// Remove the just-defined variable from the environment for generalization\n\tconst envForGen = new Map(currentState.environment);\n\tenvForGen.delete(expr.name);\n\n\t// Generalize the type before storing in the environment (apply substitution!)\n\tconst scheme = generalize(\n\t\tvalueResult.type,\n\t\tenvForGen,\n\t\tcurrentState.substitution\n\t);\n\n\t// Add to environment with generalized type\n\tconst finalEnv = mapSet(currentState.environment, expr.name, scheme);\n\tcurrentState = { ...currentState, environment: finalEnv };\n\n\t// Freshen type variables for the definition's value (thread state)\n\tconst [finalType, finalState] = freshenTypeVariables(\n\t\tvalueResult.type,\n\t\tnew Map(),\n\t\tcurrentState\n\t);\n\treturn createTypeResult(finalType, valueResult.effects, finalState);\n};\n\n// Type inference for if expressions\nexport const typeIf = (expr: IfExpression, state: TypeState): TypeResult => {\n\tlet currentState = state;\n\n\t// Type condition\n\tconst conditionResult = typeExpression(expr.condition, currentState);\n\tcurrentState = conditionResult.state;\n\n\t// Unify condition with boolean\n\tcurrentState = unify(\n\t\tconditionResult.type,\n\t\tboolType(),\n\t\tcurrentState,\n\t\tgetExprLocation(expr)\n\t);\n\n\t// Type then branch\n\tconst thenResult = typeExpression(expr.then, currentState);\n\tcurrentState = thenResult.state;\n\n\t// Type else branch\n\tconst elseResult = typeExpression(expr.else, currentState);\n\tcurrentState = elseResult.state;\n\n\t// Unify then and else types\n\tcurrentState = unify(\n\t\tthenResult.type,\n\t\telseResult.type,\n\t\tcurrentState,\n\t\tgetExprLocation(expr)\n\t);\n\n\t// Apply substitution to get final type\n\tconst finalType = substitute(thenResult.type, currentState.substitution);\n\n\treturn createTypeResult(finalType, unionEffects(conditionResult.effects, thenResult.effects, elseResult.effects), currentState);\n};\n\n// Type inference for binary expressions\nexport const typeBinary = (\n\texpr: BinaryExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// Special handling for semicolon operator (sequence) - flatten to avoid O(nÂ²) re-evaluation\n\tif (expr.operator === ';') {\n\t\t// Flatten the semicolon sequence and process each statement exactly once\n\t\tconst statements = flattenStatements(expr);\n\t\tlet currentState = state;\n\t\tlet finalType = null;\n\t\tlet allEffects = emptyEffects();\n\n\t\tfor (const statement of statements) {\n\t\t\tconst result = typeExpression(statement, currentState);\n\t\t\tcurrentState = result.state;\n\t\t\tfinalType = result.type;\n\t\t\tallEffects = unionEffects(allEffects, result.effects);\n\t\t}\n\n\t\treturn createTypeResult(finalType || unitType(), allEffects, currentState);\n\t}\n\n\tlet currentState = state;\n\n\t// Type left operand\n\tconst leftResult = typeExpression(expr.left, currentState);\n\tcurrentState = leftResult.state;\n\n\t// Type right operand\n\tconst rightResult = typeExpression(expr.right, currentState);\n\tcurrentState = rightResult.state;\n\n\t// Special handling for thrush operator (|) - function application\n\tif (expr.operator === '|') {\n\t\t// Thrush: a | b means b(a) - apply right function to left value\n\t\tif (rightResult.type.kind !== 'function') {\n\t\t\tthrowTypeError(\n\t\t\t\tlocation => nonFunctionApplicationError(rightResult.type, location),\n\t\t\t\tgetExprLocation(expr)\n\t\t\t);\n\t\t}\n\n\t\t// Check that the function can take the left value as its first argument\n\t\tif (rightResult.type.params.length < 1) {\n\t\t\tthrow new Error(\n\t\t\t\t`Thrush operator requires function with at least one parameter, got ${rightResult.type.params.length}`\n\t\t\t);\n\t\t}\n\n\t\tcurrentState = unify(\n\t\t\trightResult.type.params[0],\n\t\t\tleftResult.type,\n\t\t\tcurrentState,\n\t\t\tgetExprLocation(expr)\n\t\t);\n\n\t\t// Return the function's return type (which may be a partially applied function)\n\t\treturn createTypeResult(\n\t\t\trightResult.type.return,\n\t\t\tunionEffects(leftResult.effects, rightResult.effects),\n\t\t\tcurrentState\n\t\t);\n\t}\n\n\t// Special handling for dollar operator ($) - low precedence function application\n\tif (expr.operator === '$') {\n\t\t// Dollar: a $ b means a(b) - apply left function to right value\n\t\t// Delegate to the same logic as regular function application\n\t\tconst { typeApplication } = require('./function-application');\n\t\t\n\t\t// Create a synthetic ApplicationExpression for a $ b\n\t\tconst syntheticApp: import('../ast').ApplicationExpression = {\n\t\t\tkind: 'application',\n\t\t\tfunc: expr.left,\n\t\t\targs: [expr.right],\n\t\t\tlocation: expr.location\n\t\t};\n\t\t\n\t\treturn typeApplication(syntheticApp, currentState);\n\t}\n\n\t// Get operator type from environment\n\tconst operatorScheme = currentState.environment.get(expr.operator);\n\tif (!operatorScheme) {\n\t\tthrow new Error(`Unknown operator: ${expr.operator}`);\n\t}\n\n\tconst [operatorType, newState] = instantiate(operatorScheme, currentState);\n\tcurrentState = newState;\n\n\t// Create fresh type variable for result\n\tconst [resultType, finalState] = freshTypeVariable(currentState);\n\tcurrentState = finalState;\n\n\t// Build expected function type\n\tconst expectedType = functionType(\n\t\t[leftResult.type, rightResult.type],\n\t\tresultType\n\t);\n\n\t// Unify operator type with expected type\n\tcurrentState = unify(\n\t\toperatorType,\n\t\texpectedType,\n\t\tcurrentState,\n\t\tgetExprLocation(expr),\n\t\t{\n\t\t\treason: 'operator_application',\n\t\t\toperation: `applying operator ${expr.operator}`,\n\t\t\thint: `The ${\n\t\t\t\texpr.operator\n\t\t\t} operator expects compatible operand types. Left operand: ${typeToString(\n\t\t\t\tleftResult.type,\n\t\t\t\tcurrentState.substitution\n\t\t\t)}, Right operand: ${typeToString(\n\t\t\t\trightResult.type,\n\t\t\t\tcurrentState.substitution\n\t\t\t)}.`,\n\t\t}\n\t);\n\n\t// Apply substitution to get final result type\n\tconst [finalResultType, finalResultState] = freshenTypeVariables(\n\t\tresultType,\n\t\tnew Map(),\n\t\tcurrentState\n\t);\n\n\treturn createTypeResult(\n\t\tfinalResultType,\n\t\tunionEffects(leftResult.effects, rightResult.effects),\n\t\tfinalResultState\n\t);\n};\n\n// Type inference for mutable definitions\nexport const typeMutableDefinition = (\n\texpr: MutableDefinitionExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// Handle mutable definitions similar to regular definitions\n\tconst valueResult = typeExpression(expr.value, state);\n\tconst newEnv = mapSet(state.environment, expr.name, {\n\t\ttype: valueResult.type,\n\t\tquantifiedVars: [],\n\t});\n\treturn createTypeResult(\n\t\tvalueResult.type, \n\t\tvalueResult.effects, \n\t\t{ ...valueResult.state, environment: newEnv }\n\t);\n};\n\n// Type inference for mutations\nexport const typeMutation = (\n\texpr: MutationExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// For mutations, we need to check that the target exists and the value type matches\n\tconst targetScheme = state.environment.get(expr.target);\n\tif (!targetScheme) {\n\t\tthrowTypeError(\n\t\t\tlocation => undefinedVariableError(expr.target, location),\n\t\t\tgetExprLocation(expr)\n\t\t);\n\t}\n\n\tconst valueResult = typeExpression(expr.value, state);\n\tconst newState = unify(\n\t\ttargetScheme.type,\n\t\tvalueResult.type,\n\t\tvalueResult.state,\n\t\tgetExprLocation(expr)\n\t);\n\n\treturn createTypeResult(unitType(), valueResult.effects, newState); // Mutations return unit\n};\n\n// Type inference for imports\nexport const typeImport = (\n\texpr: ImportExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// For now, assume imports return a record type\n\treturn createPureTypeResult(recordType({}), state);\n};\n\n// Type inference for records\nexport const typeRecord = (\n\texpr: RecordExpression,\n\tstate: TypeState\n): TypeResult => {\n\tconst fields: { [key: string]: Type } = {};\n\tlet currentState = state;\n\tlet allEffects = emptyEffects();\n\n\tfor (const field of expr.fields) {\n\t\tconst fieldResult = typeExpression(field.value, currentState);\n\t\tfields[field.name] = fieldResult.type;\n\t\tcurrentState = fieldResult.state;\n\t\tallEffects = unionEffects(allEffects, fieldResult.effects);\n\t}\n\n\treturn createTypeResult(recordType(fields), allEffects, currentState);\n};\n\n// Type inference for accessors\nexport const typeAccessor = (\n\texpr: AccessorExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// Check cache first\n\tconst fieldName = expr.field;\n\tconst cachedType = state.accessorCache.get(fieldName);\n\tif (cachedType) {\n\t\treturn createPureTypeResult(cachedType, state);\n\t}\n\n\t// Accessors return functions that take any record with the required field and return the field type\n\t// @bar should have type {bar: a, ...} -> a (allows extra fields)\n\t// Use a fresh type variable for the field type\n\tconst [fieldType, nextState] = freshTypeVariable(state);\n\t// Create a simple type variable for the record (no constraints on the variable itself)\n\tconst [recordVar, finalState] = freshTypeVariable(nextState);\n\t// Create a function type with constraints attached to the function type\n\tconst funcType = functionType([recordVar], fieldType);\n\t// Add the constraint directly to the parameter variable\n\tif (recordVar.kind === 'variable') {\n\t\trecordVar.constraints = [\n\t\t\thasFieldConstraint(recordVar.name, fieldName, fieldType),\n\t\t];\n\t}\n\n\t// Cache the result for future use\n\tconst resultState = {\n\t\t...finalState,\n\t\taccessorCache: new Map(finalState.accessorCache).set(fieldName, funcType),\n\t};\n\n\treturn createPureTypeResult(funcType, resultState);\n};\n\n// Type inference for tuples\nexport const typeTuple = (\n\texpr: TupleExpression,\n\tstate: TypeState\n): TypeResult => {\n\tconst elements: Type[] = [];\n\tlet currentState = state;\n\tlet allEffects = emptyEffects();\n\n\tfor (const element of expr.elements) {\n\t\tconst elementResult = typeExpression(element, currentState);\n\t\telements.push(elementResult.type);\n\t\tcurrentState = elementResult.state;\n\t\tallEffects = unionEffects(allEffects, elementResult.effects);\n\t}\n\n\treturn createTypeResult(tupleType(elements), allEffects, currentState);\n};\n\n// Type inference for lists\nexport const typeList = (\n\texpr: ListExpression,\n\tstate: TypeState\n): TypeResult => {\n\tif (expr.elements.length === 0) {\n\t\t// Empty list - we can't infer the element type\n\t\treturn createPureTypeResult(listTypeWithElement(typeVariable('a')), state);\n\t}\n\n\t// Infer the type from the first element\n\tlet currentState = state;\n\tconst firstElementResult = typeExpression(expr.elements[0], currentState);\n\tcurrentState = firstElementResult.state;\n\tconst firstElementType = firstElementResult.type;\n\tlet allEffects = firstElementResult.effects;\n\n\t// Check that all elements have the same type\n\tfor (let i = 1; i < expr.elements.length; i++) {\n\t\tconst elementResult = typeExpression(expr.elements[i], currentState);\n\t\tcurrentState = elementResult.state;\n\t\tallEffects = unionEffects(allEffects, elementResult.effects);\n\t\tcurrentState = unify(firstElementType, elementResult.type, currentState, {\n\t\t\tline: expr.location?.start.line || 1,\n\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t});\n\t}\n\n\t// Apply substitution to get the resolved element type\n\tconst resolvedElementType = substitute(\n\t\tfirstElementType,\n\t\tcurrentState.substitution\n\t);\n\treturn createTypeResult(\n\t\tlistTypeWithElement(resolvedElementType),\n\t\tallEffects,\n\t\tcurrentState\n\t);\n};\n\n// Type inference for where expressions\nexport const typeWhere = (\n\texpr: WhereExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// Create a new type environment with the where-clause definitions\n\tlet whereEnv = new Map(state.environment);\n\tlet currentState = { ...state, environment: whereEnv };\n\n\t// Type all definitions in the where clause\n\tfor (const def of expr.definitions) {\n\t\tif ((def as DefinitionExpression).kind === 'definition') {\n\t\t\tconst definitionDef = def as DefinitionExpression;\n\t\t\tconst valueResult = typeExpression(definitionDef.value, currentState);\n\t\t\tcurrentState = valueResult.state;\n\n\t\t\t// Generalize with respect to the current whereEnv (excluding the new binding)\n\t\t\tconst tempEnv = new Map(currentState.environment);\n\t\t\ttempEnv.delete(definitionDef.name);\n\t\t\tconst scheme = generalize(\n\t\t\t\tvalueResult.type,\n\t\t\t\ttempEnv,\n\t\t\t\tcurrentState.substitution\n\t\t\t);\n\n\t\t\twhereEnv = mapSet(currentState.environment, definitionDef.name, scheme);\n\t\t\tcurrentState = { ...currentState, environment: whereEnv };\n\t\t} else if (\n\t\t\t(def as MutableDefinitionExpression).kind === 'mutable-definition'\n\t\t) {\n\t\t\tconst mutableDef = def as MutableDefinitionExpression;\n\t\t\tconst valueResult = typeExpression(mutableDef.value, currentState);\n\t\t\tcurrentState = valueResult.state;\n\n\t\t\twhereEnv = mapSet(currentState.environment, mutableDef.name, {\n\t\t\t\ttype: valueResult.type,\n\t\t\t\tquantifiedVars: [],\n\t\t\t});\n\t\t\tcurrentState = { ...currentState, environment: whereEnv };\n\t\t}\n\t}\n\n\t// Type the main expression\n\tconst resultResult = typeExpression(expr.main, currentState);\n\n\treturn createTypeResult(resultResult.type, resultResult.effects, resultResult.state);\n};\n\n// Type inference for typed expressions\nexport const typeTyped = (\n\texpr: TypedExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// For typed expressions, validate that the explicit type matches the inferred type\n\tconst inferredResult = typeExpression(expr.expression, state);\n\tconst explicitType = expr.type;\n\n\tconst newState = unify(\n\t\tinferredResult.type,\n\t\texplicitType,\n\t\tinferredResult.state,\n\t\t{\n\t\t\tline: expr.location?.start.line || 1,\n\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t}\n\t);\n\n\treturn createTypeResult(explicitType, inferredResult.effects, newState); // Use the explicit type\n};\n\n// Type inference for constrained expressions\nexport const typeConstrained = (\n\texpr: ConstrainedExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// For constrained expressions, validate that the explicit type matches the inferred type\n\tconst inferredResult = typeExpression(expr.expression, state);\n\tconst explicitType = expr.type;\n\n\tlet currentState = unify(\n\t\tinferredResult.type,\n\t\texplicitType,\n\t\tinferredResult.state,\n\t\t{\n\t\t\tline: expr.location?.start.line || 1,\n\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t}\n\t);\n\n\t// Special case: if this constrained expression is inside a function body,\n\t// the constraint should apply to the function type, not to this expression\n\t// For now, we'll just return the explicit type without applying constraints here\n\t// The constraint will be handled at the function level\n\n\t// Return the explicit type without constraints applied\n\treturn createTypeResult(explicitType, inferredResult.effects, currentState);\n};\n\n// Type constraint definition\nexport const typeConstraintDefinition = (\n\texpr: ConstraintDefinitionExpression,\n\tstate: TypeState,\n): TypeResult => {\n\tconst { name, typeParam, functions } = expr;\n\t\n\t// Create constraint signature\n\tconst functionMap = new Map<string, Type>();\n\t\n\tfor (const func of functions) {\n\t\t// Type the function signature, substituting the constraint type parameter\n\t\tconst funcType = func.type;\n\t\tfunctionMap.set(func.name, funcType);\n\t}\n\t\n\tconst signature: ConstraintSignature = {\n\t\tname,\n\t\ttypeParam,\n\t\tfunctions: functionMap,\n\t};\n\t\n\t// Add to constraint registry\n\taddConstraintDefinition(state.constraintRegistry, name, signature);\n\t\n\t// Constraint definitions have unit type\n\treturn createPureTypeResult(unitType(), state);\n};\n\n// Type implement definition  \nexport const typeImplementDefinition = (\n\texpr: ImplementDefinitionExpression,\n\tstate: TypeState,\n): TypeResult => {\n\tconst { constraintName, typeName, implementations } = expr;\n\t\n\t// Check if constraint exists\n\tconst constraintSig = getConstraintSignature(state.constraintRegistry, constraintName);\n\tif (!constraintSig) {\n\t\tthrow new Error(`Constraint '${constraintName}' not defined`);\n\t}\n\t\n\t// Type each implementation\n\tconst implementationMap = new Map<string, TypeScheme>();\n\tlet currentState = state;\n\tlet allEffects = emptyEffects();\n\t\n\tfor (const impl of implementations) {\n\t\t// Check if function is required by constraint\n\t\tconst requiredType = constraintSig.functions.get(impl.name);\n\t\tif (!requiredType) {\n\t\t\tthrow new Error(`Function '${impl.name}' not required by constraint '${constraintName}'`);\n\t\t}\n\t\t\n\t\t// Type the implementation\n\t\tconst implResult = typeExpression(impl.value, currentState);\n\t\tcurrentState = implResult.state;\n\t\tallEffects = unionEffects(allEffects, implResult.effects);\n\t\t\n\t\t// TODO: Check that implementation type matches required type\n\t\t// For now, we'll trust the implementation\n\t\t\n\t\t// Store in implementation map\n\t\timplementationMap.set(impl.name, {\n\t\t\ttype: implResult.type,\n\t\t\tquantifiedVars: [], // TODO: compute quantified variables\n\t\t\teffects: implResult.effects,\n\t\t});\n\t}\n\t\n\t// Check that all required functions are implemented\n\tfor (const [funcName] of constraintSig.functions) {\n\t\tif (!implementationMap.has(funcName)) {\n\t\t\tthrow new Error(`Missing implementation for '${funcName}' in implementation of '${constraintName}' for '${typeName}'`);\n\t\t}\n\t}\n\t\n\t// Create constraint implementation\n\tconst implementation: ConstraintImplementation = {\n\t\tfunctions: implementationMap,\n\t};\n\t\n\t// Add to constraint registry\n\tconst success = addConstraintImplementation(\n\t\tcurrentState.constraintRegistry, \n\t\tconstraintName, \n\t\ttypeName, \n\t\timplementation\n\t);\n\t\n\tif (!success) {\n\t\tthrow new Error(`Failed to add implementation of '${constraintName}' for '${typeName}'`);\n\t}\n\t\n\t// Implement definitions have unit type\n\treturn createTypeResult(unitType(), allEffects, currentState);\n};"],"names":["typeAccessor","typeBinary","typeConstrained","typeConstraintDefinition","typeDefinition","typeFunction","typeIf","typeImplementDefinition","typeImport","typeList","typeLiteral","typeMutableDefinition","typeMutation","typeRecord","typeTuple","typeTyped","typeVariableExpr","typeWhere","expr","state","value","createPureTypeResult","intType","stringType","unknownType","scheme","environment","get","name","resolveConstraintVariable","createConstraintFunctionType","require","constraintResult","resolved","needsResolution","constraintType","constraintName","functionName","throwTypeError","location","undefinedVariableError","getExprLocation","instantiatedType","newState","instantiate","effects","emptyEffects","createTypeResult","countFunctionParams","type","kind","params","length","return","flattenConstraintExpr","validateConstraintName","constraint","left","right","collectFreeVars","boundVars","Set","freeVars","walk","e","bound","has","add","newBound","body","defBound","func","args","forEach","arg","operator","condition","then","else","boundParams","functionEnv","Map","essentials","essential","set","freeVar","currentState","paramTypes","param","paramType","nextState","freshTypeVariable","quantifiedVars","push","bodyResult","typeExpression","funcType","constrainedBody","constraints","originalConstraint","propagateConstraintToTypeVariable","explicitParamCount","actualParamCount","i","functionType","placeholderType","tempEnv","mapSet","valueResult","unify","envForGen","delete","generalize","substitution","finalEnv","finalType","finalState","freshenTypeVariables","conditionResult","boolType","thenResult","elseResult","substitute","unionEffects","statements","flattenStatements","allEffects","statement","result","unitType","leftResult","rightResult","nonFunctionApplicationError","Error","typeApplication","syntheticApp","operatorScheme","operatorType","resultType","expectedType","reason","operation","hint","typeToString","finalResultType","finalResultState","newEnv","targetScheme","target","recordType","fields","field","fieldResult","fieldName","cachedType","accessorCache","fieldType","recordVar","hasFieldConstraint","resultState","elements","element","elementResult","tupleType","listTypeWithElement","typeVariable","firstElementResult","firstElementType","line","start","column","resolvedElementType","whereEnv","def","definitions","definitionDef","mutableDef","resultResult","main","inferredResult","expression","explicitType","typeParam","functions","functionMap","signature","addConstraintDefinition","constraintRegistry","typeName","implementations","constraintSig","getConstraintSignature","implementationMap","impl","requiredType","implResult","funcName","implementation","success","addConstraintImplementation"],"mappings":"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"}