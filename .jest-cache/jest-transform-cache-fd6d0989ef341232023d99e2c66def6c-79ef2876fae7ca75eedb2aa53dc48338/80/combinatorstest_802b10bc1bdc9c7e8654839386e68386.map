{"version":3,"sources":["/workspace/test/combinators.test.ts"],"sourcesContent":["import { Lexer } from \"../src/lexer\";\nimport * as C from \"../src/parser/combinators\";\n\ndescribe(\"Parser Combinators\", () => {\n  // Helper function to create tokens for testing\n  const createTokens = (input: string) => {\n    const lexer = new Lexer(input);\n    return lexer.tokenize();\n  };\n\n  // Helper function to create tokens without EOF for testing\n  const createTokensWithoutEOF = (input: string) => {\n    const lexer = new Lexer(input);\n    const tokens = lexer.tokenize();\n    // Remove EOF token for testing\n    return tokens.filter((t) => t.type !== \"EOF\");\n  };\n\n  describe(\"token\", () => {\n    test(\"should match exact token type and value\", () => {\n      const tokens = createTokensWithoutEOF(\"42\");\n      const result = C.token(\"NUMBER\", \"42\")(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"NUMBER\");\n        expect(result.value.value).toBe(\"42\");\n        expect(result.remaining).toHaveLength(0);\n      }\n    });\n\n    test(\"should match token type without value constraint\", () => {\n      const tokens = createTokens(\"42\");\n      const result = C.token(\"NUMBER\")(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"NUMBER\");\n        expect(result.value.value).toBe(\"42\");\n      }\n    });\n\n    test(\"should fail on wrong token type\", () => {\n      const tokens = createTokens(\"42\");\n      const result = C.token(\"IDENTIFIER\")(tokens);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.error).toContain(\"Expected IDENTIFIER\");\n        expect(result.error).toContain(\"but got NUMBER\");\n      }\n    });\n\n    test(\"should fail on wrong token value\", () => {\n      const tokens = createTokens(\"42\");\n      const result = C.token(\"NUMBER\", \"43\")(tokens);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.error).toContain(\"Expected NUMBER '43'\");\n        expect(result.error).toContain(\"but got NUMBER '42'\");\n      }\n    });\n\n    test(\"should fail on empty input\", () => {\n      const result = C.token(\"NUMBER\")([]);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.error).toContain(\"Expected NUMBER\");\n        expect(result.error).toContain(\"but got end of input\");\n      }\n    });\n  });\n\n  describe(\"anyToken\", () => {\n    test(\"should match any token\", () => {\n      const tokens = createTokensWithoutEOF(\"42\");\n      const result = C.anyToken()(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"NUMBER\");\n        expect(result.value.value).toBe(\"42\");\n        expect(result.remaining).toHaveLength(0);\n      }\n    });\n\n    test(\"should fail on empty input\", () => {\n      const result = C.anyToken()([]);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.error).toBe(\"Expected any token, but got end of input\");\n      }\n    });\n  });\n\n  describe(\"seq\", () => {\n    test(\"should match sequence of parsers\", () => {\n      const tokens = createTokensWithoutEOF(\"x = 42\");\n      const parser = C.seq(C.identifier(), C.operator(\"=\"), C.number());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toHaveLength(3);\n        expect(result.value[0].type).toBe(\"IDENTIFIER\");\n        expect(result.value[0].value).toBe(\"x\");\n        expect(result.value[1].type).toBe(\"OPERATOR\");\n        expect(result.value[1].value).toBe(\"=\");\n        expect(result.value[2].type).toBe(\"NUMBER\");\n        expect(result.value[2].value).toBe(\"42\");\n        expect(result.remaining).toHaveLength(0);\n      }\n    });\n\n    test(\"should fail if any parser in sequence fails\", () => {\n      const tokens = createTokens(\"x = 42\");\n      const parser = C.seq(\n        C.identifier(),\n        C.operator(\"+\"), // Wrong operator\n        C.number(),\n      );\n      const result = parser(tokens);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.error).toContain(\"Expected OPERATOR '+'\");\n        expect(result.error).toContain(\"but got OPERATOR '='\");\n      }\n    });\n\n    test(\"should handle empty sequence\", () => {\n      const tokens = createTokens(\"x = 42\");\n      const parser = C.seq();\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toHaveLength(0);\n        expect(result.remaining).toEqual(tokens);\n      }\n    });\n  });\n\n  describe(\"choice\", () => {\n    test(\"should match first successful parser\", () => {\n      const tokens = createTokens(\"42\");\n      const parser = C.choice(C.number(), C.identifier(), C.string());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"NUMBER\");\n        expect(result.value.value).toBe(\"42\");\n      }\n    });\n\n    test(\"should try all parsers in order\", () => {\n      const tokens = createTokens(\"hello\");\n      const parser = C.choice(C.number(), C.identifier(), C.string());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"IDENTIFIER\");\n        expect(result.value.value).toBe(\"hello\");\n      }\n    });\n\n    test(\"should fail if all parsers fail\", () => {\n      const tokens = createTokens(\"42\");\n      const parser = C.choice(C.identifier(), C.string());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.error).toContain(\"Expected IDENTIFIER\");\n        expect(result.error).toContain(\"but got NUMBER\");\n      }\n    });\n\n    test(\"should handle empty choice\", () => {\n      const tokens = createTokens(\"42\");\n      const parser = C.choice();\n      const result = parser(tokens);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.error).toBe(\"\");\n      }\n    });\n  });\n\n  describe(\"many\", () => {\n    test(\"should match zero or more occurrences\", () => {\n      const tokens = createTokens(\"1 2 3\");\n      const parser = C.many(C.number());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toHaveLength(3);\n        expect(result.value[0].value).toBe(\"1\");\n        expect(result.value[1].value).toBe(\"2\");\n        expect(result.value[2].value).toBe(\"3\");\n      }\n    });\n\n    test(\"should match zero occurrences\", () => {\n      const tokens = createTokens(\"hello\");\n      const parser = C.many(C.number());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toHaveLength(0);\n        expect(result.remaining).toEqual(tokens);\n      }\n    });\n\n    test(\"should handle empty input\", () => {\n      const parser = C.many(C.number());\n      const result = parser([]);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toHaveLength(0);\n        expect(result.remaining).toHaveLength(0);\n      }\n    });\n  });\n\n  describe(\"many1\", () => {\n    test(\"should match one or more occurrences\", () => {\n      const tokens = createTokens(\"1 2 3\");\n      const parser = C.many1(C.number());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toHaveLength(3);\n        expect(result.value[0].value).toBe(\"1\");\n        expect(result.value[1].value).toBe(\"2\");\n        expect(result.value[2].value).toBe(\"3\");\n      }\n    });\n\n    test(\"should fail on zero occurrences\", () => {\n      const tokens = createTokens(\"hello\");\n      const parser = C.many1(C.number());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.error).toBe(\"Expected at least one occurrence\");\n      }\n    });\n\n    test(\"should fail on empty input\", () => {\n      const parser = C.many1(C.number());\n      const result = parser([]);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.error).toBe(\"Expected at least one occurrence\");\n      }\n    });\n  });\n\n  describe(\"optional\", () => {\n    test(\"should match when parser succeeds\", () => {\n      const tokens = createTokensWithoutEOF(\"42\");\n      const parser = C.optional(C.number());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).not.toBeNull();\n        if (result.value) {\n          expect(result.value.value).toBe(\"42\");\n        }\n        expect(result.remaining).toHaveLength(0);\n      }\n    });\n\n    test(\"should return null when parser fails\", () => {\n      const tokens = createTokens(\"hello\");\n      const parser = C.optional(C.number());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toBeNull();\n        expect(result.remaining).toEqual(tokens);\n      }\n    });\n\n    test(\"should handle empty input\", () => {\n      const parser = C.optional(C.number());\n      const result = parser([]);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toBeNull();\n        expect(result.remaining).toHaveLength(0);\n      }\n    });\n  });\n\n  describe(\"map\", () => {\n    test(\"should transform successful parse result\", () => {\n      const tokens = createTokensWithoutEOF(\"42\");\n      const parser = C.map(C.number(), (token) => parseInt(token.value));\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toBe(42);\n        expect(result.remaining).toHaveLength(0);\n      }\n    });\n\n    test(\"should preserve failure\", () => {\n      const tokens = createTokens(\"hello\");\n      const parser = C.map(C.number(), (token) => parseInt(token.value));\n      const result = parser(tokens);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.error).toContain(\"Expected NUMBER\");\n        expect(result.error).toContain(\"but got IDENTIFIER\");\n      }\n    });\n  });\n\n  describe(\"lazy\", () => {\n    test(\"should defer parser creation\", () => {\n      const tokens = createTokens(\"42\");\n      let called = false;\n      const parser = C.lazy(() => {\n        called = true;\n        return C.number();\n      });\n\n      expect(called).toBe(false);\n      const result = parser(tokens);\n      expect(called).toBe(true);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"NUMBER\");\n        expect(result.value.value).toBe(\"42\");\n      }\n    });\n\n    test(\"should handle recursive parsers\", () => {\n      // This tests that lazy works for recursive definitions\n      const tokens = createTokens(\"42\");\n      const parser = C.lazy(() => C.choice(C.number(), C.identifier()));\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"NUMBER\");\n        expect(result.value.value).toBe(\"42\");\n      }\n    });\n  });\n\n  describe(\"sepBy\", () => {\n    test(\"should parse elements separated by separator\", () => {\n      const tokens = createTokens(\"1, 2, 3\");\n      const parser = C.sepBy(C.number(), C.punctuation(\",\"));\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toHaveLength(3);\n        expect(result.value[0].value).toBe(\"1\");\n        expect(result.value[1].value).toBe(\"2\");\n        expect(result.value[2].value).toBe(\"3\");\n      }\n    });\n\n    test(\"should parse single element\", () => {\n      const tokens = createTokens(\"1\");\n      const parser = C.sepBy(C.number(), C.punctuation(\",\"));\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toHaveLength(1);\n        expect(result.value[0].value).toBe(\"1\");\n      }\n    });\n\n    test(\"should parse zero elements\", () => {\n      const tokens = createTokens(\"hello\");\n      const parser = C.sepBy(C.number(), C.punctuation(\",\"));\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toHaveLength(0);\n        expect(result.remaining).toEqual(tokens);\n      }\n    });\n\n    test(\"should fail if separator is followed by invalid element\", () => {\n      const tokens = createTokens(\"1, hello\");\n      const parser = C.sepBy(C.number(), C.punctuation(\",\"));\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        // sepBy should stop at the first failure, not fail entirely\n        expect(result.value).toHaveLength(1);\n        expect(result.value[0].value).toBe(\"1\");\n      }\n    });\n  });\n\n  describe(\"parseAll\", () => {\n    test(\"should succeed when parser consumes all input\", () => {\n      const tokens = createTokensWithoutEOF(\"42\");\n      const parser = C.parseAll(C.number());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"NUMBER\");\n        expect(result.value.value).toBe(\"42\");\n      }\n    });\n\n    test(\"should fail when input remains\", () => {\n      const tokens = createTokens(\"42 hello\");\n      const parser = C.parseAll(C.number());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.error).toContain(\"Unexpected IDENTIFIER\");\n        expect(result.error).toContain(\"at end of input\");\n      }\n    });\n\n    test(\"should preserve parser failure\", () => {\n      const tokens = createTokens(\"hello\");\n      const parser = C.parseAll(C.number());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.error).toContain(\"Expected NUMBER\");\n        expect(result.error).toContain(\"but got IDENTIFIER\");\n      }\n    });\n  });\n\n  describe(\"convenience parsers\", () => {\n    test(\"identifier should match identifiers\", () => {\n      const tokens = createTokens(\"hello\");\n      const result = C.identifier()(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"IDENTIFIER\");\n        expect(result.value.value).toBe(\"hello\");\n      }\n    });\n\n    test(\"number should match numbers\", () => {\n      const tokens = createTokens(\"42\");\n      const result = C.number()(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"NUMBER\");\n        expect(result.value.value).toBe(\"42\");\n      }\n    });\n\n    test(\"string should match strings\", () => {\n      const tokens = createTokens('\"hello\"');\n      const result = C.string()(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"STRING\");\n        expect(result.value.value).toBe(\"hello\");\n      }\n    });\n\n    test(\"keyword should match specific keywords\", () => {\n      const tokens = createTokens(\"if\");\n      const result = C.keyword(\"if\")(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"KEYWORD\");\n        expect(result.value.value).toBe(\"if\");\n      }\n    });\n\n    test(\"operator should match specific operators\", () => {\n      const tokens = createTokens(\"+\");\n      const result = C.operator(\"+\")(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"OPERATOR\");\n        expect(result.value.value).toBe(\"+\");\n      }\n    });\n\n    test(\"punctuation should match specific punctuation\", () => {\n      const tokens = createTokens(\"(\");\n      const result = C.punctuation(\"(\")(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"PUNCTUATION\");\n        expect(result.value.value).toBe(\"(\");\n      }\n    });\n\n    test(\"accessor should match accessors\", () => {\n      const tokens = createTokens(\"@field\");\n      const result = C.accessor()(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value.type).toBe(\"ACCESSOR\");\n        expect(result.value.value).toBe(\"field\");\n      }\n    });\n  });\n\n  describe(\"complex combinations\", () => {\n    test(\"should handle nested sequences and choices\", () => {\n      const tokens = createTokens(\"x = 42\");\n      const parser = C.map(\n        C.seq(\n          C.identifier(),\n          C.choice(C.operator(\"=\"), C.operator(\":=\")),\n          C.choice(C.number(), C.string()),\n        ),\n        ([id, op, val]) => ({\n          variable: id.value,\n          operator: op.value,\n          value: val.value,\n        }),\n      );\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toEqual({\n          variable: \"x\",\n          operator: \"=\",\n          value: \"42\",\n        });\n      }\n    });\n\n    test(\"should handle many with separator\", () => {\n      const tokens = createTokens(\"1, 2, 3, 4\");\n      const parser = C.sepBy(C.number(), C.punctuation(\",\"));\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toHaveLength(4);\n        expect(result.value.map((t) => t.value)).toEqual([\"1\", \"2\", \"3\", \"4\"]);\n      }\n    });\n\n    test(\"should handle optional with fallback\", () => {\n      const tokens = createTokens(\"42\");\n      const parser = C.map(\n        C.seq(C.number(), C.optional(C.punctuation(\"!\"))),\n        ([num, bang]) => ({\n          value: parseInt(num.value),\n          isExclamation: bang !== null,\n        }),\n      );\n      const result = parser(tokens);\n\n      expect(result.success).toBe(true);\n      if (result.success) {\n        expect(result.value).toEqual({\n          value: 42,\n          isExclamation: false,\n        });\n      }\n    });\n  });\n\n  describe(\"error handling\", () => {\n    test(\"should provide meaningful error messages\", () => {\n      const tokens = createTokens(\"hello\");\n      const parser = C.seq(C.number(), C.operator(\"+\"), C.number());\n      const result = parser(tokens);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.error).toContain(\"Expected NUMBER\");\n        expect(result.error).toContain(\"but got IDENTIFIER\");\n        expect(result.position).toBeGreaterThan(0);\n      }\n    });\n\n    test(\"should track position for error reporting\", () => {\n      const tokens = createTokens(\"hello\");\n      const result = C.number()(tokens);\n\n      expect(result.success).toBe(false);\n      if (!result.success) {\n        expect(result.position).toBeGreaterThan(0);\n      }\n    });\n  });\n});\n"],"names":["describe","createTokens","input","lexer","Lexer","tokenize","createTokensWithoutEOF","tokens","filter","t","type","test","result","C","token","expect","success","toBe","value","remaining","toHaveLength","error","toContain","anyToken","parser","seq","identifier","operator","number","toEqual","choice","string","many","many1","optional","not","toBeNull","map","parseInt","called","lazy","sepBy","punctuation","parseAll","keyword","accessor","id","op","val","variable","num","bang","isExclamation","position","toBeGreaterThan"],"mappings":"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"}