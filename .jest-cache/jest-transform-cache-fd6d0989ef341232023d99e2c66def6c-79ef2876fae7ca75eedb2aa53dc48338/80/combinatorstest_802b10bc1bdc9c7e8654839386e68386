0b205819bb5599027fd2f926c2b93f56
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _lexer = require("../src/lexer");
const _combinators = /*#__PURE__*/ _interop_require_wildcard(require("../src/parser/combinators"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
describe("Parser Combinators", ()=>{
    // Helper function to create tokens for testing
    const createTokens = (input)=>{
        const lexer = new _lexer.Lexer(input);
        return lexer.tokenize();
    };
    // Helper function to create tokens without EOF for testing
    const createTokensWithoutEOF = (input)=>{
        const lexer = new _lexer.Lexer(input);
        const tokens = lexer.tokenize();
        // Remove EOF token for testing
        return tokens.filter((t)=>t.type !== "EOF");
    };
    describe("token", ()=>{
        test("should match exact token type and value", ()=>{
            const tokens = createTokensWithoutEOF("42");
            const result = _combinators.token("NUMBER", "42")(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("NUMBER");
                expect(result.value.value).toBe("42");
                expect(result.remaining).toHaveLength(0);
            }
        });
        test("should match token type without value constraint", ()=>{
            const tokens = createTokens("42");
            const result = _combinators.token("NUMBER")(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("NUMBER");
                expect(result.value.value).toBe("42");
            }
        });
        test("should fail on wrong token type", ()=>{
            const tokens = createTokens("42");
            const result = _combinators.token("IDENTIFIER")(tokens);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error).toContain("Expected IDENTIFIER");
                expect(result.error).toContain("but got NUMBER");
            }
        });
        test("should fail on wrong token value", ()=>{
            const tokens = createTokens("42");
            const result = _combinators.token("NUMBER", "43")(tokens);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error).toContain("Expected NUMBER '43'");
                expect(result.error).toContain("but got NUMBER '42'");
            }
        });
        test("should fail on empty input", ()=>{
            const result = _combinators.token("NUMBER")([]);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error).toContain("Expected NUMBER");
                expect(result.error).toContain("but got end of input");
            }
        });
    });
    describe("anyToken", ()=>{
        test("should match any token", ()=>{
            const tokens = createTokensWithoutEOF("42");
            const result = _combinators.anyToken()(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("NUMBER");
                expect(result.value.value).toBe("42");
                expect(result.remaining).toHaveLength(0);
            }
        });
        test("should fail on empty input", ()=>{
            const result = _combinators.anyToken()([]);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error).toBe("Expected any token, but got end of input");
            }
        });
    });
    describe("seq", ()=>{
        test("should match sequence of parsers", ()=>{
            const tokens = createTokensWithoutEOF("x = 42");
            const parser = _combinators.seq(_combinators.identifier(), _combinators.operator("="), _combinators.number());
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toHaveLength(3);
                expect(result.value[0].type).toBe("IDENTIFIER");
                expect(result.value[0].value).toBe("x");
                expect(result.value[1].type).toBe("OPERATOR");
                expect(result.value[1].value).toBe("=");
                expect(result.value[2].type).toBe("NUMBER");
                expect(result.value[2].value).toBe("42");
                expect(result.remaining).toHaveLength(0);
            }
        });
        test("should fail if any parser in sequence fails", ()=>{
            const tokens = createTokens("x = 42");
            const parser = _combinators.seq(_combinators.identifier(), _combinators.operator("+"), _combinators.number());
            const result = parser(tokens);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error).toContain("Expected OPERATOR '+'");
                expect(result.error).toContain("but got OPERATOR '='");
            }
        });
        test("should handle empty sequence", ()=>{
            const tokens = createTokens("x = 42");
            const parser = _combinators.seq();
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toHaveLength(0);
                expect(result.remaining).toEqual(tokens);
            }
        });
    });
    describe("choice", ()=>{
        test("should match first successful parser", ()=>{
            const tokens = createTokens("42");
            const parser = _combinators.choice(_combinators.number(), _combinators.identifier(), _combinators.string());
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("NUMBER");
                expect(result.value.value).toBe("42");
            }
        });
        test("should try all parsers in order", ()=>{
            const tokens = createTokens("hello");
            const parser = _combinators.choice(_combinators.number(), _combinators.identifier(), _combinators.string());
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("IDENTIFIER");
                expect(result.value.value).toBe("hello");
            }
        });
        test("should fail if all parsers fail", ()=>{
            const tokens = createTokens("42");
            const parser = _combinators.choice(_combinators.identifier(), _combinators.string());
            const result = parser(tokens);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error).toContain("Expected IDENTIFIER");
                expect(result.error).toContain("but got NUMBER");
            }
        });
        test("should handle empty choice", ()=>{
            const tokens = createTokens("42");
            const parser = _combinators.choice();
            const result = parser(tokens);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error).toBe("");
            }
        });
    });
    describe("many", ()=>{
        test("should match zero or more occurrences", ()=>{
            const tokens = createTokens("1 2 3");
            const parser = _combinators.many(_combinators.number());
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toHaveLength(3);
                expect(result.value[0].value).toBe("1");
                expect(result.value[1].value).toBe("2");
                expect(result.value[2].value).toBe("3");
            }
        });
        test("should match zero occurrences", ()=>{
            const tokens = createTokens("hello");
            const parser = _combinators.many(_combinators.number());
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toHaveLength(0);
                expect(result.remaining).toEqual(tokens);
            }
        });
        test("should handle empty input", ()=>{
            const parser = _combinators.many(_combinators.number());
            const result = parser([]);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toHaveLength(0);
                expect(result.remaining).toHaveLength(0);
            }
        });
    });
    describe("many1", ()=>{
        test("should match one or more occurrences", ()=>{
            const tokens = createTokens("1 2 3");
            const parser = _combinators.many1(_combinators.number());
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toHaveLength(3);
                expect(result.value[0].value).toBe("1");
                expect(result.value[1].value).toBe("2");
                expect(result.value[2].value).toBe("3");
            }
        });
        test("should fail on zero occurrences", ()=>{
            const tokens = createTokens("hello");
            const parser = _combinators.many1(_combinators.number());
            const result = parser(tokens);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error).toBe("Expected at least one occurrence");
            }
        });
        test("should fail on empty input", ()=>{
            const parser = _combinators.many1(_combinators.number());
            const result = parser([]);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error).toBe("Expected at least one occurrence");
            }
        });
    });
    describe("optional", ()=>{
        test("should match when parser succeeds", ()=>{
            const tokens = createTokensWithoutEOF("42");
            const parser = _combinators.optional(_combinators.number());
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).not.toBeNull();
                if (result.value) {
                    expect(result.value.value).toBe("42");
                }
                expect(result.remaining).toHaveLength(0);
            }
        });
        test("should return null when parser fails", ()=>{
            const tokens = createTokens("hello");
            const parser = _combinators.optional(_combinators.number());
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toBeNull();
                expect(result.remaining).toEqual(tokens);
            }
        });
        test("should handle empty input", ()=>{
            const parser = _combinators.optional(_combinators.number());
            const result = parser([]);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toBeNull();
                expect(result.remaining).toHaveLength(0);
            }
        });
    });
    describe("map", ()=>{
        test("should transform successful parse result", ()=>{
            const tokens = createTokensWithoutEOF("42");
            const parser = _combinators.map(_combinators.number(), (token)=>parseInt(token.value));
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toBe(42);
                expect(result.remaining).toHaveLength(0);
            }
        });
        test("should preserve failure", ()=>{
            const tokens = createTokens("hello");
            const parser = _combinators.map(_combinators.number(), (token)=>parseInt(token.value));
            const result = parser(tokens);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error).toContain("Expected NUMBER");
                expect(result.error).toContain("but got IDENTIFIER");
            }
        });
    });
    describe("lazy", ()=>{
        test("should defer parser creation", ()=>{
            const tokens = createTokens("42");
            let called = false;
            const parser = _combinators.lazy(()=>{
                called = true;
                return _combinators.number();
            });
            expect(called).toBe(false);
            const result = parser(tokens);
            expect(called).toBe(true);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("NUMBER");
                expect(result.value.value).toBe("42");
            }
        });
        test("should handle recursive parsers", ()=>{
            // This tests that lazy works for recursive definitions
            const tokens = createTokens("42");
            const parser = _combinators.lazy(()=>_combinators.choice(_combinators.number(), _combinators.identifier()));
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("NUMBER");
                expect(result.value.value).toBe("42");
            }
        });
    });
    describe("sepBy", ()=>{
        test("should parse elements separated by separator", ()=>{
            const tokens = createTokens("1, 2, 3");
            const parser = _combinators.sepBy(_combinators.number(), _combinators.punctuation(","));
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toHaveLength(3);
                expect(result.value[0].value).toBe("1");
                expect(result.value[1].value).toBe("2");
                expect(result.value[2].value).toBe("3");
            }
        });
        test("should parse single element", ()=>{
            const tokens = createTokens("1");
            const parser = _combinators.sepBy(_combinators.number(), _combinators.punctuation(","));
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toHaveLength(1);
                expect(result.value[0].value).toBe("1");
            }
        });
        test("should parse zero elements", ()=>{
            const tokens = createTokens("hello");
            const parser = _combinators.sepBy(_combinators.number(), _combinators.punctuation(","));
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toHaveLength(0);
                expect(result.remaining).toEqual(tokens);
            }
        });
        test("should fail if separator is followed by invalid element", ()=>{
            const tokens = createTokens("1, hello");
            const parser = _combinators.sepBy(_combinators.number(), _combinators.punctuation(","));
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                // sepBy should stop at the first failure, not fail entirely
                expect(result.value).toHaveLength(1);
                expect(result.value[0].value).toBe("1");
            }
        });
    });
    describe("parseAll", ()=>{
        test("should succeed when parser consumes all input", ()=>{
            const tokens = createTokensWithoutEOF("42");
            const parser = _combinators.parseAll(_combinators.number());
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("NUMBER");
                expect(result.value.value).toBe("42");
            }
        });
        test("should fail when input remains", ()=>{
            const tokens = createTokens("42 hello");
            const parser = _combinators.parseAll(_combinators.number());
            const result = parser(tokens);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error).toContain("Unexpected IDENTIFIER");
                expect(result.error).toContain("at end of input");
            }
        });
        test("should preserve parser failure", ()=>{
            const tokens = createTokens("hello");
            const parser = _combinators.parseAll(_combinators.number());
            const result = parser(tokens);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error).toContain("Expected NUMBER");
                expect(result.error).toContain("but got IDENTIFIER");
            }
        });
    });
    describe("convenience parsers", ()=>{
        test("identifier should match identifiers", ()=>{
            const tokens = createTokens("hello");
            const result = _combinators.identifier()(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("IDENTIFIER");
                expect(result.value.value).toBe("hello");
            }
        });
        test("number should match numbers", ()=>{
            const tokens = createTokens("42");
            const result = _combinators.number()(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("NUMBER");
                expect(result.value.value).toBe("42");
            }
        });
        test("string should match strings", ()=>{
            const tokens = createTokens('"hello"');
            const result = _combinators.string()(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("STRING");
                expect(result.value.value).toBe("hello");
            }
        });
        test("keyword should match specific keywords", ()=>{
            const tokens = createTokens("if");
            const result = _combinators.keyword("if")(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("KEYWORD");
                expect(result.value.value).toBe("if");
            }
        });
        test("operator should match specific operators", ()=>{
            const tokens = createTokens("+");
            const result = _combinators.operator("+")(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("OPERATOR");
                expect(result.value.value).toBe("+");
            }
        });
        test("punctuation should match specific punctuation", ()=>{
            const tokens = createTokens("(");
            const result = _combinators.punctuation("(")(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("PUNCTUATION");
                expect(result.value.value).toBe("(");
            }
        });
        test("accessor should match accessors", ()=>{
            const tokens = createTokens("@field");
            const result = _combinators.accessor()(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value.type).toBe("ACCESSOR");
                expect(result.value.value).toBe("field");
            }
        });
    });
    describe("complex combinations", ()=>{
        test("should handle nested sequences and choices", ()=>{
            const tokens = createTokens("x = 42");
            const parser = _combinators.map(_combinators.seq(_combinators.identifier(), _combinators.choice(_combinators.operator("="), _combinators.operator(":=")), _combinators.choice(_combinators.number(), _combinators.string())), ([id, op, val])=>({
                    variable: id.value,
                    operator: op.value,
                    value: val.value
                }));
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toEqual({
                    variable: "x",
                    operator: "=",
                    value: "42"
                });
            }
        });
        test("should handle many with separator", ()=>{
            const tokens = createTokens("1, 2, 3, 4");
            const parser = _combinators.sepBy(_combinators.number(), _combinators.punctuation(","));
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toHaveLength(4);
                expect(result.value.map((t)=>t.value)).toEqual([
                    "1",
                    "2",
                    "3",
                    "4"
                ]);
            }
        });
        test("should handle optional with fallback", ()=>{
            const tokens = createTokens("42");
            const parser = _combinators.map(_combinators.seq(_combinators.number(), _combinators.optional(_combinators.punctuation("!"))), ([num, bang])=>({
                    value: parseInt(num.value),
                    isExclamation: bang !== null
                }));
            const result = parser(tokens);
            expect(result.success).toBe(true);
            if (result.success) {
                expect(result.value).toEqual({
                    value: 42,
                    isExclamation: false
                });
            }
        });
    });
    describe("error handling", ()=>{
        test("should provide meaningful error messages", ()=>{
            const tokens = createTokens("hello");
            const parser = _combinators.seq(_combinators.number(), _combinators.operator("+"), _combinators.number());
            const result = parser(tokens);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error).toContain("Expected NUMBER");
                expect(result.error).toContain("but got IDENTIFIER");
                expect(result.position).toBeGreaterThan(0);
            }
        });
        test("should track position for error reporting", ()=>{
            const tokens = createTokens("hello");
            const result = _combinators.number()(tokens);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.position).toBeGreaterThan(0);
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2UvdGVzdC9jb21iaW5hdG9ycy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uL3NyYy9sZXhlclwiO1xuaW1wb3J0ICogYXMgQyBmcm9tIFwiLi4vc3JjL3BhcnNlci9jb21iaW5hdG9yc1wiO1xuXG5kZXNjcmliZShcIlBhcnNlciBDb21iaW5hdG9yc1wiLCAoKSA9PiB7XG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgdG9rZW5zIGZvciB0ZXN0aW5nXG4gIGNvbnN0IGNyZWF0ZVRva2VucyA9IChpbnB1dDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoaW5wdXQpO1xuICAgIHJldHVybiBsZXhlci50b2tlbml6ZSgpO1xuICB9O1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgdG9rZW5zIHdpdGhvdXQgRU9GIGZvciB0ZXN0aW5nXG4gIGNvbnN0IGNyZWF0ZVRva2Vuc1dpdGhvdXRFT0YgPSAoaW5wdXQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IGxleGVyID0gbmV3IExleGVyKGlucHV0KTtcbiAgICBjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuICAgIC8vIFJlbW92ZSBFT0YgdG9rZW4gZm9yIHRlc3RpbmdcbiAgICByZXR1cm4gdG9rZW5zLmZpbHRlcigodCkgPT4gdC50eXBlICE9PSBcIkVPRlwiKTtcbiAgfTtcblxuICBkZXNjcmliZShcInRva2VuXCIsICgpID0+IHtcbiAgICB0ZXN0KFwic2hvdWxkIG1hdGNoIGV4YWN0IHRva2VuIHR5cGUgYW5kIHZhbHVlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZVRva2Vuc1dpdGhvdXRFT0YoXCI0MlwiKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IEMudG9rZW4oXCJOVU1CRVJcIiwgXCI0MlwiKSh0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZS50eXBlKS50b0JlKFwiTlVNQkVSXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnZhbHVlKS50b0JlKFwiNDJcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQucmVtYWluaW5nKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIG1hdGNoIHRva2VuIHR5cGUgd2l0aG91dCB2YWx1ZSBjb25zdHJhaW50XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZVRva2VucyhcIjQyXCIpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gQy50b2tlbihcIk5VTUJFUlwiKSh0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZS50eXBlKS50b0JlKFwiTlVNQkVSXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnZhbHVlKS50b0JlKFwiNDJcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGZhaWwgb24gd3JvbmcgdG9rZW4gdHlwZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBjcmVhdGVUb2tlbnMoXCI0MlwiKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IEMudG9rZW4oXCJJREVOVElGSUVSXCIpKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbihcIkV4cGVjdGVkIElERU5USUZJRVJcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbihcImJ1dCBnb3QgTlVNQkVSXCIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBmYWlsIG9uIHdyb25nIHRva2VuIHZhbHVlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZVRva2VucyhcIjQyXCIpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gQy50b2tlbihcIk5VTUJFUlwiLCBcIjQzXCIpKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbihcIkV4cGVjdGVkIE5VTUJFUiAnNDMnXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0NvbnRhaW4oXCJidXQgZ290IE5VTUJFUiAnNDInXCIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBmYWlsIG9uIGVtcHR5IGlucHV0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IEMudG9rZW4oXCJOVU1CRVJcIikoW10pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0NvbnRhaW4oXCJFeHBlY3RlZCBOVU1CRVJcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbihcImJ1dCBnb3QgZW5kIG9mIGlucHV0XCIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcImFueVRva2VuXCIsICgpID0+IHtcbiAgICB0ZXN0KFwic2hvdWxkIG1hdGNoIGFueSB0b2tlblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBjcmVhdGVUb2tlbnNXaXRob3V0RU9GKFwiNDJcIik7XG4gICAgICBjb25zdCByZXN1bHQgPSBDLmFueVRva2VuKCkodG9rZW5zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUudHlwZSkudG9CZShcIk5VTUJFUlwiKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZS52YWx1ZSkudG9CZShcIjQyXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnJlbWFpbmluZykudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBmYWlsIG9uIGVtcHR5IGlucHV0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IEMuYW55VG9rZW4oKShbXSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQmUoXCJFeHBlY3RlZCBhbnkgdG9rZW4sIGJ1dCBnb3QgZW5kIG9mIGlucHV0XCIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcInNlcVwiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCBtYXRjaCBzZXF1ZW5jZSBvZiBwYXJzZXJzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZVRva2Vuc1dpdGhvdXRFT0YoXCJ4ID0gNDJcIik7XG4gICAgICBjb25zdCBwYXJzZXIgPSBDLnNlcShDLmlkZW50aWZpZXIoKSwgQy5vcGVyYXRvcihcIj1cIiksIEMubnVtYmVyKCkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWVbMF0udHlwZSkudG9CZShcIklERU5USUZJRVJcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWVbMF0udmFsdWUpLnRvQmUoXCJ4XCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlWzFdLnR5cGUpLnRvQmUoXCJPUEVSQVRPUlwiKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZVsxXS52YWx1ZSkudG9CZShcIj1cIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWVbMl0udHlwZSkudG9CZShcIk5VTUJFUlwiKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZVsyXS52YWx1ZSkudG9CZShcIjQyXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnJlbWFpbmluZykudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBmYWlsIGlmIGFueSBwYXJzZXIgaW4gc2VxdWVuY2UgZmFpbHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zKFwieCA9IDQyXCIpO1xuICAgICAgY29uc3QgcGFyc2VyID0gQy5zZXEoXG4gICAgICAgIEMuaWRlbnRpZmllcigpLFxuICAgICAgICBDLm9wZXJhdG9yKFwiK1wiKSwgLy8gV3Jvbmcgb3BlcmF0b3JcbiAgICAgICAgQy5udW1iZXIoKSxcbiAgICAgICk7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIodG9rZW5zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKFwiRXhwZWN0ZWQgT1BFUkFUT1IgJysnXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0NvbnRhaW4oXCJidXQgZ290IE9QRVJBVE9SICc9J1wiKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIGVtcHR5IHNlcXVlbmNlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZVRva2VucyhcInggPSA0MlwiKTtcbiAgICAgIGNvbnN0IHBhcnNlciA9IEMuc2VxKCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIodG9rZW5zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5yZW1haW5pbmcpLnRvRXF1YWwodG9rZW5zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJjaG9pY2VcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGQgbWF0Y2ggZmlyc3Qgc3VjY2Vzc2Z1bCBwYXJzZXJcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zKFwiNDJcIik7XG4gICAgICBjb25zdCBwYXJzZXIgPSBDLmNob2ljZShDLm51bWJlcigpLCBDLmlkZW50aWZpZXIoKSwgQy5zdHJpbmcoKSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIodG9rZW5zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUudHlwZSkudG9CZShcIk5VTUJFUlwiKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZS52YWx1ZSkudG9CZShcIjQyXCIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCB0cnkgYWxsIHBhcnNlcnMgaW4gb3JkZXJcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zKFwiaGVsbG9cIik7XG4gICAgICBjb25zdCBwYXJzZXIgPSBDLmNob2ljZShDLm51bWJlcigpLCBDLmlkZW50aWZpZXIoKSwgQy5zdHJpbmcoKSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIodG9rZW5zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUudHlwZSkudG9CZShcIklERU5USUZJRVJcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUudmFsdWUpLnRvQmUoXCJoZWxsb1wiKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgZmFpbCBpZiBhbGwgcGFyc2VycyBmYWlsXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZVRva2VucyhcIjQyXCIpO1xuICAgICAgY29uc3QgcGFyc2VyID0gQy5jaG9pY2UoQy5pZGVudGlmaWVyKCksIEMuc3RyaW5nKCkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbihcIkV4cGVjdGVkIElERU5USUZJRVJcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbihcImJ1dCBnb3QgTlVNQkVSXCIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgZW1wdHkgY2hvaWNlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZVRva2VucyhcIjQyXCIpO1xuICAgICAgY29uc3QgcGFyc2VyID0gQy5jaG9pY2UoKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcih0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlKFwiXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIm1hbnlcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGQgbWF0Y2ggemVybyBvciBtb3JlIG9jY3VycmVuY2VzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZVRva2VucyhcIjEgMiAzXCIpO1xuICAgICAgY29uc3QgcGFyc2VyID0gQy5tYW55KEMubnVtYmVyKCkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWVbMF0udmFsdWUpLnRvQmUoXCIxXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlWzFdLnZhbHVlKS50b0JlKFwiMlwiKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZVsyXS52YWx1ZSkudG9CZShcIjNcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIG1hdGNoIHplcm8gb2NjdXJyZW5jZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zKFwiaGVsbG9cIik7XG4gICAgICBjb25zdCBwYXJzZXIgPSBDLm1hbnkoQy5udW1iZXIoKSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIodG9rZW5zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5yZW1haW5pbmcpLnRvRXF1YWwodG9rZW5zKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIGVtcHR5IGlucHV0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IEMubWFueShDLm51bWJlcigpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihbXSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQucmVtYWluaW5nKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwibWFueTFcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGQgbWF0Y2ggb25lIG9yIG1vcmUgb2NjdXJyZW5jZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zKFwiMSAyIDNcIik7XG4gICAgICBjb25zdCBwYXJzZXIgPSBDLm1hbnkxKEMubnVtYmVyKCkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWVbMF0udmFsdWUpLnRvQmUoXCIxXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlWzFdLnZhbHVlKS50b0JlKFwiMlwiKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZVsyXS52YWx1ZSkudG9CZShcIjNcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGZhaWwgb24gemVybyBvY2N1cnJlbmNlc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBjcmVhdGVUb2tlbnMoXCJoZWxsb1wiKTtcbiAgICAgIGNvbnN0IHBhcnNlciA9IEMubWFueTEoQy5udW1iZXIoKSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIodG9rZW5zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9CZShcIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBvY2N1cnJlbmNlXCIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBmYWlsIG9uIGVtcHR5IGlucHV0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IEMubWFueTEoQy5udW1iZXIoKSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIoW10pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlKFwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIG9jY3VycmVuY2VcIik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwib3B0aW9uYWxcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGQgbWF0Y2ggd2hlbiBwYXJzZXIgc3VjY2VlZHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zV2l0aG91dEVPRihcIjQyXCIpO1xuICAgICAgY29uc3QgcGFyc2VyID0gQy5vcHRpb25hbChDLm51bWJlcigpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcih0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZSkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgIGlmIChyZXN1bHQudmFsdWUpIHtcbiAgICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnZhbHVlKS50b0JlKFwiNDJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZXhwZWN0KHJlc3VsdC5yZW1haW5pbmcpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcmV0dXJuIG51bGwgd2hlbiBwYXJzZXIgZmFpbHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zKFwiaGVsbG9cIik7XG4gICAgICBjb25zdCBwYXJzZXIgPSBDLm9wdGlvbmFsKEMubnVtYmVyKCkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlKS50b0JlTnVsbCgpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnJlbWFpbmluZykudG9FcXVhbCh0b2tlbnMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgZW1wdHkgaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VyID0gQy5vcHRpb25hbChDLm51bWJlcigpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihbXSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlKS50b0JlTnVsbCgpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnJlbWFpbmluZykudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIm1hcFwiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCB0cmFuc2Zvcm0gc3VjY2Vzc2Z1bCBwYXJzZSByZXN1bHRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zV2l0aG91dEVPRihcIjQyXCIpO1xuICAgICAgY29uc3QgcGFyc2VyID0gQy5tYXAoQy5udW1iZXIoKSwgKHRva2VuKSA9PiBwYXJzZUludCh0b2tlbi52YWx1ZSkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlKS50b0JlKDQyKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5yZW1haW5pbmcpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcHJlc2VydmUgZmFpbHVyZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBjcmVhdGVUb2tlbnMoXCJoZWxsb1wiKTtcbiAgICAgIGNvbnN0IHBhcnNlciA9IEMubWFwKEMubnVtYmVyKCksICh0b2tlbikgPT4gcGFyc2VJbnQodG9rZW4udmFsdWUpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcih0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0NvbnRhaW4oXCJFeHBlY3RlZCBOVU1CRVJcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbihcImJ1dCBnb3QgSURFTlRJRklFUlwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJsYXp5XCIsICgpID0+IHtcbiAgICB0ZXN0KFwic2hvdWxkIGRlZmVyIHBhcnNlciBjcmVhdGlvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBjcmVhdGVUb2tlbnMoXCI0MlwiKTtcbiAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHBhcnNlciA9IEMubGF6eSgoKSA9PiB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBDLm51bWJlcigpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChjYWxsZWQpLnRvQmUoZmFsc2UpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHRva2Vucyk7XG4gICAgICBleHBlY3QoY2FsbGVkKS50b0JlKHRydWUpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZS50eXBlKS50b0JlKFwiTlVNQkVSXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnZhbHVlKS50b0JlKFwiNDJcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGhhbmRsZSByZWN1cnNpdmUgcGFyc2Vyc1wiLCAoKSA9PiB7XG4gICAgICAvLyBUaGlzIHRlc3RzIHRoYXQgbGF6eSB3b3JrcyBmb3IgcmVjdXJzaXZlIGRlZmluaXRpb25zXG4gICAgICBjb25zdCB0b2tlbnMgPSBjcmVhdGVUb2tlbnMoXCI0MlwiKTtcbiAgICAgIGNvbnN0IHBhcnNlciA9IEMubGF6eSgoKSA9PiBDLmNob2ljZShDLm51bWJlcigpLCBDLmlkZW50aWZpZXIoKSkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnR5cGUpLnRvQmUoXCJOVU1CRVJcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUudmFsdWUpLnRvQmUoXCI0MlwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJzZXBCeVwiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCBwYXJzZSBlbGVtZW50cyBzZXBhcmF0ZWQgYnkgc2VwYXJhdG9yXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZVRva2VucyhcIjEsIDIsIDNcIik7XG4gICAgICBjb25zdCBwYXJzZXIgPSBDLnNlcEJ5KEMubnVtYmVyKCksIEMucHVuY3R1YXRpb24oXCIsXCIpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcih0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZSkudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlWzBdLnZhbHVlKS50b0JlKFwiMVwiKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZVsxXS52YWx1ZSkudG9CZShcIjJcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWVbMl0udmFsdWUpLnRvQmUoXCIzXCIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBwYXJzZSBzaW5nbGUgZWxlbWVudFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBjcmVhdGVUb2tlbnMoXCIxXCIpO1xuICAgICAgY29uc3QgcGFyc2VyID0gQy5zZXBCeShDLm51bWJlcigpLCBDLnB1bmN0dWF0aW9uKFwiLFwiKSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIodG9rZW5zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZVswXS52YWx1ZSkudG9CZShcIjFcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHBhcnNlIHplcm8gZWxlbWVudHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zKFwiaGVsbG9cIik7XG4gICAgICBjb25zdCBwYXJzZXIgPSBDLnNlcEJ5KEMubnVtYmVyKCksIEMucHVuY3R1YXRpb24oXCIsXCIpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcih0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZSkudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgICBleHBlY3QocmVzdWx0LnJlbWFpbmluZykudG9FcXVhbCh0b2tlbnMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBmYWlsIGlmIHNlcGFyYXRvciBpcyBmb2xsb3dlZCBieSBpbnZhbGlkIGVsZW1lbnRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zKFwiMSwgaGVsbG9cIik7XG4gICAgICBjb25zdCBwYXJzZXIgPSBDLnNlcEJ5KEMubnVtYmVyKCksIEMucHVuY3R1YXRpb24oXCIsXCIpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcih0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgLy8gc2VwQnkgc2hvdWxkIHN0b3AgYXQgdGhlIGZpcnN0IGZhaWx1cmUsIG5vdCBmYWlsIGVudGlyZWx5XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZVswXS52YWx1ZSkudG9CZShcIjFcIik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwicGFyc2VBbGxcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGQgc3VjY2VlZCB3aGVuIHBhcnNlciBjb25zdW1lcyBhbGwgaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zV2l0aG91dEVPRihcIjQyXCIpO1xuICAgICAgY29uc3QgcGFyc2VyID0gQy5wYXJzZUFsbChDLm51bWJlcigpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcih0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZS50eXBlKS50b0JlKFwiTlVNQkVSXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnZhbHVlKS50b0JlKFwiNDJcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGZhaWwgd2hlbiBpbnB1dCByZW1haW5zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZVRva2VucyhcIjQyIGhlbGxvXCIpO1xuICAgICAgY29uc3QgcGFyc2VyID0gQy5wYXJzZUFsbChDLm51bWJlcigpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcih0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0NvbnRhaW4oXCJVbmV4cGVjdGVkIElERU5USUZJRVJcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbihcImF0IGVuZCBvZiBpbnB1dFwiKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgcHJlc2VydmUgcGFyc2VyIGZhaWx1cmVcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zKFwiaGVsbG9cIik7XG4gICAgICBjb25zdCBwYXJzZXIgPSBDLnBhcnNlQWxsKEMubnVtYmVyKCkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbihcIkV4cGVjdGVkIE5VTUJFUlwiKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKFwiYnV0IGdvdCBJREVOVElGSUVSXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcImNvbnZlbmllbmNlIHBhcnNlcnNcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJpZGVudGlmaWVyIHNob3VsZCBtYXRjaCBpZGVudGlmaWVyc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBjcmVhdGVUb2tlbnMoXCJoZWxsb1wiKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IEMuaWRlbnRpZmllcigpKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnR5cGUpLnRvQmUoXCJJREVOVElGSUVSXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnZhbHVlKS50b0JlKFwiaGVsbG9cIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwibnVtYmVyIHNob3VsZCBtYXRjaCBudW1iZXJzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZVRva2VucyhcIjQyXCIpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gQy5udW1iZXIoKSh0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZS50eXBlKS50b0JlKFwiTlVNQkVSXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnZhbHVlKS50b0JlKFwiNDJcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic3RyaW5nIHNob3VsZCBtYXRjaCBzdHJpbmdzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZVRva2VucygnXCJoZWxsb1wiJyk7XG4gICAgICBjb25zdCByZXN1bHQgPSBDLnN0cmluZygpKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnR5cGUpLnRvQmUoXCJTVFJJTkdcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUudmFsdWUpLnRvQmUoXCJoZWxsb1wiKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJrZXl3b3JkIHNob3VsZCBtYXRjaCBzcGVjaWZpYyBrZXl3b3Jkc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBjcmVhdGVUb2tlbnMoXCJpZlwiKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IEMua2V5d29yZChcImlmXCIpKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnR5cGUpLnRvQmUoXCJLRVlXT1JEXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnZhbHVlKS50b0JlKFwiaWZcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwib3BlcmF0b3Igc2hvdWxkIG1hdGNoIHNwZWNpZmljIG9wZXJhdG9yc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBjcmVhdGVUb2tlbnMoXCIrXCIpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gQy5vcGVyYXRvcihcIitcIikodG9rZW5zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUudHlwZSkudG9CZShcIk9QRVJBVE9SXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnZhbHVlKS50b0JlKFwiK1wiKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJwdW5jdHVhdGlvbiBzaG91bGQgbWF0Y2ggc3BlY2lmaWMgcHVuY3R1YXRpb25cIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zKFwiKFwiKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IEMucHVuY3R1YXRpb24oXCIoXCIpKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnR5cGUpLnRvQmUoXCJQVU5DVFVBVElPTlwiKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZS52YWx1ZSkudG9CZShcIihcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwiYWNjZXNzb3Igc2hvdWxkIG1hdGNoIGFjY2Vzc29yc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBjcmVhdGVUb2tlbnMoXCJAZmllbGRcIik7XG4gICAgICBjb25zdCByZXN1bHQgPSBDLmFjY2Vzc29yKCkodG9rZW5zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUudHlwZSkudG9CZShcIkFDQ0VTU09SXCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlLnZhbHVlKS50b0JlKFwiZmllbGRcIik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiY29tcGxleCBjb21iaW5hdGlvbnNcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIG5lc3RlZCBzZXF1ZW5jZXMgYW5kIGNob2ljZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zKFwieCA9IDQyXCIpO1xuICAgICAgY29uc3QgcGFyc2VyID0gQy5tYXAoXG4gICAgICAgIEMuc2VxKFxuICAgICAgICAgIEMuaWRlbnRpZmllcigpLFxuICAgICAgICAgIEMuY2hvaWNlKEMub3BlcmF0b3IoXCI9XCIpLCBDLm9wZXJhdG9yKFwiOj1cIikpLFxuICAgICAgICAgIEMuY2hvaWNlKEMubnVtYmVyKCksIEMuc3RyaW5nKCkpLFxuICAgICAgICApLFxuICAgICAgICAoW2lkLCBvcCwgdmFsXSkgPT4gKHtcbiAgICAgICAgICB2YXJpYWJsZTogaWQudmFsdWUsXG4gICAgICAgICAgb3BlcmF0b3I6IG9wLnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiB2YWwudmFsdWUsXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcih0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZSkudG9FcXVhbCh7XG4gICAgICAgICAgdmFyaWFibGU6IFwieFwiLFxuICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICB2YWx1ZTogXCI0MlwiLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIG1hbnkgd2l0aCBzZXBhcmF0b3JcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zKFwiMSwgMiwgMywgNFwiKTtcbiAgICAgIGNvbnN0IHBhcnNlciA9IEMuc2VwQnkoQy5udW1iZXIoKSwgQy5wdW5jdHVhdGlvbihcIixcIikpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlKS50b0hhdmVMZW5ndGgoNCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUubWFwKCh0KSA9PiB0LnZhbHVlKSkudG9FcXVhbChbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCJdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIG9wdGlvbmFsIHdpdGggZmFsbGJhY2tcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5zID0gY3JlYXRlVG9rZW5zKFwiNDJcIik7XG4gICAgICBjb25zdCBwYXJzZXIgPSBDLm1hcChcbiAgICAgICAgQy5zZXEoQy5udW1iZXIoKSwgQy5vcHRpb25hbChDLnB1bmN0dWF0aW9uKFwiIVwiKSkpLFxuICAgICAgICAoW251bSwgYmFuZ10pID0+ICh7XG4gICAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bS52YWx1ZSksXG4gICAgICAgICAgaXNFeGNsYW1hdGlvbjogYmFuZyAhPT0gbnVsbCxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHRva2Vucyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlKS50b0VxdWFsKHtcbiAgICAgICAgICB2YWx1ZTogNDIsXG4gICAgICAgICAgaXNFeGNsYW1hdGlvbjogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcImVycm9yIGhhbmRsaW5nXCIsICgpID0+IHtcbiAgICB0ZXN0KFwic2hvdWxkIHByb3ZpZGUgbWVhbmluZ2Z1bCBlcnJvciBtZXNzYWdlc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBjcmVhdGVUb2tlbnMoXCJoZWxsb1wiKTtcbiAgICAgIGNvbnN0IHBhcnNlciA9IEMuc2VxKEMubnVtYmVyKCksIEMub3BlcmF0b3IoXCIrXCIpLCBDLm51bWJlcigpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcih0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0NvbnRhaW4oXCJFeHBlY3RlZCBOVU1CRVJcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbihcImJ1dCBnb3QgSURFTlRJRklFUlwiKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5wb3NpdGlvbikudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCB0cmFjayBwb3NpdGlvbiBmb3IgZXJyb3IgcmVwb3J0aW5nXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VucyA9IGNyZWF0ZVRva2VucyhcImhlbGxvXCIpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gQy5udW1iZXIoKSh0b2tlbnMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LnBvc2l0aW9uKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJjcmVhdGVUb2tlbnMiLCJpbnB1dCIsImxleGVyIiwiTGV4ZXIiLCJ0b2tlbml6ZSIsImNyZWF0ZVRva2Vuc1dpdGhvdXRFT0YiLCJ0b2tlbnMiLCJmaWx0ZXIiLCJ0IiwidHlwZSIsInRlc3QiLCJyZXN1bHQiLCJDIiwidG9rZW4iLCJleHBlY3QiLCJzdWNjZXNzIiwidG9CZSIsInZhbHVlIiwicmVtYWluaW5nIiwidG9IYXZlTGVuZ3RoIiwiZXJyb3IiLCJ0b0NvbnRhaW4iLCJhbnlUb2tlbiIsInBhcnNlciIsInNlcSIsImlkZW50aWZpZXIiLCJvcGVyYXRvciIsIm51bWJlciIsInRvRXF1YWwiLCJjaG9pY2UiLCJzdHJpbmciLCJtYW55IiwibWFueTEiLCJvcHRpb25hbCIsIm5vdCIsInRvQmVOdWxsIiwibWFwIiwicGFyc2VJbnQiLCJjYWxsZWQiLCJsYXp5Iiwic2VwQnkiLCJwdW5jdHVhdGlvbiIsInBhcnNlQWxsIiwia2V5d29yZCIsImFjY2Vzc29yIiwiaWQiLCJvcCIsInZhbCIsInZhcmlhYmxlIiwibnVtIiwiYmFuZyIsImlzRXhjbGFtYXRpb24iLCJwb3NpdGlvbiIsInRvQmVHcmVhdGVyVGhhbiJdLCJtYXBwaW5ncyI6Ijs7Ozt1QkFBc0I7cUVBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVuQkEsU0FBUyxzQkFBc0I7SUFDN0IsK0NBQStDO0lBQy9DLE1BQU1DLGVBQWUsQ0FBQ0M7UUFDcEIsTUFBTUMsUUFBUSxJQUFJQyxZQUFLLENBQUNGO1FBQ3hCLE9BQU9DLE1BQU1FLFFBQVE7SUFDdkI7SUFFQSwyREFBMkQ7SUFDM0QsTUFBTUMseUJBQXlCLENBQUNKO1FBQzlCLE1BQU1DLFFBQVEsSUFBSUMsWUFBSyxDQUFDRjtRQUN4QixNQUFNSyxTQUFTSixNQUFNRSxRQUFRO1FBQzdCLCtCQUErQjtRQUMvQixPQUFPRSxPQUFPQyxNQUFNLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUMsSUFBSSxLQUFLO0lBQ3pDO0lBRUFWLFNBQVMsU0FBUztRQUNoQlcsS0FBSywyQ0FBMkM7WUFDOUMsTUFBTUosU0FBU0QsdUJBQXVCO1lBQ3RDLE1BQU1NLFNBQVNDLGFBQUVDLEtBQUssQ0FBQyxVQUFVLE1BQU1QO1lBRXZDUSxPQUFPSCxPQUFPSSxPQUFPLEVBQUVDLElBQUksQ0FBQztZQUM1QixJQUFJTCxPQUFPSSxPQUFPLEVBQUU7Z0JBQ2xCRCxPQUFPSCxPQUFPTSxLQUFLLENBQUNSLElBQUksRUFBRU8sSUFBSSxDQUFDO2dCQUMvQkYsT0FBT0gsT0FBT00sS0FBSyxDQUFDQSxLQUFLLEVBQUVELElBQUksQ0FBQztnQkFDaENGLE9BQU9ILE9BQU9PLFNBQVMsRUFBRUMsWUFBWSxDQUFDO1lBQ3hDO1FBQ0Y7UUFFQVQsS0FBSyxvREFBb0Q7WUFDdkQsTUFBTUosU0FBU04sYUFBYTtZQUM1QixNQUFNVyxTQUFTQyxhQUFFQyxLQUFLLENBQUMsVUFBVVA7WUFFakNRLE9BQU9ILE9BQU9JLE9BQU8sRUFBRUMsSUFBSSxDQUFD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