{"version":3,"sources":["/workspace/test/adt.test.ts"],"sourcesContent":["import { describe, it, expect } from \"@jest/globals\";\nimport { Lexer } from \"../src/lexer\";\nimport { parse } from \"../src/parser/parser\";\nimport { Evaluator } from \"../src/evaluator\";\nimport { typeProgram } from '../src/typer';\nimport { typeToString } from '../src/typer/helpers';\n\n// Helper function to parse and evaluate Noolang code\nconst runNoolang = (source: string) => {\n  const lexer = new Lexer(source);\n  const tokens = lexer.tokenize();\n  const program = parse(tokens);\n\n  // Type check first\n  const typeResult = typeProgram(program);\n\n  // Then evaluate\n  const evaluator = new Evaluator();\n  const evalResult = evaluator.evaluateProgram(program);\n\n  return {\n    typeResult,\n    evalResult,\n    finalType: typeToString(typeResult.type, typeResult.state.substitution),\n    finalValue: evalResult.finalResult,\n  };\n};\n\ndescribe(\"Algebraic Data Types (ADTs)\", () => {\n  describe(\"Built-in Option Type\", () => {\n    it(\"should create Some values\", () => {\n      const result = runNoolang(`\n        x = Some 42;\n        x\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"Some\",\n        args: [{ tag: \"number\", value: 42 }],\n      });\n    });\n\n    it(\"should create None values\", () => {\n      const result = runNoolang(`\n        x = None;\n        x\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"None\",\n        args: [],\n      });\n    });\n\n    it(\"should pattern match on Some\", () => {\n      const result = runNoolang(`\n        x = Some 21;\n        result = match x with (Some y => y * 2; None => 0);\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 42 });\n    });\n\n    it(\"should pattern match on None\", () => {\n      const result = runNoolang(`\n        x = None;\n        result = match x with (Some y => y * 2; None => 99);\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 99 });\n    });\n\n    it(\"should handle nested Option values\", () => {\n      const result = runNoolang(`\n        nested = Some (Some 10);\n        result = match nested with (\n          Some inner => match inner with (Some value => value; None => 0);\n          None => -1\n        );\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 10 });\n    });\n  });\n\n  describe(\"Built-in Result Type\", () => {\n    it(\"should create Ok values\", () => {\n      const result = runNoolang(`\n        x = Ok 100;\n        x\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"Ok\",\n        args: [{ tag: \"number\", value: 100 }],\n      });\n    });\n\n    it(\"should create Err values\", () => {\n      const result = runNoolang(`\n        x = Err \"failed\";\n        x\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"Err\",\n        args: [{ tag: \"string\", value: \"failed\" }],\n      });\n    });\n\n    it(\"should pattern match on Ok\", () => {\n      const result = runNoolang(`\n        x = Ok 50;\n        result = match x with (Ok value => value + 10; Err msg => 0);\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 60 });\n    });\n\n    it(\"should pattern match on Err\", () => {\n      const result = runNoolang(`\n        x = Err \"oops\";\n        result = match x with (Ok value => value; Err msg => 404);\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 404 });\n    });\n  });\n\n  describe(\"Custom ADT Definitions\", () => {\n    it(\"should define and use a simple ADT\", () => {\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        favorite = Red;\n        favorite\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"Red\",\n        args: [],\n      });\n    });\n\n    it(\"should define ADT with parameters\", () => {\n      const result = runNoolang(`\n        type Point a = Point a a;\n        origin = Point 0 0;\n        origin\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"Point\",\n        args: [\n          { tag: \"number\", value: 0 },\n          { tag: \"number\", value: 0 },\n        ],\n      });\n    });\n\n    it(\"should pattern match on custom ADTs\", () => {\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        getColorCode = fn color => match color with (\n          Red => 1;\n          Green => 2;\n          Blue => 3\n        );\n        result = getColorCode Red;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 1 });\n    });\n\n    it.skip(\"should handle recursive ADTs\", () => {\n      // Skipped: Recursive ADTs need additional type system work for self-references\n      const result = runNoolang(`\n        type List a = Nil | Cons a (List a);\n        myList = Cons 1 (Cons 2 Nil);\n        getFirst = fn list => match list with (\n          Nil => 0;\n          Cons x xs => x\n        );\n        result = getFirst myList;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 1 });\n    });\n\n    it.skip(\"should handle complex pattern matching with variables\", () => {\n      // Skipped: Complex recursive pattern matching needs additional work\n      const result = runNoolang(`\n        type Tree a = Leaf a | Branch (Tree a) (Tree a);\n        tree = Branch (Leaf 5) (Leaf 10);\n        sumTree = fn t => match t with (\n          Leaf value => value;\n          Branch left right => (sumTree left) + (sumTree right)\n        );\n        result = sumTree tree;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 15 });\n    });\n  });\n\n  describe(\"Pattern Matching Features\", () => {\n    it(\"should handle wildcard patterns\", () => {\n      const result = runNoolang(`\n        type Maybe a = Just a | Nothing;\n        getValue = fn maybe => match maybe with (\n          Just x => x;\n          _ => 42\n        );\n        result = getValue Nothing;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 42 });\n    });\n\n    it(\"should handle literal patterns\", () => {\n      const result = runNoolang(\n        `type Status = Success | Error | Code Int; getStatusMessage = fn status => match status with (Success => \"ok\"; Error => \"fail\"; Code 404 => \"not found\"; Code x => \"unknown code\"); result = getStatusMessage (Code 404); result`,\n      );\n      expect(result.finalValue).toEqual({ tag: \"string\", value: \"not found\" });\n    });\n\n    it(\"should handle nested patterns\", () => {\n      const result = runNoolang(\n        `type Wrapper a = Wrap a; type Inner = Value Int; nested = Wrap (Value 123); extract = fn w => match w with (Wrap (Value n) => n; _ => 0); result = extract nested; result`,\n      );\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 123 });\n    });\n  });\n\n  describe(\"Type Checking\", () => {\n    it(\"should type check ADT constructors correctly\", () => {\n      const result = runNoolang(`\n        type Option a = Some a | None;\n        x = Some 42;\n        x\n      `);\n\n      // Should infer that x has type Option Int\n      expect(result.finalType).toMatch(/Option.*Int|variant.*Option/);\n    });\n\n    it(\"should enforce pattern exhaustiveness (implicit)\", () => {\n      // This should work - all patterns covered\n      const result = runNoolang(`\n        type Bool = True | False;\n        negate = fn b => match b with (True => False; False => True);\n        result = negate True;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"False\",\n        args: [],\n      });\n    });\n\n    it(\"should handle polymorphic ADTs\", () => {\n      const result = runNoolang(`\n        type Pair a b = Pair a b;\n        p = Pair 42 \"hello\";\n        getFirst = fn pair => match pair with (Pair x y => x);\n        result = getFirst p;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 42 });\n    });\n  });\n\n  describe(\"Error Cases\", () => {\n    it(\"should error on unknown constructor in patterns\", () => {\n      expect(() => {\n        runNoolang(`\n          type Color = Red | Green | Blue;\n          x = Red;\n          match x with (Yellow => 1; Red => 2)\n        `);\n      }).toThrow();\n    });\n\n    it(\"should handle partial constructor application\", () => {\n      const result = runNoolang(`\n        type Point = Point Int Int;\n        p = Point 1;  # Partial application - returns (Int) -> Point\n        p\n      `);\n\n      // Should return a function type since it's a partial application\n      expect(result.finalType).toMatch(/Int.*Point|function/);\n    });\n\n    it(\"should error when no pattern matches\", () => {\n      expect(() => {\n        const evaluator = new Evaluator();\n        const source = `\n          type Color = Red | Green | Blue;\n          x = Blue;\n          match x with (Red => 1; Green => 2)  # Missing Blue case\n        `;\n        const lexer = new Lexer(source);\n        const tokens = lexer.tokenize();\n        const program = parse(tokens);\n        evaluator.evaluateProgram(program);\n      }).toThrow(\"No pattern matched\");\n    });\n  });\n\n  describe(\"Integration with Built-in Functions\", () => {\n    it(\"should work with map and Option\", () => {\n      const result = runNoolang(`\n        options = [Some 1, None, Some 3];\n        extractValue = fn opt => match opt with (Some x => x; None => 0);\n        result = map extractValue options;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"number\", value: 1 },\n          { tag: \"number\", value: 0 },\n          { tag: \"number\", value: 3 },\n        ],\n      });\n    });\n\n    it(\"should work with filter and custom ADTs\", () => {\n      const result = runNoolang(`\n        type Status = Active | Inactive;\n        items = [Active, Inactive, Active, Active];\n        isActive = fn status => match status with (Active => True; Inactive => False);\n        result = filter isActive items;\n        result\n      `);\n\n      expect(result.finalValue.tag).toBe(\"list\");\n      if (result.finalValue.tag === \"list\") {\n        expect(result.finalValue.values).toHaveLength(3);\n        result.finalValue.values.forEach((item: any) => {\n          expect(item).toEqual({\n            tag: \"constructor\",\n            name: \"Active\",\n            args: [],\n          });\n        });\n      }\n    });\n  });\n\n  describe(\"Multiple ADT Definitions\", () => {\n    it(\"should handle multiple ADT definitions in the same program\", () => {\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        colors = [Red, Green, Blue];\n        shapes = [Circle 3, Rectangle 5 4];\n        colors\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"constructor\", name: \"Red\", args: [] },\n          { tag: \"constructor\", name: \"Green\", args: [] },\n          { tag: \"constructor\", name: \"Blue\", args: [] },\n        ],\n      });\n    });\n\n    it(\"should handle pattern matching on different ADTs separately\", () => {\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        color_to_number Red\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 1 });\n    });\n\n    it(\"should now work with map and multiple ADTs (polymorphism fixed)\", () => {\n      // This test was previously failing due to lack of polymorphism in map\n      // Now that map is properly polymorphic, it should work\n      expect(() =>\n        runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        colors = [Red, Green, Blue];\n        shapes = [Circle 3, Rectangle 5 4];\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        color_numbers = map color_to_number colors;\n        areas = map calculate_area shapes;\n        color_numbers\n      `),\n      ).not.toThrow();\n    });\n\n    it(\"should work when ADTs are used in separate operations\", () => {\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        colors = [Red, Green, Blue];\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        color_numbers = map color_to_number colors;\n        color_numbers\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"number\", value: 1 },\n          { tag: \"number\", value: 2 },\n          { tag: \"number\", value: 3 },\n        ],\n      });\n    });\n\n    it(\"should work when shapes are processed separately\", () => {\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        shapes = [Circle 3, Rectangle 5 4];\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        areas = map calculate_area shapes;\n        areas\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"number\", value: 27 },\n          { tag: \"number\", value: 20 },\n        ],\n      });\n    });\n  });\n});\n"],"names":["runNoolang","source","lexer","Lexer","tokens","tokenize","program","parse","typeResult","typeProgram","evaluator","Evaluator","evalResult","evaluateProgram","finalType","typeToString","type","state","substitution","finalValue","finalResult","describe","it","result","expect","toEqual","tag","name","args","value","skip","toMatch","toThrow","values","toBe","toHaveLength","forEach","item","not"],"mappings":"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"}