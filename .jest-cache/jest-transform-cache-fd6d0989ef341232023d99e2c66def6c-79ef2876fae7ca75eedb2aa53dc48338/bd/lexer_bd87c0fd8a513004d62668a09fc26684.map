{"version":3,"sources":["/workspace/src/lexer.ts"],"sourcesContent":["import { Position, Location, createPosition, createLocation } from \"./ast\";\n\nexport type TokenType =\n  | \"IDENTIFIER\"\n  | \"NUMBER\"\n  | \"STRING\"\n  | \"BOOLEAN\"\n  | \"OPERATOR\"\n  | \"PUNCTUATION\"\n  | \"KEYWORD\"\n  | \"COMMENT\"\n  | \"ACCESSOR\"\n  | \"EOF\";\n\nexport interface Token {\n  type: TokenType;\n  value: string;\n  location: Location;\n}\n\nexport class Lexer {\n  private input: string;\n  private position: number = 0;\n  private line: number = 1;\n  private column: number = 1;\n\n  constructor(input: string) {\n    this.input = input;\n  }\n\n  private isEOF(): boolean {\n    return this.position >= this.input.length;\n  }\n\n  private peek(): string {\n    return this.isEOF() ? \"\\0\" : this.input[this.position];\n  }\n\n  private peekNext(): string {\n    return this.position + 1 >= this.input.length\n      ? \"\\0\"\n      : this.input[this.position + 1];\n  }\n\n  private advance(): string {\n    if (this.isEOF()) return \"\\0\";\n    const char = this.input[this.position];\n    this.position++;\n    if (char === \"\\n\") {\n      this.line++;\n      this.column = 1;\n    } else {\n      this.column++;\n    }\n    return char;\n  }\n\n  // Skip any run of whitespace (spaces, tabs, newlines)\n  private skipWhitespace(): void {\n    while (!this.isEOF() && /\\s/.test(this.peek())) {\n      this.advance();\n    }\n    // Also skip comments\n    this.skipComment();\n  }\n\n  private skipComment(): void {\n    if (this.peek() === \"#\") {\n      // Skip the # character\n      this.advance();\n      // Skip everything until newline or EOF\n      while (!this.isEOF() && this.peek() !== \"\\n\") {\n        this.advance();\n      }\n    }\n  }\n\n  private readNumber(): Token {\n    const start = this.createPosition();\n    let value = \"\";\n\n    while (!this.isEOF() && /\\d/.test(this.peek())) {\n      value += this.advance();\n    }\n\n    if (this.peek() === \".\" && /\\d/.test(this.peekNext())) {\n      value += this.advance(); // consume the dot\n      while (!this.isEOF() && /\\d/.test(this.peek())) {\n        value += this.advance();\n      }\n    }\n\n    return {\n      type: \"NUMBER\",\n      value,\n      location: this.createLocation(start),\n    };\n  }\n\n  private readString(): Token {\n    const start = this.createPosition();\n    const quote = this.advance(); // consume opening quote\n    let value = \"\";\n\n    while (!this.isEOF() && this.peek() !== quote) {\n      if (this.peek() === \"\\\\\") {\n        this.advance(); // consume backslash\n        if (!this.isEOF()) {\n          value += this.advance(); // consume escaped character\n        }\n      } else {\n        value += this.advance();\n      }\n    }\n\n    if (this.peek() === quote) {\n      this.advance(); // consume closing quote\n    }\n\n    return {\n      type: \"STRING\",\n      value,\n      location: this.createLocation(start),\n    };\n  }\n\n  private readIdentifier(): Token {\n    const start = this.createPosition();\n    let value = \"\";\n\n    // Read the first character (must be letter or underscore)\n    if (!this.isEOF() && /[a-zA-Z_]/.test(this.peek())) {\n      value += this.advance();\n    }\n\n    // Read subsequent characters (can be letters, digits, or underscores)\n    while (!this.isEOF() && /[a-zA-Z0-9_]/.test(this.peek())) {\n      value += this.advance();\n    }\n\n    // Special case for mut! - check if we have \"mut\" followed by \"!\"\n    if (value === \"mut\" && !this.isEOF() && this.peek() === \"!\") {\n      value += this.advance(); // consume the !\n    }\n\n    // Check if it's a keyword\n    const keywords = [\n      \"if\",\n      \"then\",\n      \"else\",\n      \"let\",\n      \"in\",\n      \"fn\",\n      \"import\",\n      \"mut\",\n      \"mut!\",\n      \"where\",\n      \"type\",\n      \"match\",\n      \"with\",\n      \"given\",\n      \"is\",\n      \"and\",\n      \"or\",\n      \"implements\",\n      \"constraint\",\n      \"implement\",\n      // Primitive type names\n      \"Int\",\n      \"Number\",\n      \"String\",\n      \"Unit\",\n      \"List\",\n    ];\n    const type = keywords.includes(value) ? \"KEYWORD\" : \"IDENTIFIER\";\n\n    return {\n      type,\n      value,\n      location: this.createLocation(start),\n    };\n  }\n\n  private readOperator(): Token {\n    const start = this.createPosition();\n    let value = \"\";\n\n    // Multi-character operators (must have spaces around them)\n    const operators = [\n      \"|>\",\n      \"<|\",\n      \"==\",\n      \"!=\",\n      \"<=\",\n      \">=\",\n      \"=>\",\n      \"->\",\n      \"+\",\n      \"-\",\n      \"*\",\n      \"/\",\n      \"<\",\n      \">\",\n      \"=\",\n      \"|\",\n      \"$\",\n    ];\n\n    // Try to match multi-character operators first\n    for (const op of operators) {\n      if (\n        this.input.substring(this.position, this.position + op.length) === op\n      ) {\n        value = op;\n        for (let i = 0; i < op.length; i++) {\n          this.advance();\n        }\n        break;\n      }\n    }\n\n    // If no multi-character operator matched, try single character\n    if (!value && /[+\\-*/<>=!|$]/.test(this.peek())) {\n      value = this.advance();\n    }\n\n    return {\n      type: \"OPERATOR\",\n      value,\n      location: this.createLocation(start),\n    };\n  }\n\n  private readPunctuation(): Token {\n    const start = this.createPosition();\n    const value = this.advance();\n\n    return {\n      type: \"PUNCTUATION\",\n      value,\n      location: this.createLocation(start),\n    };\n  }\n\n  private readAccessor(): Token {\n    const start = this.createPosition();\n    this.advance(); // consume @\n    let field = \"\";\n\n    // Read letters, digits, and underscores after @\n    while (!this.isEOF() && /[a-zA-Z0-9_]/.test(this.peek())) {\n      field += this.advance();\n    }\n\n    return {\n      type: \"ACCESSOR\",\n      value: field,\n      location: this.createLocation(start),\n    };\n  }\n\n  private createPosition(): Position {\n    return createPosition(this.line, this.column);\n  }\n\n  private createLocation(start: Position): Location {\n    return createLocation(start, this.createPosition());\n  }\n\n  nextToken(): Token {\n    // Skip any whitespace (spaces, tabs, newlines)\n    this.skipWhitespace();\n\n    if (this.isEOF()) {\n      return {\n        type: \"EOF\",\n        value: \"\",\n        location: this.createLocation(this.createPosition()),\n      };\n    }\n\n    const char = this.peek();\n\n    // If the next character is still whitespace, skip it and get the next token\n    if (/\\s/.test(char)) {\n      this.advance();\n      return this.nextToken();\n    }\n\n    if (char === '\"' || char === \"'\") {\n      return this.readString();\n    }\n\n    if (/[a-zA-Z_]/.test(char)) {\n      return this.readIdentifier();\n    }\n\n    if (/\\d/.test(char)) {\n      return this.readNumber();\n    }\n\n    if (/[+\\-*/<>=!|$]/.test(char)) {\n      return this.readOperator();\n    }\n\n    if (/[(),;:\\[\\]{}]/.test(char)) {\n      return this.readPunctuation();\n    }\n\n    // Handle accessors\n    if (char === \"@\") {\n      return this.readAccessor();\n    }\n\n    // Handle comments\n    if (char === \"#\") {\n      this.skipComment();\n      // After skipping comment, get the next token\n      return this.nextToken();\n    }\n\n    // Unknown character\n    const start = this.createPosition();\n    const value = this.advance();\n    // If the unknown character is whitespace, skip it and get the next token\n    if (/\\s/.test(value)) {\n      return this.nextToken();\n    }\n    return {\n      type: \"PUNCTUATION\",\n      value,\n      location: this.createLocation(start),\n    };\n  }\n\n  tokenize(): Token[] {\n    const tokens: Token[] = [];\n    let token: Token;\n\n    do {\n      token = this.nextToken();\n      tokens.push(token);\n    } while (token.type !== \"EOF\");\n\n    return tokens;\n  }\n}\n"],"names":["Lexer","input","position","line","column","isEOF","length","peek","peekNext","advance","char","skipWhitespace","test","skipComment","readNumber","start","createPosition","value","type","location","createLocation","readString","quote","readIdentifier","keywords","includes","readOperator","operators","op","substring","i","readPunctuation","readAccessor","field","nextToken","tokenize","tokens","token","push"],"mappings":"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"}