f37c11a6160f7eba670f5a7222bedb6e
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Lexer", {
    enumerable: true,
    get: function() {
        return Lexer;
    }
});
const _ast = require("./ast");
class Lexer {
    input;
    position = 0;
    line = 1;
    column = 1;
    constructor(input){
        this.input = input;
    }
    isEOF() {
        return this.position >= this.input.length;
    }
    peek() {
        return this.isEOF() ? "\0" : this.input[this.position];
    }
    peekNext() {
        return this.position + 1 >= this.input.length ? "\0" : this.input[this.position + 1];
    }
    advance() {
        if (this.isEOF()) return "\0";
        const char = this.input[this.position];
        this.position++;
        if (char === "\n") {
            this.line++;
            this.column = 1;
        } else {
            this.column++;
        }
        return char;
    }
    // Skip any run of whitespace (spaces, tabs, newlines)
    skipWhitespace() {
        while(!this.isEOF() && /\s/.test(this.peek())){
            this.advance();
        }
        // Also skip comments
        this.skipComment();
    }
    skipComment() {
        if (this.peek() === "#") {
            // Skip the # character
            this.advance();
            // Skip everything until newline or EOF
            while(!this.isEOF() && this.peek() !== "\n"){
                this.advance();
            }
        }
    }
    readNumber() {
        const start = this.createPosition();
        let value = "";
        while(!this.isEOF() && /\d/.test(this.peek())){
            value += this.advance();
        }
        if (this.peek() === "." && /\d/.test(this.peekNext())) {
            value += this.advance(); // consume the dot
            while(!this.isEOF() && /\d/.test(this.peek())){
                value += this.advance();
            }
        }
        return {
            type: "NUMBER",
            value,
            location: this.createLocation(start)
        };
    }
    readString() {
        const start = this.createPosition();
        const quote = this.advance(); // consume opening quote
        let value = "";
        while(!this.isEOF() && this.peek() !== quote){
            if (this.peek() === "\\") {
                this.advance(); // consume backslash
                if (!this.isEOF()) {
                    value += this.advance(); // consume escaped character
                }
            } else {
                value += this.advance();
            }
        }
        if (this.peek() === quote) {
            this.advance(); // consume closing quote
        }
        return {
            type: "STRING",
            value,
            location: this.createLocation(start)
        };
    }
    readIdentifier() {
        const start = this.createPosition();
        let value = "";
        // Read the first character (must be letter or underscore)
        if (!this.isEOF() && /[a-zA-Z_]/.test(this.peek())) {
            value += this.advance();
        }
        // Read subsequent characters (can be letters, digits, or underscores)
        while(!this.isEOF() && /[a-zA-Z0-9_]/.test(this.peek())){
            value += this.advance();
        }
        // Special case for mut! - check if we have "mut" followed by "!"
        if (value === "mut" && !this.isEOF() && this.peek() === "!") {
            value += this.advance(); // consume the !
        }
        // Check if it's a keyword
        const keywords = [
            "if",
            "then",
            "else",
            "let",
            "in",
            "fn",
            "import",
            "mut",
            "mut!",
            "where",
            "type",
            "match",
            "with",
            "given",
            "is",
            "and",
            "or",
            "implements",
            "constraint",
            "implement",
            // Primitive type names
            "Int",
            "Number",
            "String",
            "Unit",
            "List"
        ];
        const type = keywords.includes(value) ? "KEYWORD" : "IDENTIFIER";
        return {
            type,
            value,
            location: this.createLocation(start)
        };
    }
    readOperator() {
        const start = this.createPosition();
        let value = "";
        // Multi-character operators (must have spaces around them)
        const operators = [
            "|>",
            "<|",
            "==",
            "!=",
            "<=",
            ">=",
            "=>",
            "->",
            "+",
            "-",
            "*",
            "/",
            "<",
            ">",
            "=",
            "|",
            "$"
        ];
        // Try to match multi-character operators first
        for (const op of operators){
            if (this.input.substring(this.position, this.position + op.length) === op) {
                value = op;
                for(let i = 0; i < op.length; i++){
                    this.advance();
                }
                break;
            }
        }
        // If no multi-character operator matched, try single character
        if (!value && /[+\-*/<>=!|$]/.test(this.peek())) {
            value = this.advance();
        }
        return {
            type: "OPERATOR",
            value,
            location: this.createLocation(start)
        };
    }
    readPunctuation() {
        const start = this.createPosition();
        const value = this.advance();
        return {
            type: "PUNCTUATION",
            value,
            location: this.createLocation(start)
        };
    }
    readAccessor() {
        const start = this.createPosition();
        this.advance(); // consume @
        let field = "";
        // Read letters, digits, and underscores after @
        while(!this.isEOF() && /[a-zA-Z0-9_]/.test(this.peek())){
            field += this.advance();
        }
        return {
            type: "ACCESSOR",
            value: field,
            location: this.createLocation(start)
        };
    }
    createPosition() {
        return (0, _ast.createPosition)(this.line, this.column);
    }
    createLocation(start) {
        return (0, _ast.createLocation)(start, this.createPosition());
    }
    nextToken() {
        // Skip any whitespace (spaces, tabs, newlines)
        this.skipWhitespace();
        if (this.isEOF()) {
            return {
                type: "EOF",
                value: "",
                location: this.createLocation(this.createPosition())
            };
        }
        const char = this.peek();
        // If the next character is still whitespace, skip it and get the next token
        if (/\s/.test(char)) {
            this.advance();
            return this.nextToken();
        }
        if (char === '"' || char === "'") {
            return this.readString();
        }
        if (/[a-zA-Z_]/.test(char)) {
            return this.readIdentifier();
        }
        if (/\d/.test(char)) {
            return this.readNumber();
        }
        if (/[+\-*/<>=!|$]/.test(char)) {
            return this.readOperator();
        }
        if (/[(),;:\[\]{}]/.test(char)) {
            return this.readPunctuation();
        }
        // Handle accessors
        if (char === "@") {
            return this.readAccessor();
        }
        // Handle comments
        if (char === "#") {
            this.skipComment();
            // After skipping comment, get the next token
            return this.nextToken();
        }
        // Unknown character
        const start = this.createPosition();
        const value = this.advance();
        // If the unknown character is whitespace, skip it and get the next token
        if (/\s/.test(value)) {
            return this.nextToken();
        }
        return {
            type: "PUNCTUATION",
            value,
            location: this.createLocation(start)
        };
    }
    tokenize() {
        const tokens = [];
        let token;
        do {
            token = this.nextToken();
            tokens.push(token);
        }while (token.type !== "EOF")
        return tokens;
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Uvc3JjL2xleGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvc2l0aW9uLCBMb2NhdGlvbiwgY3JlYXRlUG9zaXRpb24sIGNyZWF0ZUxvY2F0aW9uIH0gZnJvbSBcIi4vYXN0XCI7XG5cbmV4cG9ydCB0eXBlIFRva2VuVHlwZSA9XG4gIHwgXCJJREVOVElGSUVSXCJcbiAgfCBcIk5VTUJFUlwiXG4gIHwgXCJTVFJJTkdcIlxuICB8IFwiQk9PTEVBTlwiXG4gIHwgXCJPUEVSQVRPUlwiXG4gIHwgXCJQVU5DVFVBVElPTlwiXG4gIHwgXCJLRVlXT1JEXCJcbiAgfCBcIkNPTU1FTlRcIlxuICB8IFwiQUNDRVNTT1JcIlxuICB8IFwiRU9GXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW4ge1xuICB0eXBlOiBUb2tlblR5cGU7XG4gIHZhbHVlOiBzdHJpbmc7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbn1cblxuZXhwb3J0IGNsYXNzIExleGVyIHtcbiAgcHJpdmF0ZSBpbnB1dDogc3RyaW5nO1xuICBwcml2YXRlIHBvc2l0aW9uOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIGxpbmU6IG51bWJlciA9IDE7XG4gIHByaXZhdGUgY29sdW1uOiBudW1iZXIgPSAxO1xuXG4gIGNvbnN0cnVjdG9yKGlucHV0OiBzdHJpbmcpIHtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gIH1cblxuICBwcml2YXRlIGlzRU9GKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID49IHRoaXMuaW5wdXQubGVuZ3RoO1xuICB9XG5cbiAgcHJpdmF0ZSBwZWVrKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaXNFT0YoKSA/IFwiXFwwXCIgOiB0aGlzLmlucHV0W3RoaXMucG9zaXRpb25dO1xuICB9XG5cbiAgcHJpdmF0ZSBwZWVrTmV4dCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uICsgMSA+PSB0aGlzLmlucHV0Lmxlbmd0aFxuICAgICAgPyBcIlxcMFwiXG4gICAgICA6IHRoaXMuaW5wdXRbdGhpcy5wb3NpdGlvbiArIDFdO1xuICB9XG5cbiAgcHJpdmF0ZSBhZHZhbmNlKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuaXNFT0YoKSkgcmV0dXJuIFwiXFwwXCI7XG4gICAgY29uc3QgY2hhciA9IHRoaXMuaW5wdXRbdGhpcy5wb3NpdGlvbl07XG4gICAgdGhpcy5wb3NpdGlvbisrO1xuICAgIGlmIChjaGFyID09PSBcIlxcblwiKSB7XG4gICAgICB0aGlzLmxpbmUrKztcbiAgICAgIHRoaXMuY29sdW1uID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2x1bW4rKztcbiAgICB9XG4gICAgcmV0dXJuIGNoYXI7XG4gIH1cblxuICAvLyBTa2lwIGFueSBydW4gb2Ygd2hpdGVzcGFjZSAoc3BhY2VzLCB0YWJzLCBuZXdsaW5lcylcbiAgcHJpdmF0ZSBza2lwV2hpdGVzcGFjZSgpOiB2b2lkIHtcbiAgICB3aGlsZSAoIXRoaXMuaXNFT0YoKSAmJiAvXFxzLy50ZXN0KHRoaXMucGVlaygpKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgfVxuICAgIC8vIEFsc28gc2tpcCBjb21tZW50c1xuICAgIHRoaXMuc2tpcENvbW1lbnQoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2tpcENvbW1lbnQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucGVlaygpID09PSBcIiNcIikge1xuICAgICAgLy8gU2tpcCB0aGUgIyBjaGFyYWN0ZXJcbiAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgLy8gU2tpcCBldmVyeXRoaW5nIHVudGlsIG5ld2xpbmUgb3IgRU9GXG4gICAgICB3aGlsZSAoIXRoaXMuaXNFT0YoKSAmJiB0aGlzLnBlZWsoKSAhPT0gXCJcXG5cIikge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlYWROdW1iZXIoKTogVG9rZW4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5jcmVhdGVQb3NpdGlvbigpO1xuICAgIGxldCB2YWx1ZSA9IFwiXCI7XG5cbiAgICB3aGlsZSAoIXRoaXMuaXNFT0YoKSAmJiAvXFxkLy50ZXN0KHRoaXMucGVlaygpKSkge1xuICAgICAgdmFsdWUgKz0gdGhpcy5hZHZhbmNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGVlaygpID09PSBcIi5cIiAmJiAvXFxkLy50ZXN0KHRoaXMucGVla05leHQoKSkpIHtcbiAgICAgIHZhbHVlICs9IHRoaXMuYWR2YW5jZSgpOyAvLyBjb25zdW1lIHRoZSBkb3RcbiAgICAgIHdoaWxlICghdGhpcy5pc0VPRigpICYmIC9cXGQvLnRlc3QodGhpcy5wZWVrKCkpKSB7XG4gICAgICAgIHZhbHVlICs9IHRoaXMuYWR2YW5jZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk5VTUJFUlwiLFxuICAgICAgdmFsdWUsXG4gICAgICBsb2NhdGlvbjogdGhpcy5jcmVhdGVMb2NhdGlvbihzdGFydCksXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZFN0cmluZygpOiBUb2tlbiB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmNyZWF0ZVBvc2l0aW9uKCk7XG4gICAgY29uc3QgcXVvdGUgPSB0aGlzLmFkdmFuY2UoKTsgLy8gY29uc3VtZSBvcGVuaW5nIHF1b3RlXG4gICAgbGV0IHZhbHVlID0gXCJcIjtcblxuICAgIHdoaWxlICghdGhpcy5pc0VPRigpICYmIHRoaXMucGVlaygpICE9PSBxdW90ZSkge1xuICAgICAgaWYgKHRoaXMucGVlaygpID09PSBcIlxcXFxcIikge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gY29uc3VtZSBiYWNrc2xhc2hcbiAgICAgICAgaWYgKCF0aGlzLmlzRU9GKCkpIHtcbiAgICAgICAgICB2YWx1ZSArPSB0aGlzLmFkdmFuY2UoKTsgLy8gY29uc3VtZSBlc2NhcGVkIGNoYXJhY3RlclxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSArPSB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5wZWVrKCkgPT09IHF1b3RlKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gY29uc3VtZSBjbG9zaW5nIHF1b3RlXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiU1RSSU5HXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIGxvY2F0aW9uOiB0aGlzLmNyZWF0ZUxvY2F0aW9uKHN0YXJ0KSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkSWRlbnRpZmllcigpOiBUb2tlbiB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmNyZWF0ZVBvc2l0aW9uKCk7XG4gICAgbGV0IHZhbHVlID0gXCJcIjtcblxuICAgIC8vIFJlYWQgdGhlIGZpcnN0IGNoYXJhY3RlciAobXVzdCBiZSBsZXR0ZXIgb3IgdW5kZXJzY29yZSlcbiAgICBpZiAoIXRoaXMuaXNFT0YoKSAmJiAvW2EtekEtWl9dLy50ZXN0KHRoaXMucGVlaygpKSkge1xuICAgICAgdmFsdWUgKz0gdGhpcy5hZHZhbmNlKCk7XG4gICAgfVxuXG4gICAgLy8gUmVhZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMgKGNhbiBiZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIHVuZGVyc2NvcmVzKVxuICAgIHdoaWxlICghdGhpcy5pc0VPRigpICYmIC9bYS16QS1aMC05X10vLnRlc3QodGhpcy5wZWVrKCkpKSB7XG4gICAgICB2YWx1ZSArPSB0aGlzLmFkdmFuY2UoKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIG11dCEgLSBjaGVjayBpZiB3ZSBoYXZlIFwibXV0XCIgZm9sbG93ZWQgYnkgXCIhXCJcbiAgICBpZiAodmFsdWUgPT09IFwibXV0XCIgJiYgIXRoaXMuaXNFT0YoKSAmJiB0aGlzLnBlZWsoKSA9PT0gXCIhXCIpIHtcbiAgICAgIHZhbHVlICs9IHRoaXMuYWR2YW5jZSgpOyAvLyBjb25zdW1lIHRoZSAhXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhIGtleXdvcmRcbiAgICBjb25zdCBrZXl3b3JkcyA9IFtcbiAgICAgIFwiaWZcIixcbiAgICAgIFwidGhlblwiLFxuICAgICAgXCJlbHNlXCIsXG4gICAgICBcImxldFwiLFxuICAgICAgXCJpblwiLFxuICAgICAgXCJmblwiLFxuICAgICAgXCJpbXBvcnRcIixcbiAgICAgIFwibXV0XCIsXG4gICAgICBcIm11dCFcIixcbiAgICAgIFwid2hlcmVcIixcbiAgICAgIFwidHlwZVwiLFxuICAgICAgXCJtYXRjaFwiLFxuICAgICAgXCJ3aXRoXCIsXG4gICAgICBcImdpdmVuXCIsXG4gICAgICBcImlzXCIsXG4gICAgICBcImFuZFwiLFxuICAgICAgXCJvclwiLFxuICAgICAgXCJpbXBsZW1lbnRzXCIsXG4gICAgICBcImNvbnN0cmFpbnRcIixcbiAgICAgIFwiaW1wbGVtZW50XCIsXG4gICAgICAvLyBQcmltaXRpdmUgdHlwZSBuYW1lc1xuICAgICAgXCJJbnRcIixcbiAgICAgIFwiTnVtYmVyXCIsXG4gICAgICBcIlN0cmluZ1wiLFxuICAgICAgXCJVbml0XCIsXG4gICAgICBcIkxpc3RcIixcbiAgICBdO1xuICAgIGNvbnN0IHR5cGUgPSBrZXl3b3Jkcy5pbmNsdWRlcyh2YWx1ZSkgPyBcIktFWVdPUkRcIiA6IFwiSURFTlRJRklFUlwiO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGxvY2F0aW9uOiB0aGlzLmNyZWF0ZUxvY2F0aW9uKHN0YXJ0KSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkT3BlcmF0b3IoKTogVG9rZW4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5jcmVhdGVQb3NpdGlvbigpO1xuICAgIGxldCB2YWx1ZSA9IFwiXCI7XG5cbiAgICAvLyBNdWx0aS1jaGFyYWN0ZXIgb3BlcmF0b3JzIChtdXN0IGhhdmUgc3BhY2VzIGFyb3VuZCB0aGVtKVxuICAgIGNvbnN0IG9wZXJhdG9ycyA9IFtcbiAgICAgIFwifD5cIixcbiAgICAgIFwiPHxcIixcbiAgICAgIFwiPT1cIixcbiAgICAgIFwiIT1cIixcbiAgICAgIFwiPD1cIixcbiAgICAgIFwiPj1cIixcbiAgICAgIFwiPT5cIixcbiAgICAgIFwiLT5cIixcbiAgICAgIFwiK1wiLFxuICAgICAgXCItXCIsXG4gICAgICBcIipcIixcbiAgICAgIFwiL1wiLFxuICAgICAgXCI8XCIsXG4gICAgICBcIj5cIixcbiAgICAgIFwiPVwiLFxuICAgICAgXCJ8XCIsXG4gICAgICBcIiRcIixcbiAgICBdO1xuXG4gICAgLy8gVHJ5IHRvIG1hdGNoIG11bHRpLWNoYXJhY3RlciBvcGVyYXRvcnMgZmlyc3RcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wZXJhdG9ycykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmlucHV0LnN1YnN0cmluZyh0aGlzLnBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uICsgb3AubGVuZ3RoKSA9PT0gb3BcbiAgICAgICkge1xuICAgICAgICB2YWx1ZSA9IG9wO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gbXVsdGktY2hhcmFjdGVyIG9wZXJhdG9yIG1hdGNoZWQsIHRyeSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgaWYgKCF2YWx1ZSAmJiAvWytcXC0qLzw+PSF8JF0vLnRlc3QodGhpcy5wZWVrKCkpKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuYWR2YW5jZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9QRVJBVE9SXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIGxvY2F0aW9uOiB0aGlzLmNyZWF0ZUxvY2F0aW9uKHN0YXJ0KSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkUHVuY3R1YXRpb24oKTogVG9rZW4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5jcmVhdGVQb3NpdGlvbigpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5hZHZhbmNlKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQVU5DVFVBVElPTlwiLFxuICAgICAgdmFsdWUsXG4gICAgICBsb2NhdGlvbjogdGhpcy5jcmVhdGVMb2NhdGlvbihzdGFydCksXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZEFjY2Vzc29yKCk6IFRva2VuIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuY3JlYXRlUG9zaXRpb24oKTtcbiAgICB0aGlzLmFkdmFuY2UoKTsgLy8gY29uc3VtZSBAXG4gICAgbGV0IGZpZWxkID0gXCJcIjtcblxuICAgIC8vIFJlYWQgbGV0dGVycywgZGlnaXRzLCBhbmQgdW5kZXJzY29yZXMgYWZ0ZXIgQFxuICAgIHdoaWxlICghdGhpcy5pc0VPRigpICYmIC9bYS16QS1aMC05X10vLnRlc3QodGhpcy5wZWVrKCkpKSB7XG4gICAgICBmaWVsZCArPSB0aGlzLmFkdmFuY2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJBQ0NFU1NPUlwiLFxuICAgICAgdmFsdWU6IGZpZWxkLFxuICAgICAgbG9jYXRpb246IHRoaXMuY3JlYXRlTG9jYXRpb24oc3RhcnQpLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVBvc2l0aW9uKCk6IFBvc2l0aW9uIHtcbiAgICByZXR1cm4gY3JlYXRlUG9zaXRpb24odGhpcy5saW5lLCB0aGlzLmNvbHVtbik7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUxvY2F0aW9uKHN0YXJ0OiBQb3NpdGlvbik6IExvY2F0aW9uIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24oc3RhcnQsIHRoaXMuY3JlYXRlUG9zaXRpb24oKSk7XG4gIH1cblxuICBuZXh0VG9rZW4oKTogVG9rZW4ge1xuICAgIC8vIFNraXAgYW55IHdoaXRlc3BhY2UgKHNwYWNlcywgdGFicywgbmV3bGluZXMpXG4gICAgdGhpcy5za2lwV2hpdGVzcGFjZSgpO1xuXG4gICAgaWYgKHRoaXMuaXNFT0YoKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJFT0ZcIixcbiAgICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICAgIGxvY2F0aW9uOiB0aGlzLmNyZWF0ZUxvY2F0aW9uKHRoaXMuY3JlYXRlUG9zaXRpb24oKSksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGNoYXIgPSB0aGlzLnBlZWsoKTtcblxuICAgIC8vIElmIHRoZSBuZXh0IGNoYXJhY3RlciBpcyBzdGlsbCB3aGl0ZXNwYWNlLCBza2lwIGl0IGFuZCBnZXQgdGhlIG5leHQgdG9rZW5cbiAgICBpZiAoL1xccy8udGVzdChjaGFyKSkge1xuICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhciA9PT0gJ1wiJyB8fCBjaGFyID09PSBcIidcIikge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFN0cmluZygpO1xuICAgIH1cblxuICAgIGlmICgvW2EtekEtWl9dLy50ZXN0KGNoYXIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkSWRlbnRpZmllcigpO1xuICAgIH1cblxuICAgIGlmICgvXFxkLy50ZXN0KGNoYXIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKCk7XG4gICAgfVxuXG4gICAgaWYgKC9bK1xcLSovPD49IXwkXS8udGVzdChjaGFyKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZE9wZXJhdG9yKCk7XG4gICAgfVxuXG4gICAgaWYgKC9bKCksOzpcXFtcXF17fV0vLnRlc3QoY2hhcikpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRQdW5jdHVhdGlvbigpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBhY2Nlc3NvcnNcbiAgICBpZiAoY2hhciA9PT0gXCJAXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRBY2Nlc3NvcigpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb21tZW50c1xuICAgIGlmIChjaGFyID09PSBcIiNcIikge1xuICAgICAgdGhpcy5za2lwQ29tbWVudCgpO1xuICAgICAgLy8gQWZ0ZXIgc2tpcHBpbmcgY29tbWVudCwgZ2V0IHRoZSBuZXh0IHRva2VuXG4gICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICB9XG5cbiAgICAvLyBVbmtub3duIGNoYXJhY3RlclxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5jcmVhdGVQb3NpdGlvbigpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5hZHZhbmNlKCk7XG4gICAgLy8gSWYgdGhlIHVua25vd24gY2hhcmFjdGVyIGlzIHdoaXRlc3BhY2UsIHNraXAgaXQgYW5kIGdldCB0aGUgbmV4dCB0b2tlblxuICAgIGlmICgvXFxzLy50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBVTkNUVUFUSU9OXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIGxvY2F0aW9uOiB0aGlzLmNyZWF0ZUxvY2F0aW9uKHN0YXJ0KSxcbiAgICB9O1xuICB9XG5cbiAgdG9rZW5pemUoKTogVG9rZW5bXSB7XG4gICAgY29uc3QgdG9rZW5zOiBUb2tlbltdID0gW107XG4gICAgbGV0IHRva2VuOiBUb2tlbjtcblxuICAgIGRvIHtcbiAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICB9IHdoaWxlICh0b2tlbi50eXBlICE9PSBcIkVPRlwiKTtcblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJMZXhlciIsImlucHV0IiwicG9zaXRpb24iLCJsaW5lIiwiY29sdW1uIiwiaXNFT0YiLCJsZW5ndGgiLCJwZWVrIiwicGVla05leHQiLCJhZHZhbmNlIiwiY2hhciIsInNraXBXaGl0ZXNwYWNlIiwidGVzdCIsInNraXBDb21tZW50IiwicmVhZE51bWJlciIsInN0YXJ0IiwiY3JlYXRlUG9zaXRpb24iLCJ2YWx1ZSIsInR5cGUiLCJsb2NhdGlvbiIsImNyZWF0ZUxvY2F0aW9uIiwicmVhZFN0cmluZyIsInF1b3RlIiwicmVhZElkZW50aWZpZXIiLCJrZXl3b3JkcyIsImluY2x1ZGVzIiwicmVhZE9wZXJhdG9yIiwib3BlcmF0b3JzIiwib3AiLCJzdWJzdHJpbmciLCJpIiwicmVhZFB1bmN0dWF0aW9uIiwicmVhZEFjY2Vzc29yIiwiZmllbGQiLCJuZXh0VG9rZW4iLCJ0b2tlbml6ZSIsInRva2VucyIsInRva2VuIiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7OzsrQkFvQmFBOzs7ZUFBQUE7OztxQkFwQnNEO0FBb0I1RCxNQUFNQTtJQUNIQyxNQUFjO0lBQ2RDLFdBQW1CLEVBQUU7SUFDckJDLE9BQWUsRUFBRTtJQUNqQkMsU0FBaUIsRUFBRTtJQUUzQixZQUFZSCxLQUFhLENBQUU7UUFDekIsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0lBQ2Y7SUFFUUksUUFBaUI7UUFDdkIsT0FBTyxJQUFJLENBQUNILFFBQVEsSUFBSSxJQUFJLENBQUNELEtBQUssQ0FBQ0ssTUFBTTtJQUMzQztJQUVRQyxPQUFlO1FBQ3JCLE9BQU8sSUFBSSxDQUFDRixLQUFLLEtBQUssT0FBTyxJQUFJLENBQUNKLEtBQUssQ0FBQyxJQUFJLENBQUNDLFFBQVEsQ0FBQztJQUN4RDtJQUVRTSxXQUFtQjtRQUN6QixPQUFPLElBQUksQ0FBQ04sUUFBUSxHQUFHLEtBQUssSUFBSSxDQUFDRCxLQUFLLENBQUNLLE1BQU0sR0FDekMsT0FDQSxJQUFJLENBQUNMLEtBQUssQ0FBQyxJQUFJLENBQUNDLFFBQVEsR0FBRyxFQUFFO0lBQ25DO0lBRVFPLFVBQWtCO1FBQ3hCLElBQUksSUFBSSxDQUFDSixLQUFLLElBQUksT0FBTztRQUN6QixN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