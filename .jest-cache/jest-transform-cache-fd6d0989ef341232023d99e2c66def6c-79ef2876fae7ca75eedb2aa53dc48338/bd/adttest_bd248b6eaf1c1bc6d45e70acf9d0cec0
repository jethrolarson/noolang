29371053f7973c5865e86a99d6255ad0
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _lexer = require("../src/lexer");
const _parser = require("../src/parser/parser");
const _evaluator = require("../src/evaluator");
const _typer = require("../src/typer");
const _helpers = require("../src/typer/helpers");
// Helper function to parse and evaluate Noolang code
const runNoolang = (source)=>{
    const lexer = new _lexer.Lexer(source);
    const tokens = lexer.tokenize();
    const program = (0, _parser.parse)(tokens);
    // Type check first
    const typeResult = (0, _typer.typeProgram)(program);
    // Then evaluate
    const evaluator = new _evaluator.Evaluator();
    const evalResult = evaluator.evaluateProgram(program);
    return {
        typeResult,
        evalResult,
        finalType: (0, _helpers.typeToString)(typeResult.type, typeResult.state.substitution),
        finalValue: evalResult.finalResult
    };
};
(0, _globals.describe)("Algebraic Data Types (ADTs)", ()=>{
    (0, _globals.describe)("Built-in Option Type", ()=>{
        (0, _globals.it)("should create Some values", ()=>{
            const result = runNoolang(`
        x = Some 42;
        x
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "constructor",
                name: "Some",
                args: [
                    {
                        tag: "number",
                        value: 42
                    }
                ]
            });
        });
        (0, _globals.it)("should create None values", ()=>{
            const result = runNoolang(`
        x = None;
        x
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "constructor",
                name: "None",
                args: []
            });
        });
        (0, _globals.it)("should pattern match on Some", ()=>{
            const result = runNoolang(`
        x = Some 21;
        result = match x with (Some y => y * 2; None => 0);
        result
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "number",
                value: 42
            });
        });
        (0, _globals.it)("should pattern match on None", ()=>{
            const result = runNoolang(`
        x = None;
        result = match x with (Some y => y * 2; None => 99);
        result
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "number",
                value: 99
            });
        });
        (0, _globals.it)("should handle nested Option values", ()=>{
            const result = runNoolang(`
        nested = Some (Some 10);
        result = match nested with (
          Some inner => match inner with (Some value => value; None => 0);
          None => -1
        );
        result
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "number",
                value: 10
            });
        });
    });
    (0, _globals.describe)("Built-in Result Type", ()=>{
        (0, _globals.it)("should create Ok values", ()=>{
            const result = runNoolang(`
        x = Ok 100;
        x
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "constructor",
                name: "Ok",
                args: [
                    {
                        tag: "number",
                        value: 100
                    }
                ]
            });
        });
        (0, _globals.it)("should create Err values", ()=>{
            const result = runNoolang(`
        x = Err "failed";
        x
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "constructor",
                name: "Err",
                args: [
                    {
                        tag: "string",
                        value: "failed"
                    }
                ]
            });
        });
        (0, _globals.it)("should pattern match on Ok", ()=>{
            const result = runNoolang(`
        x = Ok 50;
        result = match x with (Ok value => value + 10; Err msg => 0);
        result
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "number",
                value: 60
            });
        });
        (0, _globals.it)("should pattern match on Err", ()=>{
            const result = runNoolang(`
        x = Err "oops";
        result = match x with (Ok value => value; Err msg => 404);
        result
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "number",
                value: 404
            });
        });
    });
    (0, _globals.describe)("Custom ADT Definitions", ()=>{
        (0, _globals.it)("should define and use a simple ADT", ()=>{
            const result = runNoolang(`
        type Color = Red | Green | Blue;
        favorite = Red;
        favorite
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "constructor",
                name: "Red",
                args: []
            });
        });
        (0, _globals.it)("should define ADT with parameters", ()=>{
            const result = runNoolang(`
        type Point a = Point a a;
        origin = Point 0 0;
        origin
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "constructor",
                name: "Point",
                args: [
                    {
                        tag: "number",
                        value: 0
                    },
                    {
                        tag: "number",
                        value: 0
                    }
                ]
            });
        });
        (0, _globals.it)("should pattern match on custom ADTs", ()=>{
            const result = runNoolang(`
        type Color = Red | Green | Blue;
        getColorCode = fn color => match color with (
          Red => 1;
          Green => 2;
          Blue => 3
        );
        result = getColorCode Red;
        result
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "number",
                value: 1
            });
        });
        _globals.it.skip("should handle recursive ADTs", ()=>{
            // Skipped: Recursive ADTs need additional type system work for self-references
            const result = runNoolang(`
        type List a = Nil | Cons a (List a);
        myList = Cons 1 (Cons 2 Nil);
        getFirst = fn list => match list with (
          Nil => 0;
          Cons x xs => x
        );
        result = getFirst myList;
        result
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "number",
                value: 1
            });
        });
        _globals.it.skip("should handle complex pattern matching with variables", ()=>{
            // Skipped: Complex recursive pattern matching needs additional work
            const result = runNoolang(`
        type Tree a = Leaf a | Branch (Tree a) (Tree a);
        tree = Branch (Leaf 5) (Leaf 10);
        sumTree = fn t => match t with (
          Leaf value => value;
          Branch left right => (sumTree left) + (sumTree right)
        );
        result = sumTree tree;
        result
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "number",
                value: 15
            });
        });
    });
    (0, _globals.describe)("Pattern Matching Features", ()=>{
        (0, _globals.it)("should handle wildcard patterns", ()=>{
            const result = runNoolang(`
        type Maybe a = Just a | Nothing;
        getValue = fn maybe => match maybe with (
          Just x => x;
          _ => 42
        );
        result = getValue Nothing;
        result
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "number",
                value: 42
            });
        });
        (0, _globals.it)("should handle literal patterns", ()=>{
            const result = runNoolang(`type Status = Success | Error | Code Int; getStatusMessage = fn status => match status with (Success => "ok"; Error => "fail"; Code 404 => "not found"; Code x => "unknown code"); result = getStatusMessage (Code 404); result`);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "string",
                value: "not found"
            });
        });
        (0, _globals.it)("should handle nested patterns", ()=>{
            const result = runNoolang(`type Wrapper a = Wrap a; type Inner = Value Int; nested = Wrap (Value 123); extract = fn w => match w with (Wrap (Value n) => n; _ => 0); result = extract nested; result`);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "number",
                value: 123
            });
        });
    });
    (0, _globals.describe)("Type Checking", ()=>{
        (0, _globals.it)("should type check ADT constructors correctly", ()=>{
            const result = runNoolang(`
        type Option a = Some a | None;
        x = Some 42;
        x
      `);
            // Should infer that x has type Option Int
            (0, _globals.expect)(result.finalType).toMatch(/Option.*Int|variant.*Option/);
        });
        (0, _globals.it)("should enforce pattern exhaustiveness (implicit)", ()=>{
            // This should work - all patterns covered
            const result = runNoolang(`
        type Bool = True | False;
        negate = fn b => match b with (True => False; False => True);
        result = negate True;
        result
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "constructor",
                name: "False",
                args: []
            });
        });
        (0, _globals.it)("should handle polymorphic ADTs", ()=>{
            const result = runNoolang(`
        type Pair a b = Pair a b;
        p = Pair 42 "hello";
        getFirst = fn pair => match pair with (Pair x y => x);
        result = getFirst p;
        result
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "number",
                value: 42
            });
        });
    });
    (0, _globals.describe)("Error Cases", ()=>{
        (0, _globals.it)("should error on unknown constructor in patterns", ()=>{
            (0, _globals.expect)(()=>{
                runNoolang(`
          type Color = Red | Green | Blue;
          x = Red;
          match x with (Yellow => 1; Red => 2)
        `);
            }).toThrow();
        });
        (0, _globals.it)("should handle partial constructor application", ()=>{
            const result = runNoolang(`
        type Point = Point Int Int;
        p = Point 1;  # Partial application - returns (Int) -> Point
        p
      `);
            // Should return a function type since it's a partial application
            (0, _globals.expect)(result.finalType).toMatch(/Int.*Point|function/);
        });
        (0, _globals.it)("should error when no pattern matches", ()=>{
            (0, _globals.expect)(()=>{
                const evaluator = new _evaluator.Evaluator();
                const source = `
          type Color = Red | Green | Blue;
          x = Blue;
          match x with (Red => 1; Green => 2)  # Missing Blue case
        `;
                const lexer = new _lexer.Lexer(source);
                const tokens = lexer.tokenize();
                const program = (0, _parser.parse)(tokens);
                evaluator.evaluateProgram(program);
            }).toThrow("No pattern matched");
        });
    });
    (0, _globals.describe)("Integration with Built-in Functions", ()=>{
        (0, _globals.it)("should work with map and Option", ()=>{
            const result = runNoolang(`
        options = [Some 1, None, Some 3];
        extractValue = fn opt => match opt with (Some x => x; None => 0);
        result = map extractValue options;
        result
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "list",
                values: [
                    {
                        tag: "number",
                        value: 1
                    },
                    {
                        tag: "number",
                        value: 0
                    },
                    {
                        tag: "number",
                        value: 3
                    }
                ]
            });
        });
        (0, _globals.it)("should work with filter and custom ADTs", ()=>{
            const result = runNoolang(`
        type Status = Active | Inactive;
        items = [Active, Inactive, Active, Active];
        isActive = fn status => match status with (Active => True; Inactive => False);
        result = filter isActive items;
        result
      `);
            (0, _globals.expect)(result.finalValue.tag).toBe("list");
            if (result.finalValue.tag === "list") {
                (0, _globals.expect)(result.finalValue.values).toHaveLength(3);
                result.finalValue.values.forEach((item)=>{
                    (0, _globals.expect)(item).toEqual({
                        tag: "constructor",
                        name: "Active",
                        args: []
                    });
                });
            }
        });
    });
    (0, _globals.describe)("Multiple ADT Definitions", ()=>{
        (0, _globals.it)("should handle multiple ADT definitions in the same program", ()=>{
            const result = runNoolang(`
        type Color = Red | Green | Blue;
        type Shape a = Circle a | Rectangle a a | Triangle a a a;
        colors = [Red, Green, Blue];
        shapes = [Circle 3, Rectangle 5 4];
        colors
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "list",
                values: [
                    {
                        tag: "constructor",
                        name: "Red",
                        args: []
                    },
                    {
                        tag: "constructor",
                        name: "Green",
                        args: []
                    },
                    {
                        tag: "constructor",
                        name: "Blue",
                        args: []
                    }
                ]
            });
        });
        (0, _globals.it)("should handle pattern matching on different ADTs separately", ()=>{
            const result = runNoolang(`
        type Color = Red | Green | Blue;
        type Shape a = Circle a | Rectangle a a | Triangle a a a;
        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);
        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);
        color_to_number Red
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "number",
                value: 1
            });
        });
        (0, _globals.it)("should now work with map and multiple ADTs (polymorphism fixed)", ()=>{
            // This test was previously failing due to lack of polymorphism in map
            // Now that map is properly polymorphic, it should work
            (0, _globals.expect)(()=>runNoolang(`
        type Color = Red | Green | Blue;
        type Shape a = Circle a | Rectangle a a | Triangle a a a;
        colors = [Red, Green, Blue];
        shapes = [Circle 3, Rectangle 5 4];
        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);
        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);
        color_numbers = map color_to_number colors;
        areas = map calculate_area shapes;
        color_numbers
      `)).not.toThrow();
        });
        (0, _globals.it)("should work when ADTs are used in separate operations", ()=>{
            const result = runNoolang(`
        type Color = Red | Green | Blue;
        type Shape a = Circle a | Rectangle a a | Triangle a a a;
        colors = [Red, Green, Blue];
        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);
        color_numbers = map color_to_number colors;
        color_numbers
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "list",
                values: [
                    {
                        tag: "number",
                        value: 1
                    },
                    {
                        tag: "number",
                        value: 2
                    },
                    {
                        tag: "number",
                        value: 3
                    }
                ]
            });
        });
        (0, _globals.it)("should work when shapes are processed separately", ()=>{
            const result = runNoolang(`
        type Color = Red | Green | Blue;
        type Shape a = Circle a | Rectangle a a | Triangle a a a;
        shapes = [Circle 3, Rectangle 5 4];
        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);
        areas = map calculate_area shapes;
        areas
      `);
            (0, _globals.expect)(result.finalValue).toEqual({
                tag: "list",
                values: [
                    {
                        tag: "number",
                        value: 27
                    },
                    {
                        tag: "number",
                        value: 20
                    }
                ]
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2UvdGVzdC9hZHQudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXNjcmliZSwgaXQsIGV4cGVjdCB9IGZyb20gXCJAamVzdC9nbG9iYWxzXCI7XG5pbXBvcnQgeyBMZXhlciB9IGZyb20gXCIuLi9zcmMvbGV4ZXJcIjtcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSBcIi4uL3NyYy9wYXJzZXIvcGFyc2VyXCI7XG5pbXBvcnQgeyBFdmFsdWF0b3IgfSBmcm9tIFwiLi4vc3JjL2V2YWx1YXRvclwiO1xuaW1wb3J0IHsgdHlwZVByb2dyYW0gfSBmcm9tICcuLi9zcmMvdHlwZXInO1xuaW1wb3J0IHsgdHlwZVRvU3RyaW5nIH0gZnJvbSAnLi4vc3JjL3R5cGVyL2hlbHBlcnMnO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gcGFyc2UgYW5kIGV2YWx1YXRlIE5vb2xhbmcgY29kZVxuY29uc3QgcnVuTm9vbGFuZyA9IChzb3VyY2U6IHN0cmluZykgPT4ge1xuICBjb25zdCBsZXhlciA9IG5ldyBMZXhlcihzb3VyY2UpO1xuICBjb25zdCB0b2tlbnMgPSBsZXhlci50b2tlbml6ZSgpO1xuICBjb25zdCBwcm9ncmFtID0gcGFyc2UodG9rZW5zKTtcblxuICAvLyBUeXBlIGNoZWNrIGZpcnN0XG4gIGNvbnN0IHR5cGVSZXN1bHQgPSB0eXBlUHJvZ3JhbShwcm9ncmFtKTtcblxuICAvLyBUaGVuIGV2YWx1YXRlXG4gIGNvbnN0IGV2YWx1YXRvciA9IG5ldyBFdmFsdWF0b3IoKTtcbiAgY29uc3QgZXZhbFJlc3VsdCA9IGV2YWx1YXRvci5ldmFsdWF0ZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlUmVzdWx0LFxuICAgIGV2YWxSZXN1bHQsXG4gICAgZmluYWxUeXBlOiB0eXBlVG9TdHJpbmcodHlwZVJlc3VsdC50eXBlLCB0eXBlUmVzdWx0LnN0YXRlLnN1YnN0aXR1dGlvbiksXG4gICAgZmluYWxWYWx1ZTogZXZhbFJlc3VsdC5maW5hbFJlc3VsdCxcbiAgfTtcbn07XG5cbmRlc2NyaWJlKFwiQWxnZWJyYWljIERhdGEgVHlwZXMgKEFEVHMpXCIsICgpID0+IHtcbiAgZGVzY3JpYmUoXCJCdWlsdC1pbiBPcHRpb24gVHlwZVwiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgY3JlYXRlIFNvbWUgdmFsdWVzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bk5vb2xhbmcoYFxuICAgICAgICB4ID0gU29tZSA0MjtcbiAgICAgICAgeFxuICAgICAgYCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZmluYWxWYWx1ZSkudG9FcXVhbCh7XG4gICAgICAgIHRhZzogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICBuYW1lOiBcIlNvbWVcIixcbiAgICAgICAgYXJnczogW3sgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogNDIgfV0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGNyZWF0ZSBOb25lIHZhbHVlc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBydW5Ob29sYW5nKGBcbiAgICAgICAgeCA9IE5vbmU7XG4gICAgICAgIHhcbiAgICAgIGApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmZpbmFsVmFsdWUpLnRvRXF1YWwoe1xuICAgICAgICB0YWc6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgbmFtZTogXCJOb25lXCIsXG4gICAgICAgIGFyZ3M6IFtdLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBwYXR0ZXJuIG1hdGNoIG9uIFNvbWVcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuTm9vbGFuZyhgXG4gICAgICAgIHggPSBTb21lIDIxO1xuICAgICAgICByZXN1bHQgPSBtYXRjaCB4IHdpdGggKFNvbWUgeSA9PiB5ICogMjsgTm9uZSA9PiAwKTtcbiAgICAgICAgcmVzdWx0XG4gICAgICBgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbFZhbHVlKS50b0VxdWFsKHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogNDIgfSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBwYXR0ZXJuIG1hdGNoIG9uIE5vbmVcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuTm9vbGFuZyhgXG4gICAgICAgIHggPSBOb25lO1xuICAgICAgICByZXN1bHQgPSBtYXRjaCB4IHdpdGggKFNvbWUgeSA9PiB5ICogMjsgTm9uZSA9PiA5OSk7XG4gICAgICAgIHJlc3VsdFxuICAgICAgYCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZmluYWxWYWx1ZSkudG9FcXVhbCh7IHRhZzogXCJudW1iZXJcIiwgdmFsdWU6IDk5IH0pO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIG5lc3RlZCBPcHRpb24gdmFsdWVzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bk5vb2xhbmcoYFxuICAgICAgICBuZXN0ZWQgPSBTb21lIChTb21lIDEwKTtcbiAgICAgICAgcmVzdWx0ID0gbWF0Y2ggbmVzdGVkIHdpdGggKFxuICAgICAgICAgIFNvbWUgaW5uZXIgPT4gbWF0Y2ggaW5uZXIgd2l0aCAoU29tZSB2YWx1ZSA9PiB2YWx1ZTsgTm9uZSA9PiAwKTtcbiAgICAgICAgICBOb25lID0+IC0xXG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdFxuICAgICAgYCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZmluYWxWYWx1ZSkudG9FcXVhbCh7IHRhZzogXCJudW1iZXJcIiwgdmFsdWU6IDEwIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkJ1aWx0LWluIFJlc3VsdCBUeXBlXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBjcmVhdGUgT2sgdmFsdWVzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bk5vb2xhbmcoYFxuICAgICAgICB4ID0gT2sgMTAwO1xuICAgICAgICB4XG4gICAgICBgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbFZhbHVlKS50b0VxdWFsKHtcbiAgICAgICAgdGFnOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgIG5hbWU6IFwiT2tcIixcbiAgICAgICAgYXJnczogW3sgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogMTAwIH1dLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBjcmVhdGUgRXJyIHZhbHVlc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBydW5Ob29sYW5nKGBcbiAgICAgICAgeCA9IEVyciBcImZhaWxlZFwiO1xuICAgICAgICB4XG4gICAgICBgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbFZhbHVlKS50b0VxdWFsKHtcbiAgICAgICAgdGFnOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgIG5hbWU6IFwiRXJyXCIsXG4gICAgICAgIGFyZ3M6IFt7IHRhZzogXCJzdHJpbmdcIiwgdmFsdWU6IFwiZmFpbGVkXCIgfV0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHBhdHRlcm4gbWF0Y2ggb24gT2tcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuTm9vbGFuZyhgXG4gICAgICAgIHggPSBPayA1MDtcbiAgICAgICAgcmVzdWx0ID0gbWF0Y2ggeCB3aXRoIChPayB2YWx1ZSA9PiB2YWx1ZSArIDEwOyBFcnIgbXNnID0+IDApO1xuICAgICAgICByZXN1bHRcbiAgICAgIGApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmZpbmFsVmFsdWUpLnRvRXF1YWwoeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiA2MCB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHBhdHRlcm4gbWF0Y2ggb24gRXJyXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bk5vb2xhbmcoYFxuICAgICAgICB4ID0gRXJyIFwib29wc1wiO1xuICAgICAgICByZXN1bHQgPSBtYXRjaCB4IHdpdGggKE9rIHZhbHVlID0+IHZhbHVlOyBFcnIgbXNnID0+IDQwNCk7XG4gICAgICAgIHJlc3VsdFxuICAgICAgYCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZmluYWxWYWx1ZSkudG9FcXVhbCh7IHRhZzogXCJudW1iZXJcIiwgdmFsdWU6IDQwNCB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJDdXN0b20gQURUIERlZmluaXRpb25zXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBkZWZpbmUgYW5kIHVzZSBhIHNpbXBsZSBBRFRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuTm9vbGFuZyhgXG4gICAgICAgIHR5cGUgQ29sb3IgPSBSZWQgfCBHcmVlbiB8IEJsdWU7XG4gICAgICAgIGZhdm9yaXRlID0gUmVkO1xuICAgICAgICBmYXZvcml0ZVxuICAgICAgYCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZmluYWxWYWx1ZSkudG9FcXVhbCh7XG4gICAgICAgIHRhZzogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICBuYW1lOiBcIlJlZFwiLFxuICAgICAgICBhcmdzOiBbXSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgZGVmaW5lIEFEVCB3aXRoIHBhcmFtZXRlcnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuTm9vbGFuZyhgXG4gICAgICAgIHR5cGUgUG9pbnQgYSA9IFBvaW50IGEgYTtcbiAgICAgICAgb3JpZ2luID0gUG9pbnQgMCAwO1xuICAgICAgICBvcmlnaW5cbiAgICAgIGApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmZpbmFsVmFsdWUpLnRvRXF1YWwoe1xuICAgICAgICB0YWc6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgbmFtZTogXCJQb2ludFwiLFxuICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAwIH0sXG4gICAgICAgICAgeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAwIH0sXG4gICAgICAgIF0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHBhdHRlcm4gbWF0Y2ggb24gY3VzdG9tIEFEVHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuTm9vbGFuZyhgXG4gICAgICAgIHR5cGUgQ29sb3IgPSBSZWQgfCBHcmVlbiB8IEJsdWU7XG4gICAgICAgIGdldENvbG9yQ29kZSA9IGZuIGNvbG9yID0+IG1hdGNoIGNvbG9yIHdpdGggKFxuICAgICAgICAgIFJlZCA9PiAxO1xuICAgICAgICAgIEdyZWVuID0+IDI7XG4gICAgICAgICAgQmx1ZSA9PiAzXG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdCA9IGdldENvbG9yQ29kZSBSZWQ7XG4gICAgICAgIHJlc3VsdFxuICAgICAgYCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZmluYWxWYWx1ZSkudG9FcXVhbCh7IHRhZzogXCJudW1iZXJcIiwgdmFsdWU6IDEgfSk7XG4gICAgfSk7XG5cbiAgICBpdC5za2lwKFwic2hvdWxkIGhhbmRsZSByZWN1cnNpdmUgQURUc1wiLCAoKSA9PiB7XG4gICAgICAvLyBTa2lwcGVkOiBSZWN1cnNpdmUgQURUcyBuZWVkIGFkZGl0aW9uYWwgdHlwZSBzeXN0ZW0gd29yayBmb3Igc2VsZi1yZWZlcmVuY2VzXG4gICAgICBjb25zdCByZXN1bHQgPSBydW5Ob29sYW5nKGBcbiAgICAgICAgdHlwZSBMaXN0IGEgPSBOaWwgfCBDb25zIGEgKExpc3QgYSk7XG4gICAgICAgIG15TGlzdCA9IENvbnMgMSAoQ29ucyAyIE5pbCk7XG4gICAgICAgIGdldEZpcnN0ID0gZm4gbGlzdCA9PiBtYXRjaCBsaXN0IHdpdGggKFxuICAgICAgICAgIE5pbCA9PiAwO1xuICAgICAgICAgIENvbnMgeCB4cyA9PiB4XG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdCA9IGdldEZpcnN0IG15TGlzdDtcbiAgICAgICAgcmVzdWx0XG4gICAgICBgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbFZhbHVlKS50b0VxdWFsKHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogMSB9KTtcbiAgICB9KTtcblxuICAgIGl0LnNraXAoXCJzaG91bGQgaGFuZGxlIGNvbXBsZXggcGF0dGVybiBtYXRjaGluZyB3aXRoIHZhcmlhYmxlc1wiLCAoKSA9PiB7XG4gICAgICAvLyBTa2lwcGVkOiBDb21wbGV4IHJlY3Vyc2l2ZSBwYXR0ZXJuIG1hdGNoaW5nIG5lZWRzIGFkZGl0aW9uYWwgd29ya1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuTm9vbGFuZyhgXG4gICAgICAgIHR5cGUgVHJlZSBhID0gTGVhZiBhIHwgQnJhbmNoIChUcmVlIGEpIChUcmVlIGEpO1xuICAgICAgICB0cmVlID0gQnJhbmNoIChMZWFmIDUpIChMZWFmIDEwKTtcbiAgICAgICAgc3VtVHJlZSA9IGZuIHQgPT4gbWF0Y2ggdCB3aXRoIChcbiAgICAgICAgICBMZWFmIHZhbHVlID0+IHZhbHVlO1xuICAgICAgICAgIEJyYW5jaCBsZWZ0IHJpZ2h0ID0+IChzdW1UcmVlIGxlZnQpICsgKHN1bVRyZWUgcmlnaHQpXG4gICAgICAgICk7XG4gICAgICAgIHJlc3VsdCA9IHN1bVRyZWUgdHJlZTtcbiAgICAgICAgcmVzdWx0XG4gICAgICBgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbFZhbHVlKS50b0VxdWFsKHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogMTUgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiUGF0dGVybiBNYXRjaGluZyBGZWF0dXJlc1wiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIHdpbGRjYXJkIHBhdHRlcm5zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bk5vb2xhbmcoYFxuICAgICAgICB0eXBlIE1heWJlIGEgPSBKdXN0IGEgfCBOb3RoaW5nO1xuICAgICAgICBnZXRWYWx1ZSA9IGZuIG1heWJlID0+IG1hdGNoIG1heWJlIHdpdGggKFxuICAgICAgICAgIEp1c3QgeCA9PiB4O1xuICAgICAgICAgIF8gPT4gNDJcbiAgICAgICAgKTtcbiAgICAgICAgcmVzdWx0ID0gZ2V0VmFsdWUgTm90aGluZztcbiAgICAgICAgcmVzdWx0XG4gICAgICBgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbFZhbHVlKS50b0VxdWFsKHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogNDIgfSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBoYW5kbGUgbGl0ZXJhbCBwYXR0ZXJuc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBydW5Ob29sYW5nKFxuICAgICAgICBgdHlwZSBTdGF0dXMgPSBTdWNjZXNzIHwgRXJyb3IgfCBDb2RlIEludDsgZ2V0U3RhdHVzTWVzc2FnZSA9IGZuIHN0YXR1cyA9PiBtYXRjaCBzdGF0dXMgd2l0aCAoU3VjY2VzcyA9PiBcIm9rXCI7IEVycm9yID0+IFwiZmFpbFwiOyBDb2RlIDQwNCA9PiBcIm5vdCBmb3VuZFwiOyBDb2RlIHggPT4gXCJ1bmtub3duIGNvZGVcIik7IHJlc3VsdCA9IGdldFN0YXR1c01lc3NhZ2UgKENvZGUgNDA0KTsgcmVzdWx0YCxcbiAgICAgICk7XG4gICAgICBleHBlY3QocmVzdWx0LmZpbmFsVmFsdWUpLnRvRXF1YWwoeyB0YWc6IFwic3RyaW5nXCIsIHZhbHVlOiBcIm5vdCBmb3VuZFwiIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIG5lc3RlZCBwYXR0ZXJuc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBydW5Ob29sYW5nKFxuICAgICAgICBgdHlwZSBXcmFwcGVyIGEgPSBXcmFwIGE7IHR5cGUgSW5uZXIgPSBWYWx1ZSBJbnQ7IG5lc3RlZCA9IFdyYXAgKFZhbHVlIDEyMyk7IGV4dHJhY3QgPSBmbiB3ID0+IG1hdGNoIHcgd2l0aCAoV3JhcCAoVmFsdWUgbikgPT4gbjsgXyA9PiAwKTsgcmVzdWx0ID0gZXh0cmFjdCBuZXN0ZWQ7IHJlc3VsdGAsXG4gICAgICApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbFZhbHVlKS50b0VxdWFsKHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogMTIzIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlR5cGUgQ2hlY2tpbmdcIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIHR5cGUgY2hlY2sgQURUIGNvbnN0cnVjdG9ycyBjb3JyZWN0bHlcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuTm9vbGFuZyhgXG4gICAgICAgIHR5cGUgT3B0aW9uIGEgPSBTb21lIGEgfCBOb25lO1xuICAgICAgICB4ID0gU29tZSA0MjtcbiAgICAgICAgeFxuICAgICAgYCk7XG5cbiAgICAgIC8vIFNob3VsZCBpbmZlciB0aGF0IHggaGFzIHR5cGUgT3B0aW9uIEludFxuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbFR5cGUpLnRvTWF0Y2goL09wdGlvbi4qSW50fHZhcmlhbnQuKk9wdGlvbi8pO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgZW5mb3JjZSBwYXR0ZXJuIGV4aGF1c3RpdmVuZXNzIChpbXBsaWNpdClcIiwgKCkgPT4ge1xuICAgICAgLy8gVGhpcyBzaG91bGQgd29yayAtIGFsbCBwYXR0ZXJucyBjb3ZlcmVkXG4gICAgICBjb25zdCByZXN1bHQgPSBydW5Ob29sYW5nKGBcbiAgICAgICAgdHlwZSBCb29sID0gVHJ1ZSB8IEZhbHNlO1xuICAgICAgICBuZWdhdGUgPSBmbiBiID0+IG1hdGNoIGIgd2l0aCAoVHJ1ZSA9PiBGYWxzZTsgRmFsc2UgPT4gVHJ1ZSk7XG4gICAgICAgIHJlc3VsdCA9IG5lZ2F0ZSBUcnVlO1xuICAgICAgICByZXN1bHRcbiAgICAgIGApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmZpbmFsVmFsdWUpLnRvRXF1YWwoe1xuICAgICAgICB0YWc6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgbmFtZTogXCJGYWxzZVwiLFxuICAgICAgICBhcmdzOiBbXSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIHBvbHltb3JwaGljIEFEVHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuTm9vbGFuZyhgXG4gICAgICAgIHR5cGUgUGFpciBhIGIgPSBQYWlyIGEgYjtcbiAgICAgICAgcCA9IFBhaXIgNDIgXCJoZWxsb1wiO1xuICAgICAgICBnZXRGaXJzdCA9IGZuIHBhaXIgPT4gbWF0Y2ggcGFpciB3aXRoIChQYWlyIHggeSA9PiB4KTtcbiAgICAgICAgcmVzdWx0ID0gZ2V0Rmlyc3QgcDtcbiAgICAgICAgcmVzdWx0XG4gICAgICBgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbFZhbHVlKS50b0VxdWFsKHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogNDIgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRXJyb3IgQ2FzZXNcIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIGVycm9yIG9uIHVua25vd24gY29uc3RydWN0b3IgaW4gcGF0dGVybnNcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgcnVuTm9vbGFuZyhgXG4gICAgICAgICAgdHlwZSBDb2xvciA9IFJlZCB8IEdyZWVuIHwgQmx1ZTtcbiAgICAgICAgICB4ID0gUmVkO1xuICAgICAgICAgIG1hdGNoIHggd2l0aCAoWWVsbG93ID0+IDE7IFJlZCA9PiAyKVxuICAgICAgICBgKTtcbiAgICAgIH0pLnRvVGhyb3coKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBwYXJ0aWFsIGNvbnN0cnVjdG9yIGFwcGxpY2F0aW9uXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bk5vb2xhbmcoYFxuICAgICAgICB0eXBlIFBvaW50ID0gUG9pbnQgSW50IEludDtcbiAgICAgICAgcCA9IFBvaW50IDE7ICAjIFBhcnRpYWwgYXBwbGljYXRpb24gLSByZXR1cm5zIChJbnQpIC0+IFBvaW50XG4gICAgICAgIHBcbiAgICAgIGApO1xuXG4gICAgICAvLyBTaG91bGQgcmV0dXJuIGEgZnVuY3Rpb24gdHlwZSBzaW5jZSBpdCdzIGEgcGFydGlhbCBhcHBsaWNhdGlvblxuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbFR5cGUpLnRvTWF0Y2goL0ludC4qUG9pbnR8ZnVuY3Rpb24vKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGVycm9yIHdoZW4gbm8gcGF0dGVybiBtYXRjaGVzXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGV2YWx1YXRvciA9IG5ldyBFdmFsdWF0b3IoKTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIHR5cGUgQ29sb3IgPSBSZWQgfCBHcmVlbiB8IEJsdWU7XG4gICAgICAgICAgeCA9IEJsdWU7XG4gICAgICAgICAgbWF0Y2ggeCB3aXRoIChSZWQgPT4gMTsgR3JlZW4gPT4gMikgICMgTWlzc2luZyBCbHVlIGNhc2VcbiAgICAgICAgYDtcbiAgICAgICAgY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoc291cmNlKTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHBhcnNlKHRva2Vucyk7XG4gICAgICAgIGV2YWx1YXRvci5ldmFsdWF0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICB9KS50b1Rocm93KFwiTm8gcGF0dGVybiBtYXRjaGVkXCIpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkludGVncmF0aW9uIHdpdGggQnVpbHQtaW4gRnVuY3Rpb25zXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCB3b3JrIHdpdGggbWFwIGFuZCBPcHRpb25cIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuTm9vbGFuZyhgXG4gICAgICAgIG9wdGlvbnMgPSBbU29tZSAxLCBOb25lLCBTb21lIDNdO1xuICAgICAgICBleHRyYWN0VmFsdWUgPSBmbiBvcHQgPT4gbWF0Y2ggb3B0IHdpdGggKFNvbWUgeCA9PiB4OyBOb25lID0+IDApO1xuICAgICAgICByZXN1bHQgPSBtYXAgZXh0cmFjdFZhbHVlIG9wdGlvbnM7XG4gICAgICAgIHJlc3VsdFxuICAgICAgYCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZmluYWxWYWx1ZSkudG9FcXVhbCh7XG4gICAgICAgIHRhZzogXCJsaXN0XCIsXG4gICAgICAgIHZhbHVlczogW1xuICAgICAgICAgIHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogMSB9LFxuICAgICAgICAgIHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogMCB9LFxuICAgICAgICAgIHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogMyB9LFxuICAgICAgICBdLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCB3b3JrIHdpdGggZmlsdGVyIGFuZCBjdXN0b20gQURUc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBydW5Ob29sYW5nKGBcbiAgICAgICAgdHlwZSBTdGF0dXMgPSBBY3RpdmUgfCBJbmFjdGl2ZTtcbiAgICAgICAgaXRlbXMgPSBbQWN0aXZlLCBJbmFjdGl2ZSwgQWN0aXZlLCBBY3RpdmVdO1xuICAgICAgICBpc0FjdGl2ZSA9IGZuIHN0YXR1cyA9PiBtYXRjaCBzdGF0dXMgd2l0aCAoQWN0aXZlID0+IFRydWU7IEluYWN0aXZlID0+IEZhbHNlKTtcbiAgICAgICAgcmVzdWx0ID0gZmlsdGVyIGlzQWN0aXZlIGl0ZW1zO1xuICAgICAgICByZXN1bHRcbiAgICAgIGApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmZpbmFsVmFsdWUudGFnKS50b0JlKFwibGlzdFwiKTtcbiAgICAgIGlmIChyZXN1bHQuZmluYWxWYWx1ZS50YWcgPT09IFwibGlzdFwiKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZmluYWxWYWx1ZS52YWx1ZXMpLnRvSGF2ZUxlbmd0aCgzKTtcbiAgICAgICAgcmVzdWx0LmZpbmFsVmFsdWUudmFsdWVzLmZvckVhY2goKGl0ZW06IGFueSkgPT4ge1xuICAgICAgICAgIGV4cGVjdChpdGVtKS50b0VxdWFsKHtcbiAgICAgICAgICAgIHRhZzogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgbmFtZTogXCJBY3RpdmVcIixcbiAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJNdWx0aXBsZSBBRFQgRGVmaW5pdGlvbnNcIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBtdWx0aXBsZSBBRFQgZGVmaW5pdGlvbnMgaW4gdGhlIHNhbWUgcHJvZ3JhbVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBydW5Ob29sYW5nKGBcbiAgICAgICAgdHlwZSBDb2xvciA9IFJlZCB8IEdyZWVuIHwgQmx1ZTtcbiAgICAgICAgdHlwZSBTaGFwZSBhID0gQ2lyY2xlIGEgfCBSZWN0YW5nbGUgYSBhIHwgVHJpYW5nbGUgYSBhIGE7XG4gICAgICAgIGNvbG9ycyA9IFtSZWQsIEdyZWVuLCBCbHVlXTtcbiAgICAgICAgc2hhcGVzID0gW0NpcmNsZSAzLCBSZWN0YW5nbGUgNSA0XTtcbiAgICAgICAgY29sb3JzXG4gICAgICBgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbFZhbHVlKS50b0VxdWFsKHtcbiAgICAgICAgdGFnOiBcImxpc3RcIixcbiAgICAgICAgdmFsdWVzOiBbXG4gICAgICAgICAgeyB0YWc6IFwiY29uc3RydWN0b3JcIiwgbmFtZTogXCJSZWRcIiwgYXJnczogW10gfSxcbiAgICAgICAgICB7IHRhZzogXCJjb25zdHJ1Y3RvclwiLCBuYW1lOiBcIkdyZWVuXCIsIGFyZ3M6IFtdIH0sXG4gICAgICAgICAgeyB0YWc6IFwiY29uc3RydWN0b3JcIiwgbmFtZTogXCJCbHVlXCIsIGFyZ3M6IFtdIH0sXG4gICAgICAgIF0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBwYXR0ZXJuIG1hdGNoaW5nIG9uIGRpZmZlcmVudCBBRFRzIHNlcGFyYXRlbHlcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuTm9vbGFuZyhgXG4gICAgICAgIHR5cGUgQ29sb3IgPSBSZWQgfCBHcmVlbiB8IEJsdWU7XG4gICAgICAgIHR5cGUgU2hhcGUgYSA9IENpcmNsZSBhIHwgUmVjdGFuZ2xlIGEgYSB8IFRyaWFuZ2xlIGEgYSBhO1xuICAgICAgICBjb2xvcl90b19udW1iZXIgPSBmbiBjb2xvciA9PiBtYXRjaCBjb2xvciB3aXRoIChSZWQgPT4gMTsgR3JlZW4gPT4gMjsgQmx1ZSA9PiAzKTtcbiAgICAgICAgY2FsY3VsYXRlX2FyZWEgPSBmbiBzaGFwZSA9PiBtYXRjaCBzaGFwZSB3aXRoIChDaXJjbGUgcmFkaXVzID0+IHJhZGl1cyAqIHJhZGl1cyAqIDM7IFJlY3RhbmdsZSB3aWR0aCBoZWlnaHQgPT4gd2lkdGggKiBoZWlnaHQ7IFRyaWFuZ2xlIGEgYiBjID0+IChhICogYikgLyAyKTtcbiAgICAgICAgY29sb3JfdG9fbnVtYmVyIFJlZFxuICAgICAgYCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZmluYWxWYWx1ZSkudG9FcXVhbCh7IHRhZzogXCJudW1iZXJcIiwgdmFsdWU6IDEgfSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBub3cgd29yayB3aXRoIG1hcCBhbmQgbXVsdGlwbGUgQURUcyAocG9seW1vcnBoaXNtIGZpeGVkKVwiLCAoKSA9PiB7XG4gICAgICAvLyBUaGlzIHRlc3Qgd2FzIHByZXZpb3VzbHkgZmFpbGluZyBkdWUgdG8gbGFjayBvZiBwb2x5bW9ycGhpc20gaW4gbWFwXG4gICAgICAvLyBOb3cgdGhhdCBtYXAgaXMgcHJvcGVybHkgcG9seW1vcnBoaWMsIGl0IHNob3VsZCB3b3JrXG4gICAgICBleHBlY3QoKCkgPT5cbiAgICAgICAgcnVuTm9vbGFuZyhgXG4gICAgICAgIHR5cGUgQ29sb3IgPSBSZWQgfCBHcmVlbiB8IEJsdWU7XG4gICAgICAgIHR5cGUgU2hhcGUgYSA9IENpcmNsZSBhIHwgUmVjdGFuZ2xlIGEgYSB8IFRyaWFuZ2xlIGEgYSBhO1xuICAgICAgICBjb2xvcnMgPSBbUmVkLCBHcmVlbiwgQmx1ZV07XG4gICAgICAgIHNoYXBlcyA9IFtDaXJjbGUgMywgUmVjdGFuZ2xlIDUgNF07XG4gICAgICAgIGNvbG9yX3RvX251bWJlciA9IGZuIGNvbG9yID0+IG1hdGNoIGNvbG9yIHdpdGggKFJlZCA9PiAxOyBHcmVlbiA9PiAyOyBCbHVlID0+IDMpO1xuICAgICAgICBjYWxjdWxhdGVfYXJlYSA9IGZuIHNoYXBlID0+IG1hdGNoIHNoYXBlIHdpdGggKENpcmNsZSByYWRpdXMgPT4gcmFkaXVzICogcmFkaXVzICogMzsgUmVjdGFuZ2xlIHdpZHRoIGhlaWdodCA9PiB3aWR0aCAqIGhlaWdodDsgVHJpYW5nbGUgYSBiIGMgPT4gKGEgKiBiKSAvIDIpO1xuICAgICAgICBjb2xvcl9udW1iZXJzID0gbWFwIGNvbG9yX3RvX251bWJlciBjb2xvcnM7XG4gICAgICAgIGFyZWFzID0gbWFwIGNhbGN1bGF0ZV9hcmVhIHNoYXBlcztcbiAgICAgICAgY29sb3JfbnVtYmVyc1xuICAgICAgYCksXG4gICAgICApLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCB3b3JrIHdoZW4gQURUcyBhcmUgdXNlZCBpbiBzZXBhcmF0ZSBvcGVyYXRpb25zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bk5vb2xhbmcoYFxuICAgICAgICB0eXBlIENvbG9yID0gUmVkIHwgR3JlZW4gfCBCbHVlO1xuICAgICAgICB0eXBlIFNoYXBlIGEgPSBDaXJjbGUgYSB8IFJlY3RhbmdsZSBhIGEgfCBUcmlhbmdsZSBhIGEgYTtcbiAgICAgICAgY29sb3JzID0gW1JlZCwgR3JlZW4sIEJsdWVdO1xuICAgICAgICBjb2xvcl90b19udW1iZXIgPSBmbiBjb2xvciA9PiBtYXRjaCBjb2xvciB3aXRoIChSZWQgPT4gMTsgR3JlZW4gPT4gMjsgQmx1ZSA9PiAzKTtcbiAgICAgICAgY29sb3JfbnVtYmVycyA9IG1hcCBjb2xvcl90b19udW1iZXIgY29sb3JzO1xuICAgICAgICBjb2xvcl9udW1iZXJzXG4gICAgICBgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbFZhbHVlKS50b0VxdWFsKHtcbiAgICAgICAgdGFnOiBcImxpc3RcIixcbiAgICAgICAgdmFsdWVzOiBbXG4gICAgICAgICAgeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAxIH0sXG4gICAgICAgICAgeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAyIH0sXG4gICAgICAgICAgeyB0YWc6IFwibnVtYmVyXCIsIHZhbHVlOiAzIH0sXG4gICAgICAgIF0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHdvcmsgd2hlbiBzaGFwZXMgYXJlIHByb2Nlc3NlZCBzZXBhcmF0ZWx5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bk5vb2xhbmcoYFxuICAgICAgICB0eXBlIENvbG9yID0gUmVkIHwgR3JlZW4gfCBCbHVlO1xuICAgICAgICB0eXBlIFNoYXBlIGEgPSBDaXJjbGUgYSB8IFJlY3RhbmdsZSBhIGEgfCBUcmlhbmdsZSBhIGEgYTtcbiAgICAgICAgc2hhcGVzID0gW0NpcmNsZSAzLCBSZWN0YW5nbGUgNSA0XTtcbiAgICAgICAgY2FsY3VsYXRlX2FyZWEgPSBmbiBzaGFwZSA9PiBtYXRjaCBzaGFwZSB3aXRoIChDaXJjbGUgcmFkaXVzID0+IHJhZGl1cyAqIHJhZGl1cyAqIDM7IFJlY3RhbmdsZSB3aWR0aCBoZWlnaHQgPT4gd2lkdGggKiBoZWlnaHQ7IFRyaWFuZ2xlIGEgYiBjID0+IChhICogYikgLyAyKTtcbiAgICAgICAgYXJlYXMgPSBtYXAgY2FsY3VsYXRlX2FyZWEgc2hhcGVzO1xuICAgICAgICBhcmVhc1xuICAgICAgYCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuZmluYWxWYWx1ZSkudG9FcXVhbCh7XG4gICAgICAgIHRhZzogXCJsaXN0XCIsXG4gICAgICAgIHZhbHVlczogW1xuICAgICAgICAgIHsgdGFnOiBcIm51bWJlclwiLCB2YWx1ZTogMjcgfSxcbiAgICAgICAgICB7IHRhZzogXCJudW1iZXJcIiwgdmFsdWU6IDIwIH0sXG4gICAgICAgIF0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJydW5Ob29sYW5nIiwic291cmNlIiwibGV4ZXIiLCJMZXhlciIsInRva2VucyIsInRva2VuaXplIiwicHJvZ3JhbSIsInBhcnNlIiwidHlwZVJlc3VsdCIsInR5cGVQcm9ncmFtIiwiZXZhbHVhdG9yIiwiRXZhbHVhdG9yIiwiZXZhbFJlc3VsdCIsImV2YWx1YXRlUHJvZ3JhbSIsImZpbmFsVHlwZSIsInR5cGVUb1N0cmluZyIsInR5cGUiLCJzdGF0ZSIsInN1YnN0aXR1dGlvbiIsImZpbmFsVmFsdWUiLCJmaW5hbFJlc3VsdCIsImRlc2NyaWJlIiwiaXQiLCJyZXN1bHQiLCJleHBlY3QiLCJ0b0VxdWFsIiwidGFnIiwibmFtZSIsImFyZ3MiLCJ2YWx1ZSIsInNraXAiLCJ0b01hdGNoIiwidG9UaHJvdyIsInZhbHVlcyIsInRvQmUiLCJ0b0hhdmVMZW5ndGgiLCJmb3JFYWNoIiwiaXRlbSIsIm5vdCJdLCJtYXBwaW5ncyI6Ijs7Ozt5QkFBcUM7dUJBQ2Y7d0JBQ0E7MkJBQ0k7dUJBQ0U7eUJBQ0M7QUFFN0IscURBQXFEO0FBQ3JELE1BQU1BLGFBQWEsQ0FBQ0M7SUFDbEIsTUFBTUMsUUFBUSxJQUFJQyxZQUFLLENBQUNGO0lBQ3hCLE1BQU1HLFNBQVNGLE1BQU1HLFFBQVE7SUFDN0IsTUFBTUMsVUFBVUMsSUFBQUEsYUFBSyxFQUFDSDtJQUV0QixtQkFBbUI7SUFDbkIs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