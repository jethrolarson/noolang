{"version":3,"sources":["/workspace/src/typer/function-application.ts"],"sourcesContent":["import {\n\ttype ApplicationExpression,\n\ttype PipelineExpression,\n\ttype Type,\n\ttype Constraint,\n\tfunctionType,\n\tisConstraint,\n} from '../ast';\nimport {\n\tfunctionApplicationError,\n\tnonFunctionApplicationError,\n\tformatTypeError,\n\tcreateTypeError,\n} from './type-errors';\nimport {\n\tgetExprLocation,\n\tthrowTypeError,\n\ttypeToString,\n\tpropagateConstraintToTypeVariable,\n} from './helpers';\nimport { \n\ttype TypeState, \n\ttype TypeResult, \n\tcreateTypeResult, \n\tunionEffects \n} from './types';\nimport { \n\tvalidateFunctionCall, \n\tareEffectsCompatible,\n\tmergeEffects \n} from './effect-validation';\nimport { satisfiesConstraint } from './constraints';\nimport { substitute } from './substitute';\nimport { unify } from './unify';\nimport { freshTypeVariable, instantiate } from './type-operations';\nimport { typeExpression } from './expression-dispatcher';\nimport { \n\ttryResolveConstraintFunction, \n\tgenerateConstraintError,\n\tdecorateEnvironmentWithConstraintFunctions \n} from './constraint-resolution';\n\n// Helper function to continue function application with a specialized constraint function\nfunction continueWithSpecializedFunction(\n\texpr: ApplicationExpression,\n\tspecializedFuncType: Type,\n\targTypes: Type[],\n\tallEffects: Set<import('../ast').Effect>,\n\tstate: TypeState\n): TypeResult {\n\tlet currentState = state;\n\t\n\tif (specializedFuncType.kind !== 'function') {\n\t\tthrowTypeError(\n\t\t\tlocation => nonFunctionApplicationError(specializedFuncType, location),\n\t\t\tgetExprLocation(expr)\n\t\t);\n\t}\n\n\tconst funcType = specializedFuncType;\n\n\t// Check argument count\n\tif (argTypes.length > funcType.params.length) {\n\t\tthrowTypeError(\n\t\t\tlocation =>\n\t\t\t\tfunctionApplicationError(\n\t\t\t\t\tfuncType.params[funcType.params.length - 1],\n\t\t\t\t\targTypes[funcType.params.length - 1],\n\t\t\t\t\tfuncType.params.length - 1,\n\t\t\t\t\tundefined,\n\t\t\t\t\tlocation\n\t\t\t\t),\n\t\t\tgetExprLocation(expr)\n\t\t);\n\t}\n\n\t// Unify each argument with the corresponding parameter type\n\tfor (let i = 0; i < argTypes.length; i++) {\n\t\tcurrentState = unify(\n\t\t\tfuncType.params[i],\n\t\t\targTypes[i],\n\t\t\tcurrentState,\n\t\t\tgetExprLocation(expr),\n\t\t\t{\n\t\t\t\treason: 'constraint_function_application',\n\t\t\t\toperation: `applying argument ${i + 1}`,\n\t\t\t\thint: `Argument ${i + 1} has type ${typeToString(\n\t\t\t\t\targTypes[i],\n\t\t\t\t\tcurrentState.substitution\n\t\t\t\t)} but the constraint function expects ${typeToString(\n\t\t\t\t\tfuncType.params[i],\n\t\t\t\t\tcurrentState.substitution\n\t\t\t\t)}.`,\n\t\t\t}\n\t\t);\n\t}\n\n\t// Determine the result type\n\tlet resultType = funcType.return;\n\t\n\t// If not all arguments were provided, create a partial application\n\tif (argTypes.length < funcType.params.length) {\n\t\tconst remainingParams = funcType.params.slice(argTypes.length);\n\t\tresultType = functionType(remainingParams, funcType.return, funcType.effects);\n\t}\n\n\t// Merge effects from function type and arguments\n\tconst finalEffects = unionEffects(allEffects, funcType.effects);\n\n\treturn createTypeResult(resultType, finalEffects, currentState);\n}\n\n// Comprehensive constraint validation\nexport const validateConstraints = (\n\ttype: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState => {\n\tlet currentState = state;\n\n\t// Apply substitution to get the concrete type\n\tconst substitutedType = substitute(type, state.substitution);\n\n\t// If it's a type variable with constraints, check them\n\tif (substitutedType.kind === 'variable' && substitutedType.constraints) {\n\t\tfor (const constraint of substitutedType.constraints) {\n\t\t\t// currentState = solveConstraint(constraint, currentState, location);\n\t\t}\n\t}\n\n\t// If it's a function type, check constraints on parameters and return type\n\tif (substitutedType.kind === 'function') {\n\t\t// Check constraints on parameters\n\t\tfor (const param of substitutedType.params) {\n\t\t\tcurrentState = validateConstraints(param, currentState, location);\n\t\t}\n\n\t\t// Check constraints on return type\n\t\tcurrentState = validateConstraints(\n\t\t\tsubstitutedType.return,\n\t\t\tcurrentState,\n\t\t\tlocation\n\t\t);\n\n\t\t// Check function-level constraints\n\t\tif (substitutedType.constraints) {\n\t\t\t// currentState = solveConstraints(\n\t\t\t// \tsubstitutedType.constraints,\n\t\t\t// \tcurrentState,\n\t\t\t// \tlocation\n\t\t\t// );\n\t\t}\n\t}\n\n\t// If it's a list type, check constraints on element type\n\tif (substitutedType.kind === 'list') {\n\t\tcurrentState = validateConstraints(\n\t\t\tsubstitutedType.element,\n\t\t\tcurrentState,\n\t\t\tlocation\n\t\t);\n\t}\n\n\t// If it's a record type, check constraints on field types\n\tif (substitutedType.kind === 'record') {\n\t\tfor (const fieldType of Object.values(substitutedType.fields)) {\n\t\t\tcurrentState = validateConstraints(fieldType, currentState, location);\n\t\t}\n\t}\n\n\treturn currentState;\n};\n\n// Update typeApplication to thread state through freshenTypeVariables\nexport const typeApplication = (\n\texpr: ApplicationExpression,\n\tstate: TypeState\n): TypeResult => {\n\tlet currentState = state;\n\n\t// Type the function\n\tconst funcResult = typeExpression(expr.func, currentState);\n\tcurrentState = funcResult.state;\n\tconst funcType = funcResult.type;\n\n\t// Type each argument and collect effects\n\tconst argTypes: Type[] = [];\n\tlet allEffects = funcResult.effects;\n\tfor (const arg of expr.args) {\n\t\tconst argResult = typeExpression(arg, currentState);\n\t\targTypes.push(argResult.type);\n\t\tcurrentState = argResult.state;\n\t\tallEffects = unionEffects(allEffects, argResult.effects);\n\t}\n\n\t// Check if this is a constraint function call that needs resolution\n\t// ONLY apply to functions that are explicitly defined in constraints\n\tif (expr.func.kind === 'variable' && currentState.constraintRegistry.size > 0) {\n\t\t// Only check constraint resolution if the function is explicitly in a constraint\n\t\tlet isDefinedInConstraint = false;\n\t\tfor (const [, constraintInfo] of currentState.constraintRegistry) {\n\t\t\tif (constraintInfo.signature.functions.has(expr.func.name)) {\n\t\t\t\tisDefinedInConstraint = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// ONLY apply constraint resolution to explicitly defined constraint functions\n\t\t// This excludes ADT constructors like Point, Rectangle, etc.\n\t\tif (isDefinedInConstraint) {\n\t\t\tconst constraintResolution = tryResolveConstraintFunction(\n\t\t\t\texpr.func.name,\n\t\t\t\texpr.args,\n\t\t\t\targTypes,\n\t\t\t\tcurrentState\n\t\t\t);\n\t\t\t\n\t\t\tif (constraintResolution.resolved && constraintResolution.specializedName) {\n\t\t\t\t// This is a constraint function call with a concrete resolution\n\t\t\t\t// Look up the specialized function in the environment\n\t\t\t\tconst decoratedState = decorateEnvironmentWithConstraintFunctions(currentState);\n\t\t\t\tconst specializedScheme = decoratedState.environment.get(constraintResolution.specializedName);\n\t\t\t\t\n\t\t\t\tif (specializedScheme) {\n\t\t\t\t\t// Use the specialized implementation\n\t\t\t\t\tconst [instantiatedType, newState] = instantiate(specializedScheme, decoratedState);\n\t\t\t\t\t\n\t\t\t\t\t// The specialized function should match the call pattern\n\t\t\t\t\tif (instantiatedType.kind === 'function') {\n\t\t\t\t\t\t// Continue with normal function application using the specialized type\n\t\t\t\t\t\tconst specializedFuncType = instantiatedType;\n\t\t\t\t\t\t// Replace funcType with specializedFuncType for the rest of the function\n\t\t\t\t\t\treturn continueWithSpecializedFunction(\n\t\t\t\t\t\t\texpr, \n\t\t\t\t\t\t\tspecializedFuncType, \n\t\t\t\t\t\t\targTypes, \n\t\t\t\t\t\t\tallEffects, \n\t\t\t\t\t\t\tnewState\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Could not resolve - generate helpful error\n\t\t\t\t\tconst firstArgType = argTypes.length > 0 ? substitute(argTypes[0], currentState.substitution) : null;\n\t\t\t\t\tif (firstArgType && firstArgType.kind !== 'variable') {\n\t\t\t\t\t\t// We have a concrete type but no implementation\n\t\t\t\t\t\tconst errorMessage = generateConstraintError(\n\t\t\t\t\t\t\texpr.func.name, // This should be parsed differently, but for now using function name\n\t\t\t\t\t\t\texpr.func.name,\n\t\t\t\t\t\t\tfirstArgType,\n\t\t\t\t\t\t\tcurrentState\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthrow new Error(errorMessage);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Handle function application by checking if funcType is a function\n\tif (funcType.kind === 'function') {\n\t\tif (argTypes.length > funcType.params.length) {\n\t\t\tthrowTypeError(\n\t\t\t\tlocation =>\n\t\t\t\t\tfunctionApplicationError(\n\t\t\t\t\t\tfuncType.params[funcType.params.length - 1],\n\t\t\t\t\t\targTypes[funcType.params.length - 1],\n\t\t\t\t\t\tfuncType.params.length - 1,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tlocation\n\t\t\t\t\t),\n\t\t\t\tgetExprLocation(expr)\n\t\t\t);\n\t\t}\n\n\t\t// Unify each argument with the corresponding parameter type\n\t\tfor (let i = 0; i < argTypes.length; i++) {\n\t\t\tcurrentState = unify(\n\t\t\t\tfuncType.params[i],\n\t\t\t\targTypes[i],\n\t\t\t\tcurrentState,\n\t\t\t\tgetExprLocation(expr),\n\t\t\t\t{\n\t\t\t\t\treason: 'function_application',\n\t\t\t\t\toperation: `applying argument ${i + 1}`,\n\t\t\t\t\thint: `Argument ${i + 1} has type ${typeToString(\n\t\t\t\t\t\targTypes[i],\n\t\t\t\t\t\tcurrentState.substitution\n\t\t\t\t\t)} but the function parameter expects ${typeToString(\n\t\t\t\t\t\tfuncType.params[i],\n\t\t\t\t\t\tcurrentState.substitution\n\t\t\t\t\t)}.`,\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// After unification, validate constraints on the parameter\n\t\t\tconst substitutedParam = substitute(\n\t\t\t\tfuncType.params[i],\n\t\t\t\tcurrentState.substitution\n\t\t\t);\n\n\t\t\t// Check if the parameter has constraints that need to be validated\n\t\t\tif (\n\t\t\t\tsubstitutedParam.kind === 'variable' &&\n\t\t\t\tsubstitutedParam.constraints\n\t\t\t) {\n\t\t\t\t// Validate each constraint\n\t\t\t\tfor (const constraint of substitutedParam.constraints) {\n\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t// Check if the type variable has been unified to a concrete type\n\t\t\t\t\t\tconst concreteType = currentState.substitution.get(\n\t\t\t\t\t\t\tconstraint.typeVar\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (concreteType && concreteType.kind !== 'variable') {\n\t\t\t\t\t\t\t// The type variable has been unified to a concrete type, validate the constraint\n\t\t\t\t\t\t\tif (!satisfiesConstraint(concreteType, constraint.constraint)) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\tformatTypeError(\n\t\t\t\t\t\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t\t\t\t\t\t`Type ${typeToString(\n\t\t\t\t\t\t\t\t\t\t\t\tconcreteType,\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentState.substitution\n\t\t\t\t\t\t\t\t\t\t\t)} does not satisfy constraint '${\n\t\t\t\t\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t\t\t\t\t}'`,\n\t\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tline: expr.location?.start.line || 1,\n\t\t\t\t\t\t\t\t\t\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Also validate constraints on the argument type\n\t\t\tconst substitutedArg = substitute(argTypes[i], currentState.substitution);\n\t\t\tif (substitutedArg.kind === 'variable' && substitutedArg.constraints) {\n\t\t\t\tfor (const constraint of substitutedArg.constraints) {\n\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\tconst concreteType = currentState.substitution.get(\n\t\t\t\t\t\t\tconstraint.typeVar\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (concreteType && concreteType.kind !== 'variable') {\n\t\t\t\t\t\t\tif (!satisfiesConstraint(concreteType, constraint.constraint)) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\tformatTypeError(\n\t\t\t\t\t\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t\t\t\t\t\t`Type ${typeToString(\n\t\t\t\t\t\t\t\t\t\t\t\tconcreteType,\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentState.substitution\n\t\t\t\t\t\t\t\t\t\t\t)} does not satisfy constraint '${\n\t\t\t\t\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t\t\t\t\t}'`,\n\t\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tline: expr.location?.start.line || 1,\n\t\t\t\t\t\t\t\t\t\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// CRITICAL: Also check if the argument type itself satisfies constraints\n\t\t\t// This is needed for cases where the argument is a concrete type that should satisfy constraints\n\t\t\tif (substitutedArg.kind !== 'variable') {\n\t\t\t\t// Check if the parameter has constraints that the argument should satisfy\n\t\t\t\tif (\n\t\t\t\t\tsubstitutedParam.kind === 'variable' &&\n\t\t\t\t\tsubstitutedParam.constraints\n\t\t\t\t) {\n\t\t\t\t\tfor (const constraint of substitutedParam.constraints) {\n\t\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t\tif (!satisfiesConstraint(substitutedArg, constraint.constraint)) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\tformatTypeError(\n\t\t\t\t\t\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t\t\t\t\t\t`Type ${typeToString(\n\t\t\t\t\t\t\t\t\t\t\t\tsubstitutedArg,\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentState.substitution\n\t\t\t\t\t\t\t\t\t\t\t)} does not satisfy constraint '${\n\t\t\t\t\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t\t\t\t\t}'`,\n\t\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tline: expr.location?.start.line || 1,\n\t\t\t\t\t\t\t\t\t\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Apply substitution to get the return type\n\t\tconst returnType = substitute(funcType.return, currentState.substitution);\n\n\t\t// Validate constraints on the return type\n\t\tcurrentState = validateConstraints(returnType, currentState, {\n\t\t\tline: expr.location?.start.line || 1,\n\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t});\n\n\t\t// Phase 3: Add effect validation for function calls\n\t\t// Add function's effects to the collected effects\n\t\tallEffects = unionEffects(allEffects, funcType.effects);\n\n\t\tif (argTypes.length === funcType.params.length) {\n\t\t\t// Full application - return the return type\n\n\t\t\t// CRITICAL FIX: Handle function composition constraint propagation\n\t\t\tlet finalReturnType = returnType;\n\n\t\t\t// Case 1: Direct compose function call\n\t\t\tif (\n\t\t\t\texpr.func.kind === 'variable' &&\n\t\t\t\texpr.func.name === 'compose' &&\n\t\t\t\texpr.args.length >= 1\n\t\t\t) {\n\t\t\t\tconst fArg = expr.args[0]; // First function (f in \"compose f g\")\n\t\t\t\tconst fResult = typeExpression(fArg, currentState);\n\n\t\t\t\t// If f has constraints and returnType is a function, propagate the constraints\n\t\t\t\tif (\n\t\t\t\t\tfResult.type.kind === 'function' &&\n\t\t\t\t\tfResult.type.constraints &&\n\t\t\t\t\treturnType.kind === 'function'\n\t\t\t\t) {\n\t\t\t\t\tconst enhancedReturnType = { ...returnType };\n\n\t\t\t\t\t// Map constraint variables from f's type to the new function's type variables\n\t\t\t\t\tconst updatedConstraints: Constraint[] = [];\n\t\t\t\t\tfor (const constraint of fResult.type.constraints) {\n\t\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t\t// Find the corresponding parameter in the new function\n\t\t\t\t\t\t\t// The first parameter of the composed function should inherit f's parameter constraints\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tenhancedReturnType.params.length > 0 &&\n\t\t\t\t\t\t\t\tenhancedReturnType.params[0].kind === 'variable'\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst newConstraint = isConstraint(\n\t\t\t\t\t\t\t\t\tenhancedReturnType.params[0].name,\n\t\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tupdatedConstraints.push(newConstraint);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For non-\"is\" constraints, copy as-is for now\n\t\t\t\t\t\t\tupdatedConstraints.push(constraint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tenhancedReturnType.constraints = (\n\t\t\t\t\t\tenhancedReturnType.constraints || []\n\t\t\t\t\t).concat(updatedConstraints);\n\n\t\t\t\t\t// Also propagate constraints to parameter type variables in the result function\n\t\t\t\t\tfor (const constraint of updatedConstraints) {\n\t\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t\tpropagateConstraintToTypeVariable(enhancedReturnType, constraint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfinalReturnType = enhancedReturnType;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Case 2: Application to result of compose (e.g., (compose head) id)\n\t\t\telse if (\n\t\t\t\texpr.func.kind === 'application' &&\n\t\t\t\texpr.func.func.kind === 'variable' &&\n\t\t\t\texpr.func.func.name === 'compose' &&\n\t\t\t\texpr.func.args.length >= 1\n\t\t\t) {\n\t\t\t\t// This is applying the second argument to a partial compose result\n\t\t\t\tconst fArg = expr.func.args[0]; // First function from the compose\n\t\t\t\tconst fResult = typeExpression(fArg, currentState);\n\n\t\t\t\tif (\n\t\t\t\t\tfResult.type.kind === 'function' &&\n\t\t\t\t\tfResult.type.constraints &&\n\t\t\t\t\treturnType.kind === 'function'\n\t\t\t\t) {\n\t\t\t\t\tconst enhancedReturnType = { ...returnType };\n\n\t\t\t\t\t// Map constraint variables from f's type to the new function's type variables\n\t\t\t\t\tconst updatedConstraints: Constraint[] = [];\n\t\t\t\t\tfor (const constraint of fResult.type.constraints) {\n\t\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t\t// Find the corresponding parameter in the new function\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tenhancedReturnType.params.length > 0 &&\n\t\t\t\t\t\t\t\tenhancedReturnType.params[0].kind === 'variable'\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst newConstraint = isConstraint(\n\t\t\t\t\t\t\t\t\tenhancedReturnType.params[0].name,\n\t\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tupdatedConstraints.push(newConstraint);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdatedConstraints.push(constraint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tenhancedReturnType.constraints = (\n\t\t\t\t\t\tenhancedReturnType.constraints || []\n\t\t\t\t\t).concat(updatedConstraints);\n\n\t\t\t\t\tfor (const constraint of updatedConstraints) {\n\t\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t\tpropagateConstraintToTypeVariable(enhancedReturnType, constraint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfinalReturnType = enhancedReturnType;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn createTypeResult(finalReturnType, allEffects, currentState);\n\t\t} else {\n\t\t\t// Partial application - return a function with remaining parameters\n\t\t\tconst remainingParams = funcType.params.slice(argTypes.length);\n\t\t\tconst partialFunctionType = functionType(remainingParams, returnType, funcType.effects);\n\n\t\t\t// CRITICAL FIX: Handle partial application of compose\n\t\t\tif (\n\t\t\t\texpr.func.kind === 'variable' &&\n\t\t\t\texpr.func.name === 'compose' &&\n\t\t\t\texpr.args.length >= 1\n\t\t\t) {\n\t\t\t\tconst fArg = expr.args[0]; // First function\n\t\t\t\tconst fResult = typeExpression(fArg, currentState);\n\n\t\t\t\t// If f has constraints, the partial result should eventually inherit them\n\t\t\t\tif (\n\t\t\t\t\tfResult.type.kind === 'function' &&\n\t\t\t\t\tfResult.type.constraints &&\n\t\t\t\t\tpartialFunctionType.kind === 'function'\n\t\t\t\t) {\n\t\t\t\t\tpartialFunctionType.constraints = (\n\t\t\t\t\t\tpartialFunctionType.constraints || []\n\t\t\t\t\t).concat(fResult.type.constraints);\n\n\t\t\t\t\tfor (const constraint of fResult.type.constraints) {\n\t\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t\tpropagateConstraintToTypeVariable(\n\t\t\t\t\t\t\t\tpartialFunctionType,\n\t\t\t\t\t\t\t\tconstraint\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn createTypeResult(partialFunctionType, allEffects, currentState);\n\t\t}\n\t} else if (funcType.kind === 'variable') {\n\t\t// If it's a type variable, create a function type and unify\n\t\tif (argTypes.length === 0) {\n\t\t\treturn createTypeResult(funcType, allEffects, currentState);\n\t\t}\n\n\t\tconst [paramType, newState] = freshTypeVariable(currentState);\n\t\tcurrentState = newState;\n\t\tconst [returnType, finalState] = freshTypeVariable(currentState);\n\t\tcurrentState = finalState;\n\n\t\tconst freshFunctionType = functionType([paramType], returnType);\n\t\tcurrentState = unify(funcType, freshFunctionType, currentState, {\n\t\t\tline: expr.location?.start.line || 1,\n\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t});\n\t\tcurrentState = unify(paramType, argTypes[0], currentState, {\n\t\t\tline: expr.location?.start.line || 1,\n\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t});\n\n\t\treturn createTypeResult(\n\t\t\tsubstitute(returnType, currentState.substitution),\n\t\t\tallEffects,\n\t\t\tcurrentState\n\t\t);\n\t} else {\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tnonFunctionApplicationError(funcType, {\n\t\t\t\t\tline: expr.location?.start.line || 1,\n\t\t\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t\t\t})\n\t\t\t)\n\t\t);\n\t}\n};\n\n// Type inference for pipeline expressions\nexport const typePipeline = (\n\texpr: PipelineExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// Pipeline should be function composition, not function application\n\t// For a pipeline like f |> g |> h, we want to compose them as h(g(f(x)))\n\n\tif (expr.steps.length === 1) {\n\t\treturn typeExpression(expr.steps[0], state);\n\t}\n\n\t// Start with the first function type\n\tlet currentState = state;\n\tlet composedType = typeExpression(expr.steps[0], currentState);\n\tcurrentState = composedType.state;\n\tlet allEffects = composedType.effects;\n\n\t// Compose with each subsequent function type\n\tfor (let i = 1; i < expr.steps.length; i++) {\n\t\tconst nextFuncType = typeExpression(expr.steps[i], currentState);\n\t\tcurrentState = nextFuncType.state;\n\t\tallEffects = unionEffects(allEffects, nextFuncType.effects);\n\n\t\tif (\n\t\t\tcomposedType.type.kind === 'function' &&\n\t\t\tnextFuncType.type.kind === 'function'\n\t\t) {\n\t\t\t// Check that the output of composedType matches the input of nextFuncType\n\t\t\tif (nextFuncType.type.params.length !== 1) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tformatTypeError(\n\t\t\t\t\t\tfunctionApplicationError(\n\t\t\t\t\t\t\tnextFuncType.type.params[0],\n\t\t\t\t\t\t\tnextFuncType.type,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tline: expr.location?.start.line || 1,\n\t\t\t\t\t\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcurrentState = unify(\n\t\t\t\tcomposedType.type.return,\n\t\t\t\tnextFuncType.type.params[0],\n\t\t\t\tcurrentState,\n\t\t\t\t{\n\t\t\t\t\tline: expr.location?.start.line || 1,\n\t\t\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// The composed function takes the input of the first function and returns the output of the last function\n\t\t\tcomposedType = createTypeResult(\n\t\t\t\tfunctionType(\n\t\t\t\t\t[composedType.type.params[0]],\n\t\t\t\t\tnextFuncType.type.return\n\t\t\t\t),\n\t\t\t\tallEffects,\n\t\t\t\tcurrentState\n\t\t\t);\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot compose non-function types in pipeline: ${typeToString(\n\t\t\t\t\tcomposedType.type\n\t\t\t\t)} and ${typeToString(nextFuncType.type)}`\n\t\t\t);\n\t\t}\n\t}\n\n\treturn createTypeResult(\n\t\tsubstitute(composedType.type, currentState.substitution),\n\t\tallEffects,\n\t\tcurrentState\n\t);\n};"],"names":["typeApplication","typePipeline","validateConstraints","continueWithSpecializedFunction","expr","specializedFuncType","argTypes","allEffects","state","currentState","kind","throwTypeError","location","nonFunctionApplicationError","getExprLocation","funcType","length","params","functionApplicationError","undefined","i","unify","reason","operation","hint","typeToString","substitution","resultType","return","remainingParams","slice","functionType","effects","finalEffects","unionEffects","createTypeResult","type","substitutedType","substitute","constraints","constraint","param","element","fieldType","Object","values","fields","funcResult","typeExpression","func","arg","args","argResult","push","constraintRegistry","size","isDefinedInConstraint","constraintInfo","signature","functions","has","name","constraintResolution","tryResolveConstraintFunction","resolved","specializedName","decoratedState","decorateEnvironmentWithConstraintFunctions","specializedScheme","environment","get","instantiatedType","newState","instantiate","firstArgType","errorMessage","generateConstraintError","Error","substitutedParam","concreteType","typeVar","satisfiesConstraint","formatTypeError","createTypeError","line","start","column","substitutedArg","returnType","finalReturnType","fArg","fResult","enhancedReturnType","updatedConstraints","newConstraint","isConstraint","concat","propagateConstraintToTypeVariable","partialFunctionType","paramType","freshTypeVariable","finalState","freshFunctionType","steps","composedType","nextFuncType"],"mappings":"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"}