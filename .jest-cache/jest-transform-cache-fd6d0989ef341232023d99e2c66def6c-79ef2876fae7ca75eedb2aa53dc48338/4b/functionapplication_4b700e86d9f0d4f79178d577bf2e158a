db457755a3773df997377fb94f51744d
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get typeApplication () {
        return typeApplication;
    },
    get typePipeline () {
        return typePipeline;
    },
    get validateConstraints () {
        return validateConstraints;
    }
});
const _ast = require("../ast");
const _typeerrors = require("./type-errors");
const _helpers = require("./helpers");
const _types = require("./types");
const _constraints = require("./constraints");
const _substitute = require("./substitute");
const _unify = require("./unify");
const _typeoperations = require("./type-operations");
const _expressiondispatcher = require("./expression-dispatcher");
const _constraintresolution = require("./constraint-resolution");
// Helper function to continue function application with a specialized constraint function
function continueWithSpecializedFunction(expr, specializedFuncType, argTypes, allEffects, state) {
    let currentState = state;
    if (specializedFuncType.kind !== 'function') {
        (0, _helpers.throwTypeError)((location)=>(0, _typeerrors.nonFunctionApplicationError)(specializedFuncType, location), (0, _helpers.getExprLocation)(expr));
    }
    const funcType = specializedFuncType;
    // Check argument count
    if (argTypes.length > funcType.params.length) {
        (0, _helpers.throwTypeError)((location)=>(0, _typeerrors.functionApplicationError)(funcType.params[funcType.params.length - 1], argTypes[funcType.params.length - 1], funcType.params.length - 1, undefined, location), (0, _helpers.getExprLocation)(expr));
    }
    // Unify each argument with the corresponding parameter type
    for(let i = 0; i < argTypes.length; i++){
        currentState = (0, _unify.unify)(funcType.params[i], argTypes[i], currentState, (0, _helpers.getExprLocation)(expr), {
            reason: 'constraint_function_application',
            operation: `applying argument ${i + 1}`,
            hint: `Argument ${i + 1} has type ${(0, _helpers.typeToString)(argTypes[i], currentState.substitution)} but the constraint function expects ${(0, _helpers.typeToString)(funcType.params[i], currentState.substitution)}.`
        });
    }
    // Determine the result type
    let resultType = funcType.return;
    // If not all arguments were provided, create a partial application
    if (argTypes.length < funcType.params.length) {
        const remainingParams = funcType.params.slice(argTypes.length);
        resultType = (0, _ast.functionType)(remainingParams, funcType.return, funcType.effects);
    }
    // Merge effects from function type and arguments
    const finalEffects = (0, _types.unionEffects)(allEffects, funcType.effects);
    return (0, _types.createTypeResult)(resultType, finalEffects, currentState);
}
const validateConstraints = (type, state, location)=>{
    let currentState = state;
    // Apply substitution to get the concrete type
    const substitutedType = (0, _substitute.substitute)(type, state.substitution);
    // If it's a type variable with constraints, check them
    if (substitutedType.kind === 'variable' && substitutedType.constraints) {
        for (const constraint of substitutedType.constraints){
        // currentState = solveConstraint(constraint, currentState, location);
        }
    }
    // If it's a function type, check constraints on parameters and return type
    if (substitutedType.kind === 'function') {
        // Check constraints on parameters
        for (const param of substitutedType.params){
            currentState = validateConstraints(param, currentState, location);
        }
        // Check constraints on return type
        currentState = validateConstraints(substitutedType.return, currentState, location);
        // Check function-level constraints
        if (substitutedType.constraints) {
        // currentState = solveConstraints(
        // 	substitutedType.constraints,
        // 	currentState,
        // 	location
        // );
        }
    }
    // If it's a list type, check constraints on element type
    if (substitutedType.kind === 'list') {
        currentState = validateConstraints(substitutedType.element, currentState, location);
    }
    // If it's a record type, check constraints on field types
    if (substitutedType.kind === 'record') {
        for (const fieldType of Object.values(substitutedType.fields)){
            currentState = validateConstraints(fieldType, currentState, location);
        }
    }
    return currentState;
};
const typeApplication = (expr, state)=>{
    let currentState = state;
    // Type the function
    const funcResult = (0, _expressiondispatcher.typeExpression)(expr.func, currentState);
    currentState = funcResult.state;
    const funcType = funcResult.type;
    // Type each argument and collect effects
    const argTypes = [];
    let allEffects = funcResult.effects;
    for (const arg of expr.args){
        const argResult = (0, _expressiondispatcher.typeExpression)(arg, currentState);
        argTypes.push(argResult.type);
        currentState = argResult.state;
        allEffects = (0, _types.unionEffects)(allEffects, argResult.effects);
    }
    // Check if this is a constraint function call that needs resolution
    // ONLY apply to functions that are explicitly defined in constraints
    if (expr.func.kind === 'variable' && currentState.constraintRegistry.size > 0) {
        // Only check constraint resolution if the function is explicitly in a constraint
        let isDefinedInConstraint = false;
        for (const [, constraintInfo] of currentState.constraintRegistry){
            if (constraintInfo.signature.functions.has(expr.func.name)) {
                isDefinedInConstraint = true;
                break;
            }
        }
        // ONLY apply constraint resolution to explicitly defined constraint functions
        // This excludes ADT constructors like Point, Rectangle, etc.
        if (isDefinedInConstraint) {
            const constraintResolution = (0, _constraintresolution.tryResolveConstraintFunction)(expr.func.name, expr.args, argTypes, currentState);
            if (constraintResolution.resolved && constraintResolution.specializedName) {
                // This is a constraint function call with a concrete resolution
                // Look up the specialized function in the environment
                const decoratedState = (0, _constraintresolution.decorateEnvironmentWithConstraintFunctions)(currentState);
                const specializedScheme = decoratedState.environment.get(constraintResolution.specializedName);
                if (specializedScheme) {
                    // Use the specialized implementation
                    const [instantiatedType, newState] = (0, _typeoperations.instantiate)(specializedScheme, decoratedState);
                    // The specialized function should match the call pattern
                    if (instantiatedType.kind === 'function') {
                        // Continue with normal function application using the specialized type
                        const specializedFuncType = instantiatedType;
                        // Replace funcType with specializedFuncType for the rest of the function
                        return continueWithSpecializedFunction(expr, specializedFuncType, argTypes, allEffects, newState);
                    }
                } else {
                    // Could not resolve - generate helpful error
                    const firstArgType = argTypes.length > 0 ? (0, _substitute.substitute)(argTypes[0], currentState.substitution) : null;
                    if (firstArgType && firstArgType.kind !== 'variable') {
                        // We have a concrete type but no implementation
                        const errorMessage = (0, _constraintresolution.generateConstraintError)(expr.func.name, expr.func.name, firstArgType, currentState);
                        throw new Error(errorMessage);
                    }
                }
            }
        }
    }
    // Handle function application by checking if funcType is a function
    if (funcType.kind === 'function') {
        if (argTypes.length > funcType.params.length) {
            (0, _helpers.throwTypeError)((location)=>(0, _typeerrors.functionApplicationError)(funcType.params[funcType.params.length - 1], argTypes[funcType.params.length - 1], funcType.params.length - 1, undefined, location), (0, _helpers.getExprLocation)(expr));
        }
        // Unify each argument with the corresponding parameter type
        for(let i = 0; i < argTypes.length; i++){
            currentState = (0, _unify.unify)(funcType.params[i], argTypes[i], currentState, (0, _helpers.getExprLocation)(expr), {
                reason: 'function_application',
                operation: `applying argument ${i + 1}`,
                hint: `Argument ${i + 1} has type ${(0, _helpers.typeToString)(argTypes[i], currentState.substitution)} but the function parameter expects ${(0, _helpers.typeToString)(funcType.params[i], currentState.substitution)}.`
            });
            // After unification, validate constraints on the parameter
            const substitutedParam = (0, _substitute.substitute)(funcType.params[i], currentState.substitution);
            // Check if the parameter has constraints that need to be validated
            if (substitutedParam.kind === 'variable' && substitutedParam.constraints) {
                // Validate each constraint
                for (const constraint of substitutedParam.constraints){
                    if (constraint.kind === 'is') {
                        // Check if the type variable has been unified to a concrete type
                        const concreteType = currentState.substitution.get(constraint.typeVar);
                        if (concreteType && concreteType.kind !== 'variable') {
                            // The type variable has been unified to a concrete type, validate the constraint
                            if (!(0, _constraints.satisfiesConstraint)(concreteType, constraint.constraint)) {
                                throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.createTypeError)(`Type ${(0, _helpers.typeToString)(concreteType, currentState.substitution)} does not satisfy constraint '${constraint.constraint}'`, {}, {
                                    line: expr.location?.start.line || 1,
                                    column: expr.location?.start.column || 1
                                })));
                            }
                        }
                    }
                }
            }
            // Also validate constraints on the argument type
            const substitutedArg = (0, _substitute.substitute)(argTypes[i], currentState.substitution);
            if (substitutedArg.kind === 'variable' && substitutedArg.constraints) {
                for (const constraint of substitutedArg.constraints){
                    if (constraint.kind === 'is') {
                        const concreteType = currentState.substitution.get(constraint.typeVar);
                        if (concreteType && concreteType.kind !== 'variable') {
                            if (!(0, _constraints.satisfiesConstraint)(concreteType, constraint.constraint)) {
                                throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.createTypeError)(`Type ${(0, _helpers.typeToString)(concreteType, currentState.substitution)} does not satisfy constraint '${constraint.constraint}'`, {}, {
                                    line: expr.location?.start.line || 1,
                                    column: expr.location?.start.column || 1
                                })));
                            }
                        }
                    }
                }
            }
            // CRITICAL: Also check if the argument type itself satisfies constraints
            // This is needed for cases where the argument is a concrete type that should satisfy constraints
            if (substitutedArg.kind !== 'variable') {
                // Check if the parameter has constraints that the argument should satisfy
                if (substitutedParam.kind === 'variable' && substitutedParam.constraints) {
                    for (const constraint of substitutedParam.constraints){
                        if (constraint.kind === 'is') {
                            if (!(0, _constraints.satisfiesConstraint)(substitutedArg, constraint.constraint)) {
                                throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.createTypeError)(`Type ${(0, _helpers.typeToString)(substitutedArg, currentState.substitution)} does not satisfy constraint '${constraint.constraint}'`, {}, {
                                    line: expr.location?.start.line || 1,
                                    column: expr.location?.start.column || 1
                                })));
                            }
                        }
                    }
                }
            }
        }
        // Apply substitution to get the return type
        const returnType = (0, _substitute.substitute)(funcType.return, currentState.substitution);
        // Validate constraints on the return type
        currentState = validateConstraints(returnType, currentState, {
            line: expr.location?.start.line || 1,
            column: expr.location?.start.column || 1
        });
        // Phase 3: Add effect validation for function calls
        // Add function's effects to the collected effects
        allEffects = (0, _types.unionEffects)(allEffects, funcType.effects);
        if (argTypes.length === funcType.params.length) {
            // Full application - return the return type
            // CRITICAL FIX: Handle function composition constraint propagation
            let finalReturnType = returnType;
            // Case 1: Direct compose function call
            if (expr.func.kind === 'variable' && expr.func.name === 'compose' && expr.args.length >= 1) {
                const fArg = expr.args[0]; // First function (f in "compose f g")
                const fResult = (0, _expressiondispatcher.typeExpression)(fArg, currentState);
                // If f has constraints and returnType is a function, propagate the constraints
                if (fResult.type.kind === 'function' && fResult.type.constraints && returnType.kind === 'function') {
                    const enhancedReturnType = {
                        ...returnType
                    };
                    // Map constraint variables from f's type to the new function's type variables
                    const updatedConstraints = [];
                    for (const constraint of fResult.type.constraints){
                        if (constraint.kind === 'is') {
                            // Find the corresponding parameter in the new function
                            // The first parameter of the composed function should inherit f's parameter constraints
                            if (enhancedReturnType.params.length > 0 && enhancedReturnType.params[0].kind === 'variable') {
                                const newConstraint = (0, _ast.isConstraint)(enhancedReturnType.params[0].name, constraint.constraint);
                                updatedConstraints.push(newConstraint);
                            }
                        } else {
                            // For non-"is" constraints, copy as-is for now
                            updatedConstraints.push(constraint);
                        }
                    }
                    enhancedReturnType.constraints = (enhancedReturnType.constraints || []).concat(updatedConstraints);
                    // Also propagate constraints to parameter type variables in the result function
                    for (const constraint of updatedConstraints){
                        if (constraint.kind === 'is') {
                            (0, _helpers.propagateConstraintToTypeVariable)(enhancedReturnType, constraint);
                        }
                    }
                    finalReturnType = enhancedReturnType;
                }
            } else if (expr.func.kind === 'application' && expr.func.func.kind === 'variable' && expr.func.func.name === 'compose' && expr.func.args.length >= 1) {
                // This is applying the second argument to a partial compose result
                const fArg = expr.func.args[0]; // First function from the compose
                const fResult = (0, _expressiondispatcher.typeExpression)(fArg, currentState);
                if (fResult.type.kind === 'function' && fResult.type.constraints && returnType.kind === 'function') {
                    const enhancedReturnType = {
                        ...returnType
                    };
                    // Map constraint variables from f's type to the new function's type variables
                    const updatedConstraints = [];
                    for (const constraint of fResult.type.constraints){
                        if (constraint.kind === 'is') {
                            // Find the corresponding parameter in the new function
                            if (enhancedReturnType.params.length > 0 && enhancedReturnType.params[0].kind === 'variable') {
                                const newConstraint = (0, _ast.isConstraint)(enhancedReturnType.params[0].name, constraint.constraint);
                                updatedConstraints.push(newConstraint);
                            }
                        } else {
                            updatedConstraints.push(constraint);
                        }
                    }
                    enhancedReturnType.constraints = (enhancedReturnType.constraints || []).concat(updatedConstraints);
                    for (const constraint of updatedConstraints){
                        if (constraint.kind === 'is') {
                            (0, _helpers.propagateConstraintToTypeVariable)(enhancedReturnType, constraint);
                        }
                    }
                    finalReturnType = enhancedReturnType;
                }
            }
            return (0, _types.createTypeResult)(finalReturnType, allEffects, currentState);
        } else {
            // Partial application - return a function with remaining parameters
            const remainingParams = funcType.params.slice(argTypes.length);
            const partialFunctionType = (0, _ast.functionType)(remainingParams, returnType, funcType.effects);
            // CRITICAL FIX: Handle partial application of compose
            if (expr.func.kind === 'variable' && expr.func.name === 'compose' && expr.args.length >= 1) {
                const fArg = expr.args[0]; // First function
                const fResult = (0, _expressiondispatcher.typeExpression)(fArg, currentState);
                // If f has constraints, the partial result should eventually inherit them
                if (fResult.type.kind === 'function' && fResult.type.constraints && partialFunctionType.kind === 'function') {
                    partialFunctionType.constraints = (partialFunctionType.constraints || []).concat(fResult.type.constraints);
                    for (const constraint of fResult.type.constraints){
                        if (constraint.kind === 'is') {
                            (0, _helpers.propagateConstraintToTypeVariable)(partialFunctionType, constraint);
                        }
                    }
                }
            }
            return (0, _types.createTypeResult)(partialFunctionType, allEffects, currentState);
        }
    } else if (funcType.kind === 'variable') {
        // If it's a type variable, create a function type and unify
        if (argTypes.length === 0) {
            return (0, _types.createTypeResult)(funcType, allEffects, currentState);
        }
        const [paramType, newState] = (0, _typeoperations.freshTypeVariable)(currentState);
        currentState = newState;
        const [returnType, finalState] = (0, _typeoperations.freshTypeVariable)(currentState);
        currentState = finalState;
        const freshFunctionType = (0, _ast.functionType)([
            paramType
        ], returnType);
        currentState = (0, _unify.unify)(funcType, freshFunctionType, currentState, {
            line: expr.location?.start.line || 1,
            column: expr.location?.start.column || 1
        });
        currentState = (0, _unify.unify)(paramType, argTypes[0], currentState, {
            line: expr.location?.start.line || 1,
            column: expr.location?.start.column || 1
        });
        return (0, _types.createTypeResult)((0, _substitute.substitute)(returnType, currentState.substitution), allEffects, currentState);
    } else {
        throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.nonFunctionApplicationError)(funcType, {
            line: expr.location?.start.line || 1,
            column: expr.location?.start.column || 1
        })));
    }
};
const typePipeline = (expr, state)=>{
    // Pipeline should be function composition, not function application
    // For a pipeline like f |> g |> h, we want to compose them as h(g(f(x)))
    if (expr.steps.length === 1) {
        return (0, _expressiondispatcher.typeExpression)(expr.steps[0], state);
    }
    // Start with the first function type
    let currentState = state;
    let composedType = (0, _expressiondispatcher.typeExpression)(expr.steps[0], currentState);
    currentState = composedType.state;
    let allEffects = composedType.effects;
    // Compose with each subsequent function type
    for(let i = 1; i < expr.steps.length; i++){
        const nextFuncType = (0, _expressiondispatcher.typeExpression)(expr.steps[i], currentState);
        currentState = nextFuncType.state;
        allEffects = (0, _types.unionEffects)(allEffects, nextFuncType.effects);
        if (composedType.type.kind === 'function' && nextFuncType.type.kind === 'function') {
            // Check that the output of composedType matches the input of nextFuncType
            if (nextFuncType.type.params.length !== 1) {
                throw new Error((0, _typeerrors.formatTypeError)((0, _typeerrors.functionApplicationError)(nextFuncType.type.params[0], nextFuncType.type, 0, undefined, {
                    line: expr.location?.start.line || 1,
                    column: expr.location?.start.column || 1
                })));
            }
            currentState = (0, _unify.unify)(composedType.type.return, nextFuncType.type.params[0], currentState, {
                line: expr.location?.start.line || 1,
                column: expr.location?.start.column || 1
            });
            // The composed function takes the input of the first function and returns the output of the last function
            composedType = (0, _types.createTypeResult)((0, _ast.functionType)([
                composedType.type.params[0]
            ], nextFuncType.type.return), allEffects, currentState);
        } else {
            throw new Error(`Cannot compose non-function types in pipeline: ${(0, _helpers.typeToString)(composedType.type)} and ${(0, _helpers.typeToString)(nextFuncType.type)}`);
        }
    }
    return (0, _types.createTypeResult)((0, _substitute.substitute)(composedType.type, currentState.substitution), allEffects, currentState);
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Uvc3JjL3R5cGVyL2Z1bmN0aW9uLWFwcGxpY2F0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdHR5cGUgQXBwbGljYXRpb25FeHByZXNzaW9uLFxuXHR0eXBlIFBpcGVsaW5lRXhwcmVzc2lvbixcblx0dHlwZSBUeXBlLFxuXHR0eXBlIENvbnN0cmFpbnQsXG5cdGZ1bmN0aW9uVHlwZSxcblx0aXNDb25zdHJhaW50LFxufSBmcm9tICcuLi9hc3QnO1xuaW1wb3J0IHtcblx0ZnVuY3Rpb25BcHBsaWNhdGlvbkVycm9yLFxuXHRub25GdW5jdGlvbkFwcGxpY2F0aW9uRXJyb3IsXG5cdGZvcm1hdFR5cGVFcnJvcixcblx0Y3JlYXRlVHlwZUVycm9yLFxufSBmcm9tICcuL3R5cGUtZXJyb3JzJztcbmltcG9ydCB7XG5cdGdldEV4cHJMb2NhdGlvbixcblx0dGhyb3dUeXBlRXJyb3IsXG5cdHR5cGVUb1N0cmluZyxcblx0cHJvcGFnYXRlQ29uc3RyYWludFRvVHlwZVZhcmlhYmxlLFxufSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHsgXG5cdHR5cGUgVHlwZVN0YXRlLCBcblx0dHlwZSBUeXBlUmVzdWx0LCBcblx0Y3JlYXRlVHlwZVJlc3VsdCwgXG5cdHVuaW9uRWZmZWN0cyBcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBcblx0dmFsaWRhdGVGdW5jdGlvbkNhbGwsIFxuXHRhcmVFZmZlY3RzQ29tcGF0aWJsZSxcblx0bWVyZ2VFZmZlY3RzIFxufSBmcm9tICcuL2VmZmVjdC12YWxpZGF0aW9uJztcbmltcG9ydCB7IHNhdGlzZmllc0NvbnN0cmFpbnQgfSBmcm9tICcuL2NvbnN0cmFpbnRzJztcbmltcG9ydCB7IHN1YnN0aXR1dGUgfSBmcm9tICcuL3N1YnN0aXR1dGUnO1xuaW1wb3J0IHsgdW5pZnkgfSBmcm9tICcuL3VuaWZ5JztcbmltcG9ydCB7IGZyZXNoVHlwZVZhcmlhYmxlLCBpbnN0YW50aWF0ZSB9IGZyb20gJy4vdHlwZS1vcGVyYXRpb25zJztcbmltcG9ydCB7IHR5cGVFeHByZXNzaW9uIH0gZnJvbSAnLi9leHByZXNzaW9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IHsgXG5cdHRyeVJlc29sdmVDb25zdHJhaW50RnVuY3Rpb24sIFxuXHRnZW5lcmF0ZUNvbnN0cmFpbnRFcnJvcixcblx0ZGVjb3JhdGVFbnZpcm9ubWVudFdpdGhDb25zdHJhaW50RnVuY3Rpb25zIFxufSBmcm9tICcuL2NvbnN0cmFpbnQtcmVzb2x1dGlvbic7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBmdW5jdGlvbiBhcHBsaWNhdGlvbiB3aXRoIGEgc3BlY2lhbGl6ZWQgY29uc3RyYWludCBmdW5jdGlvblxuZnVuY3Rpb24gY29udGludWVXaXRoU3BlY2lhbGl6ZWRGdW5jdGlvbihcblx0ZXhwcjogQXBwbGljYXRpb25FeHByZXNzaW9uLFxuXHRzcGVjaWFsaXplZEZ1bmNUeXBlOiBUeXBlLFxuXHRhcmdUeXBlczogVHlwZVtdLFxuXHRhbGxFZmZlY3RzOiBTZXQ8aW1wb3J0KCcuLi9hc3QnKS5FZmZlY3Q+LFxuXHRzdGF0ZTogVHlwZVN0YXRlXG4pOiBUeXBlUmVzdWx0IHtcblx0bGV0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuXHRcblx0aWYgKHNwZWNpYWxpemVkRnVuY1R5cGUua2luZCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93VHlwZUVycm9yKFxuXHRcdFx0bG9jYXRpb24gPT4gbm9uRnVuY3Rpb25BcHBsaWNhdGlvbkVycm9yKHNwZWNpYWxpemVkRnVuY1R5cGUsIGxvY2F0aW9uKSxcblx0XHRcdGdldEV4cHJMb2NhdGlvbihleHByKVxuXHRcdCk7XG5cdH1cblxuXHRjb25zdCBmdW5jVHlwZSA9IHNwZWNpYWxpemVkRnVuY1R5cGU7XG5cblx0Ly8gQ2hlY2sgYXJndW1lbnQgY291bnRcblx0aWYgKGFyZ1R5cGVzLmxlbmd0aCA+IGZ1bmNUeXBlLnBhcmFtcy5sZW5ndGgpIHtcblx0XHR0aHJvd1R5cGVFcnJvcihcblx0XHRcdGxvY2F0aW9uID0+XG5cdFx0XHRcdGZ1bmN0aW9uQXBwbGljYXRpb25FcnJvcihcblx0XHRcdFx0XHRmdW5jVHlwZS5wYXJhbXNbZnVuY1R5cGUucGFyYW1zLmxlbmd0aCAtIDFdLFxuXHRcdFx0XHRcdGFyZ1R5cGVzW2Z1bmNUeXBlLnBhcmFtcy5sZW5ndGggLSAxXSxcblx0XHRcdFx0XHRmdW5jVHlwZS5wYXJhbXMubGVuZ3RoIC0gMSxcblx0XHRcdFx0XHR1bmRlZmluZWQsXG5cdFx0XHRcdFx0bG9jYXRpb25cblx0XHRcdFx0KSxcblx0XHRcdGdldEV4cHJMb2NhdGlvbihleHByKVxuXHRcdCk7XG5cdH1cblxuXHQvLyBVbmlmeSBlYWNoIGFyZ3VtZW50IHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHR5cGVcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmdUeXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdGN1cnJlbnRTdGF0ZSA9IHVuaWZ5KFxuXHRcdFx0ZnVuY1R5cGUucGFyYW1zW2ldLFxuXHRcdFx0YXJnVHlwZXNbaV0sXG5cdFx0XHRjdXJyZW50U3RhdGUsXG5cdFx0XHRnZXRFeHByTG9jYXRpb24oZXhwciksXG5cdFx0XHR7XG5cdFx0XHRcdHJlYXNvbjogJ2NvbnN0cmFpbnRfZnVuY3Rpb25fYXBwbGljYXRpb24nLFxuXHRcdFx0XHRvcGVyYXRpb246IGBhcHBseWluZyBhcmd1bWVudCAke2kgKyAxfWAsXG5cdFx0XHRcdGhpbnQ6IGBBcmd1bWVudCAke2kgKyAxfSBoYXMgdHlwZSAke3R5cGVUb1N0cmluZyhcblx0XHRcdFx0XHRhcmdUeXBlc1tpXSxcblx0XHRcdFx0XHRjdXJyZW50U3RhdGUuc3Vic3RpdHV0aW9uXG5cdFx0XHRcdCl9IGJ1dCB0aGUgY29uc3RyYWludCBmdW5jdGlvbiBleHBlY3RzICR7dHlwZVRvU3RyaW5nKFxuXHRcdFx0XHRcdGZ1bmNUeXBlLnBhcmFtc1tpXSxcblx0XHRcdFx0XHRjdXJyZW50U3RhdGUuc3Vic3RpdHV0aW9uXG5cdFx0XHRcdCl9LmAsXG5cdFx0XHR9XG5cdFx0KTtcblx0fVxuXG5cdC8vIERldGVybWluZSB0aGUgcmVzdWx0IHR5cGVcblx0bGV0IHJlc3VsdFR5cGUgPSBmdW5jVHlwZS5yZXR1cm47XG5cdFxuXHQvLyBJZiBub3QgYWxsIGFyZ3VtZW50cyB3ZXJlIHByb3ZpZGVkLCBjcmVhdGUgYSBwYXJ0aWFsIGFwcGxpY2F0aW9uXG5cdGlmIChhcmdUeXBlcy5sZW5ndGggPCBmdW5jVHlwZS5wYXJhbXMubGVuZ3RoKSB7XG5cdFx0Y29uc3QgcmVtYWluaW5nUGFyYW1zID0gZnVuY1R5cGUucGFyYW1zLnNsaWNlKGFyZ1R5cGVzLmxlbmd0aCk7XG5cdFx0cmVzdWx0VHlwZSA9IGZ1bmN0aW9uVHlwZShyZW1haW5pbmdQYXJhbXMsIGZ1bmNUeXBlLnJldHVybiwgZnVuY1R5cGUuZWZmZWN0cyk7XG5cdH1cblxuXHQvLyBNZXJnZSBlZmZlY3RzIGZyb20gZnVuY3Rpb24gdHlwZSBhbmQgYXJndW1lbnRzXG5cdGNvbnN0IGZpbmFsRWZmZWN0cyA9IHVuaW9uRWZmZWN0cyhhbGxFZmZlY3RzLCBmdW5jVHlwZS5lZmZlY3RzKTtcblxuXHRyZXR1cm4gY3JlYXRlVHlwZVJlc3VsdChyZXN1bHRUeXBlLCBmaW5hbEVmZmVjdHMsIGN1cnJlbnRTdGF0ZSk7XG59XG5cbi8vIENvbXByZWhlbnNpdmUgY29uc3RyYWludCB2YWxpZGF0aW9uXG5leHBvcnQgY29uc3QgdmFsaWRhdGVDb25zdHJhaW50cyA9IChcblx0dHlwZTogVHlwZSxcblx0c3RhdGU6IFR5cGVTdGF0ZSxcblx0bG9jYXRpb24/OiB7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfVxuKTogVHlwZVN0YXRlID0+IHtcblx0bGV0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuXG5cdC8vIEFwcGx5IHN1YnN0aXR1dGlvbiB0byBnZXQgdGhlIGNvbmNyZXRlIHR5cGVcblx0Y29uc3Qgc3Vic3RpdHV0ZWRUeXBlID0gc3Vic3RpdHV0ZSh0eXBlLCBzdGF0ZS5zdWJzdGl0dXRpb24pO1xuXG5cdC8vIElmIGl0J3MgYSB0eXBlIHZhcmlhYmxlIHdpdGggY29uc3RyYWludHMsIGNoZWNrIHRoZW1cblx0aWYgKHN1YnN0aXR1dGVkVHlwZS5raW5kID09PSAndmFyaWFibGUnICYmIHN1YnN0aXR1dGVkVHlwZS5jb25zdHJhaW50cykge1xuXHRcdGZvciAoY29uc3QgY29uc3RyYWludCBvZiBzdWJzdGl0dXRlZFR5cGUuY29uc3RyYWludHMpIHtcblx0XHRcdC8vIGN1cnJlbnRTdGF0ZSA9IHNvbHZlQ29uc3RyYWludChjb25zdHJhaW50LCBjdXJyZW50U3RhdGUsIGxvY2F0aW9uKTtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb24gdHlwZSwgY2hlY2sgY29uc3RyYWludHMgb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuIHR5cGVcblx0aWYgKHN1YnN0aXR1dGVkVHlwZS5raW5kID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gQ2hlY2sgY29uc3RyYWludHMgb24gcGFyYW1ldGVyc1xuXHRcdGZvciAoY29uc3QgcGFyYW0gb2Ygc3Vic3RpdHV0ZWRUeXBlLnBhcmFtcykge1xuXHRcdFx0Y3VycmVudFN0YXRlID0gdmFsaWRhdGVDb25zdHJhaW50cyhwYXJhbSwgY3VycmVudFN0YXRlLCBsb2NhdGlvbik7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgY29uc3RyYWludHMgb24gcmV0dXJuIHR5cGVcblx0XHRjdXJyZW50U3RhdGUgPSB2YWxpZGF0ZUNvbnN0cmFpbnRzKFxuXHRcdFx0c3Vic3RpdHV0ZWRUeXBlLnJldHVybixcblx0XHRcdGN1cnJlbnRTdGF0ZSxcblx0XHRcdGxvY2F0aW9uXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZ1bmN0aW9uLWxldmVsIGNvbnN0cmFpbnRzXG5cdFx0aWYgKHN1YnN0aXR1dGVkVHlwZS5jb25zdHJhaW50cykge1xuXHRcdFx0Ly8gY3VycmVudFN0YXRlID0gc29sdmVDb25zdHJhaW50cyhcblx0XHRcdC8vIFx0c3Vic3RpdHV0ZWRUeXBlLmNvbnN0cmFpbnRzLFxuXHRcdFx0Ly8gXHRjdXJyZW50U3RhdGUsXG5cdFx0XHQvLyBcdGxvY2F0aW9uXG5cdFx0XHQvLyApO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIGl0J3MgYSBsaXN0IHR5cGUsIGNoZWNrIGNvbnN0cmFpbnRzIG9uIGVsZW1lbnQgdHlwZVxuXHRpZiAoc3Vic3RpdHV0ZWRUeXBlLmtpbmQgPT09ICdsaXN0Jykge1xuXHRcdGN1cnJlbnRTdGF0ZSA9IHZhbGlkYXRlQ29uc3RyYWludHMoXG5cdFx0XHRzdWJzdGl0dXRlZFR5cGUuZWxlbWVudCxcblx0XHRcdGN1cnJlbnRTdGF0ZSxcblx0XHRcdGxvY2F0aW9uXG5cdFx0KTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSByZWNvcmQgdHlwZSwgY2hlY2sgY29uc3RyYWludHMgb24gZmllbGQgdHlwZXNcblx0aWYgKHN1YnN0aXR1dGVkVHlwZS5raW5kID09PSAncmVjb3JkJykge1xuXHRcdGZvciAoY29uc3QgZmllbGRUeXBlIG9mIE9iamVjdC52YWx1ZXMoc3Vic3RpdHV0ZWRUeXBlLmZpZWxkcykpIHtcblx0XHRcdGN1cnJlbnRTdGF0ZSA9IHZhbGlkYXRlQ29uc3RyYWludHMoZmllbGRUeXBlLCBjdXJyZW50U3RhdGUsIGxvY2F0aW9uKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3VycmVudFN0YXRlO1xufTtcblxuLy8gVXBkYXRlIHR5cGVBcHBsaWNhdGlvbiB0byB0aHJlYWQgc3RhdGUgdGhyb3VnaCBmcmVzaGVuVHlwZVZhcmlhYmxlc1xuZXhwb3J0IGNvbnN0IHR5cGVBcHBsaWNhdGlvbiA9IChcblx0ZXhwcjogQXBwbGljYXRpb25FeHByZXNzaW9uLFxuXHRzdGF0ZTogVHlwZVN0YXRlXG4pOiBUeXBlUmVzdWx0ID0+IHtcblx0bGV0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuXG5cdC8vIFR5cGUgdGhlIGZ1bmN0aW9uXG5cdGNvbnN0IGZ1bmNSZXN1bHQgPSB0eXBlRXhwcmVzc2lvbihleHByLmZ1bmMsIGN1cnJlbnRTdGF0ZSk7XG5cdGN1cnJlbnRTdGF0ZSA9IGZ1bmNSZXN1bHQuc3RhdGU7XG5cdGNvbnN0IGZ1bmNUeXBlID0gZnVuY1Jlc3VsdC50eXBlO1xuXG5cdC8vIFR5cGUgZWFjaCBhcmd1bWVudCBhbmQgY29sbGVjdCBlZmZlY3RzXG5cdGNvbnN0IGFyZ1R5cGVzOiBUeXBlW10gPSBbXTtcblx0bGV0IGFsbEVmZmVjdHMgPSBmdW5jUmVzdWx0LmVmZmVjdHM7XG5cdGZvciAoY29uc3QgYXJnIG9mIGV4cHIuYXJncykge1xuXHRcdGNvbnN0IGFyZ1Jlc3VsdCA9IHR5cGVFeHByZXNzaW9uKGFyZywgY3VycmVudFN0YXRlKTtcblx0XHRhcmdUeXBlcy5wdXNoKGFyZ1Jlc3VsdC50eXBlKTtcblx0XHRjdXJyZW50U3RhdGUgPSBhcmdSZXN1bHQuc3RhdGU7XG5cdFx0YWxsRWZmZWN0cyA9IHVuaW9uRWZmZWN0cyhhbGxFZmZlY3RzLCBhcmdSZXN1bHQuZWZmZWN0cyk7XG5cdH1cblxuXHQvLyBDaGVjayBpZiB0aGlzIGlzIGEgY29uc3RyYWludCBmdW5jdGlvbiBjYWxsIHRoYXQgbmVlZHMgcmVzb2x1dGlvblxuXHQvLyBPTkxZIGFwcGx5IHRvIGZ1bmN0aW9ucyB0aGF0IGFyZSBleHBsaWNpdGx5IGRlZmluZWQgaW4gY29uc3RyYWludHNcblx0aWYgKGV4cHIuZnVuYy5raW5kID09PSAndmFyaWFibGUnICYmIGN1cnJlbnRTdGF0ZS5jb25zdHJhaW50UmVnaXN0cnkuc2l6ZSA+IDApIHtcblx0XHQvLyBPbmx5IGNoZWNrIGNvbnN0cmFpbnQgcmVzb2x1dGlvbiBpZiB0aGUgZnVuY3Rpb24gaXMgZXhwbGljaXRseSBpbiBhIGNvbnN0cmFpbnRcblx0XHRsZXQgaXNEZWZpbmVkSW5Db25zdHJhaW50ID0gZmFsc2U7XG5cdFx0Zm9yIChjb25zdCBbLCBjb25zdHJhaW50SW5mb10gb2YgY3VycmVudFN0YXRlLmNvbnN0cmFpbnRSZWdpc3RyeSkge1xuXHRcdFx0aWYgKGNvbnN0cmFpbnRJbmZvLnNpZ25hdHVyZS5mdW5jdGlvbnMuaGFzKGV4cHIuZnVuYy5uYW1lKSkge1xuXHRcdFx0XHRpc0RlZmluZWRJbkNvbnN0cmFpbnQgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gT05MWSBhcHBseSBjb25zdHJhaW50IHJlc29sdXRpb24gdG8gZXhwbGljaXRseSBkZWZpbmVkIGNvbnN0cmFpbnQgZnVuY3Rpb25zXG5cdFx0Ly8gVGhpcyBleGNsdWRlcyBBRFQgY29uc3RydWN0b3JzIGxpa2UgUG9pbnQsIFJlY3RhbmdsZSwgZXRjLlxuXHRcdGlmIChpc0RlZmluZWRJbkNvbnN0cmFpbnQpIHtcblx0XHRcdGNvbnN0IGNvbnN0cmFpbnRSZXNvbHV0aW9uID0gdHJ5UmVzb2x2ZUNvbnN0cmFpbnRGdW5jdGlvbihcblx0XHRcdFx0ZXhwci5mdW5jLm5hbWUsXG5cdFx0XHRcdGV4cHIuYXJncyxcblx0XHRcdFx0YXJnVHlwZXMsXG5cdFx0XHRcdGN1cnJlbnRTdGF0ZVxuXHRcdFx0KTtcblx0XHRcdFxuXHRcdFx0aWYgKGNvbnN0cmFpbnRSZXNvbHV0aW9uLnJlc29sdmVkICYmIGNvbnN0cmFpbnRSZXNvbHV0aW9uLnNwZWNpYWxpemVkTmFtZSkge1xuXHRcdFx0XHQvLyBUaGlzIGlzIGEgY29uc3RyYWludCBmdW5jdGlvbiBjYWxsIHdpdGggYSBjb25jcmV0ZSByZXNvbHV0aW9uXG5cdFx0XHRcdC8vIExvb2sgdXAgdGhlIHNwZWNpYWxpemVkIGZ1bmN0aW9uIGluIHRoZSBlbnZpcm9ubWVudFxuXHRcdFx0XHRjb25zdCBkZWNvcmF0ZWRTdGF0ZSA9IGRlY29yYXRlRW52aXJvbm1lbnRXaXRoQ29uc3RyYWludEZ1bmN0aW9ucyhjdXJyZW50U3RhdGUpO1xuXHRcdFx0XHRjb25zdCBzcGVjaWFsaXplZFNjaGVtZSA9IGRlY29yYXRlZFN0YXRlLmVudmlyb25tZW50LmdldChjb25zdHJhaW50UmVzb2x1dGlvbi5zcGVjaWFsaXplZE5hbWUpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHNwZWNpYWxpemVkU2NoZW1lKSB7XG5cdFx0XHRcdFx0Ly8gVXNlIHRoZSBzcGVjaWFsaXplZCBpbXBsZW1lbnRhdGlvblxuXHRcdFx0XHRcdGNvbnN0IFtpbnN0YW50aWF0ZWRUeXBlLCBuZXdTdGF0ZV0gPSBpbnN0YW50aWF0ZShzcGVjaWFsaXplZFNjaGVtZSwgZGVjb3JhdGVkU3RhdGUpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFRoZSBzcGVjaWFsaXplZCBmdW5jdGlvbiBzaG91bGQgbWF0Y2ggdGhlIGNhbGwgcGF0dGVyblxuXHRcdFx0XHRcdGlmIChpbnN0YW50aWF0ZWRUeXBlLmtpbmQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdC8vIENvbnRpbnVlIHdpdGggbm9ybWFsIGZ1bmN0aW9uIGFwcGxpY2F0aW9uIHVzaW5nIHRoZSBzcGVjaWFsaXplZCB0eXBlXG5cdFx0XHRcdFx0XHRjb25zdCBzcGVjaWFsaXplZEZ1bmNUeXBlID0gaW5zdGFudGlhdGVkVHlwZTtcblx0XHRcdFx0XHRcdC8vIFJlcGxhY2UgZnVuY1R5cGUgd2l0aCBzcGVjaWFsaXplZEZ1bmNUeXBlIGZvciB0aGUgcmVzdCBvZiB0aGUgZnVuY3Rpb25cblx0XHRcdFx0XHRcdHJldHVybiBjb250aW51ZVdpdGhTcGVjaWFsaXplZEZ1bmN0aW9uKFxuXHRcdFx0XHRcdFx0XHRleHByLCBcblx0XHRcdFx0XHRcdFx0c3BlY2lhbGl6ZWRGdW5jVHlwZSwgXG5cdFx0XHRcdFx0XHRcdGFyZ1R5cGVzLCBcblx0XHRcdFx0XHRcdFx0YWxsRWZmZWN0cywgXG5cdFx0XHRcdFx0XHRcdG5ld1N0YXRlXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBDb3VsZCBub3QgcmVzb2x2ZSAtIGdlbmVyYXRlIGhlbHBmdWwgZXJyb3Jcblx0XHRcdFx0XHRjb25zdCBmaXJzdEFyZ1R5cGUgPSBhcmdUeXBlcy5sZW5ndGggPiAwID8gc3Vic3RpdHV0ZShhcmdUeXBlc1swXSwgY3VycmVudFN0YXRlLnN1YnN0aXR1dGlvbikgOiBudWxsO1xuXHRcdFx0XHRcdGlmIChmaXJzdEFyZ1R5cGUgJiYgZmlyc3RBcmdUeXBlLmtpbmQgIT09ICd2YXJpYWJsZScpIHtcblx0XHRcdFx0XHRcdC8vIFdlIGhhdmUgYSBjb25jcmV0ZSB0eXBlIGJ1dCBubyBpbXBsZW1lbnRhdGlvblxuXHRcdFx0XHRcdFx0Y29uc3QgZXJyb3JNZXNzYWdlID0gZ2VuZXJhdGVDb25zdHJhaW50RXJyb3IoXG5cdFx0XHRcdFx0XHRcdGV4cHIuZnVuYy5uYW1lLCAvLyBUaGlzIHNob3VsZCBiZSBwYXJzZWQgZGlmZmVyZW50bHksIGJ1dCBmb3Igbm93IHVzaW5nIGZ1bmN0aW9uIG5hbWVcblx0XHRcdFx0XHRcdFx0ZXhwci5mdW5jLm5hbWUsXG5cdFx0XHRcdFx0XHRcdGZpcnN0QXJnVHlwZSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudFN0YXRlXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gSGFuZGxlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uIGJ5IGNoZWNraW5nIGlmIGZ1bmNUeXBlIGlzIGEgZnVuY3Rpb25cblx0aWYgKGZ1bmNUeXBlLmtpbmQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoYXJnVHlwZXMubGVuZ3RoID4gZnVuY1R5cGUucGFyYW1zLmxlbmd0aCkge1xuXHRcdFx0dGhyb3dUeXBlRXJyb3IoXG5cdFx0XHRcdGxvY2F0aW9uID0+XG5cdFx0XHRcdFx0ZnVuY3Rpb25BcHBsaWNhdGlvbkVycm9yKFxuXHRcdFx0XHRcdFx0ZnVuY1R5cGUucGFyYW1zW2Z1bmNUeXBlLnBhcmFtcy5sZW5ndGggLSAxXSxcblx0XHRcdFx0XHRcdGFyZ1R5cGVzW2Z1bmNUeXBlLnBhcmFtcy5sZW5ndGggLSAxXSxcblx0XHRcdFx0XHRcdGZ1bmNUeXBlLnBhcmFtcy5sZW5ndGggLSAxLFxuXHRcdFx0XHRcdFx0dW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0bG9jYXRpb25cblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRnZXRFeHByTG9jYXRpb24oZXhwcilcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gVW5pZnkgZWFjaCBhcmd1bWVudCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHBhcmFtZXRlciB0eXBlXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmdUeXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y3VycmVudFN0YXRlID0gdW5pZnkoXG5cdFx0XHRcdGZ1bmNUeXBlLnBhcmFtc1tpXSxcblx0XHRcdFx0YXJnVHlwZXNbaV0sXG5cdFx0XHRcdGN1cnJlbnRTdGF0ZSxcblx0XHRcdFx0Z2V0RXhwckxvY2F0aW9uKGV4cHIpLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmVhc29uOiAnZnVuY3Rpb25fYXBwbGljYXRpb24nLFxuXHRcdFx0XHRcdG9wZXJhdGlvbjogYGFwcGx5aW5nIGFyZ3VtZW50ICR7aSArIDF9YCxcblx0XHRcdFx0XHRoaW50OiBgQXJndW1lbnQgJHtpICsgMX0gaGFzIHR5cGUgJHt0eXBlVG9TdHJpbmcoXG5cdFx0XHRcdFx0XHRhcmdUeXBlc1tpXSxcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGF0ZS5zdWJzdGl0dXRpb25cblx0XHRcdFx0XHQpfSBidXQgdGhlIGZ1bmN0aW9uIHBhcmFtZXRlciBleHBlY3RzICR7dHlwZVRvU3RyaW5nKFxuXHRcdFx0XHRcdFx0ZnVuY1R5cGUucGFyYW1zW2ldLFxuXHRcdFx0XHRcdFx0Y3VycmVudFN0YXRlLnN1YnN0aXR1dGlvblxuXHRcdFx0XHRcdCl9LmAsXG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cblx0XHRcdC8vIEFmdGVyIHVuaWZpY2F0aW9uLCB2YWxpZGF0ZSBjb25zdHJhaW50cyBvbiB0aGUgcGFyYW1ldGVyXG5cdFx0XHRjb25zdCBzdWJzdGl0dXRlZFBhcmFtID0gc3Vic3RpdHV0ZShcblx0XHRcdFx0ZnVuY1R5cGUucGFyYW1zW2ldLFxuXHRcdFx0XHRjdXJyZW50U3RhdGUuc3Vic3RpdHV0aW9uXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBDaGVjayBpZiB0aGUgcGFyYW1ldGVyIGhhcyBjb25zdHJhaW50cyB0aGF0IG5lZWQgdG8gYmUgdmFsaWRhdGVkXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHN1YnN0aXR1dGVkUGFyYW0ua2luZCA9PT0gJ3ZhcmlhYmxlJyAmJlxuXHRcdFx0XHRzdWJzdGl0dXRlZFBhcmFtLmNvbnN0cmFpbnRzXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gVmFsaWRhdGUgZWFjaCBjb25zdHJhaW50XG5cdFx0XHRcdGZvciAoY29uc3QgY29uc3RyYWludCBvZiBzdWJzdGl0dXRlZFBhcmFtLmNvbnN0cmFpbnRzKSB7XG5cdFx0XHRcdFx0aWYgKGNvbnN0cmFpbnQua2luZCA9PT0gJ2lzJykge1xuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIHR5cGUgdmFyaWFibGUgaGFzIGJlZW4gdW5pZmllZCB0byBhIGNvbmNyZXRlIHR5cGVcblx0XHRcdFx0XHRcdGNvbnN0IGNvbmNyZXRlVHlwZSA9IGN1cnJlbnRTdGF0ZS5zdWJzdGl0dXRpb24uZ2V0KFxuXHRcdFx0XHRcdFx0XHRjb25zdHJhaW50LnR5cGVWYXJcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRpZiAoY29uY3JldGVUeXBlICYmIGNvbmNyZXRlVHlwZS5raW5kICE9PSAndmFyaWFibGUnKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFRoZSB0eXBlIHZhcmlhYmxlIGhhcyBiZWVuIHVuaWZpZWQgdG8gYSBjb25jcmV0ZSB0eXBlLCB2YWxpZGF0ZSB0aGUgY29uc3RyYWludFxuXHRcdFx0XHRcdFx0XHRpZiAoIXNhdGlzZmllc0NvbnN0cmFpbnQoY29uY3JldGVUeXBlLCBjb25zdHJhaW50LmNvbnN0cmFpbnQpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9ybWF0VHlwZUVycm9yKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjcmVhdGVUeXBlRXJyb3IoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YFR5cGUgJHt0eXBlVG9TdHJpbmcoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb25jcmV0ZVR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50U3RhdGUuc3Vic3RpdHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KX0gZG9lcyBub3Qgc2F0aXNmeSBjb25zdHJhaW50ICcke1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc3RyYWludC5jb25zdHJhaW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSdgLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHt9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxpbmU6IGV4cHIubG9jYXRpb24/LnN0YXJ0LmxpbmUgfHwgMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbHVtbjogZXhwci5sb2NhdGlvbj8uc3RhcnQuY29sdW1uIHx8IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBbHNvIHZhbGlkYXRlIGNvbnN0cmFpbnRzIG9uIHRoZSBhcmd1bWVudCB0eXBlXG5cdFx0XHRjb25zdCBzdWJzdGl0dXRlZEFyZyA9IHN1YnN0aXR1dGUoYXJnVHlwZXNbaV0sIGN1cnJlbnRTdGF0ZS5zdWJzdGl0dXRpb24pO1xuXHRcdFx0aWYgKHN1YnN0aXR1dGVkQXJnLmtpbmQgPT09ICd2YXJpYWJsZScgJiYgc3Vic3RpdHV0ZWRBcmcuY29uc3RyYWludHMpIHtcblx0XHRcdFx0Zm9yIChjb25zdCBjb25zdHJhaW50IG9mIHN1YnN0aXR1dGVkQXJnLmNvbnN0cmFpbnRzKSB7XG5cdFx0XHRcdFx0aWYgKGNvbnN0cmFpbnQua2luZCA9PT0gJ2lzJykge1xuXHRcdFx0XHRcdFx0Y29uc3QgY29uY3JldGVUeXBlID0gY3VycmVudFN0YXRlLnN1YnN0aXR1dGlvbi5nZXQoXG5cdFx0XHRcdFx0XHRcdGNvbnN0cmFpbnQudHlwZVZhclxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGlmIChjb25jcmV0ZVR5cGUgJiYgY29uY3JldGVUeXBlLmtpbmQgIT09ICd2YXJpYWJsZScpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFzYXRpc2ZpZXNDb25zdHJhaW50KGNvbmNyZXRlVHlwZSwgY29uc3RyYWludC5jb25zdHJhaW50KSkge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0XHRcdGZvcm1hdFR5cGVFcnJvcihcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3JlYXRlVHlwZUVycm9yKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGBUeXBlICR7dHlwZVRvU3RyaW5nKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uY3JldGVUeXBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFN0YXRlLnN1YnN0aXR1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCl9IGRvZXMgbm90IHNhdGlzZnkgY29uc3RyYWludCAnJHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0cmFpbnQuY29uc3RyYWludFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0nYCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsaW5lOiBleHByLmxvY2F0aW9uPy5zdGFydC5saW5lIHx8IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb2x1bW46IGV4cHIubG9jYXRpb24/LnN0YXJ0LmNvbHVtbiB8fCAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ1JJVElDQUw6IEFsc28gY2hlY2sgaWYgdGhlIGFyZ3VtZW50IHR5cGUgaXRzZWxmIHNhdGlzZmllcyBjb25zdHJhaW50c1xuXHRcdFx0Ly8gVGhpcyBpcyBuZWVkZWQgZm9yIGNhc2VzIHdoZXJlIHRoZSBhcmd1bWVudCBpcyBhIGNvbmNyZXRlIHR5cGUgdGhhdCBzaG91bGQgc2F0aXNmeSBjb25zdHJhaW50c1xuXHRcdFx0aWYgKHN1YnN0aXR1dGVkQXJnLmtpbmQgIT09ICd2YXJpYWJsZScpIHtcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIHBhcmFtZXRlciBoYXMgY29uc3RyYWludHMgdGhhdCB0aGUgYXJndW1lbnQgc2hvdWxkIHNhdGlzZnlcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHN1YnN0aXR1dGVkUGFyYW0ua2luZCA9PT0gJ3ZhcmlhYmxlJyAmJlxuXHRcdFx0XHRcdHN1YnN0aXR1dGVkUGFyYW0uY29uc3RyYWludHNcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBjb25zdHJhaW50IG9mIHN1YnN0aXR1dGVkUGFyYW0uY29uc3RyYWludHMpIHtcblx0XHRcdFx0XHRcdGlmIChjb25zdHJhaW50LmtpbmQgPT09ICdpcycpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFzYXRpc2ZpZXNDb25zdHJhaW50KHN1YnN0aXR1dGVkQXJnLCBjb25zdHJhaW50LmNvbnN0cmFpbnQpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9ybWF0VHlwZUVycm9yKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjcmVhdGVUeXBlRXJyb3IoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YFR5cGUgJHt0eXBlVG9TdHJpbmcoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdWJzdGl0dXRlZEFyZyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRTdGF0ZS5zdWJzdGl0dXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpfSBkb2VzIG5vdCBzYXRpc2Z5IGNvbnN0cmFpbnQgJyR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zdHJhaW50LmNvbnN0cmFpbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9J2AsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e30sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bGluZTogZXhwci5sb2NhdGlvbj8uc3RhcnQubGluZSB8fCAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29sdW1uOiBleHByLmxvY2F0aW9uPy5zdGFydC5jb2x1bW4gfHwgMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgc3Vic3RpdHV0aW9uIHRvIGdldCB0aGUgcmV0dXJuIHR5cGVcblx0XHRjb25zdCByZXR1cm5UeXBlID0gc3Vic3RpdHV0ZShmdW5jVHlwZS5yZXR1cm4sIGN1cnJlbnRTdGF0ZS5zdWJzdGl0dXRpb24pO1xuXG5cdFx0Ly8gVmFsaWRhdGUgY29uc3RyYWludHMgb24gdGhlIHJldHVybiB0eXBlXG5cdFx0Y3VycmVudFN0YXRlID0gdmFsaWRhdGVDb25zdHJhaW50cyhyZXR1cm5UeXBlLCBjdXJyZW50U3RhdGUsIHtcblx0XHRcdGxpbmU6IGV4cHIubG9jYXRpb24/LnN0YXJ0LmxpbmUgfHwgMSxcblx0XHRcdGNvbHVtbjogZXhwci5sb2NhdGlvbj8uc3RhcnQuY29sdW1uIHx8IDEsXG5cdFx0fSk7XG5cblx0XHQvLyBQaGFzZSAzOiBBZGQgZWZmZWN0IHZhbGlkYXRpb24gZm9yIGZ1bmN0aW9uIGNhbGxzXG5cdFx0Ly8gQWRkIGZ1bmN0aW9uJ3MgZWZmZWN0cyB0byB0aGUgY29sbGVjdGVkIGVmZmVjdHNcblx0XHRhbGxFZmZlY3RzID0gdW5pb25FZmZlY3RzKGFsbEVmZmVjdHMsIGZ1bmNUeXBlLmVmZmVjdHMpO1xuXG5cdFx0aWYgKGFyZ1R5cGVzLmxlbmd0aCA9PT0gZnVuY1R5cGUucGFyYW1zLmxlbmd0aCkge1xuXHRcdFx0Ly8gRnVsbCBhcHBsaWNhdGlvbiAtIHJldHVybiB0aGUgcmV0dXJuIHR5cGVcblxuXHRcdFx0Ly8gQ1JJVElDQUwgRklYOiBIYW5kbGUgZnVuY3Rpb24gY29tcG9zaXRpb24gY29uc3RyYWludCBwcm9wYWdhdGlvblxuXHRcdFx0bGV0IGZpbmFsUmV0dXJuVHlwZSA9IHJldHVyblR5cGU7XG5cblx0XHRcdC8vIENhc2UgMTogRGlyZWN0IGNvbXBvc2UgZnVuY3Rpb24gY2FsbFxuXHRcdFx0aWYgKFxuXHRcdFx0XHRleHByLmZ1bmMua2luZCA9PT0gJ3ZhcmlhYmxlJyAmJlxuXHRcdFx0XHRleHByLmZ1bmMubmFtZSA9PT0gJ2NvbXBvc2UnICYmXG5cdFx0XHRcdGV4cHIuYXJncy5sZW5ndGggPj0gMVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnN0IGZBcmcgPSBleHByLmFyZ3NbMF07IC8vIEZpcnN0IGZ1bmN0aW9uIChmIGluIFwiY29tcG9zZSBmIGdcIilcblx0XHRcdFx0Y29uc3QgZlJlc3VsdCA9IHR5cGVFeHByZXNzaW9uKGZBcmcsIGN1cnJlbnRTdGF0ZSk7XG5cblx0XHRcdFx0Ly8gSWYgZiBoYXMgY29uc3RyYWludHMgYW5kIHJldHVyblR5cGUgaXMgYSBmdW5jdGlvbiwgcHJvcGFnYXRlIHRoZSBjb25zdHJhaW50c1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZlJlc3VsdC50eXBlLmtpbmQgPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0XHRmUmVzdWx0LnR5cGUuY29uc3RyYWludHMgJiZcblx0XHRcdFx0XHRyZXR1cm5UeXBlLmtpbmQgPT09ICdmdW5jdGlvbidcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Y29uc3QgZW5oYW5jZWRSZXR1cm5UeXBlID0geyAuLi5yZXR1cm5UeXBlIH07XG5cblx0XHRcdFx0XHQvLyBNYXAgY29uc3RyYWludCB2YXJpYWJsZXMgZnJvbSBmJ3MgdHlwZSB0byB0aGUgbmV3IGZ1bmN0aW9uJ3MgdHlwZSB2YXJpYWJsZXNcblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkQ29uc3RyYWludHM6IENvbnN0cmFpbnRbXSA9IFtdO1xuXHRcdFx0XHRcdGZvciAoY29uc3QgY29uc3RyYWludCBvZiBmUmVzdWx0LnR5cGUuY29uc3RyYWludHMpIHtcblx0XHRcdFx0XHRcdGlmIChjb25zdHJhaW50LmtpbmQgPT09ICdpcycpIHtcblx0XHRcdFx0XHRcdFx0Ly8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBwYXJhbWV0ZXIgaW4gdGhlIG5ldyBmdW5jdGlvblxuXHRcdFx0XHRcdFx0XHQvLyBUaGUgZmlyc3QgcGFyYW1ldGVyIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbiBzaG91bGQgaW5oZXJpdCBmJ3MgcGFyYW1ldGVyIGNvbnN0cmFpbnRzXG5cdFx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0XHRlbmhhbmNlZFJldHVyblR5cGUucGFyYW1zLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHRcdFx0XHRlbmhhbmNlZFJldHVyblR5cGUucGFyYW1zWzBdLmtpbmQgPT09ICd2YXJpYWJsZSdcblx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgbmV3Q29uc3RyYWludCA9IGlzQ29uc3RyYWludChcblx0XHRcdFx0XHRcdFx0XHRcdGVuaGFuY2VkUmV0dXJuVHlwZS5wYXJhbXNbMF0ubmFtZSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0cmFpbnQuY29uc3RyYWludFxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0dXBkYXRlZENvbnN0cmFpbnRzLnB1c2gobmV3Q29uc3RyYWludCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIEZvciBub24tXCJpc1wiIGNvbnN0cmFpbnRzLCBjb3B5IGFzLWlzIGZvciBub3dcblx0XHRcdFx0XHRcdFx0dXBkYXRlZENvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZW5oYW5jZWRSZXR1cm5UeXBlLmNvbnN0cmFpbnRzID0gKFxuXHRcdFx0XHRcdFx0ZW5oYW5jZWRSZXR1cm5UeXBlLmNvbnN0cmFpbnRzIHx8IFtdXG5cdFx0XHRcdFx0KS5jb25jYXQodXBkYXRlZENvbnN0cmFpbnRzKTtcblxuXHRcdFx0XHRcdC8vIEFsc28gcHJvcGFnYXRlIGNvbnN0cmFpbnRzIHRvIHBhcmFtZXRlciB0eXBlIHZhcmlhYmxlcyBpbiB0aGUgcmVzdWx0IGZ1bmN0aW9uXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBjb25zdHJhaW50IG9mIHVwZGF0ZWRDb25zdHJhaW50cykge1xuXHRcdFx0XHRcdFx0aWYgKGNvbnN0cmFpbnQua2luZCA9PT0gJ2lzJykge1xuXHRcdFx0XHRcdFx0XHRwcm9wYWdhdGVDb25zdHJhaW50VG9UeXBlVmFyaWFibGUoZW5oYW5jZWRSZXR1cm5UeXBlLCBjb25zdHJhaW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmaW5hbFJldHVyblR5cGUgPSBlbmhhbmNlZFJldHVyblR5cGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FzZSAyOiBBcHBsaWNhdGlvbiB0byByZXN1bHQgb2YgY29tcG9zZSAoZS5nLiwgKGNvbXBvc2UgaGVhZCkgaWQpXG5cdFx0XHRlbHNlIGlmIChcblx0XHRcdFx0ZXhwci5mdW5jLmtpbmQgPT09ICdhcHBsaWNhdGlvbicgJiZcblx0XHRcdFx0ZXhwci5mdW5jLmZ1bmMua2luZCA9PT0gJ3ZhcmlhYmxlJyAmJlxuXHRcdFx0XHRleHByLmZ1bmMuZnVuYy5uYW1lID09PSAnY29tcG9zZScgJiZcblx0XHRcdFx0ZXhwci5mdW5jLmFyZ3MubGVuZ3RoID49IDFcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBUaGlzIGlzIGFwcGx5aW5nIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYSBwYXJ0aWFsIGNvbXBvc2UgcmVzdWx0XG5cdFx0XHRcdGNvbnN0IGZBcmcgPSBleHByLmZ1bmMuYXJnc1swXTsgLy8gRmlyc3QgZnVuY3Rpb24gZnJvbSB0aGUgY29tcG9zZVxuXHRcdFx0XHRjb25zdCBmUmVzdWx0ID0gdHlwZUV4cHJlc3Npb24oZkFyZywgY3VycmVudFN0YXRlKTtcblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZlJlc3VsdC50eXBlLmtpbmQgPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0XHRmUmVzdWx0LnR5cGUuY29uc3RyYWludHMgJiZcblx0XHRcdFx0XHRyZXR1cm5UeXBlLmtpbmQgPT09ICdmdW5jdGlvbidcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Y29uc3QgZW5oYW5jZWRSZXR1cm5UeXBlID0geyAuLi5yZXR1cm5UeXBlIH07XG5cblx0XHRcdFx0XHQvLyBNYXAgY29uc3RyYWludCB2YXJpYWJsZXMgZnJvbSBmJ3MgdHlwZSB0byB0aGUgbmV3IGZ1bmN0aW9uJ3MgdHlwZSB2YXJpYWJsZXNcblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkQ29uc3RyYWludHM6IENvbnN0cmFpbnRbXSA9IFtdO1xuXHRcdFx0XHRcdGZvciAoY29uc3QgY29uc3RyYWludCBvZiBmUmVzdWx0LnR5cGUuY29uc3RyYWludHMpIHtcblx0XHRcdFx0XHRcdGlmIChjb25zdHJhaW50LmtpbmQgPT09ICdpcycpIHtcblx0XHRcdFx0XHRcdFx0Ly8gRmluZCB0aGUgY29ycmVzcG9uZGluZyBwYXJhbWV0ZXIgaW4gdGhlIG5ldyBmdW5jdGlvblxuXHRcdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdFx0ZW5oYW5jZWRSZXR1cm5UeXBlLnBhcmFtcy5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0XHRcdFx0ZW5oYW5jZWRSZXR1cm5UeXBlLnBhcmFtc1swXS5raW5kID09PSAndmFyaWFibGUnXG5cdFx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IG5ld0NvbnN0cmFpbnQgPSBpc0NvbnN0cmFpbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRlbmhhbmNlZFJldHVyblR5cGUucGFyYW1zWzBdLm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdHJhaW50LmNvbnN0cmFpbnRcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdHVwZGF0ZWRDb25zdHJhaW50cy5wdXNoKG5ld0NvbnN0cmFpbnQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR1cGRhdGVkQ29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbmhhbmNlZFJldHVyblR5cGUuY29uc3RyYWludHMgPSAoXG5cdFx0XHRcdFx0XHRlbmhhbmNlZFJldHVyblR5cGUuY29uc3RyYWludHMgfHwgW11cblx0XHRcdFx0XHQpLmNvbmNhdCh1cGRhdGVkQ29uc3RyYWludHMpO1xuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBjb25zdHJhaW50IG9mIHVwZGF0ZWRDb25zdHJhaW50cykge1xuXHRcdFx0XHRcdFx0aWYgKGNvbnN0cmFpbnQua2luZCA9PT0gJ2lzJykge1xuXHRcdFx0XHRcdFx0XHRwcm9wYWdhdGVDb25zdHJhaW50VG9UeXBlVmFyaWFibGUoZW5oYW5jZWRSZXR1cm5UeXBlLCBjb25zdHJhaW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmaW5hbFJldHVyblR5cGUgPSBlbmhhbmNlZFJldHVyblR5cGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNyZWF0ZVR5cGVSZXN1bHQoZmluYWxSZXR1cm5UeXBlLCBhbGxFZmZlY3RzLCBjdXJyZW50U3RhdGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBQYXJ0aWFsIGFwcGxpY2F0aW9uIC0gcmV0dXJuIGEgZnVuY3Rpb24gd2l0aCByZW1haW5pbmcgcGFyYW1ldGVyc1xuXHRcdFx0Y29uc3QgcmVtYWluaW5nUGFyYW1zID0gZnVuY1R5cGUucGFyYW1zLnNsaWNlKGFyZ1R5cGVzLmxlbmd0aCk7XG5cdFx0XHRjb25zdCBwYXJ0aWFsRnVuY3Rpb25UeXBlID0gZnVuY3Rpb25UeXBlKHJlbWFpbmluZ1BhcmFtcywgcmV0dXJuVHlwZSwgZnVuY1R5cGUuZWZmZWN0cyk7XG5cblx0XHRcdC8vIENSSVRJQ0FMIEZJWDogSGFuZGxlIHBhcnRpYWwgYXBwbGljYXRpb24gb2YgY29tcG9zZVxuXHRcdFx0aWYgKFxuXHRcdFx0XHRleHByLmZ1bmMua2luZCA9PT0gJ3ZhcmlhYmxlJyAmJlxuXHRcdFx0XHRleHByLmZ1bmMubmFtZSA9PT0gJ2NvbXBvc2UnICYmXG5cdFx0XHRcdGV4cHIuYXJncy5sZW5ndGggPj0gMVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnN0IGZBcmcgPSBleHByLmFyZ3NbMF07IC8vIEZpcnN0IGZ1bmN0aW9uXG5cdFx0XHRcdGNvbnN0IGZSZXN1bHQgPSB0eXBlRXhwcmVzc2lvbihmQXJnLCBjdXJyZW50U3RhdGUpO1xuXG5cdFx0XHRcdC8vIElmIGYgaGFzIGNvbnN0cmFpbnRzLCB0aGUgcGFydGlhbCByZXN1bHQgc2hvdWxkIGV2ZW50dWFsbHkgaW5oZXJpdCB0aGVtXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRmUmVzdWx0LnR5cGUua2luZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0XHRcdGZSZXN1bHQudHlwZS5jb25zdHJhaW50cyAmJlxuXHRcdFx0XHRcdHBhcnRpYWxGdW5jdGlvblR5cGUua2luZCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRwYXJ0aWFsRnVuY3Rpb25UeXBlLmNvbnN0cmFpbnRzID0gKFxuXHRcdFx0XHRcdFx0cGFydGlhbEZ1bmN0aW9uVHlwZS5jb25zdHJhaW50cyB8fCBbXVxuXHRcdFx0XHRcdCkuY29uY2F0KGZSZXN1bHQudHlwZS5jb25zdHJhaW50cyk7XG5cblx0XHRcdFx0XHRmb3IgKGNvbnN0IGNvbnN0cmFpbnQgb2YgZlJlc3VsdC50eXBlLmNvbnN0cmFpbnRzKSB7XG5cdFx0XHRcdFx0XHRpZiAoY29uc3RyYWludC5raW5kID09PSAnaXMnKSB7XG5cdFx0XHRcdFx0XHRcdHByb3BhZ2F0ZUNvbnN0cmFpbnRUb1R5cGVWYXJpYWJsZShcblx0XHRcdFx0XHRcdFx0XHRwYXJ0aWFsRnVuY3Rpb25UeXBlLFxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0cmFpbnRcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNyZWF0ZVR5cGVSZXN1bHQocGFydGlhbEZ1bmN0aW9uVHlwZSwgYWxsRWZmZWN0cywgY3VycmVudFN0YXRlKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoZnVuY1R5cGUua2luZCA9PT0gJ3ZhcmlhYmxlJykge1xuXHRcdC8vIElmIGl0J3MgYSB0eXBlIHZhcmlhYmxlLCBjcmVhdGUgYSBmdW5jdGlvbiB0eXBlIGFuZCB1bmlmeVxuXHRcdGlmIChhcmdUeXBlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBjcmVhdGVUeXBlUmVzdWx0KGZ1bmNUeXBlLCBhbGxFZmZlY3RzLCBjdXJyZW50U3RhdGUpO1xuXHRcdH1cblxuXHRcdGNvbnN0IFtwYXJhbVR5cGUsIG5ld1N0YXRlXSA9IGZyZXNoVHlwZVZhcmlhYmxlKGN1cnJlbnRTdGF0ZSk7XG5cdFx0Y3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG5cdFx0Y29uc3QgW3JldHVyblR5cGUsIGZpbmFsU3RhdGVdID0gZnJlc2hUeXBlVmFyaWFibGUoY3VycmVudFN0YXRlKTtcblx0XHRjdXJyZW50U3RhdGUgPSBmaW5hbFN0YXRlO1xuXG5cdFx0Y29uc3QgZnJlc2hGdW5jdGlvblR5cGUgPSBmdW5jdGlvblR5cGUoW3BhcmFtVHlwZV0sIHJldHVyblR5cGUpO1xuXHRcdGN1cnJlbnRTdGF0ZSA9IHVuaWZ5KGZ1bmNUeXBlLCBmcmVzaEZ1bmN0aW9uVHlwZSwgY3VycmVudFN0YXRlLCB7XG5cdFx0XHRsaW5lOiBleHByLmxvY2F0aW9uPy5zdGFydC5saW5lIHx8IDEsXG5cdFx0XHRjb2x1bW46IGV4cHIubG9jYXRpb24/LnN0YXJ0LmNvbHVtbiB8fCAxLFxuXHRcdH0pO1xuXHRcdGN1cnJlbnRTdGF0ZSA9IHVuaWZ5KHBhcmFtVHlwZSwgYXJnVHlwZXNbMF0sIGN1cnJlbnRTdGF0ZSwge1xuXHRcdFx0bGluZTogZXhwci5sb2NhdGlvbj8uc3RhcnQubGluZSB8fCAxLFxuXHRcdFx0Y29sdW1uOiBleHByLmxvY2F0aW9uPy5zdGFydC5jb2x1bW4gfHwgMSxcblx0XHR9KTtcblxuXHRcdHJldHVybiBjcmVhdGVUeXBlUmVzdWx0KFxuXHRcdFx0c3Vic3RpdHV0ZShyZXR1cm5UeXBlLCBjdXJyZW50U3RhdGUuc3Vic3RpdHV0aW9uKSxcblx0XHRcdGFsbEVmZmVjdHMsXG5cdFx0XHRjdXJyZW50U3RhdGVcblx0XHQpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGZvcm1hdFR5cGVFcnJvcihcblx0XHRcdFx0bm9uRnVuY3Rpb25BcHBsaWNhdGlvbkVycm9yKGZ1bmNUeXBlLCB7XG5cdFx0XHRcdFx0bGluZTogZXhwci5sb2NhdGlvbj8uc3RhcnQubGluZSB8fCAxLFxuXHRcdFx0XHRcdGNvbHVtbjogZXhwci5sb2NhdGlvbj8uc3RhcnQuY29sdW1uIHx8IDEsXG5cdFx0XHRcdH0pXG5cdFx0XHQpXG5cdFx0KTtcblx0fVxufTtcblxuLy8gVHlwZSBpbmZlcmVuY2UgZm9yIHBpcGVsaW5lIGV4cHJlc3Npb25zXG5leHBvcnQgY29uc3QgdHlwZVBpcGVsaW5lID0gKFxuXHRleHByOiBQaXBlbGluZUV4cHJlc3Npb24sXG5cdHN0YXRlOiBUeXBlU3RhdGVcbik6IFR5cGVSZXN1bHQgPT4ge1xuXHQvLyBQaXBlbGluZSBzaG91bGQgYmUgZnVuY3Rpb24gY29tcG9zaXRpb24sIG5vdCBmdW5jdGlvbiBhcHBsaWNhdGlvblxuXHQvLyBGb3IgYSBwaXBlbGluZSBsaWtlIGYgfD4gZyB8PiBoLCB3ZSB3YW50IHRvIGNvbXBvc2UgdGhlbSBhcyBoKGcoZih4KSkpXG5cblx0aWYgKGV4cHIuc3RlcHMubGVuZ3RoID09PSAxKSB7XG5cdFx0cmV0dXJuIHR5cGVFeHByZXNzaW9uKGV4cHIuc3RlcHNbMF0sIHN0YXRlKTtcblx0fVxuXG5cdC8vIFN0YXJ0IHdpdGggdGhlIGZpcnN0IGZ1bmN0aW9uIHR5cGVcblx0bGV0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuXHRsZXQgY29tcG9zZWRUeXBlID0gdHlwZUV4cHJlc3Npb24oZXhwci5zdGVwc1swXSwgY3VycmVudFN0YXRlKTtcblx0Y3VycmVudFN0YXRlID0gY29tcG9zZWRUeXBlLnN0YXRlO1xuXHRsZXQgYWxsRWZmZWN0cyA9IGNvbXBvc2VkVHlwZS5lZmZlY3RzO1xuXG5cdC8vIENvbXBvc2Ugd2l0aCBlYWNoIHN1YnNlcXVlbnQgZnVuY3Rpb24gdHlwZVxuXHRmb3IgKGxldCBpID0gMTsgaSA8IGV4cHIuc3RlcHMubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBuZXh0RnVuY1R5cGUgPSB0eXBlRXhwcmVzc2lvbihleHByLnN0ZXBzW2ldLCBjdXJyZW50U3RhdGUpO1xuXHRcdGN1cnJlbnRTdGF0ZSA9IG5leHRGdW5jVHlwZS5zdGF0ZTtcblx0XHRhbGxFZmZlY3RzID0gdW5pb25FZmZlY3RzKGFsbEVmZmVjdHMsIG5leHRGdW5jVHlwZS5lZmZlY3RzKTtcblxuXHRcdGlmIChcblx0XHRcdGNvbXBvc2VkVHlwZS50eXBlLmtpbmQgPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdG5leHRGdW5jVHlwZS50eXBlLmtpbmQgPT09ICdmdW5jdGlvbidcblx0XHQpIHtcblx0XHRcdC8vIENoZWNrIHRoYXQgdGhlIG91dHB1dCBvZiBjb21wb3NlZFR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgb2YgbmV4dEZ1bmNUeXBlXG5cdFx0XHRpZiAobmV4dEZ1bmNUeXBlLnR5cGUucGFyYW1zLmxlbmd0aCAhPT0gMSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0Zm9ybWF0VHlwZUVycm9yKFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb25BcHBsaWNhdGlvbkVycm9yKFxuXHRcdFx0XHRcdFx0XHRuZXh0RnVuY1R5cGUudHlwZS5wYXJhbXNbMF0sXG5cdFx0XHRcdFx0XHRcdG5leHRGdW5jVHlwZS50eXBlLFxuXHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHR1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRsaW5lOiBleHByLmxvY2F0aW9uPy5zdGFydC5saW5lIHx8IDEsXG5cdFx0XHRcdFx0XHRcdFx0Y29sdW1uOiBleHByLmxvY2F0aW9uPy5zdGFydC5jb2x1bW4gfHwgMSxcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Y3VycmVudFN0YXRlID0gdW5pZnkoXG5cdFx0XHRcdGNvbXBvc2VkVHlwZS50eXBlLnJldHVybixcblx0XHRcdFx0bmV4dEZ1bmNUeXBlLnR5cGUucGFyYW1zWzBdLFxuXHRcdFx0XHRjdXJyZW50U3RhdGUsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsaW5lOiBleHByLmxvY2F0aW9uPy5zdGFydC5saW5lIHx8IDEsXG5cdFx0XHRcdFx0Y29sdW1uOiBleHByLmxvY2F0aW9uPy5zdGFydC5jb2x1bW4gfHwgMSxcblx0XHRcdFx0fVxuXHRcdFx0KTtcblxuXHRcdFx0Ly8gVGhlIGNvbXBvc2VkIGZ1bmN0aW9uIHRha2VzIHRoZSBpbnB1dCBvZiB0aGUgZmlyc3QgZnVuY3Rpb24gYW5kIHJldHVybnMgdGhlIG91dHB1dCBvZiB0aGUgbGFzdCBmdW5jdGlvblxuXHRcdFx0Y29tcG9zZWRUeXBlID0gY3JlYXRlVHlwZVJlc3VsdChcblx0XHRcdFx0ZnVuY3Rpb25UeXBlKFxuXHRcdFx0XHRcdFtjb21wb3NlZFR5cGUudHlwZS5wYXJhbXNbMF1dLFxuXHRcdFx0XHRcdG5leHRGdW5jVHlwZS50eXBlLnJldHVyblxuXHRcdFx0XHQpLFxuXHRcdFx0XHRhbGxFZmZlY3RzLFxuXHRcdFx0XHRjdXJyZW50U3RhdGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0YENhbm5vdCBjb21wb3NlIG5vbi1mdW5jdGlvbiB0eXBlcyBpbiBwaXBlbGluZTogJHt0eXBlVG9TdHJpbmcoXG5cdFx0XHRcdFx0Y29tcG9zZWRUeXBlLnR5cGVcblx0XHRcdFx0KX0gYW5kICR7dHlwZVRvU3RyaW5nKG5leHRGdW5jVHlwZS50eXBlKX1gXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjcmVhdGVUeXBlUmVzdWx0KFxuXHRcdHN1YnN0aXR1dGUoY29tcG9zZWRUeXBlLnR5cGUsIGN1cnJlbnRTdGF0ZS5zdWJzdGl0dXRpb24pLFxuXHRcdGFsbEVmZmVjdHMsXG5cdFx0Y3VycmVudFN0YXRlXG5cdCk7XG59OyJdLCJuYW1lcyI6WyJ0eXBlQXBwbGljYXRpb24iLCJ0eXBlUGlwZWxpbmUiLCJ2YWxpZGF0ZUNvbnN0cmFpbnRzIiwiY29udGludWVXaXRoU3BlY2lhbGl6ZWRGdW5jdGlvbiIsImV4cHIiLCJzcGVjaWFsaXplZEZ1bmNUeXBlIiwiYXJnVHlwZXMiLCJhbGxFZmZlY3RzIiwic3RhdGUiLCJjdXJyZW50U3RhdGUiLCJraW5kIiwidGhyb3dUeXBlRXJyb3IiLCJsb2NhdGlvbiIsIm5vbkZ1bmN0aW9uQXBwbGljYXRpb25FcnJvciIsImdldEV4cHJMb2NhdGlvbiIsImZ1bmNUeXBlIiwibGVuZ3RoIiwicGFyYW1zIiwiZnVuY3Rpb25BcHBsaWNhdGlvbkVycm9yIiwidW5kZWZpbmVkIiwiaSIsInVuaWZ5IiwicmVhc29uIiwib3BlcmF0aW9uIiwiaGludCIsInR5cGVUb1N0cmluZyIsInN1YnN0aXR1dGlvbiIsInJlc3VsdFR5cGUiLCJyZXR1cm4iLCJyZW1haW5pbmdQYXJhbXMiLCJzbGljZSIsImZ1bmN0aW9uVHlwZSIsImVmZmVjdHMiLCJmaW5hbEVmZmVjdHMiLCJ1bmlvbkVmZmVjdHMiLCJjcmVhdGVUeXBlUmVzdWx0IiwidHlwZSIsInN1YnN0aXR1dGVkVHlwZSIsInN1YnN0aXR1dGUiLCJjb25zdHJhaW50cyIsImNvbnN0cmFpbnQiLCJwYXJhbSIsImVsZW1lbnQiLCJmaWVsZFR5cGUiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmaWVsZHMiLCJmdW5jUmVzdWx0IiwidHlwZUV4cHJlc3Npb24iLCJmdW5jIiwiYXJnIiwiYXJncyIsImFyZ1Jlc3VsdCIsInB1c2giLCJjb25zdHJhaW50UmVnaXN0cnkiLCJzaXplIiwiaXNEZWZpbmVkSW5Db25zdHJhaW50IiwiY29uc3RyYWludEluZm8iLCJzaWduYXR1cmUiLCJmdW5jdGlvbnMiLCJoYXMiLCJuYW1lIiwiY29uc3RyYWludFJlc29sdXRpb24iLCJ0cnlSZXNvbHZlQ29uc3RyYWludEZ1bmN0aW9uIiwicmVzb2x2ZWQiLCJzcGVjaWFsaXplZE5hbWUiLCJkZWNvcmF0ZWRTdGF0ZSIsImRlY29yYXRlRW52aXJvbm1lbnRXaXRoQ29uc3RyYWludEZ1bmN0aW9ucyIsInNwZWNpYWxpemVkU2NoZW1lIiwiZW52aXJvbm1lbnQiLCJnZXQiLCJpbnN0YW50aWF0ZWRUeXBlIiwibmV3U3RhdGUiLCJpbnN0YW50aWF0ZSIsImZpcnN0QXJnVHlwZSIsImVycm9yTWVzc2FnZSIsImdlbmVyYXRlQ29uc3RyYWludEVycm9yIiwiRXJyb3IiLCJzdWJzdGl0dXRlZFBhcmFtIiwiY29uY3JldGVUeXBlIiwidHlwZVZhciIsInNhdGlzZmllc0NvbnN0cmFpbnQiLCJmb3JtYXRUeXBlRXJyb3IiLCJjcmVhdGVUeXBlRXJyb3IiLCJsaW5lIiwic3RhcnQiLCJjb2x1bW4iLCJzdWJzdGl0dXRlZEFyZyIsInJldHVyblR5cGUiLCJmaW5hbFJldHVyblR5cGUiLCJmQXJnIiwiZlJlc3VsdCIsImVuaGFuY2VkUmV0dXJuVHlwZSIsInVwZGF0ZWRDb25zdHJhaW50cyIsIm5ld0NvbnN0cmFpbnQiLCJpc0NvbnN0cmFpbnQiLCJjb25jYXQiLCJwcm9wYWdhdGVDb25zdHJhaW50VG9UeXBlVmFyaWFibGUiLCJwYXJ0aWFsRnVuY3Rpb25UeXBlIiwicGFyYW1UeXBlIiwiZnJlc2hUeXBlVmFyaWFibGUiLCJmaW5hbFN0YXRlIiwiZnJlc2hGdW5jdGlvblR5cGUiLCJzdGVwcyIsImNvbXBvc2VkVHlwZSIsIm5leHRGdW5jVHlwZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7UUE4S2FBO2VBQUFBOztRQWtiQUM7ZUFBQUE7O1FBL2VBQztlQUFBQTs7O3FCQTFHTjs0QkFNQTt5QkFNQTt1QkFNQTs2QkFNNkI7NEJBQ1Q7dUJBQ0w7Z0NBQ3lCO3NDQUNoQjtzQ0FLeEI7QUFFUCwwRkFBMEY7QUFDMUYsU0FBU0MsZ0NBQ1JDLElBQTJCLEVBQzNCQyxtQkFBeUIsRUFDekJDLFFBQWdCLEVBQ2hCQyxVQUF3QyxFQUN4Q0MsS0FBZ0I7SUFFaEIsSUFBSUMsZUFBZUQ7SUFFbkIsSUFBSUgsb0JBQW9CSyxJQUFJLEtBQUssWUFBWTtRQUM1Q0MsSUFBQUEsdUJBQWMsRUFDYkMsQ0FBQUEsV0FBWUMsSUFBQUEsdUNBQTJCLEVBQUNSLHFCQUFxQk8sV0FDN0RFLElBQUFBLHdCQUFlLEVBQUNWO0lBRWxCO0lBRUEsTUFBTVcsV0FBV1Y7SUFFakIsdUJBQXVCO0lBQ3ZCLElBQUlD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