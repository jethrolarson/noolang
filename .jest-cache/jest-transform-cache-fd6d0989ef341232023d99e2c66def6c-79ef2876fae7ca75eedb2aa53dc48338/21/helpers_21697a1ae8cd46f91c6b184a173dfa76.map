{"version":3,"sources":["/workspace/src/typer/helpers.ts"],"sourcesContent":["import { type Type, functionType, typeVariable, type VariableType, type PrimitiveType, type FunctionType, type ListType, type TupleType, type RecordType, type UnionType, type VariantType, ConstraintExpr, Constraint, IsConstraint, HasFieldConstraint, ImplementsConstraint, CustomConstraint } from \"../ast\";\nimport { formatTypeError } from \"./type-errors\";\nimport { NoolangError } from \"../errors\";\nimport { substitute } from \"./substitute\";\nimport type { Effect } from \"../ast\";\n\ntype CodeLocation = {\n  line: number;\n  column: number;\n};\n\n// Helper: Extract location from expression or provide default\nexport const getExprLocation = (expr: {\n  location?: { start: CodeLocation };\n}): CodeLocation => ({\n  line: expr.location?.start.line || 1,\n  column: expr.location?.start.column || 1,\n});\n\n// Helper: Throw formatted type error with consistent pattern\nexport function throwTypeError(\n  errorFactory: (location: CodeLocation) => NoolangError,\n  location?: CodeLocation\n): never {\n  const loc = location || { line: 1, column: 1 };\n  throw new Error(formatTypeError(errorFactory(loc)));\n}\n\n// Helper: Format effects as string for type display\nexport function formatEffectsString(effects: Set<Effect>): string {\n  if (effects.size === 0) return \"\";\n  return ` ${Array.from(effects).map(e => `!${e}`).join(' ')}`;\n}\n\n// Helper: Create common function types\nexport const createUnaryFunctionType = (\n  paramType: Type,\n  returnType: Type\n): Type => functionType([paramType], returnType);\n\nexport const createBinaryFunctionType = (\n  param1Type: Type,\n  param2Type: Type,\n  returnType: Type\n): Type => functionType([param1Type, param2Type], returnType);\n\n// Helper: Create polymorphic function types with type variables\nexport const createPolymorphicUnaryFunction = (\n  paramVar: string,\n  returnVar: string\n): Type => functionType([typeVariable(paramVar)], typeVariable(returnVar));\n\nexport const createPolymorphicBinaryFunction = (\n  param1Var: string,\n  param2Var: string,\n  returnVar: string\n): Type =>\n  functionType(\n    [typeVariable(param1Var), typeVariable(param2Var)],\n    typeVariable(returnVar)\n  );\n\n\n// Utility: mapObject for mapping over record fields\nexport function mapObject<T, U>(\n  obj: { [k: string]: T },\n  fn: (v: T, k: string) => U,\n): { [k: string]: U } {\n  const result: { [k: string]: U } = {};\n  for (const k in obj) result[k] = fn(obj[k], k);\n  return result;\n}\n\n// Utility: mapSet for immutable Map updates - optimized to avoid copying large maps\nexport function mapSet<K, V>(map: Map<K, V>, key: K, value: V): Map<K, V> {\n  // For performance, avoid copying large maps unnecessarily\n  if (map.has(key) && map.get(key) === value) {\n    return map; // No change needed\n  }\n  const copy = new Map(map);\n  copy.set(key, value);\n  return copy;\n}\n\n// Utility: isTypeKind type guard\nexport function isTypeKind<T extends Type[\"kind\"]>(\n  t: Type,\n  kind: T,\n): t is Extract<Type, { kind: T }> {\n  return t.kind === kind;\n}\n\n\n// Cache for typesEqual to avoid repeated deep comparisons\nconst typesEqualCache = new Map<string, boolean>();\n\n// Check if two types are structurally equal\nexport const typesEqual = (t1: Type, t2: Type): boolean => {\n  // Quick reference equality check\n  if (t1 === t2) return true;\n  \n  if (t1.kind !== t2.kind) {\n    return false;\n  }\n  \n  // Simple cache for primitive/variable types\n  if ((t1.kind === 'primitive' || t1.kind === 'variable') && (t2.kind === 'primitive' || t2.kind === 'variable')) {\n    const key = `${t1.kind}:${(t1 as any).name}-${t2.kind}:${(t2 as any).name}`;\n    let cached = typesEqualCache.get(key);\n    if (cached !== undefined) return cached;\n    \n    const result = typesEqualUncached(t1, t2);\n    if (typesEqualCache.size < 500) {\n      typesEqualCache.set(key, result);\n    }\n    return result;\n  }\n  \n  return typesEqualUncached(t1, t2);\n};\n\nconst typesEqualUncached = (t1: Type, t2: Type): boolean => {\n\n  switch (t1.kind) {\n    case \"variable\":\n      return t1.name === (t2 as VariableType).name;\n\n    case \"primitive\":\n      return t1.name === (t2 as PrimitiveType).name;\n\n    case \"function\": {\n      const f2 = t2 as FunctionType;\n      if (t1.params.length !== f2.params.length) {\n        return false;\n      }\n      return (\n        t1.params.every((param, i) => typesEqual(param, f2.params[i])) &&\n        typesEqual(t1.return, f2.return)\n      );\n    }\n\n    case \"list\":\n      return typesEqual(t1.element, (t2 as ListType).element);\n\n    case \"tuple\": {\n      const t2_tuple = t2 as TupleType;\n      if (t1.elements.length !== t2_tuple.elements.length) {\n        return false;\n      }\n      return t1.elements.every((element, i) =>\n        typesEqual(element, t2_tuple.elements[i]),\n      );\n    }\n\n    case \"record\": {\n      const t2_record = t2 as RecordType;\n      const keys1 = Object.keys(t1.fields);\n      const keys2 = Object.keys(t2_record.fields);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) =>\n        typesEqual(t1.fields[key], t2_record.fields[key]),\n      );\n    }\n\n    case \"union\": {\n      const t2_union = t2 as UnionType;\n      if (t1.types.length !== t2_union.types.length) {\n        return false;\n      }\n      return t1.types.every((type, i) => typesEqual(type, t2_union.types[i]));\n    }\n\n    case \"unit\":\n      return true;\n\n    case \"variant\": {\n      const t2_variant = t2 as VariantType;\n      if (t1.name !== t2_variant.name) {\n        return false;\n      }\n      if (t1.args.length !== t2_variant.args.length) {\n        return false;\n      }\n      return t1.args.every((arg, i) => typesEqual(arg, t2_variant.args[i]));\n    }\n\n    default:\n      return false;\n  }\n};\n\n\n// Efficient type similarity check to avoid JSON.stringify (simplified for constraint comparison)\nexport const typesSimilar = (t1: Type, t2: Type): boolean => {\n\tif (t1.kind !== t2.kind) return false;\n\n\tswitch (t1.kind) {\n\t\tcase \"primitive\":\n\t\t\treturn t1.name === (t2 as PrimitiveType).name;\n\t\tcase \"variable\":\n\t\t\treturn t1.name === (t2 as VariableType).name;\n\t\tcase \"function\": {\n\t\t\tconst t2Func = t2 as FunctionType;\n\t\t\treturn (\n\t\t\t\tt1.params.length === t2Func.params.length &&\n\t\t\t\tt1.params.every((p, i) => typesSimilar(p, t2Func.params[i])) &&\n\t\t\t\ttypesSimilar(t1.return, t2Func.return)\n\t\t\t);\n\t\t}\n\t\tcase \"list\":\n\t\t\treturn typesSimilar(t1.element, (t2 as ListType).element);\n\t\tcase \"record\": {\n\t\t\tconst t2Record = t2 as RecordType;\n\t\t\tconst fields1 = Object.keys(t1.fields);\n\t\t\tconst fields2 = Object.keys(t2Record.fields);\n\t\t\treturn (\n\t\t\t\tfields1.length === fields2.length &&\n\t\t\t\tfields1.every(\n\t\t\t\t\t(f) =>\n\t\t\t\t\t\tf in t2Record.fields &&\n\t\t\t\t\t\ttypesSimilar(t1.fields[f], t2Record.fields[f]),\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\tcase \"tuple\": {\n\t\t\tconst t2Tuple = t2 as TupleType;\n\t\t\treturn (\n\t\t\t\tt1.elements.length === t2Tuple.elements.length &&\n\t\t\t\tt1.elements.every((e, i) => typesSimilar(e, t2Tuple.elements[i]))\n\t\t\t);\n\t\t}\n\t\tcase \"union\": {\n\t\t\tconst t2Union = t2 as UnionType;\n\t\t\treturn (\n\t\t\t\tt1.types.length === t2Union.types.length &&\n\t\t\t\tt1.types.every((type, i) => typesSimilar(type, t2Union.types[i]))\n\t\t\t);\n\t\t}\n\t\tdefault:\n\t\t\treturn false;\n\t}\n};\n\n// Efficient constraint comparison to replace expensive JSON.stringify\nexport const constraintsEqual = (c1: Constraint, c2: Constraint): boolean => {\n\tif (c1.kind !== c2.kind || c1.typeVar !== c2.typeVar) return false;\n\n\tswitch (c1.kind) {\n\t\tcase \"is\":\n\t\t\treturn c1.constraint === (c2 as IsConstraint).constraint;\n\t\tcase \"hasField\": {\n\t\t\tconst c2HasField = c2 as HasFieldConstraint;\n\t\t\treturn (\n\t\t\t\tc1.field === c2HasField.field &&\n\t\t\t\ttypesSimilar(c1.fieldType, c2HasField.fieldType)\n\t\t\t);\n\t\t}\n\t\tcase \"implements\":\n\t\t\treturn c1.interfaceName === (c2 as ImplementsConstraint).interfaceName;\n\t\tcase \"custom\":\n\t\t\treturn c1.constraint === (c2 as CustomConstraint).constraint;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n};\n\n// Helper function to propagate a constraint to matching type variables in a function type\nexport const propagateConstraintToTypeVariable = (\n\tfuncType: Type,\n\tconstraint: Constraint,\n): void => {\n\tif (funcType.kind !== \"function\") return;\n\n\t// Apply constraint to matching type variables in parameters\n\tfor (const param of funcType.params) {\n\t\tif (param.kind === \"variable\" && param.name === constraint.typeVar) {\n\t\t\tif (!param.constraints) {\n\t\t\t\tparam.constraints = [];\n\t\t\t}\n\t\t\t// Check if this constraint is already present\n\t\t\tconst existingConstraint = param.constraints.find((c) =>\n\t\t\t\tconstraintsEqual(c, constraint),\n\t\t\t);\n\t\t\tif (!existingConstraint) {\n\t\t\t\tparam.constraints.push(constraint);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Also apply to return type if it matches\n\tif (\n\t\tfuncType.return.kind === \"variable\" &&\n\t\tfuncType.return.name === constraint.typeVar\n\t) {\n\t\tif (!funcType.return.constraints) {\n\t\t\tfuncType.return.constraints = [];\n\t\t}\n\t\tconst existingConstraint = funcType.return.constraints.find((c) =>\n\t\t\tconstraintsEqual(c, constraint),\n\t\t);\n\t\tif (!existingConstraint) {\n\t\t\tfuncType.return.constraints.push(constraint);\n\t\t}\n\t}\n};\n\n// Utility function to convert type to string\nexport const typeToString = (\n\ttype: Type,\n\tsubstitution: Map<string, Type> = new Map(),\n\tshowConstraints: boolean = true,\n): string => {\n\tconst greek = [\n\t\t\"α\",\n\t\t\"β\",\n\t\t\"γ\",\n\t\t\"δ\",\n\t\t\"ε\",\n\t\t\"ζ\",\n\t\t\"η\",\n\t\t\"θ\",\n\t\t\"ι\",\n\t\t\"κ\",\n\t\t\"λ\",\n\t\t\"μ\",\n\t\t\"ν\",\n\t\t\"ξ\",\n\t\t\"ο\",\n\t\t\"π\",\n\t\t\"ρ\",\n\t\t\"σ\",\n\t\t\"τ\",\n\t\t\"υ\",\n\t\t\"φ\",\n\t\t\"χ\",\n\t\t\"ψ\",\n\t\t\"ω\",\n\t];\n\tconst mapping = new Map<string, string>();\n\tlet next = 0;\n\n\tfunction norm(t: Type): string {\n\t\tswitch (t.kind) {\n\t\t\tcase \"primitive\":\n\t\t\t\treturn t.name;\n\t\t\tcase \"function\": {\n\t\t\t\tconst paramStr = t.params.map(norm).join(\" \");\n\t\t\t\tconst effectStr = formatEffectsString(t.effects);\n\t\t\t\tconst baseType = `(${paramStr}) -> ${norm(t.return)}${effectStr}`;\n\n\t\t\t\tconst constraintStr =\n\t\t\t\t\tshowConstraints && t.constraints && t.constraints.length > 0\n\t\t\t\t\t\t? ` given ${\n\t\t\t\t\t\t\t\t(t as any).originalConstraint\n\t\t\t\t\t\t\t\t\t? formatConstraintExpr((t as any).originalConstraint)\n\t\t\t\t\t\t\t\t\t: deduplicateConstraints(t.constraints)\n\t\t\t\t\t\t\t\t\t\t\t.map(formatConstraint)\n\t\t\t\t\t\t\t\t\t\t\t.join(\" \")\n\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t: \"\";\n\t\t\t\treturn constraintStr ? `${baseType}${constraintStr}` : baseType;\n\t\t\t}\n\t\t\tcase \"variable\": {\n\t\t\t\tlet varStr = \"\";\n\t\t\t\tif (!mapping.has(t.name)) {\n\t\t\t\t\t// If the type variable name is a single letter, keep it as-is\n\t\t\t\t\t// This preserves explicit type annotations like 'a -> a'\n\t\t\t\t\tif (t.name.length === 1 && /^[a-z]$/.test(t.name)) {\n\t\t\t\t\t\tmapping.set(t.name, t.name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmapping.set(t.name, greek[next] || `t${next}`);\n\t\t\t\t\t\tnext++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: it's set if not defined above\n\t\t\t\tvarStr = mapping.get(t.name)!;\n\n\t\t\t\treturn varStr;\n\t\t\t}\n\t\t\tcase \"list\":\n\t\t\t\treturn `List ${norm(t.element)}`;\n\t\t\tcase \"tuple\":\n\t\t\t\treturn `(${t.elements.map(norm).join(\" \")})`;\n\t\t\tcase \"record\":\n\t\t\t\treturn `{ ${Object.entries(t.fields)\n\t\t\t\t\t.map(([name, fieldType]) => `${name}: ${norm(fieldType)}`)\n\t\t\t\t\t.join(\" \")} }`;\n\t\t\tcase \"union\":\n\t\t\t\treturn `(${t.types.map(norm).join(\" | \")})`;\n\t\t\tcase \"variant\":\n\t\t\t\tif (t.args.length === 0) {\n\t\t\t\t\treturn t.name;\n\t\t\t\t} else {\n\t\t\t\t\treturn `${t.name} ${t.args.map(norm).join(\" \")}`;\n\t\t\t\t}\n\t\t\tcase \"unit\":\n\t\t\t\treturn \"unit\";\n\t\t\tcase \"unknown\":\n\t\t\t\treturn \"?\";\n\t\t\tdefault:\n\t\t\t\treturn \"unknown\";\n\t\t}\n\t}\n\n\tfunction formatConstraint(c: Constraint): string {\n\t\tswitch (c.kind) {\n\t\t\tcase \"is\": {\n\t\t\t\t// Use the normalized variable name for consistency\n\t\t\t\tconst normalizedVarName = mapping.get(c.typeVar) || c.typeVar;\n\t\t\t\treturn `${normalizedVarName} is ${c.constraint}`;\n\t\t\t}\n\t\t\tcase \"hasField\": {\n\t\t\t\t// For hasField constraints, we need to use the normalized variable name\n\t\t\t\t// that matches the parameter it's constraining\n\t\t\t\tconst normalizedVarName2 = mapping.get(c.typeVar) || c.typeVar;\n\t\t\t\treturn `${normalizedVarName2} has field \"${c.field}\" of type ${norm(\n\t\t\t\t\tc.fieldType,\n\t\t\t\t)}`;\n\t\t\t}\n\t\t\tcase \"implements\": {\n\t\t\t\tconst normalizedVarName3 = mapping.get(c.typeVar) || c.typeVar;\n\t\t\t\treturn `${normalizedVarName3} implements ${c.interfaceName}`;\n\t\t\t}\n\t\t\tcase \"custom\": {\n\t\t\t\tconst normalizedVarName4 = mapping.get(c.typeVar) || c.typeVar;\n\t\t\t\treturn `${normalizedVarName4} satisfies ${c.constraint} ${c.args\n\t\t\t\t\t.map(norm)\n\t\t\t\t\t.join(\" \")}`;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn \"unknown constraint\";\n\t\t}\n\t}\n\n\tfunction formatConstraintExpr(expr: ConstraintExpr): string {\n\t\tswitch (expr.kind) {\n\t\t\tcase \"is\":\n\t\t\tcase \"hasField\":\n\t\t\tcase \"implements\":\n\t\t\tcase \"custom\":\n\t\t\t\treturn formatConstraint(expr);\n\t\t\tcase \"and\":\n\t\t\t\treturn `${formatConstraintExpr(expr.left)} and ${formatConstraintExpr(\n\t\t\t\t\texpr.right,\n\t\t\t\t)}`;\n\t\t\tcase \"or\":\n\t\t\t\treturn `${formatConstraintExpr(expr.left)} or ${formatConstraintExpr(\n\t\t\t\t\texpr.right,\n\t\t\t\t)}`;\n\t\t\tcase \"paren\":\n\t\t\t\treturn `(${formatConstraintExpr(expr.expr)})`;\n\t\t\tdefault:\n\t\t\t\treturn \"unknown constraint\";\n\t\t}\n\t}\n\n\t// Helper function to deduplicate constraints\n\tfunction deduplicateConstraints(constraints: Constraint[]): Constraint[] {\n\t\tconst result: Constraint[] = [];\n\n\t\tfor (const constraint of constraints) {\n\t\t\tconst isDuplicate = result.some((c) => constraintsEqual(c, constraint));\n\t\t\tif (!isDuplicate) {\n\t\t\t\tresult.push(constraint);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// Apply substitution to the type before normalizing\n\tconst substitutedType = substitute(type, substitution);\n\treturn norm(substitutedType);\n};\n\n// Check if a type variable occurs in a type (for occurs check)\nexport const occursIn = (varName: string, type: Type): boolean => {\n\tswitch (type.kind) {\n\t\tcase \"variable\":\n\t\t\treturn type.name === varName;\n\t\tcase \"function\":\n\t\t\treturn (\n\t\t\t\ttype.params.some((param) => occursIn(varName, param)) ||\n\t\t\t\toccursIn(varName, type.return)\n\t\t\t);\n\t\tcase \"list\":\n\t\t\treturn occursIn(varName, type.element);\n\t\tcase \"tuple\":\n\t\t\treturn type.elements.some((element) => occursIn(varName, element));\n\t\tcase \"record\":\n\t\t\treturn Object.values(type.fields).some((fieldType) =>\n\t\t\t\toccursIn(varName, fieldType),\n\t\t\t);\n\t\tcase \"union\":\n\t\t\treturn type.types.some((t) => occursIn(varName, t));\n\t\tcase \"variant\":\n\t\t\treturn type.args.some((arg) => occursIn(varName, arg));\n\t\tdefault:\n\t\t\treturn false;\n\t}\n};"],"names":["constraintsEqual","createBinaryFunctionType","createPolymorphicBinaryFunction","createPolymorphicUnaryFunction","createUnaryFunctionType","formatEffectsString","getExprLocation","isTypeKind","mapObject","mapSet","occursIn","propagateConstraintToTypeVariable","throwTypeError","typeToString","typesEqual","typesSimilar","expr","line","location","start","column","errorFactory","loc","Error","formatTypeError","effects","size","Array","from","map","e","join","paramType","returnType","functionType","param1Type","param2Type","paramVar","returnVar","typeVariable","param1Var","param2Var","obj","fn","result","k","key","value","has","get","copy","Map","set","t","kind","typesEqualCache","t1","t2","name","cached","undefined","typesEqualUncached","f2","params","length","every","param","i","return","element","t2_tuple","elements","t2_record","keys1","Object","keys","fields","keys2","t2_union","types","type","t2_variant","args","arg","t2Func","p","t2Record","fields1","fields2","f","t2Tuple","t2Union","c1","c2","typeVar","constraint","c2HasField","field","fieldType","interfaceName","funcType","constraints","existingConstraint","find","c","push","substitution","showConstraints","greek","mapping","next","norm","paramStr","effectStr","baseType","constraintStr","originalConstraint","formatConstraintExpr","deduplicateConstraints","formatConstraint","varStr","test","entries","normalizedVarName","normalizedVarName2","normalizedVarName3","normalizedVarName4","left","right","isDuplicate","some","substitutedType","substitute","varName","values"],"mappings":";;;;;;;;;;;QAsPaA;eAAAA;;QA9MAC;eAAAA;;QAYAC;eAAAA;;QALAC;eAAAA;;QAZAC;eAAAA;;QANGC;eAAAA;;QAjBHC;eAAAA;;QAyEGC;eAAAA;;QArBAC;eAAAA;;QAUAC;eAAAA;;QAoZHC;eAAAA;;QAjNAC;eAAAA;;QAzPGC;eAAAA;;QAiSHC;eAAAA;;QApNAC;eAAAA;;QAkGAC;eAAAA;;;qBAnM2R;4BACxQ;4BAEL;AASpB,MAAMT,kBAAkB,CAACU,OAEX,CAAA;QACnBC,MAAMD,KAAKE,QAAQ,EAAEC,MAAMF,QAAQ;QACnCG,QAAQJ,KAAKE,QAAQ,EAAEC,MAAMC,UAAU;IACzC,CAAA;AAGO,SAASR,eACdS,YAAsD,EACtDH,QAAuB;IAEvB,MAAMI,MAAMJ,YAAY;QAAED,MAAM;QAAGG,QAAQ;IAAE;IAC7C,MAAM,IAAIG,MAAMC,IAAAA,2BAAe,EAACH,aAAaC;AAC/C;AAGO,SAASjB,oBAAoBoB,OAAoB;IACtD,IAAIA,QAAQC,IAAI,KAAK,GAAG,OAAO;IAC/B,OAAO,CAAC,CAAC,EAAEC,MAAMC,IAAI,CAACH,SAASI,GAAG,CAACC,CAAAA,IAAK,CAAC,CAAC,EAAEA,GAAG,EAAEC,IAAI,CAAC,MAAM;AAC9D;AAGO,MAAM3B,0BAA0B,CACrC4B,WACAC,aACSC,IAAAA,iBAAY,EAAC;QAACF;KAAU,EAAEC;AAE9B,MAAMhC,2BAA2B,CACtCkC,YACAC,YACAH,aACSC,IAAAA,iBAAY,EAAC;QAACC;QAAYC;KAAW,EAAEH;AAG3C,MAAM9B,iCAAiC,CAC5CkC,UACAC,YACSJ,IAAAA,iBAAY,EAAC;QAACK,IAAAA,iBAAY,EAACF;KAAU,EAAEE,IAAAA,iBAAY,EAACD;AAExD,MAAMpC,kCAAkC,CAC7CsC,WACAC,WACAH,YAEAJ,IAAAA,iBAAY,EACV;QAACK,IAAAA,iBAAY,EAACC;QAAYD,IAAAA,iBAAY,EAACE;KAAW,EAClDF,IAAAA,iBAAY,EAACD;AAKV,SAAS9B,UACdkC,GAAuB,EACvBC,EAA0B;IAE1B,MAAMC,SAA6B,CAAC;IACpC,IAAK,MAAMC,KAAKH,IAAKE,MAAM,CAACC,EAAE,GAAGF,GAAGD,GAAG,CAACG,EAAE,EAAEA;IAC5C,OAAOD;AACT;AAGO,SAASnC,OAAaoB,GAAc,EAAEiB,GAAM,EAAEC,KAAQ;IAC3D,0DAA0D;IAC1D,IAAIlB,IAAImB,GAAG,CAACF,QAAQjB,IAAIoB,GAAG,CAACH,SAASC,OAAO;QAC1C,OAAOlB,KAAK,mBAAmB;IACjC;IACA,MAAMqB,OAAO,IAAIC,IAAItB;IACrBqB,KAAKE,GAAG,CAACN,KAAKC;IACd,OAAOG;AACT;AAGO,SAAS3C,WACd8C,CAAO,EACPC,IAAO;IAEP,OAAOD,EAAEC,IAAI,KAAKA;AACpB;AAGA,0DAA0D;AAC1D,MAAMC,kBAAkB,IAAIJ;AAGrB,MAAMrC,aAAa,CAAC0C,IAAUC;IACnC,iCAAiC;IACjC,IAAID,OAAOC,IAAI,OAAO;IAEtB,IAAID,GAAGF,IAAI,KAAKG,GAAGH,IAAI,EAAE;QACvB,OAAO;IACT;IAEA,4CAA4C;IAC5C,IAAI,AAACE,CAAAA,GAAGF,IAAI,KAAK,eAAeE,GAAGF,IAAI,KAAK,UAAS,KAAOG,CAAAA,GAAGH,IAAI,KAAK,eAAeG,GAAGH,IAAI,KAAK,UAAS,GAAI;QAC9G,MAAMR,MAAM,GAAGU,GAAGF,IAAI,CAAC,CAAC,EAAE,AAACE,GAAWE,IAAI,CAAC,CAAC,EAAED,GAAGH,IAAI,CAAC,CAAC,EAAE,AAACG,GAAWC,IAAI,EAAE;QAC3E,IAAIC,SAASJ,gBAAgBN,GAAG,CAACH;QACjC,IAAIa,WAAWC,WAAW,OAAOD;QAEjC,MAAMf,SAASiB,mBAAmBL,IAAIC;QACtC,IAAIF,gBAAgB7B,IAAI,GAAG,KAAK;YAC9B6B,gBAAgBH,GAAG,CAACN,KAAKF;QAC3B;QACA,OAAOA;IACT;IAEA,OAAOiB,mBAAmBL,IAAIC;AAChC;AAEA,MAAMI,qBAAqB,CAACL,IAAUC;IAEpC,OAAQD,GAAGF,IAAI;QACb,KAAK;YACH,OAAOE,GAAGE,IAAI,KAAK,AAACD,GAAoBC,IAAI;QAE9C,KAAK;YACH,OAAOF,GAAGE,IAAI,KAAK,AAACD,GAAqBC,IAAI;QAE/C,KAAK;YAAY;gBACf,MAAMI,KAAKL;gBACX,IAAID,GAAGO,MAAM,CAACC,MAAM,KAAKF,GAAGC,MAAM,CAACC,MAAM,EAAE;oBACzC,OAAO;gBACT;gBACA,OACER,GAAGO,MAAM,CAACE,KAAK,CAAC,CAACC,OAAOC,IAAMrD,WAAWoD,OAAOJ,GAAGC,MAAM,CAACI,EAAE,MAC5DrD,WAAW0C,GAAGY,MAAM,EAAEN,GAAGM,MAAM;YAEnC;QAEA,KAAK;YACH,OAAOtD,WAAW0C,GAAGa,OAAO,EAAE,AAACZ,GAAgBY,OAAO;QAExD,KAAK;YAAS;gBACZ,MAAMC,WAAWb;gBACjB,IAAID,GAAGe,QAAQ,CAACP,MAAM,KAAKM,SAASC,QAAQ,CAACP,MAAM,EAAE;oBACnD,OAAO;gBACT;gBACA,OAAOR,GAAGe,QAAQ,CAACN,KAAK,CAAC,CAACI,SAASF,IACjCrD,WAAWuD,SAASC,SAASC,QAAQ,CAACJ,EAAE;YAE5C;QAEA,KAAK;YAAU;gBACb,MAAMK,YAAYf;gBAClB,MAAMgB,QAAQC,OAAOC,IAAI,CAACnB,GAAGoB,MAAM;gBACnC,MAAMC,QAAQH,OAAOC,IAAI,CAACH,UAAUI,MAAM;gBAC1C,IAAIH,MAAMT,MAAM,KAAKa,MAAMb,MAAM,EAAE;oBACjC,OAAO;gBACT;gBACA,OAAOS,MAAMR,KAAK,CAAC,CAACnB,MAClBhC,WAAW0C,GAAGoB,MAAM,CAAC9B,IAAI,EAAE0B,UAAUI,MAAM,CAAC9B,IAAI;YAEpD;QAEA,KAAK;YAAS;gBACZ,MAAMgC,WAAWrB;gBACjB,IAAID,GAAGuB,KAAK,CAACf,MAAM,KAAKc,SAASC,KAAK,CAACf,MAAM,EAAE;oBAC7C,OAAO;gBACT;gBACA,OAAOR,GAAGuB,KAAK,CAACd,KAAK,CAAC,CAACe,MAAMb,IAAMrD,WAAWkE,MAAMF,SAASC,KAAK,CAACZ,EAAE;YACvE;QAEA,KAAK;YACH,OAAO;QAET,KAAK;YAAW;gBACd,MAAMc,aAAaxB;gBACnB,IAAID,GAAGE,IAAI,KAAKuB,WAAWvB,IAAI,EAAE;oBAC/B,OAAO;gBACT;gBACA,IAAIF,GAAG0B,IAAI,CAAClB,MAAM,KAAKiB,WAAWC,IAAI,CAAClB,MAAM,EAAE;oBAC7C,OAAO;gBACT;gBACA,OAAOR,GAAG0B,IAAI,CAACjB,KAAK,CAAC,CAACkB,KAAKhB,IAAMrD,WAAWqE,KAAKF,WAAWC,IAAI,CAACf,EAAE;YACrE;QAEA;YACE,OAAO;IACX;AACF;AAIO,MAAMpD,eAAe,CAACyC,IAAUC;IACtC,IAAID,GAAGF,IAAI,KAAKG,GAAGH,IAAI,EAAE,OAAO;IAEhC,OAAQE,GAAGF,IAAI;QACd,KAAK;YACJ,OAAOE,GAAGE,IAAI,KAAK,AAACD,GAAqBC,IAAI;QAC9C,KAAK;YACJ,OAAOF,GAAGE,IAAI,KAAK,AAACD,GAAoBC,IAAI;QAC7C,KAAK;YAAY;gBAChB,MAAM0B,SAAS3B;gBACf,OACCD,GAAGO,MAAM,CAACC,MAAM,KAAKoB,OAAOrB,MAAM,CAACC,MAAM,IACzCR,GAAGO,MAAM,CAACE,KAAK,CAAC,CAACoB,GAAGlB,IAAMpD,aAAasE,GAAGD,OAAOrB,MAAM,CAACI,EAAE,MAC1DpD,aAAayC,GAAGY,MAAM,EAAEgB,OAAOhB,MAAM;YAEvC;QACA,KAAK;YACJ,OAAOrD,aAAayC,GAAGa,OAAO,EAAE,AAACZ,GAAgBY,OAAO;QACzD,KAAK;YAAU;gBACd,MAAMiB,WAAW7B;gBACjB,MAAM8B,UAAUb,OAAOC,IAAI,CAACnB,GAAGoB,MAAM;gBACrC,MAAMY,UAAUd,OAAOC,IAAI,CAACW,SAASV,MAAM;gBAC3C,OACCW,QAAQvB,MAAM,KAAKwB,QAAQxB,MAAM,IACjCuB,QAAQtB,KAAK,CACZ,CAACwB,IACAA,KAAKH,SAASV,MAAM,IACpB7D,aAAayC,GAAGoB,MAAM,CAACa,EAAE,EAAEH,SAASV,MAAM,CAACa,EAAE;YAGjD;QACA,KAAK;YAAS;gBACb,MAAMC,UAAUjC;gBAChB,OACCD,GAAGe,QAAQ,CAACP,MAAM,KAAK0B,QAAQnB,QAAQ,CAACP,MAAM,IAC9CR,GAAGe,QAAQ,CAACN,KAAK,CAAC,CAACnC,GAAGqC,IAAMpD,aAAae,GAAG4D,QAAQnB,QAAQ,CAACJ,EAAE;YAEjE;QACA,KAAK;YAAS;gBACb,MAAMwB,UAAUlC;gBAChB,OACCD,GAAGuB,KAAK,CAACf,MAAM,KAAK2B,QAAQZ,KAAK,CAACf,MAAM,IACxCR,GAAGuB,KAAK,CAACd,KAAK,CAAC,CAACe,MAAMb,IAAMpD,aAAaiE,MAAMW,QAAQZ,KAAK,CAACZ,EAAE;YAEjE;QACA;YACC,OAAO;IACT;AACD;AAGO,MAAMnE,mBAAmB,CAAC4F,IAAgBC;IAChD,IAAID,GAAGtC,IAAI,KAAKuC,GAAGvC,IAAI,IAAIsC,GAAGE,OAAO,KAAKD,GAAGC,OAAO,EAAE,OAAO;IAE7D,OAAQF,GAAGtC,IAAI;QACd,KAAK;YACJ,OAAOsC,GAAGG,UAAU,KAAK,AAACF,GAAoBE,UAAU;QACzD,KAAK;YAAY;gBAChB,MAAMC,aAAaH;gBACnB,OACCD,GAAGK,KAAK,KAAKD,WAAWC,KAAK,IAC7BlF,aAAa6E,GAAGM,SAAS,EAAEF,WAAWE,SAAS;YAEjD;QACA,KAAK;YACJ,OAAON,GAAGO,aAAa,KAAK,AAACN,GAA4BM,aAAa;QACvE,KAAK;YACJ,OAAOP,GAAGG,UAAU,KAAK,AAACF,GAAwBE,UAAU;QAC7D;YACC,OAAO;IACT;AACD;AAGO,MAAMpF,oCAAoC,CAChDyF,UACAL;IAEA,IAAIK,SAAS9C,IAAI,KAAK,YAAY;IAElC,4DAA4D;IAC5D,KAAK,MAAMY,SAASkC,SAASrC,MAAM,CAAE;QACpC,IAAIG,MAAMZ,IAAI,KAAK,cAAcY,MAAMR,IAAI,KAAKqC,WAAWD,OAAO,EAAE;YACnE,IAAI,CAAC5B,MAAMmC,WAAW,EAAE;gBACvBnC,MAAMmC,WAAW,GAAG,EAAE;YACvB;YACA,8CAA8C;YAC9C,MAAMC,qBAAqBpC,MAAMmC,WAAW,CAACE,IAAI,CAAC,CAACC,IAClDxG,iBAAiBwG,GAAGT;YAErB,IAAI,CAACO,oBAAoB;gBACxBpC,MAAMmC,WAAW,CAACI,IAAI,CAACV;YACxB;QACD;IACD;IAEA,0CAA0C;IAC1C,IACCK,SAAShC,MAAM,CAACd,IAAI,KAAK,cACzB8C,SAAShC,MAAM,CAACV,IAAI,KAAKqC,WAAWD,OAAO,EAC1C;QACD,IAAI,CAACM,SAAShC,MAAM,CAACiC,WAAW,EAAE;YACjCD,SAAShC,MAAM,CAACiC,WAAW,GAAG,EAAE;QACjC;QACA,MAAMC,qBAAqBF,SAAShC,MAAM,CAACiC,WAAW,CAACE,IAAI,CAAC,CAACC,IAC5DxG,iBAAiBwG,GAAGT;QAErB,IAAI,CAACO,oBAAoB;YACxBF,SAAShC,MAAM,CAACiC,WAAW,CAACI,IAAI,CAACV;QAClC;IACD;AACD;AAGO,MAAMlF,eAAe,CAC3BmE,MACA0B,eAAkC,IAAIvD,KAAK,EAC3CwD,kBAA2B,IAAI;IAE/B,MAAMC,QAAQ;QACb;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACA;IACD,MAAMC,UAAU,IAAI1D;IACpB,IAAI2D,OAAO;IAEX,SAASC,KAAK1D,CAAO;QACpB,OAAQA,EAAEC,IAAI;YACb,KAAK;gBACJ,OAAOD,EAAEK,IAAI;YACd,KAAK;gBAAY;oBAChB,MAAMsD,WAAW3D,EAAEU,MAAM,CAAClC,GAAG,CAACkF,MAAMhF,IAAI,CAAC;oBACzC,MAAMkF,YAAY5G,oBAAoBgD,EAAE5B,OAAO;oBAC/C,MAAMyF,WAAW,CAAC,CAAC,EAAEF,SAAS,KAAK,EAAED,KAAK1D,EAAEe,MAAM,IAAI6C,WAAW;oBAEjE,MAAME,gBACLR,mBAAmBtD,EAAEgD,WAAW,IAAIhD,EAAEgD,WAAW,CAACrC,MAAM,GAAG,IACxD,CAAC,OAAO,EACR,AAACX,EAAU+D,kBAAkB,GAC1BC,qBAAqB,AAAChE,EAAU+D,kBAAkB,IAClDE,uBAAuBjE,EAAEgD,WAAW,EACnCxE,GAAG,CAAC0F,kBACJxF,IAAI,CAAC,MACR,GACD;oBACJ,OAAOoF,gBAAgB,GAAGD,WAAWC,eAAe,GAAGD;gBACxD;YACA,KAAK;gBAAY;oBAChB,IAAIM,SAAS;oBACb,IAAI,CAACX,QAAQ7D,GAAG,CAACK,EAAEK,IAAI,GAAG;wBACzB,8DAA8D;wBAC9D,yDAAyD;wBACzD,IAAIL,EAAEK,IAAI,CAACM,MAAM,KAAK,KAAK,UAAUyD,IAAI,CAACpE,EAAEK,IAAI,GAAG;4BAClDmD,QAAQzD,GAAG,CAACC,EAAEK,IAAI,EAAEL,EAAEK,IAAI;wBAC3B,OAAO;4BACNmD,QAAQzD,GAAG,CAACC,EAAEK,IAAI,EAAEkD,KAAK,CAACE,KAAK,IAAI,CAAC,CAAC,EAAEA,MAAM;4BAC7CA;wBACD;oBACD;oBACA,4EAA4E;oBAC5EU,SAASX,QAAQ5D,GAAG,CAACI,EAAEK,IAAI;oBAE3B,OAAO8D;gBACR;YACA,KAAK;gBACJ,OAAO,CAAC,KAAK,EAAET,KAAK1D,EAAEgB,OAAO,GAAG;YACjC,KAAK;gBACJ,OAAO,CAAC,CAAC,EAAEhB,EAAEkB,QAAQ,CAAC1C,GAAG,CAACkF,MAAMhF,IAAI,CAAC,KAAK,CAAC,CAAC;YAC7C,KAAK;gBACJ,OAAO,CAAC,EAAE,EAAE2C,OAAOgD,OAAO,CAACrE,EAAEuB,MAAM,EACjC/C,GAAG,CAAC,CAAC,CAAC6B,MAAMwC,UAAU,GAAK,GAAGxC,KAAK,EAAE,EAAEqD,KAAKb,YAAY,EACxDnE,IAAI,CAAC,KAAK,EAAE,CAAC;YAChB,KAAK;gBACJ,OAAO,CAAC,CAAC,EAAEsB,EAAE0B,KAAK,CAAClD,GAAG,CAACkF,MAAMhF,IAAI,CAAC,OAAO,CAAC,CAAC;YAC5C,KAAK;gBACJ,IAAIsB,EAAE6B,IAAI,CAAClB,MAAM,KAAK,GAAG;oBACxB,OAAOX,EAAEK,IAAI;gBACd,OAAO;oBACN,OAAO,GAAGL,EAAEK,IAAI,CAAC,CAAC,EAAEL,EAAE6B,IAAI,CAACrD,GAAG,CAACkF,MAAMhF,IAAI,CAAC,MAAM;gBACjD;YACD,KAAK;gBACJ,OAAO;YACR,KAAK;gBACJ,OAAO;YACR;gBACC,OAAO;QACT;IACD;IAEA,SAASwF,iBAAiBf,CAAa;QACtC,OAAQA,EAAElD,IAAI;YACb,KAAK;gBAAM;oBACV,mDAAmD;oBACnD,MAAMqE,oBAAoBd,QAAQ5D,GAAG,CAACuD,EAAEV,OAAO,KAAKU,EAAEV,OAAO;oBAC7D,OAAO,GAAG6B,kBAAkB,IAAI,EAAEnB,EAAET,UAAU,EAAE;gBACjD;YACA,KAAK;gBAAY;oBAChB,wEAAwE;oBACxE,+CAA+C;oBAC/C,MAAM6B,qBAAqBf,QAAQ5D,GAAG,CAACuD,EAAEV,OAAO,KAAKU,EAAEV,OAAO;oBAC9D,OAAO,GAAG8B,mBAAmB,YAAY,EAAEpB,EAAEP,KAAK,CAAC,UAAU,EAAEc,KAC9DP,EAAEN,SAAS,GACT;gBACJ;YACA,KAAK;gBAAc;oBAClB,MAAM2B,qBAAqBhB,QAAQ5D,GAAG,CAACuD,EAAEV,OAAO,KAAKU,EAAEV,OAAO;oBAC9D,OAAO,GAAG+B,mBAAmB,YAAY,EAAErB,EAAEL,aAAa,EAAE;gBAC7D;YACA,KAAK;gBAAU;oBACd,MAAM2B,qBAAqBjB,QAAQ5D,GAAG,CAACuD,EAAEV,OAAO,KAAKU,EAAEV,OAAO;oBAC9D,OAAO,GAAGgC,mBAAmB,WAAW,EAAEtB,EAAET,UAAU,CAAC,CAAC,EAAES,EAAEtB,IAAI,CAC9DrD,GAAG,CAACkF,MACJhF,IAAI,CAAC,MAAM;gBACd;YACA;gBACC,OAAO;QACT;IACD;IAEA,SAASsF,qBAAqBrG,IAAoB;QACjD,OAAQA,KAAKsC,IAAI;YAChB,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;gBACJ,OAAOiE,iBAAiBvG;YACzB,KAAK;gBACJ,OAAO,GAAGqG,qBAAqBrG,KAAK+G,IAAI,EAAE,KAAK,EAAEV,qBAChDrG,KAAKgH,KAAK,GACR;YACJ,KAAK;gBACJ,OAAO,GAAGX,qBAAqBrG,KAAK+G,IAAI,EAAE,IAAI,EAAEV,qBAC/CrG,KAAKgH,KAAK,GACR;YACJ,KAAK;gBACJ,OAAO,CAAC,CAAC,EAAEX,qBAAqBrG,KAAKA,IAAI,EAAE,CAAC,CAAC;YAC9C;gBACC,OAAO;QACT;IACD;IAEA,6CAA6C;IAC7C,SAASsG,uBAAuBjB,WAAyB;QACxD,MAAMzD,SAAuB,EAAE;QAE/B,KAAK,MAAMmD,cAAcM,YAAa;YACrC,MAAM4B,cAAcrF,OAAOsF,IAAI,CAAC,CAAC1B,IAAMxG,iBAAiBwG,GAAGT;YAC3D,IAAI,CAACkC,aAAa;gBACjBrF,OAAO6D,IAAI,CAACV;YACb;QACD;QAEA,OAAOnD;IACR;IAEA,oDAAoD;IACpD,MAAMuF,kBAAkBC,IAAAA,sBAAU,EAACpD,MAAM0B;IACzC,OAAOK,KAAKoB;AACb;AAGO,MAAMzH,WAAW,CAAC2H,SAAiBrD;IACzC,OAAQA,KAAK1B,IAAI;QAChB,KAAK;YACJ,OAAO0B,KAAKtB,IAAI,KAAK2E;QACtB,KAAK;YACJ,OACCrD,KAAKjB,MAAM,CAACmE,IAAI,CAAC,CAAChE,QAAUxD,SAAS2H,SAASnE,WAC9CxD,SAAS2H,SAASrD,KAAKZ,MAAM;QAE/B,KAAK;YACJ,OAAO1D,SAAS2H,SAASrD,KAAKX,OAAO;QACtC,KAAK;YACJ,OAAOW,KAAKT,QAAQ,CAAC2D,IAAI,CAAC,CAAC7D,UAAY3D,SAAS2H,SAAShE;QAC1D,KAAK;YACJ,OAAOK,OAAO4D,MAAM,CAACtD,KAAKJ,MAAM,EAAEsD,IAAI,CAAC,CAAChC,YACvCxF,SAAS2H,SAASnC;QAEpB,KAAK;YACJ,OAAOlB,KAAKD,KAAK,CAACmD,IAAI,CAAC,CAAC7E,IAAM3C,SAAS2H,SAAShF;QACjD,KAAK;YACJ,OAAO2B,KAAKE,IAAI,CAACgD,IAAI,CAAC,CAAC/C,MAAQzE,SAAS2H,SAASlD;QAClD;YACC,OAAO;IACT;AACD"}