cbc1aa6d83b95e70f440a7994b337f2e
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get constraintsEqual () {
        return constraintsEqual;
    },
    get createBinaryFunctionType () {
        return createBinaryFunctionType;
    },
    get createPolymorphicBinaryFunction () {
        return createPolymorphicBinaryFunction;
    },
    get createPolymorphicUnaryFunction () {
        return createPolymorphicUnaryFunction;
    },
    get createUnaryFunctionType () {
        return createUnaryFunctionType;
    },
    get formatEffectsString () {
        return formatEffectsString;
    },
    get getExprLocation () {
        return getExprLocation;
    },
    get isTypeKind () {
        return isTypeKind;
    },
    get mapObject () {
        return mapObject;
    },
    get mapSet () {
        return mapSet;
    },
    get occursIn () {
        return occursIn;
    },
    get propagateConstraintToTypeVariable () {
        return propagateConstraintToTypeVariable;
    },
    get throwTypeError () {
        return throwTypeError;
    },
    get typeToString () {
        return typeToString;
    },
    get typesEqual () {
        return typesEqual;
    },
    get typesSimilar () {
        return typesSimilar;
    }
});
const _ast = require("../ast");
const _typeerrors = require("./type-errors");
const _substitute = require("./substitute");
const getExprLocation = (expr)=>({
        line: expr.location?.start.line || 1,
        column: expr.location?.start.column || 1
    });
function throwTypeError(errorFactory, location) {
    const loc = location || {
        line: 1,
        column: 1
    };
    throw new Error((0, _typeerrors.formatTypeError)(errorFactory(loc)));
}
function formatEffectsString(effects) {
    if (effects.size === 0) return "";
    return ` ${Array.from(effects).map((e)=>`!${e}`).join(' ')}`;
}
const createUnaryFunctionType = (paramType, returnType)=>(0, _ast.functionType)([
        paramType
    ], returnType);
const createBinaryFunctionType = (param1Type, param2Type, returnType)=>(0, _ast.functionType)([
        param1Type,
        param2Type
    ], returnType);
const createPolymorphicUnaryFunction = (paramVar, returnVar)=>(0, _ast.functionType)([
        (0, _ast.typeVariable)(paramVar)
    ], (0, _ast.typeVariable)(returnVar));
const createPolymorphicBinaryFunction = (param1Var, param2Var, returnVar)=>(0, _ast.functionType)([
        (0, _ast.typeVariable)(param1Var),
        (0, _ast.typeVariable)(param2Var)
    ], (0, _ast.typeVariable)(returnVar));
function mapObject(obj, fn) {
    const result = {};
    for(const k in obj)result[k] = fn(obj[k], k);
    return result;
}
function mapSet(map, key, value) {
    // For performance, avoid copying large maps unnecessarily
    if (map.has(key) && map.get(key) === value) {
        return map; // No change needed
    }
    const copy = new Map(map);
    copy.set(key, value);
    return copy;
}
function isTypeKind(t, kind) {
    return t.kind === kind;
}
// Cache for typesEqual to avoid repeated deep comparisons
const typesEqualCache = new Map();
const typesEqual = (t1, t2)=>{
    // Quick reference equality check
    if (t1 === t2) return true;
    if (t1.kind !== t2.kind) {
        return false;
    }
    // Simple cache for primitive/variable types
    if ((t1.kind === 'primitive' || t1.kind === 'variable') && (t2.kind === 'primitive' || t2.kind === 'variable')) {
        const key = `${t1.kind}:${t1.name}-${t2.kind}:${t2.name}`;
        let cached = typesEqualCache.get(key);
        if (cached !== undefined) return cached;
        const result = typesEqualUncached(t1, t2);
        if (typesEqualCache.size < 500) {
            typesEqualCache.set(key, result);
        }
        return result;
    }
    return typesEqualUncached(t1, t2);
};
const typesEqualUncached = (t1, t2)=>{
    switch(t1.kind){
        case "variable":
            return t1.name === t2.name;
        case "primitive":
            return t1.name === t2.name;
        case "function":
            {
                const f2 = t2;
                if (t1.params.length !== f2.params.length) {
                    return false;
                }
                return t1.params.every((param, i)=>typesEqual(param, f2.params[i])) && typesEqual(t1.return, f2.return);
            }
        case "list":
            return typesEqual(t1.element, t2.element);
        case "tuple":
            {
                const t2_tuple = t2;
                if (t1.elements.length !== t2_tuple.elements.length) {
                    return false;
                }
                return t1.elements.every((element, i)=>typesEqual(element, t2_tuple.elements[i]));
            }
        case "record":
            {
                const t2_record = t2;
                const keys1 = Object.keys(t1.fields);
                const keys2 = Object.keys(t2_record.fields);
                if (keys1.length !== keys2.length) {
                    return false;
                }
                return keys1.every((key)=>typesEqual(t1.fields[key], t2_record.fields[key]));
            }
        case "union":
            {
                const t2_union = t2;
                if (t1.types.length !== t2_union.types.length) {
                    return false;
                }
                return t1.types.every((type, i)=>typesEqual(type, t2_union.types[i]));
            }
        case "unit":
            return true;
        case "variant":
            {
                const t2_variant = t2;
                if (t1.name !== t2_variant.name) {
                    return false;
                }
                if (t1.args.length !== t2_variant.args.length) {
                    return false;
                }
                return t1.args.every((arg, i)=>typesEqual(arg, t2_variant.args[i]));
            }
        default:
            return false;
    }
};
const typesSimilar = (t1, t2)=>{
    if (t1.kind !== t2.kind) return false;
    switch(t1.kind){
        case "primitive":
            return t1.name === t2.name;
        case "variable":
            return t1.name === t2.name;
        case "function":
            {
                const t2Func = t2;
                return t1.params.length === t2Func.params.length && t1.params.every((p, i)=>typesSimilar(p, t2Func.params[i])) && typesSimilar(t1.return, t2Func.return);
            }
        case "list":
            return typesSimilar(t1.element, t2.element);
        case "record":
            {
                const t2Record = t2;
                const fields1 = Object.keys(t1.fields);
                const fields2 = Object.keys(t2Record.fields);
                return fields1.length === fields2.length && fields1.every((f)=>f in t2Record.fields && typesSimilar(t1.fields[f], t2Record.fields[f]));
            }
        case "tuple":
            {
                const t2Tuple = t2;
                return t1.elements.length === t2Tuple.elements.length && t1.elements.every((e, i)=>typesSimilar(e, t2Tuple.elements[i]));
            }
        case "union":
            {
                const t2Union = t2;
                return t1.types.length === t2Union.types.length && t1.types.every((type, i)=>typesSimilar(type, t2Union.types[i]));
            }
        default:
            return false;
    }
};
const constraintsEqual = (c1, c2)=>{
    if (c1.kind !== c2.kind || c1.typeVar !== c2.typeVar) return false;
    switch(c1.kind){
        case "is":
            return c1.constraint === c2.constraint;
        case "hasField":
            {
                const c2HasField = c2;
                return c1.field === c2HasField.field && typesSimilar(c1.fieldType, c2HasField.fieldType);
            }
        case "implements":
            return c1.interfaceName === c2.interfaceName;
        case "custom":
            return c1.constraint === c2.constraint;
        default:
            return false;
    }
};
const propagateConstraintToTypeVariable = (funcType, constraint)=>{
    if (funcType.kind !== "function") return;
    // Apply constraint to matching type variables in parameters
    for (const param of funcType.params){
        if (param.kind === "variable" && param.name === constraint.typeVar) {
            if (!param.constraints) {
                param.constraints = [];
            }
            // Check if this constraint is already present
            const existingConstraint = param.constraints.find((c)=>constraintsEqual(c, constraint));
            if (!existingConstraint) {
                param.constraints.push(constraint);
            }
        }
    }
    // Also apply to return type if it matches
    if (funcType.return.kind === "variable" && funcType.return.name === constraint.typeVar) {
        if (!funcType.return.constraints) {
            funcType.return.constraints = [];
        }
        const existingConstraint = funcType.return.constraints.find((c)=>constraintsEqual(c, constraint));
        if (!existingConstraint) {
            funcType.return.constraints.push(constraint);
        }
    }
};
const typeToString = (type, substitution = new Map(), showConstraints = true)=>{
    const greek = [
        "α",
        "β",
        "γ",
        "δ",
        "ε",
        "ζ",
        "η",
        "θ",
        "ι",
        "κ",
        "λ",
        "μ",
        "ν",
        "ξ",
        "ο",
        "π",
        "ρ",
        "σ",
        "τ",
        "υ",
        "φ",
        "χ",
        "ψ",
        "ω"
    ];
    const mapping = new Map();
    let next = 0;
    function norm(t) {
        switch(t.kind){
            case "primitive":
                return t.name;
            case "function":
                {
                    const paramStr = t.params.map(norm).join(" ");
                    const effectStr = formatEffectsString(t.effects);
                    const baseType = `(${paramStr}) -> ${norm(t.return)}${effectStr}`;
                    const constraintStr = showConstraints && t.constraints && t.constraints.length > 0 ? ` given ${t.originalConstraint ? formatConstraintExpr(t.originalConstraint) : deduplicateConstraints(t.constraints).map(formatConstraint).join(" ")}` : "";
                    return constraintStr ? `${baseType}${constraintStr}` : baseType;
                }
            case "variable":
                {
                    let varStr = "";
                    if (!mapping.has(t.name)) {
                        // If the type variable name is a single letter, keep it as-is
                        // This preserves explicit type annotations like 'a -> a'
                        if (t.name.length === 1 && /^[a-z]$/.test(t.name)) {
                            mapping.set(t.name, t.name);
                        } else {
                            mapping.set(t.name, greek[next] || `t${next}`);
                            next++;
                        }
                    }
                    // biome-ignore lint/style/noNonNullAssertion: it's set if not defined above
                    varStr = mapping.get(t.name);
                    return varStr;
                }
            case "list":
                return `List ${norm(t.element)}`;
            case "tuple":
                return `(${t.elements.map(norm).join(" ")})`;
            case "record":
                return `{ ${Object.entries(t.fields).map(([name, fieldType])=>`${name}: ${norm(fieldType)}`).join(" ")} }`;
            case "union":
                return `(${t.types.map(norm).join(" | ")})`;
            case "variant":
                if (t.args.length === 0) {
                    return t.name;
                } else {
                    return `${t.name} ${t.args.map(norm).join(" ")}`;
                }
            case "unit":
                return "unit";
            case "unknown":
                return "?";
            default:
                return "unknown";
        }
    }
    function formatConstraint(c) {
        switch(c.kind){
            case "is":
                {
                    // Use the normalized variable name for consistency
                    const normalizedVarName = mapping.get(c.typeVar) || c.typeVar;
                    return `${normalizedVarName} is ${c.constraint}`;
                }
            case "hasField":
                {
                    // For hasField constraints, we need to use the normalized variable name
                    // that matches the parameter it's constraining
                    const normalizedVarName2 = mapping.get(c.typeVar) || c.typeVar;
                    return `${normalizedVarName2} has field "${c.field}" of type ${norm(c.fieldType)}`;
                }
            case "implements":
                {
                    const normalizedVarName3 = mapping.get(c.typeVar) || c.typeVar;
                    return `${normalizedVarName3} implements ${c.interfaceName}`;
                }
            case "custom":
                {
                    const normalizedVarName4 = mapping.get(c.typeVar) || c.typeVar;
                    return `${normalizedVarName4} satisfies ${c.constraint} ${c.args.map(norm).join(" ")}`;
                }
            default:
                return "unknown constraint";
        }
    }
    function formatConstraintExpr(expr) {
        switch(expr.kind){
            case "is":
            case "hasField":
            case "implements":
            case "custom":
                return formatConstraint(expr);
            case "and":
                return `${formatConstraintExpr(expr.left)} and ${formatConstraintExpr(expr.right)}`;
            case "or":
                return `${formatConstraintExpr(expr.left)} or ${formatConstraintExpr(expr.right)}`;
            case "paren":
                return `(${formatConstraintExpr(expr.expr)})`;
            default:
                return "unknown constraint";
        }
    }
    // Helper function to deduplicate constraints
    function deduplicateConstraints(constraints) {
        const result = [];
        for (const constraint of constraints){
            const isDuplicate = result.some((c)=>constraintsEqual(c, constraint));
            if (!isDuplicate) {
                result.push(constraint);
            }
        }
        return result;
    }
    // Apply substitution to the type before normalizing
    const substitutedType = (0, _substitute.substitute)(type, substitution);
    return norm(substitutedType);
};
const occursIn = (varName, type)=>{
    switch(type.kind){
        case "variable":
            return type.name === varName;
        case "function":
            return type.params.some((param)=>occursIn(varName, param)) || occursIn(varName, type.return);
        case "list":
            return occursIn(varName, type.element);
        case "tuple":
            return type.elements.some((element)=>occursIn(varName, element));
        case "record":
            return Object.values(type.fields).some((fieldType)=>occursIn(varName, fieldType));
        case "union":
            return type.types.some((t)=>occursIn(varName, t));
        case "variant":
            return type.args.some((arg)=>occursIn(varName, arg));
        default:
            return false;
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Uvc3JjL3R5cGVyL2hlbHBlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHlwZSBUeXBlLCBmdW5jdGlvblR5cGUsIHR5cGVWYXJpYWJsZSwgdHlwZSBWYXJpYWJsZVR5cGUsIHR5cGUgUHJpbWl0aXZlVHlwZSwgdHlwZSBGdW5jdGlvblR5cGUsIHR5cGUgTGlzdFR5cGUsIHR5cGUgVHVwbGVUeXBlLCB0eXBlIFJlY29yZFR5cGUsIHR5cGUgVW5pb25UeXBlLCB0eXBlIFZhcmlhbnRUeXBlLCBDb25zdHJhaW50RXhwciwgQ29uc3RyYWludCwgSXNDb25zdHJhaW50LCBIYXNGaWVsZENvbnN0cmFpbnQsIEltcGxlbWVudHNDb25zdHJhaW50LCBDdXN0b21Db25zdHJhaW50IH0gZnJvbSBcIi4uL2FzdFwiO1xuaW1wb3J0IHsgZm9ybWF0VHlwZUVycm9yIH0gZnJvbSBcIi4vdHlwZS1lcnJvcnNcIjtcbmltcG9ydCB7IE5vb2xhbmdFcnJvciB9IGZyb20gXCIuLi9lcnJvcnNcIjtcbmltcG9ydCB7IHN1YnN0aXR1dGUgfSBmcm9tIFwiLi9zdWJzdGl0dXRlXCI7XG5pbXBvcnQgdHlwZSB7IEVmZmVjdCB9IGZyb20gXCIuLi9hc3RcIjtcblxudHlwZSBDb2RlTG9jYXRpb24gPSB7XG4gIGxpbmU6IG51bWJlcjtcbiAgY29sdW1uOiBudW1iZXI7XG59O1xuXG4vLyBIZWxwZXI6IEV4dHJhY3QgbG9jYXRpb24gZnJvbSBleHByZXNzaW9uIG9yIHByb3ZpZGUgZGVmYXVsdFxuZXhwb3J0IGNvbnN0IGdldEV4cHJMb2NhdGlvbiA9IChleHByOiB7XG4gIGxvY2F0aW9uPzogeyBzdGFydDogQ29kZUxvY2F0aW9uIH07XG59KTogQ29kZUxvY2F0aW9uID0+ICh7XG4gIGxpbmU6IGV4cHIubG9jYXRpb24/LnN0YXJ0LmxpbmUgfHwgMSxcbiAgY29sdW1uOiBleHByLmxvY2F0aW9uPy5zdGFydC5jb2x1bW4gfHwgMSxcbn0pO1xuXG4vLyBIZWxwZXI6IFRocm93IGZvcm1hdHRlZCB0eXBlIGVycm9yIHdpdGggY29uc2lzdGVudCBwYXR0ZXJuXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dUeXBlRXJyb3IoXG4gIGVycm9yRmFjdG9yeTogKGxvY2F0aW9uOiBDb2RlTG9jYXRpb24pID0+IE5vb2xhbmdFcnJvcixcbiAgbG9jYXRpb24/OiBDb2RlTG9jYXRpb25cbik6IG5ldmVyIHtcbiAgY29uc3QgbG9jID0gbG9jYXRpb24gfHwgeyBsaW5lOiAxLCBjb2x1bW46IDEgfTtcbiAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdFR5cGVFcnJvcihlcnJvckZhY3RvcnkobG9jKSkpO1xufVxuXG4vLyBIZWxwZXI6IEZvcm1hdCBlZmZlY3RzIGFzIHN0cmluZyBmb3IgdHlwZSBkaXNwbGF5XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RWZmZWN0c1N0cmluZyhlZmZlY3RzOiBTZXQ8RWZmZWN0Pik6IHN0cmluZyB7XG4gIGlmIChlZmZlY3RzLnNpemUgPT09IDApIHJldHVybiBcIlwiO1xuICByZXR1cm4gYCAke0FycmF5LmZyb20oZWZmZWN0cykubWFwKGUgPT4gYCEke2V9YCkuam9pbignICcpfWA7XG59XG5cbi8vIEhlbHBlcjogQ3JlYXRlIGNvbW1vbiBmdW5jdGlvbiB0eXBlc1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVVuYXJ5RnVuY3Rpb25UeXBlID0gKFxuICBwYXJhbVR5cGU6IFR5cGUsXG4gIHJldHVyblR5cGU6IFR5cGVcbik6IFR5cGUgPT4gZnVuY3Rpb25UeXBlKFtwYXJhbVR5cGVdLCByZXR1cm5UeXBlKTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUJpbmFyeUZ1bmN0aW9uVHlwZSA9IChcbiAgcGFyYW0xVHlwZTogVHlwZSxcbiAgcGFyYW0yVHlwZTogVHlwZSxcbiAgcmV0dXJuVHlwZTogVHlwZVxuKTogVHlwZSA9PiBmdW5jdGlvblR5cGUoW3BhcmFtMVR5cGUsIHBhcmFtMlR5cGVdLCByZXR1cm5UeXBlKTtcblxuLy8gSGVscGVyOiBDcmVhdGUgcG9seW1vcnBoaWMgZnVuY3Rpb24gdHlwZXMgd2l0aCB0eXBlIHZhcmlhYmxlc1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVBvbHltb3JwaGljVW5hcnlGdW5jdGlvbiA9IChcbiAgcGFyYW1WYXI6IHN0cmluZyxcbiAgcmV0dXJuVmFyOiBzdHJpbmdcbik6IFR5cGUgPT4gZnVuY3Rpb25UeXBlKFt0eXBlVmFyaWFibGUocGFyYW1WYXIpXSwgdHlwZVZhcmlhYmxlKHJldHVyblZhcikpO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUG9seW1vcnBoaWNCaW5hcnlGdW5jdGlvbiA9IChcbiAgcGFyYW0xVmFyOiBzdHJpbmcsXG4gIHBhcmFtMlZhcjogc3RyaW5nLFxuICByZXR1cm5WYXI6IHN0cmluZ1xuKTogVHlwZSA9PlxuICBmdW5jdGlvblR5cGUoXG4gICAgW3R5cGVWYXJpYWJsZShwYXJhbTFWYXIpLCB0eXBlVmFyaWFibGUocGFyYW0yVmFyKV0sXG4gICAgdHlwZVZhcmlhYmxlKHJldHVyblZhcilcbiAgKTtcblxuXG4vLyBVdGlsaXR5OiBtYXBPYmplY3QgZm9yIG1hcHBpbmcgb3ZlciByZWNvcmQgZmllbGRzXG5leHBvcnQgZnVuY3Rpb24gbWFwT2JqZWN0PFQsIFU+KFxuICBvYmo6IHsgW2s6IHN0cmluZ106IFQgfSxcbiAgZm46ICh2OiBULCBrOiBzdHJpbmcpID0+IFUsXG4pOiB7IFtrOiBzdHJpbmddOiBVIH0ge1xuICBjb25zdCByZXN1bHQ6IHsgW2s6IHN0cmluZ106IFUgfSA9IHt9O1xuICBmb3IgKGNvbnN0IGsgaW4gb2JqKSByZXN1bHRba10gPSBmbihvYmpba10sIGspO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBVdGlsaXR5OiBtYXBTZXQgZm9yIGltbXV0YWJsZSBNYXAgdXBkYXRlcyAtIG9wdGltaXplZCB0byBhdm9pZCBjb3B5aW5nIGxhcmdlIG1hcHNcbmV4cG9ydCBmdW5jdGlvbiBtYXBTZXQ8SywgVj4obWFwOiBNYXA8SywgVj4sIGtleTogSywgdmFsdWU6IFYpOiBNYXA8SywgVj4ge1xuICAvLyBGb3IgcGVyZm9ybWFuY2UsIGF2b2lkIGNvcHlpbmcgbGFyZ2UgbWFwcyB1bm5lY2Vzc2FyaWx5XG4gIGlmIChtYXAuaGFzKGtleSkgJiYgbWFwLmdldChrZXkpID09PSB2YWx1ZSkge1xuICAgIHJldHVybiBtYXA7IC8vIE5vIGNoYW5nZSBuZWVkZWRcbiAgfVxuICBjb25zdCBjb3B5ID0gbmV3IE1hcChtYXApO1xuICBjb3B5LnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbi8vIFV0aWxpdHk6IGlzVHlwZUtpbmQgdHlwZSBndWFyZFxuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZUtpbmQ8VCBleHRlbmRzIFR5cGVbXCJraW5kXCJdPihcbiAgdDogVHlwZSxcbiAga2luZDogVCxcbik6IHQgaXMgRXh0cmFjdDxUeXBlLCB7IGtpbmQ6IFQgfT4ge1xuICByZXR1cm4gdC5raW5kID09PSBraW5kO1xufVxuXG5cbi8vIENhY2hlIGZvciB0eXBlc0VxdWFsIHRvIGF2b2lkIHJlcGVhdGVkIGRlZXAgY29tcGFyaXNvbnNcbmNvbnN0IHR5cGVzRXF1YWxDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBib29sZWFuPigpO1xuXG4vLyBDaGVjayBpZiB0d28gdHlwZXMgYXJlIHN0cnVjdHVyYWxseSBlcXVhbFxuZXhwb3J0IGNvbnN0IHR5cGVzRXF1YWwgPSAodDE6IFR5cGUsIHQyOiBUeXBlKTogYm9vbGVhbiA9PiB7XG4gIC8vIFF1aWNrIHJlZmVyZW5jZSBlcXVhbGl0eSBjaGVja1xuICBpZiAodDEgPT09IHQyKSByZXR1cm4gdHJ1ZTtcbiAgXG4gIGlmICh0MS5raW5kICE9PSB0Mi5raW5kKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIFxuICAvLyBTaW1wbGUgY2FjaGUgZm9yIHByaW1pdGl2ZS92YXJpYWJsZSB0eXBlc1xuICBpZiAoKHQxLmtpbmQgPT09ICdwcmltaXRpdmUnIHx8IHQxLmtpbmQgPT09ICd2YXJpYWJsZScpICYmICh0Mi5raW5kID09PSAncHJpbWl0aXZlJyB8fCB0Mi5raW5kID09PSAndmFyaWFibGUnKSkge1xuICAgIGNvbnN0IGtleSA9IGAke3QxLmtpbmR9OiR7KHQxIGFzIGFueSkubmFtZX0tJHt0Mi5raW5kfTokeyh0MiBhcyBhbnkpLm5hbWV9YDtcbiAgICBsZXQgY2FjaGVkID0gdHlwZXNFcXVhbENhY2hlLmdldChrZXkpO1xuICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGNhY2hlZDtcbiAgICBcbiAgICBjb25zdCByZXN1bHQgPSB0eXBlc0VxdWFsVW5jYWNoZWQodDEsIHQyKTtcbiAgICBpZiAodHlwZXNFcXVhbENhY2hlLnNpemUgPCA1MDApIHtcbiAgICAgIHR5cGVzRXF1YWxDYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIFxuICByZXR1cm4gdHlwZXNFcXVhbFVuY2FjaGVkKHQxLCB0Mik7XG59O1xuXG5jb25zdCB0eXBlc0VxdWFsVW5jYWNoZWQgPSAodDE6IFR5cGUsIHQyOiBUeXBlKTogYm9vbGVhbiA9PiB7XG5cbiAgc3dpdGNoICh0MS5raW5kKSB7XG4gICAgY2FzZSBcInZhcmlhYmxlXCI6XG4gICAgICByZXR1cm4gdDEubmFtZSA9PT0gKHQyIGFzIFZhcmlhYmxlVHlwZSkubmFtZTtcblxuICAgIGNhc2UgXCJwcmltaXRpdmVcIjpcbiAgICAgIHJldHVybiB0MS5uYW1lID09PSAodDIgYXMgUHJpbWl0aXZlVHlwZSkubmFtZTtcblxuICAgIGNhc2UgXCJmdW5jdGlvblwiOiB7XG4gICAgICBjb25zdCBmMiA9IHQyIGFzIEZ1bmN0aW9uVHlwZTtcbiAgICAgIGlmICh0MS5wYXJhbXMubGVuZ3RoICE9PSBmMi5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIHQxLnBhcmFtcy5ldmVyeSgocGFyYW0sIGkpID0+IHR5cGVzRXF1YWwocGFyYW0sIGYyLnBhcmFtc1tpXSkpICYmXG4gICAgICAgIHR5cGVzRXF1YWwodDEucmV0dXJuLCBmMi5yZXR1cm4pXG4gICAgICApO1xuICAgIH1cblxuICAgIGNhc2UgXCJsaXN0XCI6XG4gICAgICByZXR1cm4gdHlwZXNFcXVhbCh0MS5lbGVtZW50LCAodDIgYXMgTGlzdFR5cGUpLmVsZW1lbnQpO1xuXG4gICAgY2FzZSBcInR1cGxlXCI6IHtcbiAgICAgIGNvbnN0IHQyX3R1cGxlID0gdDIgYXMgVHVwbGVUeXBlO1xuICAgICAgaWYgKHQxLmVsZW1lbnRzLmxlbmd0aCAhPT0gdDJfdHVwbGUuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0MS5lbGVtZW50cy5ldmVyeSgoZWxlbWVudCwgaSkgPT5cbiAgICAgICAgdHlwZXNFcXVhbChlbGVtZW50LCB0Ml90dXBsZS5lbGVtZW50c1tpXSksXG4gICAgICApO1xuICAgIH1cblxuICAgIGNhc2UgXCJyZWNvcmRcIjoge1xuICAgICAgY29uc3QgdDJfcmVjb3JkID0gdDIgYXMgUmVjb3JkVHlwZTtcbiAgICAgIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXModDEuZmllbGRzKTtcbiAgICAgIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXModDJfcmVjb3JkLmZpZWxkcyk7XG4gICAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleXMxLmV2ZXJ5KChrZXkpID0+XG4gICAgICAgIHR5cGVzRXF1YWwodDEuZmllbGRzW2tleV0sIHQyX3JlY29yZC5maWVsZHNba2V5XSksXG4gICAgICApO1xuICAgIH1cblxuICAgIGNhc2UgXCJ1bmlvblwiOiB7XG4gICAgICBjb25zdCB0Ml91bmlvbiA9IHQyIGFzIFVuaW9uVHlwZTtcbiAgICAgIGlmICh0MS50eXBlcy5sZW5ndGggIT09IHQyX3VuaW9uLnR5cGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDEudHlwZXMuZXZlcnkoKHR5cGUsIGkpID0+IHR5cGVzRXF1YWwodHlwZSwgdDJfdW5pb24udHlwZXNbaV0pKTtcbiAgICB9XG5cbiAgICBjYXNlIFwidW5pdFwiOlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIFwidmFyaWFudFwiOiB7XG4gICAgICBjb25zdCB0Ml92YXJpYW50ID0gdDIgYXMgVmFyaWFudFR5cGU7XG4gICAgICBpZiAodDEubmFtZSAhPT0gdDJfdmFyaWFudC5uYW1lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0MS5hcmdzLmxlbmd0aCAhPT0gdDJfdmFyaWFudC5hcmdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDEuYXJncy5ldmVyeSgoYXJnLCBpKSA9PiB0eXBlc0VxdWFsKGFyZywgdDJfdmFyaWFudC5hcmdzW2ldKSk7XG4gICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuXG4vLyBFZmZpY2llbnQgdHlwZSBzaW1pbGFyaXR5IGNoZWNrIHRvIGF2b2lkIEpTT04uc3RyaW5naWZ5IChzaW1wbGlmaWVkIGZvciBjb25zdHJhaW50IGNvbXBhcmlzb24pXG5leHBvcnQgY29uc3QgdHlwZXNTaW1pbGFyID0gKHQxOiBUeXBlLCB0MjogVHlwZSk6IGJvb2xlYW4gPT4ge1xuXHRpZiAodDEua2luZCAhPT0gdDIua2luZCkgcmV0dXJuIGZhbHNlO1xuXG5cdHN3aXRjaCAodDEua2luZCkge1xuXHRcdGNhc2UgXCJwcmltaXRpdmVcIjpcblx0XHRcdHJldHVybiB0MS5uYW1lID09PSAodDIgYXMgUHJpbWl0aXZlVHlwZSkubmFtZTtcblx0XHRjYXNlIFwidmFyaWFibGVcIjpcblx0XHRcdHJldHVybiB0MS5uYW1lID09PSAodDIgYXMgVmFyaWFibGVUeXBlKS5uYW1lO1xuXHRcdGNhc2UgXCJmdW5jdGlvblwiOiB7XG5cdFx0XHRjb25zdCB0MkZ1bmMgPSB0MiBhcyBGdW5jdGlvblR5cGU7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHR0MS5wYXJhbXMubGVuZ3RoID09PSB0MkZ1bmMucGFyYW1zLmxlbmd0aCAmJlxuXHRcdFx0XHR0MS5wYXJhbXMuZXZlcnkoKHAsIGkpID0+IHR5cGVzU2ltaWxhcihwLCB0MkZ1bmMucGFyYW1zW2ldKSkgJiZcblx0XHRcdFx0dHlwZXNTaW1pbGFyKHQxLnJldHVybiwgdDJGdW5jLnJldHVybilcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGNhc2UgXCJsaXN0XCI6XG5cdFx0XHRyZXR1cm4gdHlwZXNTaW1pbGFyKHQxLmVsZW1lbnQsICh0MiBhcyBMaXN0VHlwZSkuZWxlbWVudCk7XG5cdFx0Y2FzZSBcInJlY29yZFwiOiB7XG5cdFx0XHRjb25zdCB0MlJlY29yZCA9IHQyIGFzIFJlY29yZFR5cGU7XG5cdFx0XHRjb25zdCBmaWVsZHMxID0gT2JqZWN0LmtleXModDEuZmllbGRzKTtcblx0XHRcdGNvbnN0IGZpZWxkczIgPSBPYmplY3Qua2V5cyh0MlJlY29yZC5maWVsZHMpO1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0ZmllbGRzMS5sZW5ndGggPT09IGZpZWxkczIubGVuZ3RoICYmXG5cdFx0XHRcdGZpZWxkczEuZXZlcnkoXG5cdFx0XHRcdFx0KGYpID0+XG5cdFx0XHRcdFx0XHRmIGluIHQyUmVjb3JkLmZpZWxkcyAmJlxuXHRcdFx0XHRcdFx0dHlwZXNTaW1pbGFyKHQxLmZpZWxkc1tmXSwgdDJSZWNvcmQuZmllbGRzW2ZdKSxcblx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2FzZSBcInR1cGxlXCI6IHtcblx0XHRcdGNvbnN0IHQyVHVwbGUgPSB0MiBhcyBUdXBsZVR5cGU7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHR0MS5lbGVtZW50cy5sZW5ndGggPT09IHQyVHVwbGUuZWxlbWVudHMubGVuZ3RoICYmXG5cdFx0XHRcdHQxLmVsZW1lbnRzLmV2ZXJ5KChlLCBpKSA9PiB0eXBlc1NpbWlsYXIoZSwgdDJUdXBsZS5lbGVtZW50c1tpXSkpXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRjYXNlIFwidW5pb25cIjoge1xuXHRcdFx0Y29uc3QgdDJVbmlvbiA9IHQyIGFzIFVuaW9uVHlwZTtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdHQxLnR5cGVzLmxlbmd0aCA9PT0gdDJVbmlvbi50eXBlcy5sZW5ndGggJiZcblx0XHRcdFx0dDEudHlwZXMuZXZlcnkoKHR5cGUsIGkpID0+IHR5cGVzU2ltaWxhcih0eXBlLCB0MlVuaW9uLnR5cGVzW2ldKSlcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbi8vIEVmZmljaWVudCBjb25zdHJhaW50IGNvbXBhcmlzb24gdG8gcmVwbGFjZSBleHBlbnNpdmUgSlNPTi5zdHJpbmdpZnlcbmV4cG9ydCBjb25zdCBjb25zdHJhaW50c0VxdWFsID0gKGMxOiBDb25zdHJhaW50LCBjMjogQ29uc3RyYWludCk6IGJvb2xlYW4gPT4ge1xuXHRpZiAoYzEua2luZCAhPT0gYzIua2luZCB8fCBjMS50eXBlVmFyICE9PSBjMi50eXBlVmFyKSByZXR1cm4gZmFsc2U7XG5cblx0c3dpdGNoIChjMS5raW5kKSB7XG5cdFx0Y2FzZSBcImlzXCI6XG5cdFx0XHRyZXR1cm4gYzEuY29uc3RyYWludCA9PT0gKGMyIGFzIElzQ29uc3RyYWludCkuY29uc3RyYWludDtcblx0XHRjYXNlIFwiaGFzRmllbGRcIjoge1xuXHRcdFx0Y29uc3QgYzJIYXNGaWVsZCA9IGMyIGFzIEhhc0ZpZWxkQ29uc3RyYWludDtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdGMxLmZpZWxkID09PSBjMkhhc0ZpZWxkLmZpZWxkICYmXG5cdFx0XHRcdHR5cGVzU2ltaWxhcihjMS5maWVsZFR5cGUsIGMySGFzRmllbGQuZmllbGRUeXBlKVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2FzZSBcImltcGxlbWVudHNcIjpcblx0XHRcdHJldHVybiBjMS5pbnRlcmZhY2VOYW1lID09PSAoYzIgYXMgSW1wbGVtZW50c0NvbnN0cmFpbnQpLmludGVyZmFjZU5hbWU7XG5cdFx0Y2FzZSBcImN1c3RvbVwiOlxuXHRcdFx0cmV0dXJuIGMxLmNvbnN0cmFpbnQgPT09IChjMiBhcyBDdXN0b21Db25zdHJhaW50KS5jb25zdHJhaW50O1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwcm9wYWdhdGUgYSBjb25zdHJhaW50IHRvIG1hdGNoaW5nIHR5cGUgdmFyaWFibGVzIGluIGEgZnVuY3Rpb24gdHlwZVxuZXhwb3J0IGNvbnN0IHByb3BhZ2F0ZUNvbnN0cmFpbnRUb1R5cGVWYXJpYWJsZSA9IChcblx0ZnVuY1R5cGU6IFR5cGUsXG5cdGNvbnN0cmFpbnQ6IENvbnN0cmFpbnQsXG4pOiB2b2lkID0+IHtcblx0aWYgKGZ1bmNUeXBlLmtpbmQgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuO1xuXG5cdC8vIEFwcGx5IGNvbnN0cmFpbnQgdG8gbWF0Y2hpbmcgdHlwZSB2YXJpYWJsZXMgaW4gcGFyYW1ldGVyc1xuXHRmb3IgKGNvbnN0IHBhcmFtIG9mIGZ1bmNUeXBlLnBhcmFtcykge1xuXHRcdGlmIChwYXJhbS5raW5kID09PSBcInZhcmlhYmxlXCIgJiYgcGFyYW0ubmFtZSA9PT0gY29uc3RyYWludC50eXBlVmFyKSB7XG5cdFx0XHRpZiAoIXBhcmFtLmNvbnN0cmFpbnRzKSB7XG5cdFx0XHRcdHBhcmFtLmNvbnN0cmFpbnRzID0gW107XG5cdFx0XHR9XG5cdFx0XHQvLyBDaGVjayBpZiB0aGlzIGNvbnN0cmFpbnQgaXMgYWxyZWFkeSBwcmVzZW50XG5cdFx0XHRjb25zdCBleGlzdGluZ0NvbnN0cmFpbnQgPSBwYXJhbS5jb25zdHJhaW50cy5maW5kKChjKSA9PlxuXHRcdFx0XHRjb25zdHJhaW50c0VxdWFsKGMsIGNvbnN0cmFpbnQpLFxuXHRcdFx0KTtcblx0XHRcdGlmICghZXhpc3RpbmdDb25zdHJhaW50KSB7XG5cdFx0XHRcdHBhcmFtLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxzbyBhcHBseSB0byByZXR1cm4gdHlwZSBpZiBpdCBtYXRjaGVzXG5cdGlmIChcblx0XHRmdW5jVHlwZS5yZXR1cm4ua2luZCA9PT0gXCJ2YXJpYWJsZVwiICYmXG5cdFx0ZnVuY1R5cGUucmV0dXJuLm5hbWUgPT09IGNvbnN0cmFpbnQudHlwZVZhclxuXHQpIHtcblx0XHRpZiAoIWZ1bmNUeXBlLnJldHVybi5jb25zdHJhaW50cykge1xuXHRcdFx0ZnVuY1R5cGUucmV0dXJuLmNvbnN0cmFpbnRzID0gW107XG5cdFx0fVxuXHRcdGNvbnN0IGV4aXN0aW5nQ29uc3RyYWludCA9IGZ1bmNUeXBlLnJldHVybi5jb25zdHJhaW50cy5maW5kKChjKSA9PlxuXHRcdFx0Y29uc3RyYWludHNFcXVhbChjLCBjb25zdHJhaW50KSxcblx0XHQpO1xuXHRcdGlmICghZXhpc3RpbmdDb25zdHJhaW50KSB7XG5cdFx0XHRmdW5jVHlwZS5yZXR1cm4uY29uc3RyYWludHMucHVzaChjb25zdHJhaW50KTtcblx0XHR9XG5cdH1cbn07XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gY29udmVydCB0eXBlIHRvIHN0cmluZ1xuZXhwb3J0IGNvbnN0IHR5cGVUb1N0cmluZyA9IChcblx0dHlwZTogVHlwZSxcblx0c3Vic3RpdHV0aW9uOiBNYXA8c3RyaW5nLCBUeXBlPiA9IG5ldyBNYXAoKSxcblx0c2hvd0NvbnN0cmFpbnRzOiBib29sZWFuID0gdHJ1ZSxcbik6IHN0cmluZyA9PiB7XG5cdGNvbnN0IGdyZWVrID0gW1xuXHRcdFwizrFcIixcblx0XHRcIs6yXCIsXG5cdFx0XCLOs1wiLFxuXHRcdFwizrRcIixcblx0XHRcIs61XCIsXG5cdFx0XCLOtlwiLFxuXHRcdFwizrdcIixcblx0XHRcIs64XCIsXG5cdFx0XCLOuVwiLFxuXHRcdFwizrpcIixcblx0XHRcIs67XCIsXG5cdFx0XCLOvFwiLFxuXHRcdFwizr1cIixcblx0XHRcIs6+XCIsXG5cdFx0XCLOv1wiLFxuXHRcdFwiz4BcIixcblx0XHRcIs+BXCIsXG5cdFx0XCLPg1wiLFxuXHRcdFwiz4RcIixcblx0XHRcIs+FXCIsXG5cdFx0XCLPhlwiLFxuXHRcdFwiz4dcIixcblx0XHRcIs+IXCIsXG5cdFx0XCLPiVwiLFxuXHRdO1xuXHRjb25zdCBtYXBwaW5nID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcblx0bGV0IG5leHQgPSAwO1xuXG5cdGZ1bmN0aW9uIG5vcm0odDogVHlwZSk6IHN0cmluZyB7XG5cdFx0c3dpdGNoICh0LmtpbmQpIHtcblx0XHRcdGNhc2UgXCJwcmltaXRpdmVcIjpcblx0XHRcdFx0cmV0dXJuIHQubmFtZTtcblx0XHRcdGNhc2UgXCJmdW5jdGlvblwiOiB7XG5cdFx0XHRcdGNvbnN0IHBhcmFtU3RyID0gdC5wYXJhbXMubWFwKG5vcm0pLmpvaW4oXCIgXCIpO1xuXHRcdFx0XHRjb25zdCBlZmZlY3RTdHIgPSBmb3JtYXRFZmZlY3RzU3RyaW5nKHQuZWZmZWN0cyk7XG5cdFx0XHRcdGNvbnN0IGJhc2VUeXBlID0gYCgke3BhcmFtU3RyfSkgLT4gJHtub3JtKHQucmV0dXJuKX0ke2VmZmVjdFN0cn1gO1xuXG5cdFx0XHRcdGNvbnN0IGNvbnN0cmFpbnRTdHIgPVxuXHRcdFx0XHRcdHNob3dDb25zdHJhaW50cyAmJiB0LmNvbnN0cmFpbnRzICYmIHQuY29uc3RyYWludHMubGVuZ3RoID4gMFxuXHRcdFx0XHRcdFx0PyBgIGdpdmVuICR7XG5cdFx0XHRcdFx0XHRcdFx0KHQgYXMgYW55KS5vcmlnaW5hbENvbnN0cmFpbnRcblx0XHRcdFx0XHRcdFx0XHRcdD8gZm9ybWF0Q29uc3RyYWludEV4cHIoKHQgYXMgYW55KS5vcmlnaW5hbENvbnN0cmFpbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGRlZHVwbGljYXRlQ29uc3RyYWludHModC5jb25zdHJhaW50cylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQubWFwKGZvcm1hdENvbnN0cmFpbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LmpvaW4oXCIgXCIpXG5cdFx0XHRcdFx0XHRcdH1gXG5cdFx0XHRcdFx0XHQ6IFwiXCI7XG5cdFx0XHRcdHJldHVybiBjb25zdHJhaW50U3RyID8gYCR7YmFzZVR5cGV9JHtjb25zdHJhaW50U3RyfWAgOiBiYXNlVHlwZTtcblx0XHRcdH1cblx0XHRcdGNhc2UgXCJ2YXJpYWJsZVwiOiB7XG5cdFx0XHRcdGxldCB2YXJTdHIgPSBcIlwiO1xuXHRcdFx0XHRpZiAoIW1hcHBpbmcuaGFzKHQubmFtZSkpIHtcblx0XHRcdFx0XHQvLyBJZiB0aGUgdHlwZSB2YXJpYWJsZSBuYW1lIGlzIGEgc2luZ2xlIGxldHRlciwga2VlcCBpdCBhcy1pc1xuXHRcdFx0XHRcdC8vIFRoaXMgcHJlc2VydmVzIGV4cGxpY2l0IHR5cGUgYW5ub3RhdGlvbnMgbGlrZSAnYSAtPiBhJ1xuXHRcdFx0XHRcdGlmICh0Lm5hbWUubGVuZ3RoID09PSAxICYmIC9eW2Etel0kLy50ZXN0KHQubmFtZSkpIHtcblx0XHRcdFx0XHRcdG1hcHBpbmcuc2V0KHQubmFtZSwgdC5uYW1lKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWFwcGluZy5zZXQodC5uYW1lLCBncmVla1tuZXh0XSB8fCBgdCR7bmV4dH1gKTtcblx0XHRcdFx0XHRcdG5leHQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYmlvbWUtaWdub3JlIGxpbnQvc3R5bGUvbm9Ob25OdWxsQXNzZXJ0aW9uOiBpdCdzIHNldCBpZiBub3QgZGVmaW5lZCBhYm92ZVxuXHRcdFx0XHR2YXJTdHIgPSBtYXBwaW5nLmdldCh0Lm5hbWUpITtcblxuXHRcdFx0XHRyZXR1cm4gdmFyU3RyO1xuXHRcdFx0fVxuXHRcdFx0Y2FzZSBcImxpc3RcIjpcblx0XHRcdFx0cmV0dXJuIGBMaXN0ICR7bm9ybSh0LmVsZW1lbnQpfWA7XG5cdFx0XHRjYXNlIFwidHVwbGVcIjpcblx0XHRcdFx0cmV0dXJuIGAoJHt0LmVsZW1lbnRzLm1hcChub3JtKS5qb2luKFwiIFwiKX0pYDtcblx0XHRcdGNhc2UgXCJyZWNvcmRcIjpcblx0XHRcdFx0cmV0dXJuIGB7ICR7T2JqZWN0LmVudHJpZXModC5maWVsZHMpXG5cdFx0XHRcdFx0Lm1hcCgoW25hbWUsIGZpZWxkVHlwZV0pID0+IGAke25hbWV9OiAke25vcm0oZmllbGRUeXBlKX1gKVxuXHRcdFx0XHRcdC5qb2luKFwiIFwiKX0gfWA7XG5cdFx0XHRjYXNlIFwidW5pb25cIjpcblx0XHRcdFx0cmV0dXJuIGAoJHt0LnR5cGVzLm1hcChub3JtKS5qb2luKFwiIHwgXCIpfSlgO1xuXHRcdFx0Y2FzZSBcInZhcmlhbnRcIjpcblx0XHRcdFx0aWYgKHQuYXJncy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gdC5uYW1lO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBgJHt0Lm5hbWV9ICR7dC5hcmdzLm1hcChub3JtKS5qb2luKFwiIFwiKX1gO1xuXHRcdFx0XHR9XG5cdFx0XHRjYXNlIFwidW5pdFwiOlxuXHRcdFx0XHRyZXR1cm4gXCJ1bml0XCI7XG5cdFx0XHRjYXNlIFwidW5rbm93blwiOlxuXHRcdFx0XHRyZXR1cm4gXCI/XCI7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gXCJ1bmtub3duXCI7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0Q29uc3RyYWludChjOiBDb25zdHJhaW50KTogc3RyaW5nIHtcblx0XHRzd2l0Y2ggKGMua2luZCkge1xuXHRcdFx0Y2FzZSBcImlzXCI6IHtcblx0XHRcdFx0Ly8gVXNlIHRoZSBub3JtYWxpemVkIHZhcmlhYmxlIG5hbWUgZm9yIGNvbnNpc3RlbmN5XG5cdFx0XHRcdGNvbnN0IG5vcm1hbGl6ZWRWYXJOYW1lID0gbWFwcGluZy5nZXQoYy50eXBlVmFyKSB8fCBjLnR5cGVWYXI7XG5cdFx0XHRcdHJldHVybiBgJHtub3JtYWxpemVkVmFyTmFtZX0gaXMgJHtjLmNvbnN0cmFpbnR9YDtcblx0XHRcdH1cblx0XHRcdGNhc2UgXCJoYXNGaWVsZFwiOiB7XG5cdFx0XHRcdC8vIEZvciBoYXNGaWVsZCBjb25zdHJhaW50cywgd2UgbmVlZCB0byB1c2UgdGhlIG5vcm1hbGl6ZWQgdmFyaWFibGUgbmFtZVxuXHRcdFx0XHQvLyB0aGF0IG1hdGNoZXMgdGhlIHBhcmFtZXRlciBpdCdzIGNvbnN0cmFpbmluZ1xuXHRcdFx0XHRjb25zdCBub3JtYWxpemVkVmFyTmFtZTIgPSBtYXBwaW5nLmdldChjLnR5cGVWYXIpIHx8IGMudHlwZVZhcjtcblx0XHRcdFx0cmV0dXJuIGAke25vcm1hbGl6ZWRWYXJOYW1lMn0gaGFzIGZpZWxkIFwiJHtjLmZpZWxkfVwiIG9mIHR5cGUgJHtub3JtKFxuXHRcdFx0XHRcdGMuZmllbGRUeXBlLFxuXHRcdFx0XHQpfWA7XG5cdFx0XHR9XG5cdFx0XHRjYXNlIFwiaW1wbGVtZW50c1wiOiB7XG5cdFx0XHRcdGNvbnN0IG5vcm1hbGl6ZWRWYXJOYW1lMyA9IG1hcHBpbmcuZ2V0KGMudHlwZVZhcikgfHwgYy50eXBlVmFyO1xuXHRcdFx0XHRyZXR1cm4gYCR7bm9ybWFsaXplZFZhck5hbWUzfSBpbXBsZW1lbnRzICR7Yy5pbnRlcmZhY2VOYW1lfWA7XG5cdFx0XHR9XG5cdFx0XHRjYXNlIFwiY3VzdG9tXCI6IHtcblx0XHRcdFx0Y29uc3Qgbm9ybWFsaXplZFZhck5hbWU0ID0gbWFwcGluZy5nZXQoYy50eXBlVmFyKSB8fCBjLnR5cGVWYXI7XG5cdFx0XHRcdHJldHVybiBgJHtub3JtYWxpemVkVmFyTmFtZTR9IHNhdGlzZmllcyAke2MuY29uc3RyYWludH0gJHtjLmFyZ3Ncblx0XHRcdFx0XHQubWFwKG5vcm0pXG5cdFx0XHRcdFx0LmpvaW4oXCIgXCIpfWA7XG5cdFx0XHR9XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gXCJ1bmtub3duIGNvbnN0cmFpbnRcIjtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRDb25zdHJhaW50RXhwcihleHByOiBDb25zdHJhaW50RXhwcik6IHN0cmluZyB7XG5cdFx0c3dpdGNoIChleHByLmtpbmQpIHtcblx0XHRcdGNhc2UgXCJpc1wiOlxuXHRcdFx0Y2FzZSBcImhhc0ZpZWxkXCI6XG5cdFx0XHRjYXNlIFwiaW1wbGVtZW50c1wiOlxuXHRcdFx0Y2FzZSBcImN1c3RvbVwiOlxuXHRcdFx0XHRyZXR1cm4gZm9ybWF0Q29uc3RyYWludChleHByKTtcblx0XHRcdGNhc2UgXCJhbmRcIjpcblx0XHRcdFx0cmV0dXJuIGAke2Zvcm1hdENvbnN0cmFpbnRFeHByKGV4cHIubGVmdCl9IGFuZCAke2Zvcm1hdENvbnN0cmFpbnRFeHByKFxuXHRcdFx0XHRcdGV4cHIucmlnaHQsXG5cdFx0XHRcdCl9YDtcblx0XHRcdGNhc2UgXCJvclwiOlxuXHRcdFx0XHRyZXR1cm4gYCR7Zm9ybWF0Q29uc3RyYWludEV4cHIoZXhwci5sZWZ0KX0gb3IgJHtmb3JtYXRDb25zdHJhaW50RXhwcihcblx0XHRcdFx0XHRleHByLnJpZ2h0LFxuXHRcdFx0XHQpfWA7XG5cdFx0XHRjYXNlIFwicGFyZW5cIjpcblx0XHRcdFx0cmV0dXJuIGAoJHtmb3JtYXRDb25zdHJhaW50RXhwcihleHByLmV4cHIpfSlgO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIFwidW5rbm93biBjb25zdHJhaW50XCI7XG5cdFx0fVxuXHR9XG5cblx0Ly8gSGVscGVyIGZ1bmN0aW9uIHRvIGRlZHVwbGljYXRlIGNvbnN0cmFpbnRzXG5cdGZ1bmN0aW9uIGRlZHVwbGljYXRlQ29uc3RyYWludHMoY29uc3RyYWludHM6IENvbnN0cmFpbnRbXSk6IENvbnN0cmFpbnRbXSB7XG5cdFx0Y29uc3QgcmVzdWx0OiBDb25zdHJhaW50W10gPSBbXTtcblxuXHRcdGZvciAoY29uc3QgY29uc3RyYWludCBvZiBjb25zdHJhaW50cykge1xuXHRcdFx0Y29uc3QgaXNEdXBsaWNhdGUgPSByZXN1bHQuc29tZSgoYykgPT4gY29uc3RyYWludHNFcXVhbChjLCBjb25zdHJhaW50KSk7XG5cdFx0XHRpZiAoIWlzRHVwbGljYXRlKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKGNvbnN0cmFpbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvLyBBcHBseSBzdWJzdGl0dXRpb24gdG8gdGhlIHR5cGUgYmVmb3JlIG5vcm1hbGl6aW5nXG5cdGNvbnN0IHN1YnN0aXR1dGVkVHlwZSA9IHN1YnN0aXR1dGUodHlwZSwgc3Vic3RpdHV0aW9uKTtcblx0cmV0dXJuIG5vcm0oc3Vic3RpdHV0ZWRUeXBlKTtcbn07XG5cbi8vIENoZWNrIGlmIGEgdHlwZSB2YXJpYWJsZSBvY2N1cnMgaW4gYSB0eXBlIChmb3Igb2NjdXJzIGNoZWNrKVxuZXhwb3J0IGNvbnN0IG9jY3Vyc0luID0gKHZhck5hbWU6IHN0cmluZywgdHlwZTogVHlwZSk6IGJvb2xlYW4gPT4ge1xuXHRzd2l0Y2ggKHR5cGUua2luZCkge1xuXHRcdGNhc2UgXCJ2YXJpYWJsZVwiOlxuXHRcdFx0cmV0dXJuIHR5cGUubmFtZSA9PT0gdmFyTmFtZTtcblx0XHRjYXNlIFwiZnVuY3Rpb25cIjpcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdHR5cGUucGFyYW1zLnNvbWUoKHBhcmFtKSA9PiBvY2N1cnNJbih2YXJOYW1lLCBwYXJhbSkpIHx8XG5cdFx0XHRcdG9jY3Vyc0luKHZhck5hbWUsIHR5cGUucmV0dXJuKVxuXHRcdFx0KTtcblx0XHRjYXNlIFwibGlzdFwiOlxuXHRcdFx0cmV0dXJuIG9jY3Vyc0luKHZhck5hbWUsIHR5cGUuZWxlbWVudCk7XG5cdFx0Y2FzZSBcInR1cGxlXCI6XG5cdFx0XHRyZXR1cm4gdHlwZS5lbGVtZW50cy5zb21lKChlbGVtZW50KSA9PiBvY2N1cnNJbih2YXJOYW1lLCBlbGVtZW50KSk7XG5cdFx0Y2FzZSBcInJlY29yZFwiOlxuXHRcdFx0cmV0dXJuIE9iamVjdC52YWx1ZXModHlwZS5maWVsZHMpLnNvbWUoKGZpZWxkVHlwZSkgPT5cblx0XHRcdFx0b2NjdXJzSW4odmFyTmFtZSwgZmllbGRUeXBlKSxcblx0XHRcdCk7XG5cdFx0Y2FzZSBcInVuaW9uXCI6XG5cdFx0XHRyZXR1cm4gdHlwZS50eXBlcy5zb21lKCh0KSA9PiBvY2N1cnNJbih2YXJOYW1lLCB0KSk7XG5cdFx0Y2FzZSBcInZhcmlhbnRcIjpcblx0XHRcdHJldHVybiB0eXBlLmFyZ3Muc29tZSgoYXJnKSA9PiBvY2N1cnNJbih2YXJOYW1lLCBhcmcpKTtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59OyJdLCJuYW1lcyI6WyJjb25zdHJhaW50c0VxdWFsIiwiY3JlYXRlQmluYXJ5RnVuY3Rpb25UeXBlIiwiY3JlYXRlUG9seW1vcnBoaWNCaW5hcnlGdW5jdGlvbiIsImNyZWF0ZVBvbHltb3JwaGljVW5hcnlGdW5jdGlvbiIsImNyZWF0ZVVuYXJ5RnVuY3Rpb25UeXBlIiwiZm9ybWF0RWZmZWN0c1N0cmluZyIsImdldEV4cHJMb2NhdGlvbiIsImlzVHlwZUtpbmQiLCJtYXBPYmplY3QiLCJtYXBTZXQiLCJvY2N1cnNJbiIsInByb3BhZ2F0ZUNvbnN0cmFpbnRUb1R5cGVWYXJpYWJsZSIsInRocm93VHlwZUVycm9yIiwidHlwZVRvU3RyaW5nIiwidHlwZXNFcXVhbCIsInR5cGVzU2ltaWxhciIsImV4cHIiLCJsaW5lIiwibG9jYXRpb24iLCJzdGFydCIsImNvbHVtbiIsImVycm9yRmFjdG9yeSIsImxvYyIsIkVycm9yIiwiZm9ybWF0VHlwZUVycm9yIiwiZWZmZWN0cyIsInNpemUiLCJBcnJheSIsImZyb20iLCJtYXAiLCJlIiwiam9pbiIsInBhcmFtVHlwZSIsInJldHVyblR5cGUiLCJmdW5jdGlvblR5cGUiLCJwYXJhbTFUeXBlIiwicGFyYW0yVHlwZSIsInBhcmFtVmFyIiwicmV0dXJuVmFyIiwidHlwZVZhcmlhYmxlIiwicGFyYW0xVmFyIiwicGFyYW0yVmFyIiwib2JqIiwiZm4iLCJyZXN1bHQiLCJrIiwia2V5IiwidmFsdWUiLCJoYXMiLCJnZXQiLCJjb3B5IiwiTWFwIiwic2V0IiwidCIsImtpbmQiLCJ0eXBlc0VxdWFsQ2FjaGUiLCJ0MSIsInQyIiwibmFtZSIsImNhY2hlZCIsInVuZGVmaW5lZCIsInR5cGVzRXF1YWxVbmNhY2hlZCIsImYyIiwicGFyYW1zIiwibGVuZ3RoIiwiZXZlcnkiLCJwYXJhbSIsImkiLCJyZXR1cm4iLCJlbGVtZW50IiwidDJfdHVwbGUiLCJlbGVtZW50cyIsInQyX3JlY29yZCIsImtleXMxIiwiT2JqZWN0Iiwia2V5cyIsImZpZWxkcyIsImtleXMyIiwidDJfdW5pb24iLCJ0eXBlcyIsInR5cGUiLCJ0Ml92YXJpYW50IiwiYXJncyIsImFyZyIsInQyRnVuYyIsInAiLCJ0MlJlY29yZCIsImZpZWxkczEiLCJmaWVsZHMyIiwiZiIsInQyVHVwbGUiLCJ0MlVuaW9uIiwiYzEiLCJjMiIsInR5cGVWYXIiLCJjb25zdHJhaW50IiwiYzJIYXNGaWVsZCIsImZpZWxkIiwiZmllbGRUeXBlIiwiaW50ZXJmYWNlTmFtZSIsImZ1bmNUeXBlIiwiY29uc3RyYWludHMiLCJleGlzdGluZ0NvbnN0cmFpbnQiLCJmaW5kIiwiYyIsInB1c2giLCJzdWJzdGl0dXRpb24iLCJzaG93Q29uc3RyYWludHMiLCJncmVlayIsIm1hcHBpbmciLCJuZXh0Iiwibm9ybSIsInBhcmFtU3RyIiwiZWZmZWN0U3RyIiwiYmFzZVR5cGUiLCJjb25zdHJhaW50U3RyIiwib3JpZ2luYWxDb25zdHJhaW50IiwiZm9ybWF0Q29uc3RyYWludEV4cHIiLCJkZWR1cGxpY2F0ZUNvbnN0cmFpbnRzIiwiZm9ybWF0Q29uc3RyYWludCIsInZhclN0ciIsInRlc3QiLCJlbnRyaWVzIiwibm9ybWFsaXplZFZhck5hbWUiLCJub3JtYWxpemVkVmFyTmFtZTIiLCJub3JtYWxpemVkVmFyTmFtZTMiLCJub3JtYWxpemVkVmFyTmFtZTQiLCJsZWZ0IiwicmlnaHQiLCJpc0R1cGxpY2F0ZSIsInNvbWUiLCJzdWJzdGl0dXRlZFR5cGUiLCJzdWJzdGl0dXRlIiwidmFyTmFtZSIsInZhbHVlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7UUFzUGFBO2VBQUFBOztRQTlNQUM7ZUFBQUE7O1FBWUFDO2VBQUFBOztRQUxBQztlQUFBQTs7UUFaQUM7ZUFBQUE7O1FBTkdDO2VBQUFBOztRQWpCSEM7ZUFBQUE7O1FBeUVHQztlQUFBQTs7UUFyQkFDO2VBQUFBOztRQVVBQztlQUFBQTs7UUFvWkhDO2VBQUFBOztRQWpOQUM7ZUFBQUE7O1FBelBHQztlQUFBQTs7UUFpU0hDO2VBQUFBOztRQXBOQUM7ZUFBQUE7O1FBa0dBQztlQUFBQTs7O3FCQW5NMlI7NEJBQ3hROzRCQUVMO0FBU3BCLE1BQU1ULGtCQUFrQixDQUFDVSxPQUVYLENBQUE7UUFDbkJDLE1BQU1ELEtBQUtFLFFBQVEsRUFBRUMsTUFBTUYsUUFBUTtRQUNuQ0csUUFBUUosS0FBS0UsUUFBUSxFQUFFQyxNQUFNQyxVQUFVO0lBQ3pDLENBQUE7QUFHTyxTQUFTUixlQUNkUyxZQUFzRCxFQUN0REgsUUFBdUI7SUFFdkIsTUFBTUksTUFBTUosWUFBWTtRQUFFRCxNQUFNO1FBQUdHLFFBQVE7SUFBRTtJQUM3QyxNQUFNLElBQUlHLE1BQU1DLElBQUFBLDJCQUFlLEVBQUNILGFBQWFDO0FBQy9DO0FBR08sU0FBU2pCLG9CQUFvQm9CLE9BQW9CO0lBQ3RELElBQUlBLFFBQVFDLElBQUksS0FBSyxHQUFHLE9BQU87SUFDL0IsT0FBTyxDQUFDLENBQUMsRUFBRUMsTUFBTUMsSUFBSSxDQUFDSCxTQUFTSSxHQUFHLENBQUNDLENBQUFBLElBQUssQ0FBQyxDQUFDLEVBQUVBLEdBQUcsRUFBRUMsSUFBSSxDQUFDLE1BQU07QUFDOUQ7QUFHTyxNQUFNM0IsMEJBQTBCLENBQ3JDNEIsV0FDQUMsYUFDU0MsSUFBQUEsaUJBQVksRUFBQztRQUFDRjtLQUFVLEVBQUVDO0FB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