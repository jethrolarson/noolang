{"file":"/workspace/src/lexer.ts","mappings":";;;AAAA,+BAA2E;AAoB3E,MAAa,KAAK;IAMhB,YAAY,KAAa;QAJjB,aAAQ,GAAW,CAAC,CAAC;QACrB,SAAI,GAAW,CAAC,CAAC;QACjB,WAAM,GAAW,CAAC,CAAC;QAGzB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACrB,CAAC;IAEO,KAAK;QACX,OAAO,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;IAC5C,CAAC;IAEO,IAAI;QACV,OAAO,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACzD,CAAC;IAEO,QAAQ;QACd,OAAO,IAAI,CAAC,QAAQ,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM;YAC3C,CAAC,CAAC,IAAI;YACN,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC;IACpC,CAAC;IAEO,OAAO;QACb,IAAI,IAAI,CAAC,KAAK,EAAE;YAAE,OAAO,IAAI,CAAC;QAC9B,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,CAAC,QAAQ,EAAE,CAAC;QAChB,IAAI,IAAI,KAAK,IAAI,EAAE,CAAC;YAClB,IAAI,CAAC,IAAI,EAAE,CAAC;YACZ,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAClB,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,MAAM,EAAE,CAAC;QAChB,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,sDAAsD;IAC9C,cAAc;QACpB,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC;YAC/C,IAAI,CAAC,OAAO,EAAE,CAAC;QACjB,CAAC;QACD,qBAAqB;QACrB,IAAI,CAAC,WAAW,EAAE,CAAC;IACrB,CAAC;IAEO,WAAW;QACjB,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,EAAE,CAAC;YACxB,uBAAuB;YACvB,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,uCAAuC;YACvC,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,IAAI,EAAE,CAAC;gBAC7C,IAAI,CAAC,OAAO,EAAE,CAAC;YACjB,CAAC;QACH,CAAC;IACH,CAAC;IAEO,UAAU;QAChB,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QACpC,IAAI,KAAK,GAAG,EAAE,CAAC;QAEf,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC;YAC/C,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;QAC1B,CAAC;QAED,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC;YACtD,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,kBAAkB;YAC3C,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC;gBAC/C,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;YAC1B,CAAC;QACH,CAAC;QAED,OAAO;YACL,IAAI,EAAE,QAAQ;YACd,KAAK;YACL,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC;SACrC,CAAC;IACJ,CAAC;IAEO,UAAU;QAChB,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QACpC,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,wBAAwB;QACtD,IAAI,KAAK,GAAG,EAAE,CAAC;QAEf,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,KAAK,EAAE,CAAC;YAC9C,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,IAAI,EAAE,CAAC;gBACzB,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,oBAAoB;gBACpC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,CAAC;oBAClB,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,4BAA4B;gBACvD,CAAC;YACH,CAAC;iBAAM,CAAC;gBACN,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;YAC1B,CAAC;QACH,CAAC;QAED,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,KAAK,EAAE,CAAC;YAC1B,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,wBAAwB;QAC1C,CAAC;QAED,OAAO;YACL,IAAI,EAAE,QAAQ;YACd,KAAK;YACL,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC;SACrC,CAAC;IACJ,CAAC;IAEO,cAAc;QACpB,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QACpC,IAAI,KAAK,GAAG,EAAE,CAAC;QAEf,0DAA0D;QAC1D,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC;YACnD,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;QAC1B,CAAC;QAED,sEAAsE;QACtE,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC;YACzD,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;QAC1B,CAAC;QAED,iEAAiE;QACjE,IAAI,KAAK,KAAK,KAAK,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,EAAE,CAAC;YAC5D,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,gBAAgB;QAC3C,CAAC;QAED,0BAA0B;QAC1B,MAAM,QAAQ,GAAG;YACf,IAAI;YACJ,MAAM;YACN,MAAM;YACN,KAAK;YACL,IAAI;YACJ,IAAI;YACJ,QAAQ;YACR,KAAK;YACL,MAAM;YACN,OAAO;YACP,MAAM;YACN,OAAO;YACP,MAAM;YACN,OAAO;YACP,IAAI;YACJ,KAAK;YACL,IAAI;YACJ,YAAY;YACZ,YAAY;YACZ,WAAW;YACX,uBAAuB;YACvB,KAAK;YACL,QAAQ;YACR,QAAQ;YACR,MAAM;YACN,MAAM;SACP,CAAC;QACF,MAAM,IAAI,GAAG,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,YAAY,CAAC;QAEjE,OAAO;YACL,IAAI;YACJ,KAAK;YACL,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC;SACrC,CAAC;IACJ,CAAC;IAEO,YAAY;QAClB,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QACpC,IAAI,KAAK,GAAG,EAAE,CAAC;QAEf,2DAA2D;QAC3D,MAAM,SAAS,GAAG;YAChB,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,GAAG;YACH,GAAG;YACH,GAAG;YACH,GAAG;YACH,GAAG;YACH,GAAG;YACH,GAAG;YACH,GAAG;YACH,GAAG;SACJ,CAAC;QAEF,+CAA+C;QAC/C,KAAK,MAAM,EAAE,IAAI,SAAS,EAAE,CAAC;YAC3B,IACE,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC,MAAM,CAAC,KAAK,EAAE,EACrE,CAAC;gBACD,KAAK,GAAG,EAAE,CAAC;gBACX,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACnC,IAAI,CAAC,OAAO,EAAE,CAAC;gBACjB,CAAC;gBACD,MAAM;YACR,CAAC;QACH,CAAC;QAED,+DAA+D;QAC/D,IAAI,CAAC,KAAK,IAAI,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC;YAChD,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;QACzB,CAAC;QAED,OAAO;YACL,IAAI,EAAE,UAAU;YAChB,KAAK;YACL,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC;SACrC,CAAC;IACJ,CAAC;IAEO,eAAe;QACrB,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QACpC,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;QAE7B,OAAO;YACL,IAAI,EAAE,aAAa;YACnB,KAAK;YACL,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC;SACrC,CAAC;IACJ,CAAC;IAEO,YAAY;QAClB,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QACpC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,YAAY;QAC5B,IAAI,KAAK,GAAG,EAAE,CAAC;QAEf,gDAAgD;QAChD,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC;YACzD,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;QAC1B,CAAC;QAED,OAAO;YACL,IAAI,EAAE,UAAU;YAChB,KAAK,EAAE,KAAK;YACZ,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC;SACrC,CAAC;IACJ,CAAC;IAEO,cAAc;QACpB,OAAO,IAAA,oBAAc,EAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;IAChD,CAAC;IAEO,cAAc,CAAC,KAAe;QACpC,OAAO,IAAA,oBAAc,EAAC,KAAK,EAAE,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC;IACtD,CAAC;IAED,SAAS;QACP,+CAA+C;QAC/C,IAAI,CAAC,cAAc,EAAE,CAAC;QAEtB,IAAI,IAAI,CAAC,KAAK,EAAE,EAAE,CAAC;YACjB,OAAO;gBACL,IAAI,EAAE,KAAK;gBACX,KAAK,EAAE,EAAE;gBACT,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC;aACrD,CAAC;QACJ,CAAC;QAED,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QAEzB,4EAA4E;QAC5E,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;YACpB,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAO,IAAI,CAAC,SAAS,EAAE,CAAC;QAC1B,CAAC;QAED,IAAI,IAAI,KAAK,GAAG,IAAI,IAAI,KAAK,GAAG,EAAE,CAAC;YACjC,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;QAC3B,CAAC;QAED,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;YAC3B,OAAO,IAAI,CAAC,cAAc,EAAE,CAAC;QAC/B,CAAC;QAED,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;YACpB,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;QAC3B,CAAC;QAED,IAAI,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;YAC/B,OAAO,IAAI,CAAC,YAAY,EAAE,CAAC;QAC7B,CAAC;QAED,IAAI,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;YAC/B,OAAO,IAAI,CAAC,eAAe,EAAE,CAAC;QAChC,CAAC;QAED,mBAAmB;QACnB,IAAI,IAAI,KAAK,GAAG,EAAE,CAAC;YACjB,OAAO,IAAI,CAAC,YAAY,EAAE,CAAC;QAC7B,CAAC;QAED,kBAAkB;QAClB,IAAI,IAAI,KAAK,GAAG,EAAE,CAAC;YACjB,IAAI,CAAC,WAAW,EAAE,CAAC;YACnB,6CAA6C;YAC7C,OAAO,IAAI,CAAC,SAAS,EAAE,CAAC;QAC1B,CAAC;QAED,oBAAoB;QACpB,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QACpC,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;QAC7B,yEAAyE;QACzE,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;YACrB,OAAO,IAAI,CAAC,SAAS,EAAE,CAAC;QAC1B,CAAC;QACD,OAAO;YACL,IAAI,EAAE,aAAa;YACnB,KAAK;YACL,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC;SACrC,CAAC;IACJ,CAAC;IAED,QAAQ;QACN,MAAM,MAAM,GAAY,EAAE,CAAC;QAC3B,IAAI,KAAY,CAAC;QAEjB,GAAG,CAAC;YACF,KAAK,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;YACzB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACrB,CAAC,QAAQ,KAAK,CAAC,IAAI,KAAK,KAAK,EAAE;QAE/B,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AAtUD,sBAsUC","names":[],"sources":["/workspace/src/lexer.ts"],"sourcesContent":["import { Position, Location, createPosition, createLocation } from \"./ast\";\n\nexport type TokenType =\n  | \"IDENTIFIER\"\n  | \"NUMBER\"\n  | \"STRING\"\n  | \"BOOLEAN\"\n  | \"OPERATOR\"\n  | \"PUNCTUATION\"\n  | \"KEYWORD\"\n  | \"COMMENT\"\n  | \"ACCESSOR\"\n  | \"EOF\";\n\nexport interface Token {\n  type: TokenType;\n  value: string;\n  location: Location;\n}\n\nexport class Lexer {\n  private input: string;\n  private position: number = 0;\n  private line: number = 1;\n  private column: number = 1;\n\n  constructor(input: string) {\n    this.input = input;\n  }\n\n  private isEOF(): boolean {\n    return this.position >= this.input.length;\n  }\n\n  private peek(): string {\n    return this.isEOF() ? \"\\0\" : this.input[this.position];\n  }\n\n  private peekNext(): string {\n    return this.position + 1 >= this.input.length\n      ? \"\\0\"\n      : this.input[this.position + 1];\n  }\n\n  private advance(): string {\n    if (this.isEOF()) return \"\\0\";\n    const char = this.input[this.position];\n    this.position++;\n    if (char === \"\\n\") {\n      this.line++;\n      this.column = 1;\n    } else {\n      this.column++;\n    }\n    return char;\n  }\n\n  // Skip any run of whitespace (spaces, tabs, newlines)\n  private skipWhitespace(): void {\n    while (!this.isEOF() && /\\s/.test(this.peek())) {\n      this.advance();\n    }\n    // Also skip comments\n    this.skipComment();\n  }\n\n  private skipComment(): void {\n    if (this.peek() === \"#\") {\n      // Skip the # character\n      this.advance();\n      // Skip everything until newline or EOF\n      while (!this.isEOF() && this.peek() !== \"\\n\") {\n        this.advance();\n      }\n    }\n  }\n\n  private readNumber(): Token {\n    const start = this.createPosition();\n    let value = \"\";\n\n    while (!this.isEOF() && /\\d/.test(this.peek())) {\n      value += this.advance();\n    }\n\n    if (this.peek() === \".\" && /\\d/.test(this.peekNext())) {\n      value += this.advance(); // consume the dot\n      while (!this.isEOF() && /\\d/.test(this.peek())) {\n        value += this.advance();\n      }\n    }\n\n    return {\n      type: \"NUMBER\",\n      value,\n      location: this.createLocation(start),\n    };\n  }\n\n  private readString(): Token {\n    const start = this.createPosition();\n    const quote = this.advance(); // consume opening quote\n    let value = \"\";\n\n    while (!this.isEOF() && this.peek() !== quote) {\n      if (this.peek() === \"\\\\\") {\n        this.advance(); // consume backslash\n        if (!this.isEOF()) {\n          value += this.advance(); // consume escaped character\n        }\n      } else {\n        value += this.advance();\n      }\n    }\n\n    if (this.peek() === quote) {\n      this.advance(); // consume closing quote\n    }\n\n    return {\n      type: \"STRING\",\n      value,\n      location: this.createLocation(start),\n    };\n  }\n\n  private readIdentifier(): Token {\n    const start = this.createPosition();\n    let value = \"\";\n\n    // Read the first character (must be letter or underscore)\n    if (!this.isEOF() && /[a-zA-Z_]/.test(this.peek())) {\n      value += this.advance();\n    }\n\n    // Read subsequent characters (can be letters, digits, or underscores)\n    while (!this.isEOF() && /[a-zA-Z0-9_]/.test(this.peek())) {\n      value += this.advance();\n    }\n\n    // Special case for mut! - check if we have \"mut\" followed by \"!\"\n    if (value === \"mut\" && !this.isEOF() && this.peek() === \"!\") {\n      value += this.advance(); // consume the !\n    }\n\n    // Check if it's a keyword\n    const keywords = [\n      \"if\",\n      \"then\",\n      \"else\",\n      \"let\",\n      \"in\",\n      \"fn\",\n      \"import\",\n      \"mut\",\n      \"mut!\",\n      \"where\",\n      \"type\",\n      \"match\",\n      \"with\",\n      \"given\",\n      \"is\",\n      \"and\",\n      \"or\",\n      \"implements\",\n      \"constraint\",\n      \"implement\",\n      // Primitive type names\n      \"Int\",\n      \"Number\",\n      \"String\",\n      \"Unit\",\n      \"List\",\n    ];\n    const type = keywords.includes(value) ? \"KEYWORD\" : \"IDENTIFIER\";\n\n    return {\n      type,\n      value,\n      location: this.createLocation(start),\n    };\n  }\n\n  private readOperator(): Token {\n    const start = this.createPosition();\n    let value = \"\";\n\n    // Multi-character operators (must have spaces around them)\n    const operators = [\n      \"|>\",\n      \"<|\",\n      \"==\",\n      \"!=\",\n      \"<=\",\n      \">=\",\n      \"=>\",\n      \"->\",\n      \"+\",\n      \"-\",\n      \"*\",\n      \"/\",\n      \"<\",\n      \">\",\n      \"=\",\n      \"|\",\n      \"$\",\n    ];\n\n    // Try to match multi-character operators first\n    for (const op of operators) {\n      if (\n        this.input.substring(this.position, this.position + op.length) === op\n      ) {\n        value = op;\n        for (let i = 0; i < op.length; i++) {\n          this.advance();\n        }\n        break;\n      }\n    }\n\n    // If no multi-character operator matched, try single character\n    if (!value && /[+\\-*/<>=!|$]/.test(this.peek())) {\n      value = this.advance();\n    }\n\n    return {\n      type: \"OPERATOR\",\n      value,\n      location: this.createLocation(start),\n    };\n  }\n\n  private readPunctuation(): Token {\n    const start = this.createPosition();\n    const value = this.advance();\n\n    return {\n      type: \"PUNCTUATION\",\n      value,\n      location: this.createLocation(start),\n    };\n  }\n\n  private readAccessor(): Token {\n    const start = this.createPosition();\n    this.advance(); // consume @\n    let field = \"\";\n\n    // Read letters, digits, and underscores after @\n    while (!this.isEOF() && /[a-zA-Z0-9_]/.test(this.peek())) {\n      field += this.advance();\n    }\n\n    return {\n      type: \"ACCESSOR\",\n      value: field,\n      location: this.createLocation(start),\n    };\n  }\n\n  private createPosition(): Position {\n    return createPosition(this.line, this.column);\n  }\n\n  private createLocation(start: Position): Location {\n    return createLocation(start, this.createPosition());\n  }\n\n  nextToken(): Token {\n    // Skip any whitespace (spaces, tabs, newlines)\n    this.skipWhitespace();\n\n    if (this.isEOF()) {\n      return {\n        type: \"EOF\",\n        value: \"\",\n        location: this.createLocation(this.createPosition()),\n      };\n    }\n\n    const char = this.peek();\n\n    // If the next character is still whitespace, skip it and get the next token\n    if (/\\s/.test(char)) {\n      this.advance();\n      return this.nextToken();\n    }\n\n    if (char === '\"' || char === \"'\") {\n      return this.readString();\n    }\n\n    if (/[a-zA-Z_]/.test(char)) {\n      return this.readIdentifier();\n    }\n\n    if (/\\d/.test(char)) {\n      return this.readNumber();\n    }\n\n    if (/[+\\-*/<>=!|$]/.test(char)) {\n      return this.readOperator();\n    }\n\n    if (/[(),;:\\[\\]{}]/.test(char)) {\n      return this.readPunctuation();\n    }\n\n    // Handle accessors\n    if (char === \"@\") {\n      return this.readAccessor();\n    }\n\n    // Handle comments\n    if (char === \"#\") {\n      this.skipComment();\n      // After skipping comment, get the next token\n      return this.nextToken();\n    }\n\n    // Unknown character\n    const start = this.createPosition();\n    const value = this.advance();\n    // If the unknown character is whitespace, skip it and get the next token\n    if (/\\s/.test(value)) {\n      return this.nextToken();\n    }\n    return {\n      type: \"PUNCTUATION\",\n      value,\n      location: this.createLocation(start),\n    };\n  }\n\n  tokenize(): Token[] {\n    const tokens: Token[] = [];\n    let token: Token;\n\n    do {\n      token = this.nextToken();\n      tokens.push(token);\n    } while (token.type !== \"EOF\");\n\n    return tokens;\n  }\n}\n"],"version":3}