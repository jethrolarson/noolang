04957bea8a34f2326a8bbc7a6dd535ce
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.accessor = exports.punctuation = exports.operator = exports.keyword = exports.string = exports.number = exports.identifier = exports.parseAll = exports.sepBy = exports.lazy = exports.map = exports.optional = exports.many1 = exports.many = exports.choice = exports.seq = exports.anyToken = exports.token = void 0;
// Basic token matching
const token = (type, value) => (tokens) => {
    if (tokens.length === 0) {
        return {
            success: false,
            error: `Expected ${type}${value ? ` '${value}'` : ""}, but got end of input`,
            position: 0,
        };
    }
    const [first, ...rest] = tokens;
    if (first.type === type && (value === undefined || first.value === value)) {
        return {
            success: true,
            value: first,
            remaining: rest,
        };
    }
    return {
        success: false,
        error: `Expected ${type}${value ? ` '${value}'` : ""}, but got ${first.type} '${first.value}'`,
        position: first.location.start.line,
    };
};
exports.token = token;
// Match any token
const anyToken = () => (tokens) => {
    if (tokens.length === 0) {
        return {
            success: false,
            error: "Expected any token, but got end of input",
            position: 0,
        };
    }
    const [first, ...rest] = tokens;
    return {
        success: true,
        value: first,
        remaining: rest,
    };
};
exports.anyToken = anyToken;
// Sequence of parsers
const seq = (...parsers) => (tokens) => {
    const results = [];
    let remaining = tokens;
    for (const parser of parsers) {
        const result = parser(remaining);
        if (!result.success) {
            return result;
        }
        results.push(result.value);
        remaining = result.remaining;
    }
    return {
        success: true,
        value: results,
        remaining,
    };
};
exports.seq = seq;
// Choice between parsers (try each until one succeeds)
const choice = (...parsers) => (tokens) => {
    let lastError = "";
    let lastPosition = 0;
    for (const parser of parsers) {
        const result = parser(tokens);
        if (result.success) {
            return result;
        }
        // Keep track of the error from the parser that got furthest
        if (result.position > lastPosition) {
            lastError = result.error;
            lastPosition = result.position;
        }
    }
    return {
        success: false,
        error: lastError,
        position: lastPosition,
    };
};
exports.choice = choice;
// Zero or more repetitions
const many = (parser) => (tokens) => {
    const results = [];
    let remaining = tokens;
    while (remaining.length > 0) {
        const result = parser(remaining);
        if (!result.success) {
            break;
        }
        results.push(result.value);
        remaining = result.remaining;
    }
    return {
        success: true,
        value: results,
        remaining,
    };
};
exports.many = many;
// One or more repetitions
const many1 = (parser) => (tokens) => {
    const manyResult = (0, exports.many)(parser)(tokens);
    if (!manyResult.success || manyResult.value.length === 0) {
        return {
            success: false,
            error: "Expected at least one occurrence",
            position: tokens[0]?.location.start.line || 0,
        };
    }
    return manyResult;
};
exports.many1 = many1;
// Optional parser (zero or one)
const optional = (parser) => (tokens) => {
    const result = parser(tokens);
    return result.success
        ? result
        : {
            success: true,
            value: null,
            remaining: tokens,
        };
};
exports.optional = optional;
// Transform parse result
const map = (parser, fn) => (tokens) => {
    const result = parser(tokens);
    return result.success
        ? {
            success: true,
            value: fn(result.value),
            remaining: result.remaining,
        }
        : result;
};
exports.map = map;
// Lazy parser for recursive grammars
const lazy = (parserFn) => (tokens) => parserFn()(tokens);
exports.lazy = lazy;
// Separated by something
const sepBy = (parser, separator) => {
    return (tokens) => {
        const results = [];
        let remaining = tokens;
        // Parse first element
        const firstResult = parser(remaining);
        if (!firstResult.success) {
            return {
                success: true,
                value: [],
                remaining,
            };
        }
        results.push(firstResult.value);
        remaining = firstResult.remaining;
        // Parse subsequent elements separated by separator
        while (remaining.length > 0) {
            const sepResult = separator(remaining);
            if (!sepResult.success) {
                break;
            }
            const elemResult = parser(sepResult.remaining);
            if (!elemResult.success) {
                break;
            }
            results.push(elemResult.value);
            remaining = elemResult.remaining;
        }
        return {
            success: true,
            value: results,
            remaining,
        };
    };
};
exports.sepBy = sepBy;
// Parse until end of input
const parseAll = (parser) => (tokens) => {
    const result = parser(tokens);
    if (!result.success || !result.remaining.length) {
        return result;
    }
    const unexpected = result.remaining[0];
    return {
        success: false,
        error: `Unexpected ${unexpected.type} '${unexpected.value}' at end of input`,
        position: unexpected.location.start.line,
    };
};
exports.parseAll = parseAll;
// Convenience parsers for common token types
const identifier = () => (0, exports.token)("IDENTIFIER");
exports.identifier = identifier;
const number = () => (0, exports.token)("NUMBER");
exports.number = number;
const string = () => (0, exports.token)("STRING");
exports.string = string;
const keyword = (value) => (0, exports.token)("KEYWORD", value);
exports.keyword = keyword;
const operator = (value) => (0, exports.token)("OPERATOR", value);
exports.operator = operator;
const punctuation = (value) => (0, exports.token)("PUNCTUATION", value);
exports.punctuation = punctuation;
const accessor = () => (0, exports.token)("ACCESSOR");
exports.accessor = accessor;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL3dvcmtzcGFjZS9zcmMvcGFyc2VyL2NvbWJpbmF0b3JzLnRzIiwibWFwcGluZ3MiOiI7OztBQWtCQSx1QkFBdUI7QUFDaEIsTUFBTSxLQUFLLEdBQ2hCLENBQUMsSUFBZSxFQUFFLEtBQWMsRUFBaUIsRUFBRSxDQUNuRCxDQUFDLE1BQWUsRUFBRSxFQUFFO0lBQ2xCLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUN4QixPQUFPO1lBQ0wsT0FBTyxFQUFFLEtBQUs7WUFDZCxLQUFLLEVBQUUsWUFBWSxJQUFJLEdBQ3JCLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFDMUIsd0JBQXdCO1lBQ3hCLFFBQVEsRUFBRSxDQUFDO1NBQ1osQ0FBQztJQUNKLENBQUM7SUFFRCxNQUFNLENBQUMsS0FBSyxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDO0lBQ2hDLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssU0FBUyxJQUFJLEtBQUssQ0FBQyxLQUFLLEtBQUssS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUMxRSxPQUFPO1lBQ0wsT0FBTyxFQUFFLElBQUk7WUFDYixLQUFLLEVBQUUsS0FBSztZQUNaLFNBQVMsRUFBRSxJQUFJO1NBQ2hCLENBQUM7SUFDSixDQUFDO0lBRUQsT0FBTztRQUNMLE9BQU8sRUFBRSxLQUFLO1FBQ2QsS0FBSyxFQUFFLFlBQVksSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxhQUNsRCxLQUFLLENBQUMsSUFDUixLQUFLLEtBQUssQ0FBQyxLQUFLLEdBQUc7UUFDbkIsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUk7S0FDcEMsQ0FBQztBQUNKLENBQUMsQ0FBQztBQTdCUyxRQUFBLEtBQUssU0E2QmQ7QUFFSixrQkFBa0I7QUFDWCxNQUFNLFFBQVEsR0FBRyxHQUFrQixFQUFFLENBQUMsQ0FBQyxNQUFlLEVBQUUsRUFBRTtJQUMvRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDeEIsT0FBTztZQUNMLE9BQU8sRUFBRSxLQUFLO1lBQ2QsS0FBSyxFQUFFLDBDQUEwQztZQUNqRCxRQUFRLEVBQUUsQ0FBQztTQUNaLENBQUM7SUFDSixDQUFDO0lBRUQsTUFBTSxDQUFDLEtBQUssRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQztJQUNoQyxPQUFPO1FBQ0wsT0FBTyxFQUFFLElBQUk7UUFDYixLQUFLLEVBQUUsS0FBSztRQUNaLFNBQVMsRUFBRSxJQUFJO0tBQ2hCLENBQUM7QUFDSixDQUFDLENBQUM7QUFmVyxRQUFBLFFBQVEsWUFlbkI7QUFFRixzQkFBc0I7QUFDZixNQUFNLEdBQUcsR0FDZCxDQUFrQixHQUFHLE9BQXlDLEVBQWEsRUFBRSxDQUM3RSxDQUFDLE1BQWUsRUFBRSxFQUFFO0lBQ2xCLE1BQU0sT0FBTyxHQUFRLEVBQUUsQ0FBQztJQUN4QixJQUFJLFNBQVMsR0FBRyxNQUFNLENBQUM7SUFFdkIsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUM3QixNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNwQixPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO1FBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0IsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDL0IsQ0FBQztJQUVELE9BQU87UUFDTCxPQUFPLEVBQUUsSUFBSTtRQUNiLEtBQUssRUFBRSxPQUFZO1FBQ25CLFNBQVM7S0FDVixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBcEJTLFFBQUEsR0FBRyxPQW9CWjtBQUVKLHVEQUF1RDtBQUNoRCxNQUFNLE1BQU0sR0FDakIsQ0FBSSxHQUFHLE9BQW9CLEVBQWEsRUFBRSxDQUMxQyxDQUFDLE1BQWUsRUFBRSxFQUFFO0lBQ2xCLElBQUksU0FBUyxHQUFXLEVBQUUsQ0FBQztJQUMzQixJQUFJLFlBQVksR0FBVyxDQUFDLENBQUM7SUFFN0IsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUM3QixNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDOUIsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDbkIsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUNELDREQUE0RDtRQUM1RCxJQUFJLE1BQU0sQ0FBQyxRQUFRLEdBQUcsWUFBWSxFQUFFLENBQUM7WUFDbkMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUM7WUFDekIsWUFBWSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUM7UUFDakMsQ0FBQztJQUNILENBQUM7SUFFRCxPQUFPO1FBQ0wsT0FBTyxFQUFFLEtBQUs7UUFDZCxLQUFLLEVBQUUsU0FBUztRQUNoQixRQUFRLEVBQUUsWUFBWTtLQUN2QixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBdkJTLFFBQUEsTUFBTSxVQXVCZjtBQUVKLDJCQUEyQjtBQUNwQixNQUFNLElBQUksR0FDZixDQUFJLE1BQWlCLEVBQWUsRUFBRSxDQUN0QyxDQUFDLE1BQWUsRUFBRSxFQUFFO0lBQ2xCLE1BQU0sT0FBTyxHQUFRLEVBQUUsQ0FBQztJQUN4QixJQUFJLFNBQVMsR0FBRyxNQUFNLENBQUM7SUFFdkIsT0FBTyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQzVCLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3BCLE1BQU07UUFDUixDQUFDO1FBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0IsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDL0IsQ0FBQztJQUVELE9BQU87UUFDTCxPQUFPLEVBQUUsSUFBSTtRQUNiLEtBQUssRUFBRSxPQUFPO1FBQ2QsU0FBUztLQUNWLENBQUM7QUFDSixDQUFDLENBQUM7QUFwQlMsUUFBQSxJQUFJLFFBb0JiO0FBRUosMEJBQTBCO0FBQ25CLE1BQU0sS0FBSyxHQUNoQixDQUFJLE1BQWlCLEVBQWUsRUFBRSxDQUN0QyxDQUFDLE1BQWUsRUFBRSxFQUFFO0lBQ2xCLE1BQU0sVUFBVSxHQUFHLElBQUEsWUFBSSxFQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQ3pELE9BQU87WUFDTCxPQUFPLEVBQUUsS0FBSztZQUNkLEtBQUssRUFBRSxrQ0FBa0M7WUFDekMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDO1NBQzlDLENBQUM7SUFDSixDQUFDO0lBQ0QsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQyxDQUFDO0FBWlMsUUFBQSxLQUFLLFNBWWQ7QUFFSixnQ0FBZ0M7QUFDekIsTUFBTSxRQUFRLEdBQ25CLENBQUksTUFBaUIsRUFBb0IsRUFBRSxDQUMzQyxDQUFDLE1BQWUsRUFBRSxFQUFFO0lBQ2xCLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM5QixPQUFPLE1BQU0sQ0FBQyxPQUFPO1FBQ3BCLENBQUMsQ0FBQyxNQUFNO1FBQ1IsQ0FBQyxDQUFDO1lBQ0EsT0FBTyxFQUFFLElBQUk7WUFDYixLQUFLLEVBQUUsSUFBSTtZQUNYLFNBQVMsRUFBRSxNQUFNO1NBQ2pCLENBQUM7QUFDTixDQUFDLENBQUM7QUFYUyxRQUFBLFFBQVEsWUFXakI7QUFFSix5QkFBeUI7QUFDbEIsTUFBTSxHQUFHLEdBQ2QsQ0FBTyxNQUFpQixFQUFFLEVBQW1CLEVBQWEsRUFBRSxDQUM1RCxDQUFDLE1BQWUsRUFBRSxFQUFFO0lBQ2xCLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM5QixPQUFPLE1BQU0sQ0FBQyxPQUFPO1FBQ3BCLENBQUMsQ0FBQztZQUNBLE9BQU8sRUFBRSxJQUFJO1lBQ2IsS0FBSyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO1lBQ3ZCLFNBQVMsRUFBRSxNQUFNLENBQUMsU0FBUztTQUMzQjtRQUNGLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDWixDQUFDLENBQUM7QUFYUyxRQUFBLEdBQUcsT0FXWjtBQUVKLHFDQUFxQztBQUM5QixNQUFNLElBQUksR0FDZixDQUFJLFFBQXlCLEVBQWEsRUFBRSxDQUM1QyxDQUFDLE1BQWUsRUFBRSxFQUFFLENBQ2xCLFFBQVEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBSFYsUUFBQSxJQUFJLFFBR007QUFFdkIseUJBQXlCO0FBQ2xCLE1BQU0sS0FBSyxHQUFHLENBQ25CLE1BQWlCLEVBQ2pCLFNBQW9CLEVBQ1AsRUFBRTtJQUNmLE9BQU8sQ0FBQyxNQUFlLEVBQUUsRUFBRTtRQUN6QixNQUFNLE9BQU8sR0FBUSxFQUFFLENBQUM7UUFDeEIsSUFBSSxTQUFTLEdBQUcsTUFBTSxDQUFDO1FBRXZCLHNCQUFzQjtRQUN0QixNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUN6QixPQUFPO2dCQUNMLE9BQU8sRUFBRSxJQUFJO2dCQUNiLEtBQUssRUFBRSxFQUFFO2dCQUNULFNBQVM7YUFDVixDQUFDO1FBQ0osQ0FBQztRQUVELE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2hDLFNBQVMsR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDO1FBRWxDLG1EQUFtRDtRQUNuRCxPQUFPLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7WUFDNUIsTUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ3ZCLE1BQU07WUFDUixDQUFDO1lBRUQsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUMvQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUN4QixNQUFNO1lBQ1IsQ0FBQztZQUVELE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQy9CLFNBQVMsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDO1FBQ25DLENBQUM7UUFFRCxPQUFPO1lBQ0wsT0FBTyxFQUFFLElBQUk7WUFDYixLQUFLLEVBQUUsT0FBTztZQUNkLFNBQVM7U0FDVixDQUFDO0lBQ0osQ0FBQyxDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBM0NXLFFBQUEsS0FBSyxTQTJDaEI7QUFFRiwyQkFBMkI7QUFDcEIsTUFBTSxRQUFRLEdBQ3BCLENBQUksTUFBaUIsRUFBYSxFQUFFLENBQ3BDLENBQUMsTUFBZSxFQUFFLEVBQUU7SUFDbkIsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzlCLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNqRCxPQUFPLE1BQU0sQ0FBQztJQUNmLENBQUM7SUFFRCxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZDLE9BQU87UUFDTixPQUFPLEVBQUUsS0FBSztRQUNkLEtBQUssRUFBRSxjQUFjLFVBQVUsQ0FBQyxJQUFJLEtBQUssVUFBVSxDQUFDLEtBQUssbUJBQW1CO1FBQzVFLFFBQVEsRUFBRSxVQUFVLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJO0tBQ3hDLENBQUM7QUFDSCxDQUFDLENBQUM7QUFkVSxRQUFBLFFBQVEsWUFjbEI7QUFFSCw2Q0FBNkM7QUFDdEMsTUFBTSxVQUFVLEdBQUcsR0FBa0IsRUFBRSxDQUFDLElBQUEsYUFBSyxFQUFDLFlBQVksQ0FBQyxDQUFDO0FBQXRELFFBQUEsVUFBVSxjQUE0QztBQUM1RCxNQUFNLE1BQU0sR0FBRyxHQUFrQixFQUFFLENBQUMsSUFBQSxhQUFLLEVBQUMsUUFBUSxDQUFDLENBQUM7QUFBOUMsUUFBQSxNQUFNLFVBQXdDO0FBQ3BELE1BQU0sTUFBTSxHQUFHLEdBQWtCLEVBQUUsQ0FBQyxJQUFBLGFBQUssRUFBQyxRQUFRLENBQUMsQ0FBQztBQUE5QyxRQUFBLE1BQU0sVUFBd0M7QUFDcEQsTUFBTSxPQUFPLEdBQUcsQ0FBQyxLQUFhLEVBQWlCLEVBQUUsQ0FDdkQsSUFBQSxhQUFLLEVBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBRFosUUFBQSxPQUFPLFdBQ0s7QUFDbEIsTUFBTSxRQUFRLEdBQUcsQ0FBQyxLQUFhLEVBQWlCLEVBQUUsQ0FDeEQsSUFBQSxhQUFLLEVBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBRGIsUUFBQSxRQUFRLFlBQ0s7QUFDbkIsTUFBTSxXQUFXLEdBQUcsQ0FBQyxLQUFhLEVBQWlCLEVBQUUsQ0FDM0QsSUFBQSxhQUFLLEVBQUMsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBRGhCLFFBQUEsV0FBVyxlQUNLO0FBQ3RCLE1BQU0sUUFBUSxHQUFHLEdBQWtCLEVBQUUsQ0FBQyxJQUFBLGFBQUssRUFBQyxVQUFVLENBQUMsQ0FBQztBQUFsRCxRQUFBLFFBQVEsWUFBMEMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL3dvcmtzcGFjZS9zcmMvcGFyc2VyL2NvbWJpbmF0b3JzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgVG9rZW4sIFRva2VuVHlwZSB9IGZyb20gXCIuLi9sZXhlclwiO1xuXG5leHBvcnQgdHlwZSBQYXJzZUVycm9yID0ge1xuICBzdWNjZXNzOiBmYWxzZTtcbiAgZXJyb3I6IHN0cmluZztcbiAgcG9zaXRpb246IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIFBhcnNlU3VjY2VzczxUPiA9IHtcbiAgc3VjY2VzczogdHJ1ZTtcbiAgdmFsdWU6IFQ7XG4gIHJlbWFpbmluZzogVG9rZW5bXTtcbn07XG5cbmV4cG9ydCB0eXBlIFBhcnNlUmVzdWx0PFQ+ID0gUGFyc2VTdWNjZXNzPFQ+IHwgUGFyc2VFcnJvcjtcblxuZXhwb3J0IHR5cGUgUGFyc2VyPFQ+ID0gKHRva2VuczogVG9rZW5bXSkgPT4gUGFyc2VSZXN1bHQ8VD47XG5cbi8vIEJhc2ljIHRva2VuIG1hdGNoaW5nXG5leHBvcnQgY29uc3QgdG9rZW4gPVxuICAodHlwZTogVG9rZW5UeXBlLCB2YWx1ZT86IHN0cmluZyk6IFBhcnNlcjxUb2tlbj4gPT5cbiAgKHRva2VuczogVG9rZW5bXSkgPT4ge1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBFeHBlY3RlZCAke3R5cGV9JHtcbiAgICAgICAgICB2YWx1ZSA/IGAgJyR7dmFsdWV9J2AgOiBcIlwiXG4gICAgICAgIH0sIGJ1dCBnb3QgZW5kIG9mIGlucHV0YCxcbiAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IFtmaXJzdCwgLi4ucmVzdF0gPSB0b2tlbnM7XG4gICAgaWYgKGZpcnN0LnR5cGUgPT09IHR5cGUgJiYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgZmlyc3QudmFsdWUgPT09IHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZpcnN0LFxuICAgICAgICByZW1haW5pbmc6IHJlc3QsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBgRXhwZWN0ZWQgJHt0eXBlfSR7dmFsdWUgPyBgICcke3ZhbHVlfSdgIDogXCJcIn0sIGJ1dCBnb3QgJHtcbiAgICAgICAgZmlyc3QudHlwZVxuICAgICAgfSAnJHtmaXJzdC52YWx1ZX0nYCxcbiAgICAgIHBvc2l0aW9uOiBmaXJzdC5sb2NhdGlvbi5zdGFydC5saW5lLFxuICAgIH07XG4gIH07XG5cbi8vIE1hdGNoIGFueSB0b2tlblxuZXhwb3J0IGNvbnN0IGFueVRva2VuID0gKCk6IFBhcnNlcjxUb2tlbj4gPT4gKHRva2VuczogVG9rZW5bXSkgPT4ge1xuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBcIkV4cGVjdGVkIGFueSB0b2tlbiwgYnV0IGdvdCBlbmQgb2YgaW5wdXRcIixcbiAgICAgIHBvc2l0aW9uOiAwLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBbZmlyc3QsIC4uLnJlc3RdID0gdG9rZW5zO1xuICByZXR1cm4ge1xuICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgdmFsdWU6IGZpcnN0LFxuICAgIHJlbWFpbmluZzogcmVzdCxcbiAgfTtcbn07XG5cbi8vIFNlcXVlbmNlIG9mIHBhcnNlcnNcbmV4cG9ydCBjb25zdCBzZXEgPVxuICA8VCBleHRlbmRzIGFueVtdPiguLi5wYXJzZXJzOiB7IFtLIGluIGtleW9mIFRdOiBQYXJzZXI8VFtLXT4gfSk6IFBhcnNlcjxUPiA9PlxuICAodG9rZW5zOiBUb2tlbltdKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0czogVFtdID0gW107XG4gICAgbGV0IHJlbWFpbmluZyA9IHRva2VucztcblxuICAgIGZvciAoY29uc3QgcGFyc2VyIG9mIHBhcnNlcnMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihyZW1haW5pbmcpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICByZW1haW5pbmcgPSByZXN1bHQucmVtYWluaW5nO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgdmFsdWU6IHJlc3VsdHMgYXMgVCxcbiAgICAgIHJlbWFpbmluZyxcbiAgICB9O1xuICB9O1xuXG4vLyBDaG9pY2UgYmV0d2VlbiBwYXJzZXJzICh0cnkgZWFjaCB1bnRpbCBvbmUgc3VjY2VlZHMpXG5leHBvcnQgY29uc3QgY2hvaWNlID1cbiAgPFQ+KC4uLnBhcnNlcnM6IFBhcnNlcjxUPltdKTogUGFyc2VyPFQ+ID0+XG4gICh0b2tlbnM6IFRva2VuW10pID0+IHtcbiAgICBsZXQgbGFzdEVycm9yOiBzdHJpbmcgPSBcIlwiO1xuICAgIGxldCBsYXN0UG9zaXRpb246IG51bWJlciA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IHBhcnNlciBvZiBwYXJzZXJzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIodG9rZW5zKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgZXJyb3IgZnJvbSB0aGUgcGFyc2VyIHRoYXQgZ290IGZ1cnRoZXN0XG4gICAgICBpZiAocmVzdWx0LnBvc2l0aW9uID4gbGFzdFBvc2l0aW9uKSB7XG4gICAgICAgIGxhc3RFcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICAgICAgbGFzdFBvc2l0aW9uID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBsYXN0RXJyb3IsXG4gICAgICBwb3NpdGlvbjogbGFzdFBvc2l0aW9uLFxuICAgIH07XG4gIH07XG5cbi8vIFplcm8gb3IgbW9yZSByZXBldGl0aW9uc1xuZXhwb3J0IGNvbnN0IG1hbnkgPVxuICA8VD4ocGFyc2VyOiBQYXJzZXI8VD4pOiBQYXJzZXI8VFtdPiA9PlxuICAodG9rZW5zOiBUb2tlbltdKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0czogVFtdID0gW107XG4gICAgbGV0IHJlbWFpbmluZyA9IHRva2VucztcblxuICAgIHdoaWxlIChyZW1haW5pbmcubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHJlbWFpbmluZyk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICByZW1haW5pbmcgPSByZXN1bHQucmVtYWluaW5nO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgdmFsdWU6IHJlc3VsdHMsXG4gICAgICByZW1haW5pbmcsXG4gICAgfTtcbiAgfTtcblxuLy8gT25lIG9yIG1vcmUgcmVwZXRpdGlvbnNcbmV4cG9ydCBjb25zdCBtYW55MSA9XG4gIDxUPihwYXJzZXI6IFBhcnNlcjxUPik6IFBhcnNlcjxUW10+ID0+XG4gICh0b2tlbnM6IFRva2VuW10pID0+IHtcbiAgICBjb25zdCBtYW55UmVzdWx0ID0gbWFueShwYXJzZXIpKHRva2Vucyk7XG4gICAgaWYgKCFtYW55UmVzdWx0LnN1Y2Nlc3MgfHwgbWFueVJlc3VsdC52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogXCJFeHBlY3RlZCBhdCBsZWFzdCBvbmUgb2NjdXJyZW5jZVwiLFxuICAgICAgICBwb3NpdGlvbjogdG9rZW5zWzBdPy5sb2NhdGlvbi5zdGFydC5saW5lIHx8IDAsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbWFueVJlc3VsdDtcbiAgfTtcblxuLy8gT3B0aW9uYWwgcGFyc2VyICh6ZXJvIG9yIG9uZSlcbmV4cG9ydCBjb25zdCBvcHRpb25hbCA9XG4gIDxUPihwYXJzZXI6IFBhcnNlcjxUPik6IFBhcnNlcjxUIHwgbnVsbD4gPT5cbiAgKHRva2VuczogVG9rZW5bXSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcih0b2tlbnMpO1xuICAgIHJldHVybiByZXN1bHQuc3VjY2Vzc1xuXHRcdFx0XHRcdD8gcmVzdWx0XG5cdFx0XHRcdFx0OiB7XG5cdFx0XHRcdFx0XHRcdHN1Y2Nlc3M6IHRydWUsXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBudWxsLFxuXHRcdFx0XHRcdFx0XHRyZW1haW5pbmc6IHRva2Vucyxcblx0XHRcdFx0XHRcdH07XG4gIH07XG5cbi8vIFRyYW5zZm9ybSBwYXJzZSByZXN1bHRcbmV4cG9ydCBjb25zdCBtYXAgPVxuICA8VCwgVT4ocGFyc2VyOiBQYXJzZXI8VD4sIGZuOiAodmFsdWU6IFQpID0+IFUpOiBQYXJzZXI8VT4gPT5cbiAgKHRva2VuczogVG9rZW5bXSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcih0b2tlbnMpO1xuICAgIHJldHVybiByZXN1bHQuc3VjY2Vzc1xuXHRcdFx0XHRcdD8ge1xuXHRcdFx0XHRcdFx0XHRzdWNjZXNzOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogZm4ocmVzdWx0LnZhbHVlKSxcblx0XHRcdFx0XHRcdFx0cmVtYWluaW5nOiByZXN1bHQucmVtYWluaW5nLFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDogcmVzdWx0O1xuICB9O1xuXG4vLyBMYXp5IHBhcnNlciBmb3IgcmVjdXJzaXZlIGdyYW1tYXJzXG5leHBvcnQgY29uc3QgbGF6eSA9XG4gIDxUPihwYXJzZXJGbjogKCkgPT4gUGFyc2VyPFQ+KTogUGFyc2VyPFQ+ID0+XG4gICh0b2tlbnM6IFRva2VuW10pID0+XG4gICAgcGFyc2VyRm4oKSh0b2tlbnMpO1xuXG4vLyBTZXBhcmF0ZWQgYnkgc29tZXRoaW5nXG5leHBvcnQgY29uc3Qgc2VwQnkgPSA8VCwgUz4oXG4gIHBhcnNlcjogUGFyc2VyPFQ+LFxuICBzZXBhcmF0b3I6IFBhcnNlcjxTPixcbik6IFBhcnNlcjxUW10+ID0+IHtcbiAgcmV0dXJuICh0b2tlbnM6IFRva2VuW10pID0+IHtcbiAgICBjb25zdCByZXN1bHRzOiBUW10gPSBbXTtcbiAgICBsZXQgcmVtYWluaW5nID0gdG9rZW5zO1xuXG4gICAgLy8gUGFyc2UgZmlyc3QgZWxlbWVudFxuICAgIGNvbnN0IGZpcnN0UmVzdWx0ID0gcGFyc2VyKHJlbWFpbmluZyk7XG4gICAgaWYgKCFmaXJzdFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgIHJlbWFpbmluZyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmVzdWx0cy5wdXNoKGZpcnN0UmVzdWx0LnZhbHVlKTtcbiAgICByZW1haW5pbmcgPSBmaXJzdFJlc3VsdC5yZW1haW5pbmc7XG5cbiAgICAvLyBQYXJzZSBzdWJzZXF1ZW50IGVsZW1lbnRzIHNlcGFyYXRlZCBieSBzZXBhcmF0b3JcbiAgICB3aGlsZSAocmVtYWluaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNlcFJlc3VsdCA9IHNlcGFyYXRvcihyZW1haW5pbmcpO1xuICAgICAgaWYgKCFzZXBSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgZWxlbVJlc3VsdCA9IHBhcnNlcihzZXBSZXN1bHQucmVtYWluaW5nKTtcbiAgICAgIGlmICghZWxlbVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRzLnB1c2goZWxlbVJlc3VsdC52YWx1ZSk7XG4gICAgICByZW1haW5pbmcgPSBlbGVtUmVzdWx0LnJlbWFpbmluZztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHZhbHVlOiByZXN1bHRzLFxuICAgICAgcmVtYWluaW5nLFxuICAgIH07XG4gIH07XG59O1xuXG4vLyBQYXJzZSB1bnRpbCBlbmQgb2YgaW5wdXRcbmV4cG9ydCBjb25zdCBwYXJzZUFsbCA9XG5cdDxUPihwYXJzZXI6IFBhcnNlcjxUPik6IFBhcnNlcjxUPiA9PlxuXHQodG9rZW5zOiBUb2tlbltdKSA9PiB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gcGFyc2VyKHRva2Vucyk7XG5cdFx0aWYgKCFyZXN1bHQuc3VjY2VzcyB8fCAhcmVzdWx0LnJlbWFpbmluZy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdW5leHBlY3RlZCA9IHJlc3VsdC5yZW1haW5pbmdbMF07XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN1Y2Nlc3M6IGZhbHNlLFxuXHRcdFx0ZXJyb3I6IGBVbmV4cGVjdGVkICR7dW5leHBlY3RlZC50eXBlfSAnJHt1bmV4cGVjdGVkLnZhbHVlfScgYXQgZW5kIG9mIGlucHV0YCxcblx0XHRcdHBvc2l0aW9uOiB1bmV4cGVjdGVkLmxvY2F0aW9uLnN0YXJ0LmxpbmUsXG5cdFx0fTtcblx0fTtcblxuLy8gQ29udmVuaWVuY2UgcGFyc2VycyBmb3IgY29tbW9uIHRva2VuIHR5cGVzXG5leHBvcnQgY29uc3QgaWRlbnRpZmllciA9ICgpOiBQYXJzZXI8VG9rZW4+ID0+IHRva2VuKFwiSURFTlRJRklFUlwiKTtcbmV4cG9ydCBjb25zdCBudW1iZXIgPSAoKTogUGFyc2VyPFRva2VuPiA9PiB0b2tlbihcIk5VTUJFUlwiKTtcbmV4cG9ydCBjb25zdCBzdHJpbmcgPSAoKTogUGFyc2VyPFRva2VuPiA9PiB0b2tlbihcIlNUUklOR1wiKTtcbmV4cG9ydCBjb25zdCBrZXl3b3JkID0gKHZhbHVlOiBzdHJpbmcpOiBQYXJzZXI8VG9rZW4+ID0+XG5cdHRva2VuKFwiS0VZV09SRFwiLCB2YWx1ZSk7XG5leHBvcnQgY29uc3Qgb3BlcmF0b3IgPSAodmFsdWU6IHN0cmluZyk6IFBhcnNlcjxUb2tlbj4gPT5cblx0dG9rZW4oXCJPUEVSQVRPUlwiLCB2YWx1ZSk7XG5leHBvcnQgY29uc3QgcHVuY3R1YXRpb24gPSAodmFsdWU6IHN0cmluZyk6IFBhcnNlcjxUb2tlbj4gPT5cblx0dG9rZW4oXCJQVU5DVFVBVElPTlwiLCB2YWx1ZSk7XG5leHBvcnQgY29uc3QgYWNjZXNzb3IgPSAoKTogUGFyc2VyPFRva2VuPiA9PiB0b2tlbihcIkFDQ0VTU09SXCIpOyJdLCJ2ZXJzaW9uIjozfQ==