{"file":"/workspace/src/typer/__tests__/typer.test.ts","mappings":"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","names":[],"sources":["/workspace/src/typer/__tests__/typer.test.ts"],"sourcesContent":["import { describe, it, expect } from \"@jest/globals\";\nimport { Lexer } from \"../../lexer\";\nimport { parse } from \"../../parser/parser\";\nimport { typeProgram } from '..';\nimport { typeToString } from '../helpers';\nimport { createTypeState } from '..';\nimport { initializeBuiltins } from '../builtins';\n\n// Helper function to parse a string into a program\nconst parseProgram = (source: string) => {\n  const lexer = new Lexer(source);\n  const tokens = lexer.tokenize();\n  return parse(tokens);\n};\n\ndescribe(\"Functional Type Inference\", () => {\n  describe(\"Basic Types\", () => {\n    it(\"should infer integer literal\", () => {\n      const program = parseProgram(\"42\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should infer string literal\", () => {\n      const program = parseProgram('\"hello\"');\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\n        \"String\"\n      );\n    });\n\n    it(\"should infer boolean literal\", () => {\n      const program = parseProgram(\"True\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Bool\");\n    });\n  });\n\n  describe(\"Function Types\", () => {\n    it(\"should infer identity function\", () => {\n      const program = parseProgram(\"fn x => x\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\n        \"(α) -> α\"\n      );\n    });\n\n    it(\"should infer function with multiple parameters\", () => {\n      const program = parseProgram(\"fn x y => x + y\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\n        \"(Int) -> (Int) -> Int\"\n      );\n    });\n\n    it(\"should infer nested function\", () => {\n      const program = parseProgram(\"fn x => fn y => x + y\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\n        \"(Int) -> (Int) -> Int\"\n      );\n    });\n  });\n\n  describe(\"Let Polymorphism\", () => {\n    it(\"should generalize identity function\", () => {\n      const program = parseProgram(\"id = fn x => x; id 42\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should allow polymorphic function to be used with different types\", () => {\n      const program = parseProgram('id = fn x => x; id 42; id \"hello\"');\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\n        \"String\"\n      );\n    });\n\n    it(\"should handle recursive definitions\", () => {\n      const program = parseProgram(\n        \"fact = fn n => if n == 0 then 1 else n * (fact (n - 1)); fact 5\"\n      );\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n  });\n\n  describe(\"Function Application\", () => {\n    it(\"should apply function to argument\", () => {\n      const program = parseProgram(\"(fn x => x + 1) 42\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should handle partial application\", () => {\n      const program = parseProgram(\n        \"add = fn x y => x + y; add5 = add 5; add5 3\"\n      );\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should handle curried application\", () => {\n      const program = parseProgram(\"add = fn x y => x + y; add 2 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n  });\n\n  describe(\"Binary Operators\", () => {\n    it(\"should infer arithmetic operations\", () => {\n      const program = parseProgram(\"2 + 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should infer comparison operations\", () => {\n      const program = parseProgram(\"2 < 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Bool\");\n    });\n\n    it(\"should infer equality operations\", () => {\n      const program = parseProgram(\"2 == 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Bool\");\n    });\n  });\n\n  describe(\"If Expressions\", () => {\n    it(\"should infer if expression with same types\", () => {\n      const program = parseProgram(\"if True then 1 else 2\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should handle if expression with different types\", () => {\n      const program = parseProgram('if True then 1 else \"hello\"');\n      expect(() => typeProgram(program)).toThrow();\n    });\n  });\n\n  describe(\"Sequences\", () => {\n    it(\"should handle semicolon sequences\", () => {\n      const program = parseProgram(\"1; 2; 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should handle sequences with definitions\", () => {\n      const program = parseProgram(\"x = 1; y = 2; x + y\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n  });\n\n  describe(\"Built-in Functions\", () => {\n    it(\"should handle built-in arithmetic operators\", () => {\n      const program = parseProgram(\"2 + 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Int\");\n    });\n\n    it(\"should handle built-in comparison operators\", () => {\n      const program = parseProgram(\"2 == 3\");\n      const result = typeProgram(program);\n      expect(typeToString(result.type, result.state.substitution)).toBe(\"Bool\");\n    });\n  });\n\n  describe(\"Type Environment\", () => {\n    it(\"should initialize with built-ins\", () => {\n      const state = createTypeState();\n      const newState = initializeBuiltins(state);\n\n      expect(newState.environment.has(\"+\")).toBe(true);\n      expect(newState.environment.has(\"-\")).toBe(true);\n      expect(newState.environment.has(\"*\")).toBe(true);\n      expect(newState.environment.has(\"/\")).toBe(true);\n      expect(newState.environment.has(\"==\")).toBe(true);\n      expect(newState.environment.has(\";\")).toBe(true);\n    });\n  });\n\n  describe(\"Error Cases\", () => {\n    it(\"should reject undefined variables\", () => {\n      const program = parseProgram(\"undefined_var\");\n      expect(() => typeProgram(program)).toThrow(\"Undefined variable\");\n    });\n\n    it(\"should reject type mismatches in function application\", () => {\n      const program = parseProgram('(fn x => x + 1) \"hello\"');\n      expect(() => typeProgram(program)).toThrow();\n    });\n\n    it(\"should reject non-boolean conditions in if expressions\", () => {\n      const program = parseProgram(\"if 42 then 1 else 2\");\n      expect(() => typeProgram(program)).toThrow();\n    });\n  });\n});\n\ndescribe(\"Constraint Propagation (Functional Typer)\", () => {\n  it(\"should throw a type error when constraints are not satisfied in composition\", () => {\n    const program = parseProgram(`\n      compose = fn f g => fn x => f (g x);\n      safeHead = compose head;\n      listId = fn x => x;\n      result = safeHead listId [1, 2, 3]\n    `);\n    // This should work now since head is safe and returns Option\n    const result = typeProgram(program);\n    expect(result).toBeDefined();\n  });\n\n  it(\"should allow composition when constraints are satisfied (functional typer)\", () => {\n    const program = parseProgram(`\n      compose = fn f g => fn x => f (g x);\n      safeHead = compose head;\n      listId = fn x => x;\n      result = safeHead listId [[1, 2, 3], [4, 5, 6]]\n    `);\n    const result = typeProgram(program);\n    const typeStr = typeToString(result.type, result.state.substitution);\n    // head now returns Option List Int instead of List Int\n    expect(typeStr).toBe(\"Option List Int\");\n  });\n});\n"],"version":3}