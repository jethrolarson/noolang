{"file":"/workspace/src/typer/constraints.ts","mappings":";;;AAoMA,8DAmCC;AAGD,kEA8BC;AAID,gFAkCC;AA9SD,gCAA+H;AAE/H,+CAAiE;AACjE,6CAA0C;AAC1C,uCAAuE;AACvE,mCAAgC;AAEhC,+BAA+B;AACxB,MAAM,gBAAgB,GAAG,CAC/B,WAAyB,EACzB,KAAgB,EAChB,QAA2C,EAC/B,EAAE;IACd,IAAI,YAAY,GAAG,KAAK,CAAC;IAEzB,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE,CAAC;QACtC,YAAY,GAAG,IAAA,uBAAe,EAAC,UAAU,EAAE,YAAY,EAAE,QAAQ,CAAC,CAAC;IACpE,CAAC;IAED,OAAO,YAAY,CAAC;AACrB,CAAC,CAAC;AAZW,QAAA,gBAAgB,oBAY3B;AAEK,MAAM,eAAe,GAAG,CAC9B,UAAsB,EACtB,KAAgB,EAChB,QAA2C,EAC/B,EAAE;IACd,QAAQ,UAAU,CAAC,IAAI,EAAE,CAAC;QACzB,KAAK,IAAI;YACR,OAAO,iBAAiB,CAAC,UAAU,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;QACvD,KAAK,UAAU;YACd,OAAO,uBAAuB,CAAC,UAAU,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;QAC7D,KAAK,YAAY;YAChB,OAAO,yBAAyB,CAAC,UAAU,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;QAC/D,KAAK,QAAQ;YACZ,OAAO,qBAAqB,CAAC,UAAU,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;QAC3D;YACC,OAAO,KAAK,CAAC;IACf,CAAC;AACF,CAAC,CAAC;AAjBW,QAAA,eAAe,mBAiB1B;AAEF,MAAM,iBAAiB,GAAG,CACzB,UAA+D,EAC/D,KAAgB,EAChB,QAA2C,EAC/B,EAAE;IACd,iCAAiC;IACjC,IAAA,8BAAsB,EAAC,UAAU,CAAC,UAAU,CAAC,CAAC;IAE9C,MAAM,OAAO,GAAG,IAAA,uBAAU,EACzB,IAAA,kBAAY,EAAC,UAAU,CAAC,OAAO,CAAC,EAChC,KAAK,CAAC,YAAY,CAClB,CAAC;IAEF,iGAAiG;IACjG,IAAI,OAAO,CAAC,IAAI,KAAK,UAAU,EAAE,CAAC;QACjC,sDAAsD;QACtD,IAAI,CAAC,IAAA,2BAAmB,EAAC,OAAO,EAAE,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC;YAC1D,MAAM,IAAI,KAAK,CACd,IAAA,6BAAe,EACd,IAAA,6BAAe,EACd,QAAQ,IAAA,sBAAY,EACnB,OAAO,EACP,KAAK,CAAC,YAAY,CAClB,iCACA,UAAU,CAAC,UACZ,2MAA2M,EAC3M,EAAE,EACF,QAAQ,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,CAClC,CACD,CACD,CAAC;QACH,CAAC;IACF,CAAC;SAAM,CAAC;QACP,wEAAwE;QACxE,wEAAwE;QACxE,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;YAC1B,OAAO,CAAC,WAAW,GAAG,EAAE,CAAC;QAC1B,CAAC;QAED,8CAA8C;QAC9C,MAAM,kBAAkB,GAAG,OAAO,CAAC,WAAW,CAAC,IAAI,CAClD,CAAC,CAAC,EAAE,EAAE,CACL,CAAC,CAAC,IAAI,KAAK,IAAI;YACf,CAAC,CAAC,OAAO,KAAK,UAAU,CAAC,OAAO;YAChC,CAAC,CAAC,UAAU,KAAK,UAAU,CAAC,UAAU,CACvC,CAAC;QAEF,IAAI,CAAC,kBAAkB,EAAE,CAAC;YACzB,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACtC,CAAC;IACF,CAAC;IAED,OAAO,KAAK,CAAC;AACd,CAAC,CAAC;AAEF,MAAM,uBAAuB,GAAG,CAC/B,UAKC,EACD,KAAgB,EAChB,QAA2C,EAC/B,EAAE;IACd,MAAM,OAAO,GAAG,IAAA,uBAAU,EACzB,IAAA,kBAAY,EAAC,UAAU,CAAC,OAAO,CAAC,EAChC,KAAK,CAAC,YAAY,CAClB,CAAC;IAEF,IAAI,OAAO,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;QAC/B,iEAAiE;QACjE,IAAI,CAAC,CAAC,UAAU,CAAC,KAAK,IAAI,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC;YAC3C,MAAM,IAAI,KAAK,CACd,IAAA,6BAAe,EACd,IAAA,6BAAe,EACd,uCAAuC,UAAU,CAAC,KAAK,GAAG,EAC1D,EAAE,EACF,QAAQ,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,CAClC,CACD,CACD,CAAC;QACH,CAAC;QAED,uBAAuB;QACvB,IAAI,QAAQ,GAAG,KAAK,CAAC;QACrB,QAAQ,GAAG,IAAA,aAAK,EACf,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,EAChC,UAAU,CAAC,SAAS,EACpB,QAAQ,EACR,QAAQ,CACR,CAAC;QAEF,OAAO,QAAQ,CAAC;IACjB,CAAC;SAAM,IAAI,OAAO,CAAC,IAAI,KAAK,UAAU,EAAE,CAAC;QACxC,mEAAmE;QACnE,OAAO,KAAK,CAAC;IACd,CAAC;SAAM,CAAC;QACP,MAAM,IAAI,KAAK,CACd,IAAA,6BAAe,EACd,IAAA,6BAAe,EACd,QAAQ,IAAA,sBAAY,EACnB,OAAO,EACP,KAAK,CAAC,YAAY,CAClB,qBAAqB,EACtB,EAAE,EACF,QAAQ,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,CAClC,CACD,CACD,CAAC;IACH,CAAC;AACF,CAAC,CAAC;AAEF,MAAM,yBAAyB,GAAG,CACjC,UAA0E,EAC1E,KAAgB,EAChB,QAA2C,EAC/B,EAAE;IACd,2CAA2C;IAC3C,4EAA4E;IAC5E,OAAO,KAAK,CAAC;AACd,CAAC,CAAC;AAEF,MAAM,qBAAqB,GAAG,CAC7B,UAKC,EACD,KAAgB,EAChB,QAA2C,EAC/B,EAAE;IACd,2CAA2C;IAC3C,mEAAmE;IACnE,OAAO,KAAK,CAAC;AACd,CAAC,CAAC;AAEF,2CAA2C;AACpC,MAAM,sBAAsB,GAAG,CAAC,UAAkB,EAAQ,EAAE;IAClE,sEAAsE;IACtE,MAAM,IAAI,KAAK,CACd,eAAe,UAAU,yEAAyE,CAClG,CAAC;AACH,CAAC,CAAC;AALW,QAAA,sBAAsB,0BAKjC;AAEK,MAAM,mBAAmB,GAAG,CAAC,IAAU,EAAE,UAAkB,EAAW,EAAE;IAC9E,yEAAyE;IACzE,OAAO,KAAK,CAAC;AACd,CAAC,CAAC;AAHW,QAAA,mBAAmB,uBAG9B;AAKF,4EAA4E;AAC5E,SAAgB,yBAAyB,CAAC,IAAU,EAAE,UAAsB;IAC3E,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;QACnB,KAAK,UAAU;YACd,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,IAAI,EAAE,CAAC;YAC1C,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAA,0BAAgB,EAAC,CAAC,EAAE,UAAU,CAAC,CAAC,EAAE,CAAC;gBACpE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACnC,CAAC;iBAAM,CAAC;YACR,CAAC;YACD,MAAM;QACP,KAAK,UAAU;YACd,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;gBACjC,yBAAyB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;YAC9C,CAAC;YACD,yBAAyB,CAAC,IAAI,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;YACnD,MAAM;QACP,KAAK,MAAM;YACV,yBAAyB,CAAC,IAAI,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;YACpD,MAAM;QACP,KAAK,OAAO;YACX,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAChC,yBAAyB,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;YAC3C,CAAC;YACD,MAAM;QACP,KAAK,QAAQ;YACZ,KAAK,MAAM,SAAS,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;gBACpD,yBAAyB,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;YAClD,CAAC;YACD,MAAM;QACP,KAAK,OAAO;YACX,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;gBAC5B,yBAAyB,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;YAC1C,CAAC;YACD,MAAM;QACP,4CAA4C;IAC7C,CAAC;AACF,CAAC;AAED,2EAA2E;AAC3E,SAAgB,2BAA2B,CAC1C,OAAe,EACf,YAA+B;IAE/B,MAAM,IAAI,GAAG,IAAI,GAAG,EAAU,CAAC;IAC/B,IAAI,WAAW,GAAiB,EAAE,CAAC;IACnC,IAAI,cAAc,GAAG,OAAO,CAAC;IAC7B,IAAI,WAAW,GAAG,YAAY,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IAEnD,OAAO,WAAW,IAAI,IAAA,oBAAU,EAAC,WAAW,EAAE,UAAU,CAAC,EAAE,CAAC;QAC3D,IAAI,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,EAAE,CAAC;YAC9B,MAAM,CAAC,iBAAiB;QACzB,CAAC;QACD,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;QAEzB,IAAI,WAAW,CAAC,WAAW,EAAE,CAAC;YAC7B,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;QAC3D,CAAC;QAED,cAAc,GAAG,WAAW,CAAC,IAAI,CAAC;QAClC,WAAW,GAAG,YAAY,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IAChD,CAAC;IAED,mCAAmC;IACnC,MAAM,QAAQ,GAAG,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IAC3C,IAAI,QAAQ,IAAI,IAAA,oBAAU,EAAC,QAAQ,EAAE,UAAU,CAAC,IAAI,QAAQ,CAAC,WAAW,EAAE,CAAC;QAC1E,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;IACxD,CAAC;IAED,OAAO,WAAW,CAAC;AACpB,CAAC;AAGD,yEAAyE;AACzE,SAAgB,kCAAkC,CAAC,KAAgB;IAClE,KAAK,MAAM,CAAC,OAAO,EAAE,YAAY,CAAC,IAAI,KAAK,CAAC,YAAY,CAAC,OAAO,EAAE,EAAE,CAAC;QACpE,mDAAmD;QACnD,IAAI,YAAY,CAAC,IAAI,KAAK,UAAU,EAAE,CAAC;YACtC,sDAAsD;YACtD,MAAM,kBAAkB,GAAG,2BAA2B,CACrD,OAAO,EACP,KAAK,CAAC,YAAY,CAClB,CAAC;YACF,KAAK,MAAM,UAAU,IAAI,kBAAkB,EAAE,CAAC;gBAC7C,IACC,UAAU,CAAC,IAAI,KAAK,UAAU;oBAC9B,IAAA,oBAAU,EAAC,YAAY,EAAE,QAAQ,CAAC,EACjC,CAAC;oBACF,IAAI,CAAC,CAAC,UAAU,CAAC,KAAK,IAAI,YAAY,CAAC,MAAM,CAAC,EAAE,CAAC;wBAChD,MAAM,IAAI,KAAK,CACd,uCAAuC,UAAU,CAAC,KAAK,GAAG,CAC1D,CAAC;oBACH,CAAC;oBACD,+CAA+C;gBAChD,CAAC;qBAAM,IAAI,UAAU,CAAC,IAAI,KAAK,IAAI,EAAE,CAAC;oBACrC,IAAI,CAAC,IAAA,2BAAmB,EAAC,YAAY,EAAE,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC;wBAC/D,MAAM,IAAI,KAAK,CACd,kBAAkB,OAAO,oBAAoB,IAAA,sBAAY,EACxD,YAAY,CACZ,qCACA,UAAU,CAAC,UACZ,iMAAiM,CACjM,CAAC;oBACH,CAAC;gBACF,CAAC;YACF,CAAC;QACF,CAAC;IACF,CAAC;AACF,CAAC","names":[],"sources":["/workspace/src/typer/constraints.ts"],"sourcesContent":["import {typeVariable, Constraint, Type, HasFieldConstraint, IsConstraint, ImplementsConstraint, CustomConstraint} from \"../ast\"\nimport { TypeState } from \"./types\";\nimport { formatTypeError, createTypeError } from \"./type-errors\";\nimport { substitute } from \"./substitute\";\nimport { constraintsEqual, isTypeKind, typeToString } from \"./helpers\";\nimport { unify } from \"./unify\";\n\n// Constraint solving functions\nexport const solveConstraints = (\n\tconstraints: Constraint[],\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n): TypeState => {\n\tlet currentState = state;\n\n\tfor (const constraint of constraints) {\n\t\tcurrentState = solveConstraint(constraint, currentState, location);\n\t}\n\n\treturn currentState;\n};\n\nexport const solveConstraint = (\n\tconstraint: Constraint,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n): TypeState => {\n\tswitch (constraint.kind) {\n\t\tcase \"is\":\n\t\t\treturn solveIsConstraint(constraint, state, location);\n\t\tcase \"hasField\":\n\t\t\treturn solveHasFieldConstraint(constraint, state, location);\n\t\tcase \"implements\":\n\t\t\treturn solveImplementsConstraint(constraint, state, location);\n\t\tcase \"custom\":\n\t\t\treturn solveCustomConstraint(constraint, state, location);\n\t\tdefault:\n\t\t\treturn state;\n\t}\n};\n\nconst solveIsConstraint = (\n\tconstraint: { kind: \"is\"; typeVar: string; constraint: string },\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n): TypeState => {\n\t// Validate constraint name first\n\tvalidateConstraintName(constraint.constraint);\n\n\tconst typeVar = substitute(\n\t\ttypeVariable(constraint.typeVar),\n\t\tstate.substitution,\n\t);\n\n\t// If the type variable has been unified to a concrete type, check if it satisfies the constraint\n\tif (typeVar.kind !== \"variable\") {\n\t\t// Check if the concrete type satisfies the constraint\n\t\tif (!satisfiesConstraint(typeVar, constraint.constraint)) {\n\t\t\tthrow new Error(\n\t\t\t\tformatTypeError(\n\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t`Type ${typeToString(\n\t\t\t\t\t\t\ttypeVar,\n\t\t\t\t\t\t\tstate.substitution,\n\t\t\t\t\t\t)} does not satisfy constraint '${\n\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t}'. This often occurs when trying to use a partial function (one that can fail) in an unsafe context like function composition. Consider using total functions that return Option or Result types instead.`,\n\t\t\t\t\t\t{},\n\t\t\t\t\t\tlocation || { line: 1, column: 1 },\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t} else {\n\t\t// For type variables, we need to track the constraint for later solving\n\t\t// Add the constraint to the type variable if it doesn't already have it\n\t\tif (!typeVar.constraints) {\n\t\t\ttypeVar.constraints = [];\n\t\t}\n\n\t\t// Check if this constraint is already present\n\t\tconst existingConstraint = typeVar.constraints.find(\n\t\t\t(c) =>\n\t\t\t\tc.kind === \"is\" &&\n\t\t\t\tc.typeVar === constraint.typeVar &&\n\t\t\t\tc.constraint === constraint.constraint,\n\t\t);\n\n\t\tif (!existingConstraint) {\n\t\t\ttypeVar.constraints.push(constraint);\n\t\t}\n\t}\n\n\treturn state;\n};\n\nconst solveHasFieldConstraint = (\n\tconstraint: {\n\t\tkind: \"hasField\";\n\t\ttypeVar: string;\n\t\tfield: string;\n\t\tfieldType: Type;\n\t},\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n): TypeState => {\n\tconst typeVar = substitute(\n\t\ttypeVariable(constraint.typeVar),\n\t\tstate.substitution,\n\t);\n\n\tif (typeVar.kind === \"record\") {\n\t\t// Check if the record has the required field with the right type\n\t\tif (!(constraint.field in typeVar.fields)) {\n\t\t\tthrow new Error(\n\t\t\t\tformatTypeError(\n\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t`Record type missing required field '${constraint.field}'`,\n\t\t\t\t\t\t{},\n\t\t\t\t\t\tlocation || { line: 1, column: 1 },\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t// Unify the field type\n\t\tlet newState = state;\n\t\tnewState = unify(\n\t\t\ttypeVar.fields[constraint.field],\n\t\t\tconstraint.fieldType,\n\t\t\tnewState,\n\t\t\tlocation,\n\t\t);\n\n\t\treturn newState;\n\t} else if (typeVar.kind === \"variable\") {\n\t\t// For type variables, we'll track the constraint for later solving\n\t\treturn state;\n\t} else {\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tcreateTypeError(\n\t\t\t\t\t`Type ${typeToString(\n\t\t\t\t\t\ttypeVar,\n\t\t\t\t\t\tstate.substitution,\n\t\t\t\t\t)} cannot have fields`,\n\t\t\t\t\t{},\n\t\t\t\t\tlocation || { line: 1, column: 1 },\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n};\n\nconst solveImplementsConstraint = (\n\tconstraint: { kind: \"implements\"; typeVar: string; interfaceName: string },\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n): TypeState => {\n\t// For now, we'll just track the constraint\n\t// In a full implementation, we'd check if the type implements the interface\n\treturn state;\n};\n\nconst solveCustomConstraint = (\n\tconstraint: {\n\t\tkind: \"custom\";\n\t\ttypeVar: string;\n\t\tconstraint: string;\n\t\targs: Type[];\n\t},\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n): TypeState => {\n\t// For now, we'll just track the constraint\n\t// In a full implementation, we'd call the custom constraint solver\n\treturn state;\n};\n\n// Validate that a constraint name is valid\nexport const validateConstraintName = (constraint: string): void => {\n\t// All constraints are now meaningless type checks, so reject them all\n\tthrow new Error(\n\t\t`Constraint '${constraint}' is not supported. Use hasField constraints for record typing instead.`,\n\t);\n};\n\nexport const satisfiesConstraint = (type: Type, constraint: string): boolean => {\n\t// All non-hasField constraints are meaningless, so they're not supported\n\treturn false;\n};\n\n\n\n\n// Helper: Recursively push a constraint to all type variables inside a type\nexport function propagateConstraintToType(type: Type, constraint: Constraint) {\n\tswitch (type.kind) {\n\t\tcase \"variable\":\n\t\t\ttype.constraints = type.constraints || [];\n\t\t\tif (!type.constraints.some((c) => constraintsEqual(c, constraint))) {\n\t\t\t\ttype.constraints.push(constraint);\n\t\t\t} else {\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"function\":\n\t\t\tfor (const param of type.params) {\n\t\t\t\tpropagateConstraintToType(param, constraint);\n\t\t\t}\n\t\t\tpropagateConstraintToType(type.return, constraint);\n\t\t\tbreak;\n\t\tcase \"list\":\n\t\t\tpropagateConstraintToType(type.element, constraint);\n\t\t\tbreak;\n\t\tcase \"tuple\":\n\t\t\tfor (const el of type.elements) {\n\t\t\t\tpropagateConstraintToType(el, constraint);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"record\":\n\t\t\tfor (const fieldType of Object.values(type.fields)) {\n\t\t\t\tpropagateConstraintToType(fieldType, constraint);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"union\":\n\t\t\tfor (const t of type.types) {\n\t\t\t\tpropagateConstraintToType(t, constraint);\n\t\t\t}\n\t\t\tbreak;\n\t\t// For primitives, unit, unknown: do nothing\n\t}\n}\n\n// Collect all constraints for a variable, following the substitution chain\nexport function collectAllConstraintsForVar(\n\tvarName: string,\n\tsubstitution: Map<string, Type>,\n): Constraint[] {\n\tconst seen = new Set<string>();\n\tlet constraints: Constraint[] = [];\n\tlet currentVarName = varName;\n\tlet currentType = substitution.get(currentVarName);\n\n\twhile (currentType && isTypeKind(currentType, \"variable\")) {\n\t\tif (seen.has(currentVarName)) {\n\t\t\tbreak; // Prevent cycles\n\t\t}\n\t\tseen.add(currentVarName);\n\n\t\tif (currentType.constraints) {\n\t\t\tconstraints = constraints.concat(currentType.constraints);\n\t\t}\n\n\t\tcurrentVarName = currentType.name;\n\t\tcurrentType = substitution.get(currentVarName);\n\t}\n\n\t// Also check the original variable\n\tconst origType = substitution.get(varName);\n\tif (origType && isTypeKind(origType, \"variable\") && origType.constraints) {\n\t\tconstraints = constraints.concat(origType.constraints);\n\t}\n\n\treturn constraints;\n}\n\n \n// After type inference, validate all constraints in the substitution map\nexport function validateAllSubstitutionConstraints(state: TypeState) {\n\tfor (const [varName, concreteType] of state.substitution.entries()) {\n\t\t// Only check if the concreteType is not a variable\n\t\tif (concreteType.kind !== \"variable\") {\n\t\t\t// Collect all constraints from the substitution chain\n\t\t\tconst constraintsToCheck = collectAllConstraintsForVar(\n\t\t\t\tvarName,\n\t\t\t\tstate.substitution,\n\t\t\t);\n\t\t\tfor (const constraint of constraintsToCheck) {\n\t\t\t\tif (\n\t\t\t\t\tconstraint.kind === \"hasField\" &&\n\t\t\t\t\tisTypeKind(concreteType, \"record\")\n\t\t\t\t) {\n\t\t\t\t\tif (!(constraint.field in concreteType.fields)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Record type missing required field '${constraint.field}'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t// Optionally, unify field types here if needed\n\t\t\t\t} else if (constraint.kind === \"is\") {\n\t\t\t\t\tif (!satisfiesConstraint(concreteType, constraint.constraint)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Type variable '${varName}' was unified to ${typeToString(\n\t\t\t\t\t\t\t\tconcreteType,\n\t\t\t\t\t\t\t)} but does not satisfy constraint '${\n\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t}'. This typically means a partial function is being used in an unsafe context. Consider using total functions that return Option or Result types instead of partial functions with constraints.`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"],"version":3}