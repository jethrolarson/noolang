{"file":"/workspace/src/typer/unify.ts","mappings":"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","names":[],"sources":["/workspace/src/typer/unify.ts"],"sourcesContent":["import { Type } from '../ast';\nimport { substitute } from './substitute';\nimport { TypeState } from './types';\nimport { isTypeKind, typesEqual, constraintsEqual } from './helpers';\nimport {\n\tformatTypeError,\n\tcreateTypeError,\n\toperatorTypeError,\n\tunificationError,\n} from './type-errors';\nimport { Constraint } from '../ast';\nimport { mapSet, typeToString, occursIn } from './helpers';\nimport { satisfiesConstraint, propagateConstraintToType } from './constraints';\nimport { functionApplicationError } from './type-errors';\n\n// Performance tracking\nlet unifyCallCount = 0;\nlet totalUnifyTime = 0;\nlet slowUnifyCalls: Array<{type1: string, type2: string, time: number}> = [];\nlet unifyCallSources = new Map<string, number>(); // Track where unify calls come from\nlet unifyTypePatterns = new Map<string, number>(); // Track what types are being unified\n\nconst typeToPattern = (t: Type): string => {\n\tswitch (t.kind) {\n\t\tcase 'variable': return `var:${t.name}`;\n\t\tcase 'primitive': return `prim:${t.name}`;\n\t\tcase 'function': return `fn:${t.params.length}p`;\n\t\tcase 'list': return `list`;\n\t\tcase 'record': return `rec:${Object.keys(t.fields).length}f`;\n\t\tcase 'tuple': return `tup:${t.elements.length}e`;\n\t\tcase 'variant': return `var:${t.name}:${t.args.length}a`;\n\t\tdefault: return t.kind;\n\t}\n};\n\n// Cache for unification results to avoid repeated work\nconst unifyCache = new Map<string, TypeState>();\n\nconst unifyInternal = (\n\tt1: Type,\n\tt2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n\tcontext?: {\n\t\treason?: string;\n\t\toperation?: string;\n\t\thint?: string;\n\t}\n): TypeState => {\n\t// Early equality check before substitution for performance\n\tif (t1 === t2) return state;\n\n\tconst s1 = substitute(t1, state.substitution);\n\tconst s2 = substitute(t2, state.substitution);\n\n\tif (typesEqual(s1, s2)) return state;\n\n\t// Handle variables (either order)\n\tif (isTypeKind(s1, 'variable')) return unifyVariable(s1, s2, state, location);\n\tif (isTypeKind(s2, 'variable')) return unifyVariable(s2, s1, state, location);\n\n\t// Handle function types\n\tif (isTypeKind(s1, 'function') && isTypeKind(s2, 'function')) {\n\t\treturn unifyFunction(s1, s2, state, location);\n\t}\n\n\t// Handle list types\n\tif (isTypeKind(s1, 'list') && isTypeKind(s2, 'list')) {\n\t\treturn unifyList(s1, s2, state, location);\n\t}\n\n\t// Handle tuple types\n\tif (isTypeKind(s1, 'tuple') && isTypeKind(s2, 'tuple')) {\n\t\treturn unifyTuple(s1, s2, state, location);\n\t}\n\n\t// Handle record types\n\tif (isTypeKind(s1, 'record') && isTypeKind(s2, 'record')) {\n\t\treturn unifyRecord(s1, s2, state, location);\n\t}\n\n\t// Handle union types\n\tif (isTypeKind(s1, 'union') && isTypeKind(s2, 'union')) {\n\t\treturn unifyUnion(s1, s2, state, location);\n\t}\n\n\t// Handle primitive types\n\tif (isTypeKind(s1, 'primitive') && isTypeKind(s2, 'primitive')) {\n\t\treturn unifyPrimitive(s1, s2, state, location);\n\t}\n\n\t// Handle unit types\n\tif (isTypeKind(s1, 'unit') && isTypeKind(s2, 'unit')) {\n\t\treturn unifyUnit(s1, s2, state, location);\n\t}\n\n\t// Handle variant types (ADTs like Option, Result, etc.)\n\tif (isTypeKind(s1, 'variant') && isTypeKind(s2, 'variant')) {\n\t\treturn unifyVariant(s1, s2, state, location);\n\t}\n\n\t// If we get here, the types cannot be unified\n\t// Add debug info for difficult cases\n\tconst debugContext = context || {};\n\tif (\n\t\ts1.kind === s2.kind &&\n\t\ts1.kind === 'primitive' &&\n\t\t(s1 as any).name === (s2 as any).name\n\t) {\n\t\tdebugContext.reason = 'concrete_vs_variable';\n\t\tdebugContext.hint = `Both types appear to be ${\n\t\t\t(s1 as any).name\n\t\t} but they are not unifying. This suggests the type equality check is failing. Type 1: ${JSON.stringify(\n\t\t\ts1\n\t\t)}, Type 2: ${JSON.stringify(\n\t\t\ts2\n\t\t)}. Check if there are extra properties or constraints causing inequality.`;\n\t}\n\n\tthrow new Error(\n\t\tformatTypeError(\n\t\t\tunificationError(s1, s2, debugContext, location || { line: 1, column: 1 })\n\t\t)\n\t);\n};\n\nexport const unify = (\n\tt1: Type,\n\tt2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number },\n\tcontext?: {\n\t\treason?: string;\n\t\toperation?: string;\n\t\thint?: string;\n\t}\n): TypeState => {\n\tconst start = Date.now();\n\tunifyCallCount++;\n\t\n\t// Track call sources using stack trace\n\tconst stack = new Error().stack || '';\n\tconst caller = stack.split('\\n')[2] || 'unknown';\n\tconst source = caller.includes('at ') ? caller.split('at ')[1].split(' ')[0] : 'unknown';\n\tunifyCallSources.set(source, (unifyCallSources.get(source) || 0) + 1);\n\t\n\t// Track type patterns being unified\n\tconst pattern = `${typeToPattern(t1)} = ${typeToPattern(t2)}`;\n\tunifyTypePatterns.set(pattern, (unifyTypePatterns.get(pattern) || 0) + 1);\n\t\n\tconst result = unifyInternal(t1, t2, state, location, context);\n\t\n\tconst time = Date.now() - start;\n\ttotalUnifyTime += time;\n\t\n\tif (time > 10) {\n\t\tslowUnifyCalls.push({\n\t\t\ttype1: `${t1.kind}:${t1.kind === 'variable' ? t1.name : '?'}`,\n\t\t\ttype2: `${t2.kind}:${t2.kind === 'variable' ? t2.name : '?'}`,\n\t\t\ttime\n\t\t});\n\t}\n\t\n\tif (unifyCallCount % 5000 === 0) {\n\t\tconsole.warn(`Unify: ${unifyCallCount} calls, ${totalUnifyTime}ms total, ${slowUnifyCalls.length} slow calls`);\n\t\t\n\t\t// Show top call sources\n\t\tconst topSources = Array.from(unifyCallSources.entries())\n\t\t\t.sort((a, b) => b[1] - a[1])\n\t\t\t.slice(0, 5);\n\t\tconsole.warn('Top unify call sources:', topSources);\n\t\t\n\t\t// Show most repeated type patterns\n\t\tconst topPatterns = Array.from(unifyTypePatterns.entries())\n\t\t\t.sort((a, b) => b[1] - a[1])\n\t\t\t.slice(0, 5);\n\t\tconsole.warn('Most repeated unifications:', topPatterns);\n\t}\n\t\n\treturn result;\n};\n\nfunction unifyUnion(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'union') || !isTypeKind(s2, 'union')) {\n\t\tthrow new Error('unifyUnion called with non-union types');\n\t}\n\t// For now, require exact match of union types\n\tif (s1.types.length !== s2.types.length)\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tcreateTypeError(\n\t\t\t\t\t`Union type mismatch: ${s1.types.length} vs ${s2.types.length} types`,\n\t\t\t\t\t{},\n\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\tlet currentState = state;\n\tfor (let i = 0; i < s1.types.length; i++) {\n\t\tcurrentState = unify(s1.types[i], s2.types[i], currentState, location);\n\t}\n\treturn currentState;\n}\n\nfunction unifyPrimitive(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'primitive') || !isTypeKind(s2, 'primitive')) {\n\t\tthrow new Error('unifyPrimitive called with non-primitive types');\n\t}\n\tif (s1.name !== s2.name)\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\toperatorTypeError('', s1, s2, location || { line: 1, column: 1 })\n\t\t\t)\n\t\t);\n\treturn state;\n}\n\nfunction unifyUnit(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'unit') || !isTypeKind(s2, 'unit')) {\n\t\tthrow new Error('unifyUnit called with non-unit types');\n\t}\n\treturn state;\n}\n\n// --- Unification helpers ---\nfunction unifyVariable(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'variable')) {\n\t\tthrow new Error('unifyVariable called with non-variable s1');\n\t}\n\t// Optimized constraint collection - avoid array spreading\n\tlet constraintsToCheck: Constraint[] = [];\n\tlet seenVars = new Set<string>();\n\tlet currentVar: Type = s1;\n\twhile (isTypeKind(currentVar, 'variable')) {\n\t\tif (seenVars.has(currentVar.name)) break;\n\t\tseenVars.add(currentVar.name);\n\t\tif (currentVar.constraints) {\n\t\t\t// Use forEach instead of spread for better performance\n\t\t\tcurrentVar.constraints.forEach(c => constraintsToCheck.push(c));\n\t\t}\n\t\tconst next = state.substitution.get(currentVar.name);\n\t\tif (!next) break;\n\t\tcurrentVar = next;\n\t}\n\t// If s2 is a variable, merge all constraints into it\n\tif (isTypeKind(s2, 'variable')) {\n\t\ts2.constraints = s2.constraints || [];\n\t\t// Optimized constraint merging - use efficient constraint comparison\n\t\tfor (const c of constraintsToCheck) {\n\t\t\tif (!s2.constraints.some(existing => constraintsEqual(c, existing))) {\n\t\t\t\ts2.constraints.push(c);\n\t\t\t}\n\t\t}\n\t}\n\t// Occurs check\n\tif (occursIn(s1.name, s2))\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tcreateTypeError(\n\t\t\t\t\t`Occurs check failed: ${s1.name} occurs in ${typeToString(\n\t\t\t\t\t\ts2,\n\t\t\t\t\t\tstate.substitution\n\t\t\t\t\t)}`,\n\t\t\t\t\t{},\n\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\tlet newState = {\n\t\t...state,\n\t\tsubstitution: mapSet(state.substitution, s1.name, s2),\n\t};\n\t// If s2 is not a variable, propagate or check constraints\n\tif (!isTypeKind(s2, 'variable')) {\n\t\tfor (const constraint of constraintsToCheck) {\n\t\t\tif (constraint.kind === 'hasField' && isTypeKind(s2, 'record')) {\n\t\t\t\tnewState = unify(\n\t\t\t\t\ts2.fields[constraint.field],\n\t\t\t\t\tconstraint.fieldType,\n\t\t\t\t\tnewState,\n\t\t\t\t\tlocation\n\t\t\t\t);\n\t\t\t} else if (constraint.kind === 'is') {\n\t\t\t\tif (isTypeKind(s2, 'primitive')) {\n\t\t\t\t\tif (!satisfiesConstraint(s2, constraint.constraint)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\tformatTypeError(\n\t\t\t\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t\t\t\t`Type ${typeToString(\n\t\t\t\t\t\t\t\t\t\ts2,\n\t\t\t\t\t\t\t\t\t\tstate.substitution\n\t\t\t\t\t\t\t\t\t)} does not satisfy constraint '${\n\t\t\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t\t\t}'. This error typically occurs when attempting to use a partial function (one that can fail) in an unsafe context like function composition. Consider using total functions that return Option or Result types instead.`,\n\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Propagate the constraint recursively to all type variables inside s2\n\t\t\t\t\tpropagateConstraintToType(s2, constraint);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For other constraint kinds, propagate recursively\n\t\t\t\tpropagateConstraintToType(s2, constraint);\n\t\t\t}\n\t\t}\n\t}\n\treturn newState;\n}\n\nlet functionUnifyCount = 0;\nlet functionUnifyPatterns = new Map<string, number>();\n\nfunction unifyFunction(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'function') || !isTypeKind(s2, 'function')) {\n\t\tthrow new Error('unifyFunction called with non-function types');\n\t}\n\t\n\tfunctionUnifyCount++;\n\tconst pattern = `${s1.params.length}p_${s2.params.length}p`;\n\tfunctionUnifyPatterns.set(pattern, (functionUnifyPatterns.get(pattern) || 0) + 1);\n\t\n\tif (functionUnifyCount % 1000 === 0) {\n\t\tconsole.warn(`Function unify: ${functionUnifyCount} calls, top patterns:`, \n\t\t\tArray.from(functionUnifyPatterns.entries()).sort((a,b) => b[1] - a[1]).slice(0,3));\n\t}\n\n\tif (s1.params.length !== s2.params.length)\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tfunctionApplicationError(\n\t\t\t\t\ts1,\n\t\t\t\t\ts2,\n\t\t\t\t\t0,\n\t\t\t\t\tundefined,\n\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\tlet currentState = state;\n\n\t// First, propagate function-level constraints to the relevant type variables\n\tif (s1.constraints) {\n\t\tfor (const constraint of s1.constraints) {\n\t\t\t// Propagate to all type variables in s1\n\t\t\tpropagateConstraintToType(s1, constraint);\n\t\t}\n\t}\n\n\tif (s2.constraints) {\n\t\tfor (const constraint of s2.constraints) {\n\t\t\t// Propagate to all type variables in s2\n\t\t\tpropagateConstraintToType(s2, constraint);\n\t\t}\n\t}\n\n\t// Then unify parameters and return types\n\tfor (let i = 0; i < s1.params.length; i++) {\n\t\t// Skip expensive constraint propagation for non-variables\n\t\tconst s1var = s1.params[i];\n\t\tconst s2var = s2.params[i];\n\t\tif (isTypeKind(s1var, 'variable') && isTypeKind(s2var, 'variable') && \n\t\t    (s1var.constraints?.length || s2var.constraints?.length)) {\n\t\t\ts1var.constraints = s1var.constraints || [];\n\t\t\ts2var.constraints = s2var.constraints || [];\n\t\t\t// Optimized constraint merging using efficient comparison\n\t\t\t// Propagate s1 -> s2\n\t\t\tfor (const c of s1var.constraints) {\n\t\t\t\tif (!s2var.constraints.some(existing => constraintsEqual(c, existing))) {\n\t\t\t\t\ts2var.constraints.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Propagate s2 -> s1\n\t\t\tfor (const c of s2var.constraints) {\n\t\t\t\tif (!s1var.constraints.some(existing => constraintsEqual(c, existing))) {\n\t\t\t\t\ts1var.constraints.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcurrentState = unify(s1.params[i], s2.params[i], currentState, location);\n\t}\n\tcurrentState = unify(s1.return, s2.return, currentState, location);\n\n\treturn currentState;\n}\n\nfunction unifyList(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'list') || !isTypeKind(s2, 'list')) {\n\t\tthrow new Error('unifyList called with non-list types');\n\t}\n\treturn unify(s1.element, s2.element, state, location);\n}\n\nfunction unifyTuple(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'tuple') || !isTypeKind(s2, 'tuple')) {\n\t\tthrow new Error('unifyTuple called with non-tuple types');\n\t}\n\tif (s1.elements.length !== s2.elements.length)\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tcreateTypeError(\n\t\t\t\t\t`Tuple length mismatch: ${s1.elements.length} vs ${s2.elements.length}`,\n\t\t\t\t\t{},\n\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\tlet currentState = state;\n\tfor (let i = 0; i < s1.elements.length; i++) {\n\t\tcurrentState = unify(\n\t\t\ts1.elements[i],\n\t\t\ts2.elements[i],\n\t\t\tcurrentState,\n\t\t\tlocation\n\t\t);\n\t}\n\treturn currentState;\n}\n\nfunction unifyVariant(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'variant') || !isTypeKind(s2, 'variant')) {\n\t\tthrow new Error('unifyVariant called with non-variant types');\n\t}\n\n\t// Variant types must have the same name (e.g., both \"Option\")\n\tif (s1.name !== s2.name) {\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tcreateTypeError(\n\t\t\t\t\t`Variant name mismatch: ${s1.name} vs ${s2.name}`,\n\t\t\t\t\t{},\n\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n\t// Variant types must have the same number of type arguments\n\tif (s1.args.length !== s2.args.length) {\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tcreateTypeError(\n\t\t\t\t\t`Variant arity mismatch: ${s1.name} has ${s1.args.length} vs ${s2.args.length} type arguments`,\n\t\t\t\t\t{},\n\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n\t// Unify corresponding type arguments\n\tlet currentState = state;\n\tfor (let i = 0; i < s1.args.length; i++) {\n\t\tcurrentState = unify(s1.args[i], s2.args[i], currentState, location);\n\t}\n\treturn currentState;\n}\n\nfunction unifyRecord(\n\ts1: Type,\n\ts2: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState {\n\tif (!isTypeKind(s1, 'record') || !isTypeKind(s2, 'record')) {\n\t\tthrow new Error('unifyRecord called with non-record types');\n\t}\n\tconst keys1 = Object.keys(s1.fields);\n\tlet currentState = state;\n\tfor (const key of keys1) {\n\t\tif (!(key in s2.fields))\n\t\t\tthrow new Error(\n\t\t\t\tformatTypeError(\n\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t`Required field missing: ${key}`,\n\t\t\t\t\t\t{},\n\t\t\t\t\t\tlocation || { line: 1, column: 1 }\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\tcurrentState = unify(\n\t\t\ts1.fields[key],\n\t\t\ts2.fields[key],\n\t\t\tcurrentState,\n\t\t\tlocation\n\t\t);\n\t}\n\treturn currentState;\n}\n"],"version":3}