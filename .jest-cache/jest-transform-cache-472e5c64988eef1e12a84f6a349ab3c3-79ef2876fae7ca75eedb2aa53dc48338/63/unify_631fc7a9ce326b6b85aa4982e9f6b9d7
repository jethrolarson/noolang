68b5bbd3774272d037261f0d3951d5e0
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unify = void 0;
const substitute_1 = require("./substitute");
const helpers_1 = require("./helpers");
const type_errors_1 = require("./type-errors");
const helpers_2 = require("./helpers");
const constraints_1 = require("./constraints");
const type_errors_2 = require("./type-errors");
// Performance tracking
let unifyCallCount = 0;
let totalUnifyTime = 0;
let slowUnifyCalls = [];
let unifyCallSources = new Map(); // Track where unify calls come from
let unifyTypePatterns = new Map(); // Track what types are being unified
const typeToPattern = (t) => {
    switch (t.kind) {
        case 'variable': return `var:${t.name}`;
        case 'primitive': return `prim:${t.name}`;
        case 'function': return `fn:${t.params.length}p`;
        case 'list': return `list`;
        case 'record': return `rec:${Object.keys(t.fields).length}f`;
        case 'tuple': return `tup:${t.elements.length}e`;
        case 'variant': return `var:${t.name}:${t.args.length}a`;
        default: return t.kind;
    }
};
// Cache for unification results to avoid repeated work
const unifyCache = new Map();
const unifyInternal = (t1, t2, state, location, context) => {
    // Early equality check before substitution for performance
    if (t1 === t2)
        return state;
    const s1 = (0, substitute_1.substitute)(t1, state.substitution);
    const s2 = (0, substitute_1.substitute)(t2, state.substitution);
    if ((0, helpers_1.typesEqual)(s1, s2))
        return state;
    // Handle variables (either order)
    if ((0, helpers_1.isTypeKind)(s1, 'variable'))
        return unifyVariable(s1, s2, state, location);
    if ((0, helpers_1.isTypeKind)(s2, 'variable'))
        return unifyVariable(s2, s1, state, location);
    // Handle function types
    if ((0, helpers_1.isTypeKind)(s1, 'function') && (0, helpers_1.isTypeKind)(s2, 'function')) {
        return unifyFunction(s1, s2, state, location);
    }
    // Handle list types
    if ((0, helpers_1.isTypeKind)(s1, 'list') && (0, helpers_1.isTypeKind)(s2, 'list')) {
        return unifyList(s1, s2, state, location);
    }
    // Handle tuple types
    if ((0, helpers_1.isTypeKind)(s1, 'tuple') && (0, helpers_1.isTypeKind)(s2, 'tuple')) {
        return unifyTuple(s1, s2, state, location);
    }
    // Handle record types
    if ((0, helpers_1.isTypeKind)(s1, 'record') && (0, helpers_1.isTypeKind)(s2, 'record')) {
        return unifyRecord(s1, s2, state, location);
    }
    // Handle union types
    if ((0, helpers_1.isTypeKind)(s1, 'union') && (0, helpers_1.isTypeKind)(s2, 'union')) {
        return unifyUnion(s1, s2, state, location);
    }
    // Handle primitive types
    if ((0, helpers_1.isTypeKind)(s1, 'primitive') && (0, helpers_1.isTypeKind)(s2, 'primitive')) {
        return unifyPrimitive(s1, s2, state, location);
    }
    // Handle unit types
    if ((0, helpers_1.isTypeKind)(s1, 'unit') && (0, helpers_1.isTypeKind)(s2, 'unit')) {
        return unifyUnit(s1, s2, state, location);
    }
    // Handle variant types (ADTs like Option, Result, etc.)
    if ((0, helpers_1.isTypeKind)(s1, 'variant') && (0, helpers_1.isTypeKind)(s2, 'variant')) {
        return unifyVariant(s1, s2, state, location);
    }
    // If we get here, the types cannot be unified
    // Add debug info for difficult cases
    const debugContext = context || {};
    if (s1.kind === s2.kind &&
        s1.kind === 'primitive' &&
        s1.name === s2.name) {
        debugContext.reason = 'concrete_vs_variable';
        debugContext.hint = `Both types appear to be ${s1.name} but they are not unifying. This suggests the type equality check is failing. Type 1: ${JSON.stringify(s1)}, Type 2: ${JSON.stringify(s2)}. Check if there are extra properties or constraints causing inequality.`;
    }
    throw new Error((0, type_errors_1.formatTypeError)((0, type_errors_1.unificationError)(s1, s2, debugContext, location || { line: 1, column: 1 })));
};
const unify = (t1, t2, state, location, context) => {
    const start = Date.now();
    unifyCallCount++;
    // Track call sources using stack trace
    const stack = new Error().stack || '';
    const caller = stack.split('\n')[2] || 'unknown';
    const source = caller.includes('at ') ? caller.split('at ')[1].split(' ')[0] : 'unknown';
    unifyCallSources.set(source, (unifyCallSources.get(source) || 0) + 1);
    // Track type patterns being unified
    const pattern = `${typeToPattern(t1)} = ${typeToPattern(t2)}`;
    unifyTypePatterns.set(pattern, (unifyTypePatterns.get(pattern) || 0) + 1);
    const result = unifyInternal(t1, t2, state, location, context);
    const time = Date.now() - start;
    totalUnifyTime += time;
    if (time > 10) {
        slowUnifyCalls.push({
            type1: `${t1.kind}:${t1.kind === 'variable' ? t1.name : '?'}`,
            type2: `${t2.kind}:${t2.kind === 'variable' ? t2.name : '?'}`,
            time
        });
    }
    if (unifyCallCount % 5000 === 0) {
        console.warn(`Unify: ${unifyCallCount} calls, ${totalUnifyTime}ms total, ${slowUnifyCalls.length} slow calls`);
        // Show top call sources
        const topSources = Array.from(unifyCallSources.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);
        console.warn('Top unify call sources:', topSources);
        // Show most repeated type patterns
        const topPatterns = Array.from(unifyTypePatterns.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);
        console.warn('Most repeated unifications:', topPatterns);
    }
    return result;
};
exports.unify = unify;
function unifyUnion(s1, s2, state, location) {
    if (!(0, helpers_1.isTypeKind)(s1, 'union') || !(0, helpers_1.isTypeKind)(s2, 'union')) {
        throw new Error('unifyUnion called with non-union types');
    }
    // For now, require exact match of union types
    if (s1.types.length !== s2.types.length)
        throw new Error((0, type_errors_1.formatTypeError)((0, type_errors_1.createTypeError)(`Union type mismatch: ${s1.types.length} vs ${s2.types.length} types`, {}, location || { line: 1, column: 1 })));
    let currentState = state;
    for (let i = 0; i < s1.types.length; i++) {
        currentState = (0, exports.unify)(s1.types[i], s2.types[i], currentState, location);
    }
    return currentState;
}
function unifyPrimitive(s1, s2, state, location) {
    if (!(0, helpers_1.isTypeKind)(s1, 'primitive') || !(0, helpers_1.isTypeKind)(s2, 'primitive')) {
        throw new Error('unifyPrimitive called with non-primitive types');
    }
    if (s1.name !== s2.name)
        throw new Error((0, type_errors_1.formatTypeError)((0, type_errors_1.operatorTypeError)('', s1, s2, location || { line: 1, column: 1 })));
    return state;
}
function unifyUnit(s1, s2, state, location) {
    if (!(0, helpers_1.isTypeKind)(s1, 'unit') || !(0, helpers_1.isTypeKind)(s2, 'unit')) {
        throw new Error('unifyUnit called with non-unit types');
    }
    return state;
}
// --- Unification helpers ---
function unifyVariable(s1, s2, state, location) {
    if (!(0, helpers_1.isTypeKind)(s1, 'variable')) {
        throw new Error('unifyVariable called with non-variable s1');
    }
    // Optimized constraint collection - avoid array spreading
    let constraintsToCheck = [];
    let seenVars = new Set();
    let currentVar = s1;
    while ((0, helpers_1.isTypeKind)(currentVar, 'variable')) {
        if (seenVars.has(currentVar.name))
            break;
        seenVars.add(currentVar.name);
        if (currentVar.constraints) {
            // Use forEach instead of spread for better performance
            currentVar.constraints.forEach(c => constraintsToCheck.push(c));
        }
        const next = state.substitution.get(currentVar.name);
        if (!next)
            break;
        currentVar = next;
    }
    // If s2 is a variable, merge all constraints into it
    if ((0, helpers_1.isTypeKind)(s2, 'variable')) {
        s2.constraints = s2.constraints || [];
        // Optimized constraint merging - use efficient constraint comparison
        for (const c of constraintsToCheck) {
            if (!s2.constraints.some(existing => (0, helpers_1.constraintsEqual)(c, existing))) {
                s2.constraints.push(c);
            }
        }
    }
    // Occurs check
    if ((0, helpers_2.occursIn)(s1.name, s2))
        throw new Error((0, type_errors_1.formatTypeError)((0, type_errors_1.createTypeError)(`Occurs check failed: ${s1.name} occurs in ${(0, helpers_2.typeToString)(s2, state.substitution)}`, {}, location || { line: 1, column: 1 })));
    let newState = {
        ...state,
        substitution: (0, helpers_2.mapSet)(state.substitution, s1.name, s2),
    };
    // If s2 is not a variable, propagate or check constraints
    if (!(0, helpers_1.isTypeKind)(s2, 'variable')) {
        for (const constraint of constraintsToCheck) {
            if (constraint.kind === 'hasField' && (0, helpers_1.isTypeKind)(s2, 'record')) {
                newState = (0, exports.unify)(s2.fields[constraint.field], constraint.fieldType, newState, location);
            }
            else if (constraint.kind === 'is') {
                if ((0, helpers_1.isTypeKind)(s2, 'primitive')) {
                    if (!(0, constraints_1.satisfiesConstraint)(s2, constraint.constraint)) {
                        throw new Error((0, type_errors_1.formatTypeError)((0, type_errors_1.createTypeError)(`Type ${(0, helpers_2.typeToString)(s2, state.substitution)} does not satisfy constraint '${constraint.constraint}'. This error typically occurs when attempting to use a partial function (one that can fail) in an unsafe context like function composition. Consider using total functions that return Option or Result types instead.`, {}, location || { line: 1, column: 1 })));
                    }
                }
                else {
                    // Propagate the constraint recursively to all type variables inside s2
                    (0, constraints_1.propagateConstraintToType)(s2, constraint);
                }
            }
            else {
                // For other constraint kinds, propagate recursively
                (0, constraints_1.propagateConstraintToType)(s2, constraint);
            }
        }
    }
    return newState;
}
let functionUnifyCount = 0;
let functionUnifyPatterns = new Map();
function unifyFunction(s1, s2, state, location) {
    if (!(0, helpers_1.isTypeKind)(s1, 'function') || !(0, helpers_1.isTypeKind)(s2, 'function')) {
        throw new Error('unifyFunction called with non-function types');
    }
    functionUnifyCount++;
    const pattern = `${s1.params.length}p_${s2.params.length}p`;
    functionUnifyPatterns.set(pattern, (functionUnifyPatterns.get(pattern) || 0) + 1);
    if (functionUnifyCount % 1000 === 0) {
        console.warn(`Function unify: ${functionUnifyCount} calls, top patterns:`, Array.from(functionUnifyPatterns.entries()).sort((a, b) => b[1] - a[1]).slice(0, 3));
    }
    if (s1.params.length !== s2.params.length)
        throw new Error((0, type_errors_1.formatTypeError)((0, type_errors_2.functionApplicationError)(s1, s2, 0, undefined, location || { line: 1, column: 1 })));
    let currentState = state;
    // First, propagate function-level constraints to the relevant type variables
    if (s1.constraints) {
        for (const constraint of s1.constraints) {
            // Propagate to all type variables in s1
            (0, constraints_1.propagateConstraintToType)(s1, constraint);
        }
    }
    if (s2.constraints) {
        for (const constraint of s2.constraints) {
            // Propagate to all type variables in s2
            (0, constraints_1.propagateConstraintToType)(s2, constraint);
        }
    }
    // Then unify parameters and return types
    for (let i = 0; i < s1.params.length; i++) {
        // Skip expensive constraint propagation for non-variables
        const s1var = s1.params[i];
        const s2var = s2.params[i];
        if ((0, helpers_1.isTypeKind)(s1var, 'variable') && (0, helpers_1.isTypeKind)(s2var, 'variable') &&
            (s1var.constraints?.length || s2var.constraints?.length)) {
            s1var.constraints = s1var.constraints || [];
            s2var.constraints = s2var.constraints || [];
            // Optimized constraint merging using efficient comparison
            // Propagate s1 -> s2
            for (const c of s1var.constraints) {
                if (!s2var.constraints.some(existing => (0, helpers_1.constraintsEqual)(c, existing))) {
                    s2var.constraints.push(c);
                }
            }
            // Propagate s2 -> s1
            for (const c of s2var.constraints) {
                if (!s1var.constraints.some(existing => (0, helpers_1.constraintsEqual)(c, existing))) {
                    s1var.constraints.push(c);
                }
            }
        }
        currentState = (0, exports.unify)(s1.params[i], s2.params[i], currentState, location);
    }
    currentState = (0, exports.unify)(s1.return, s2.return, currentState, location);
    return currentState;
}
function unifyList(s1, s2, state, location) {
    if (!(0, helpers_1.isTypeKind)(s1, 'list') || !(0, helpers_1.isTypeKind)(s2, 'list')) {
        throw new Error('unifyList called with non-list types');
    }
    return (0, exports.unify)(s1.element, s2.element, state, location);
}
function unifyTuple(s1, s2, state, location) {
    if (!(0, helpers_1.isTypeKind)(s1, 'tuple') || !(0, helpers_1.isTypeKind)(s2, 'tuple')) {
        throw new Error('unifyTuple called with non-tuple types');
    }
    if (s1.elements.length !== s2.elements.length)
        throw new Error((0, type_errors_1.formatTypeError)((0, type_errors_1.createTypeError)(`Tuple length mismatch: ${s1.elements.length} vs ${s2.elements.length}`, {}, location || { line: 1, column: 1 })));
    let currentState = state;
    for (let i = 0; i < s1.elements.length; i++) {
        currentState = (0, exports.unify)(s1.elements[i], s2.elements[i], currentState, location);
    }
    return currentState;
}
function unifyVariant(s1, s2, state, location) {
    if (!(0, helpers_1.isTypeKind)(s1, 'variant') || !(0, helpers_1.isTypeKind)(s2, 'variant')) {
        throw new Error('unifyVariant called with non-variant types');
    }
    // Variant types must have the same name (e.g., both "Option")
    if (s1.name !== s2.name) {
        throw new Error((0, type_errors_1.formatTypeError)((0, type_errors_1.createTypeError)(`Variant name mismatch: ${s1.name} vs ${s2.name}`, {}, location || { line: 1, column: 1 })));
    }
    // Variant types must have the same number of type arguments
    if (s1.args.length !== s2.args.length) {
        throw new Error((0, type_errors_1.formatTypeError)((0, type_errors_1.createTypeError)(`Variant arity mismatch: ${s1.name} has ${s1.args.length} vs ${s2.args.length} type arguments`, {}, location || { line: 1, column: 1 })));
    }
    // Unify corresponding type arguments
    let currentState = state;
    for (let i = 0; i < s1.args.length; i++) {
        currentState = (0, exports.unify)(s1.args[i], s2.args[i], currentState, location);
    }
    return currentState;
}
function unifyRecord(s1, s2, state, location) {
    if (!(0, helpers_1.isTypeKind)(s1, 'record') || !(0, helpers_1.isTypeKind)(s2, 'record')) {
        throw new Error('unifyRecord called with non-record types');
    }
    const keys1 = Object.keys(s1.fields);
    let currentState = state;
    for (const key of keys1) {
        if (!(key in s2.fields))
            throw new Error((0, type_errors_1.formatTypeError)((0, type_errors_1.createTypeError)(`Required field missing: ${key}`, {}, location || { line: 1, column: 1 })));
        currentState = (0, exports.unify)(s1.fields[key], s2.fields[key], currentState, location);
    }
    return currentState;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBZSxFQUNkLElBQUEsNkJBQWUsRUFDZCwyQkFBMkIsR0FBRyxFQUFFLEVBQ2hDLEVBQUUsRUFDRixRQUFRLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FDbEMsQ0FDRCxDQUNELENBQUM7UUFDSCxZQUFZLEdBQUcsSUFBQSxhQUFLLEVBQ25CLEVBQUUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQ2QsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFDZCxZQUFZLEVBQ1osUUFBUSxDQUNSLENBQUM7SUFDSCxDQUFDO0lBQ0QsT0FBTyxZQUFZLENBQUM7QUFDckIsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvd29ya3NwYWNlL3NyYy90eXBlci91bmlmeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUeXBlIH0gZnJvbSAnLi4vYXN0JztcbmltcG9ydCB7IHN1YnN0aXR1dGUgfSBmcm9tICcuL3N1YnN0aXR1dGUnO1xuaW1wb3J0IHsgVHlwZVN0YXRlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBpc1R5cGVLaW5kLCB0eXBlc0VxdWFsLCBjb25zdHJhaW50c0VxdWFsIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7XG5cdGZvcm1hdFR5cGVFcnJvcixcblx0Y3JlYXRlVHlwZUVycm9yLFxuXHRvcGVyYXRvclR5cGVFcnJvcixcblx0dW5pZmljYXRpb25FcnJvcixcbn0gZnJvbSAnLi90eXBlLWVycm9ycyc7XG5pbXBvcnQgeyBDb25zdHJhaW50IH0gZnJvbSAnLi4vYXN0JztcbmltcG9ydCB7IG1hcFNldCwgdHlwZVRvU3RyaW5nLCBvY2N1cnNJbiB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyBzYXRpc2ZpZXNDb25zdHJhaW50LCBwcm9wYWdhdGVDb25zdHJhaW50VG9UeXBlIH0gZnJvbSAnLi9jb25zdHJhaW50cyc7XG5pbXBvcnQgeyBmdW5jdGlvbkFwcGxpY2F0aW9uRXJyb3IgfSBmcm9tICcuL3R5cGUtZXJyb3JzJztcblxuLy8gUGVyZm9ybWFuY2UgdHJhY2tpbmdcbmxldCB1bmlmeUNhbGxDb3VudCA9IDA7XG5sZXQgdG90YWxVbmlmeVRpbWUgPSAwO1xubGV0IHNsb3dVbmlmeUNhbGxzOiBBcnJheTx7dHlwZTE6IHN0cmluZywgdHlwZTI6IHN0cmluZywgdGltZTogbnVtYmVyfT4gPSBbXTtcbmxldCB1bmlmeUNhbGxTb3VyY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTsgLy8gVHJhY2sgd2hlcmUgdW5pZnkgY2FsbHMgY29tZSBmcm9tXG5sZXQgdW5pZnlUeXBlUGF0dGVybnMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpOyAvLyBUcmFjayB3aGF0IHR5cGVzIGFyZSBiZWluZyB1bmlmaWVkXG5cbmNvbnN0IHR5cGVUb1BhdHRlcm4gPSAodDogVHlwZSk6IHN0cmluZyA9PiB7XG5cdHN3aXRjaCAodC5raW5kKSB7XG5cdFx0Y2FzZSAndmFyaWFibGUnOiByZXR1cm4gYHZhcjoke3QubmFtZX1gO1xuXHRcdGNhc2UgJ3ByaW1pdGl2ZSc6IHJldHVybiBgcHJpbToke3QubmFtZX1gO1xuXHRcdGNhc2UgJ2Z1bmN0aW9uJzogcmV0dXJuIGBmbjoke3QucGFyYW1zLmxlbmd0aH1wYDtcblx0XHRjYXNlICdsaXN0JzogcmV0dXJuIGBsaXN0YDtcblx0XHRjYXNlICdyZWNvcmQnOiByZXR1cm4gYHJlYzoke09iamVjdC5rZXlzKHQuZmllbGRzKS5sZW5ndGh9ZmA7XG5cdFx0Y2FzZSAndHVwbGUnOiByZXR1cm4gYHR1cDoke3QuZWxlbWVudHMubGVuZ3RofWVgO1xuXHRcdGNhc2UgJ3ZhcmlhbnQnOiByZXR1cm4gYHZhcjoke3QubmFtZX06JHt0LmFyZ3MubGVuZ3RofWFgO1xuXHRcdGRlZmF1bHQ6IHJldHVybiB0LmtpbmQ7XG5cdH1cbn07XG5cbi8vIENhY2hlIGZvciB1bmlmaWNhdGlvbiByZXN1bHRzIHRvIGF2b2lkIHJlcGVhdGVkIHdvcmtcbmNvbnN0IHVuaWZ5Q2FjaGUgPSBuZXcgTWFwPHN0cmluZywgVHlwZVN0YXRlPigpO1xuXG5jb25zdCB1bmlmeUludGVybmFsID0gKFxuXHR0MTogVHlwZSxcblx0dDI6IFR5cGUsXG5cdHN0YXRlOiBUeXBlU3RhdGUsXG5cdGxvY2F0aW9uPzogeyBsaW5lOiBudW1iZXI7IGNvbHVtbjogbnVtYmVyIH0sXG5cdGNvbnRleHQ/OiB7XG5cdFx0cmVhc29uPzogc3RyaW5nO1xuXHRcdG9wZXJhdGlvbj86IHN0cmluZztcblx0XHRoaW50Pzogc3RyaW5nO1xuXHR9XG4pOiBUeXBlU3RhdGUgPT4ge1xuXHQvLyBFYXJseSBlcXVhbGl0eSBjaGVjayBiZWZvcmUgc3Vic3RpdHV0aW9uIGZvciBwZXJmb3JtYW5jZVxuXHRpZiAodDEgPT09IHQyKSByZXR1cm4gc3RhdGU7XG5cblx0Y29uc3QgczEgPSBzdWJzdGl0dXRlKHQxLCBzdGF0ZS5zdWJzdGl0dXRpb24pO1xuXHRjb25zdCBzMiA9IHN1YnN0aXR1dGUodDIsIHN0YXRlLnN1YnN0aXR1dGlvbik7XG5cblx0aWYgKHR5cGVzRXF1YWwoczEsIHMyKSkgcmV0dXJuIHN0YXRlO1xuXG5cdC8vIEhhbmRsZSB2YXJpYWJsZXMgKGVpdGhlciBvcmRlcilcblx0aWYgKGlzVHlwZUtpbmQoczEsICd2YXJpYWJsZScpKSByZXR1cm4gdW5pZnlWYXJpYWJsZShzMSwgczIsIHN0YXRlLCBsb2NhdGlvbik7XG5cdGlmIChpc1R5cGVLaW5kKHMyLCAndmFyaWFibGUnKSkgcmV0dXJuIHVuaWZ5VmFyaWFibGUoczIsIHMxLCBzdGF0ZSwgbG9jYXRpb24pO1xuXG5cdC8vIEhhbmRsZSBmdW5jdGlvbiB0eXBlc1xuXHRpZiAoaXNUeXBlS2luZChzMSwgJ2Z1bmN0aW9uJykgJiYgaXNUeXBlS2luZChzMiwgJ2Z1bmN0aW9uJykpIHtcblx0XHRyZXR1cm4gdW5pZnlGdW5jdGlvbihzMSwgczIsIHN0YXRlLCBsb2NhdGlvbik7XG5cdH1cblxuXHQvLyBIYW5kbGUgbGlzdCB0eXBlc1xuXHRpZiAoaXNUeXBlS2luZChzMSwgJ2xpc3QnKSAmJiBpc1R5cGVLaW5kKHMyLCAnbGlzdCcpKSB7XG5cdFx0cmV0dXJuIHVuaWZ5TGlzdChzMSwgczIsIHN0YXRlLCBsb2NhdGlvbik7XG5cdH1cblxuXHQvLyBIYW5kbGUgdHVwbGUgdHlwZXNcblx0aWYgKGlzVHlwZUtpbmQoczEsICd0dXBsZScpICYmIGlzVHlwZUtpbmQoczIsICd0dXBsZScpKSB7XG5cdFx0cmV0dXJuIHVuaWZ5VHVwbGUoczEsIHMyLCBzdGF0ZSwgbG9jYXRpb24pO1xuXHR9XG5cblx0Ly8gSGFuZGxlIHJlY29yZCB0eXBlc1xuXHRpZiAoaXNUeXBlS2luZChzMSwgJ3JlY29yZCcpICYmIGlzVHlwZUtpbmQoczIsICdyZWNvcmQnKSkge1xuXHRcdHJldHVybiB1bmlmeVJlY29yZChzMSwgczIsIHN0YXRlLCBsb2NhdGlvbik7XG5cdH1cblxuXHQvLyBIYW5kbGUgdW5pb24gdHlwZXNcblx0aWYgKGlzVHlwZUtpbmQoczEsICd1bmlvbicpICYmIGlzVHlwZUtpbmQoczIsICd1bmlvbicpKSB7XG5cdFx0cmV0dXJuIHVuaWZ5VW5pb24oczEsIHMyLCBzdGF0ZSwgbG9jYXRpb24pO1xuXHR9XG5cblx0Ly8gSGFuZGxlIHByaW1pdGl2ZSB0eXBlc1xuXHRpZiAoaXNUeXBlS2luZChzMSwgJ3ByaW1pdGl2ZScpICYmIGlzVHlwZUtpbmQoczIsICdwcmltaXRpdmUnKSkge1xuXHRcdHJldHVybiB1bmlmeVByaW1pdGl2ZShzMSwgczIsIHN0YXRlLCBsb2NhdGlvbik7XG5cdH1cblxuXHQvLyBIYW5kbGUgdW5pdCB0eXBlc1xuXHRpZiAoaXNUeXBlS2luZChzMSwgJ3VuaXQnKSAmJiBpc1R5cGVLaW5kKHMyLCAndW5pdCcpKSB7XG5cdFx0cmV0dXJuIHVuaWZ5VW5pdChzMSwgczIsIHN0YXRlLCBsb2NhdGlvbik7XG5cdH1cblxuXHQvLyBIYW5kbGUgdmFyaWFudCB0eXBlcyAoQURUcyBsaWtlIE9wdGlvbiwgUmVzdWx0LCBldGMuKVxuXHRpZiAoaXNUeXBlS2luZChzMSwgJ3ZhcmlhbnQnKSAmJiBpc1R5cGVLaW5kKHMyLCAndmFyaWFudCcpKSB7XG5cdFx0cmV0dXJuIHVuaWZ5VmFyaWFudChzMSwgczIsIHN0YXRlLCBsb2NhdGlvbik7XG5cdH1cblxuXHQvLyBJZiB3ZSBnZXQgaGVyZSwgdGhlIHR5cGVzIGNhbm5vdCBiZSB1bmlmaWVkXG5cdC8vIEFkZCBkZWJ1ZyBpbmZvIGZvciBkaWZmaWN1bHQgY2FzZXNcblx0Y29uc3QgZGVidWdDb250ZXh0ID0gY29udGV4dCB8fCB7fTtcblx0aWYgKFxuXHRcdHMxLmtpbmQgPT09IHMyLmtpbmQgJiZcblx0XHRzMS5raW5kID09PSAncHJpbWl0aXZlJyAmJlxuXHRcdChzMSBhcyBhbnkpLm5hbWUgPT09IChzMiBhcyBhbnkpLm5hbWVcblx0KSB7XG5cdFx0ZGVidWdDb250ZXh0LnJlYXNvbiA9ICdjb25jcmV0ZV92c192YXJpYWJsZSc7XG5cdFx0ZGVidWdDb250ZXh0LmhpbnQgPSBgQm90aCB0eXBlcyBhcHBlYXIgdG8gYmUgJHtcblx0XHRcdChzMSBhcyBhbnkpLm5hbWVcblx0XHR9IGJ1dCB0aGV5IGFyZSBub3QgdW5pZnlpbmcuIFRoaXMgc3VnZ2VzdHMgdGhlIHR5cGUgZXF1YWxpdHkgY2hlY2sgaXMgZmFpbGluZy4gVHlwZSAxOiAke0pTT04uc3RyaW5naWZ5KFxuXHRcdFx0czFcblx0XHQpfSwgVHlwZSAyOiAke0pTT04uc3RyaW5naWZ5KFxuXHRcdFx0czJcblx0XHQpfS4gQ2hlY2sgaWYgdGhlcmUgYXJlIGV4dHJhIHByb3BlcnRpZXMgb3IgY29uc3RyYWludHMgY2F1c2luZyBpbmVxdWFsaXR5LmA7XG5cdH1cblxuXHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0Zm9ybWF0VHlwZUVycm9yKFxuXHRcdFx0dW5pZmljYXRpb25FcnJvcihzMSwgczIsIGRlYnVnQ29udGV4dCwgbG9jYXRpb24gfHwgeyBsaW5lOiAxLCBjb2x1bW46IDEgfSlcblx0XHQpXG5cdCk7XG59O1xuXG5leHBvcnQgY29uc3QgdW5pZnkgPSAoXG5cdHQxOiBUeXBlLFxuXHR0MjogVHlwZSxcblx0c3RhdGU6IFR5cGVTdGF0ZSxcblx0bG9jYXRpb24/OiB7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfSxcblx0Y29udGV4dD86IHtcblx0XHRyZWFzb24/OiBzdHJpbmc7XG5cdFx0b3BlcmF0aW9uPzogc3RyaW5nO1xuXHRcdGhpbnQ/OiBzdHJpbmc7XG5cdH1cbik6IFR5cGVTdGF0ZSA9PiB7XG5cdGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcblx0dW5pZnlDYWxsQ291bnQrKztcblx0XG5cdC8vIFRyYWNrIGNhbGwgc291cmNlcyB1c2luZyBzdGFjayB0cmFjZVxuXHRjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrIHx8ICcnO1xuXHRjb25zdCBjYWxsZXIgPSBzdGFjay5zcGxpdCgnXFxuJylbMl0gfHwgJ3Vua25vd24nO1xuXHRjb25zdCBzb3VyY2UgPSBjYWxsZXIuaW5jbHVkZXMoJ2F0ICcpID8gY2FsbGVyLnNwbGl0KCdhdCAnKVsxXS5zcGxpdCgnICcpWzBdIDogJ3Vua25vd24nO1xuXHR1bmlmeUNhbGxTb3VyY2VzLnNldChzb3VyY2UsICh1bmlmeUNhbGxTb3VyY2VzLmdldChzb3VyY2UpIHx8IDApICsgMSk7XG5cdFxuXHQvLyBUcmFjayB0eXBlIHBhdHRlcm5zIGJlaW5nIHVuaWZpZWRcblx0Y29uc3QgcGF0dGVybiA9IGAke3R5cGVUb1BhdHRlcm4odDEpfSA9ICR7dHlwZVRvUGF0dGVybih0Mil9YDtcblx0dW5pZnlUeXBlUGF0dGVybnMuc2V0KHBhdHRlcm4sICh1bmlmeVR5cGVQYXR0ZXJucy5nZXQocGF0dGVybikgfHwgMCkgKyAxKTtcblx0XG5cdGNvbnN0IHJlc3VsdCA9IHVuaWZ5SW50ZXJuYWwodDEsIHQyLCBzdGF0ZSwgbG9jYXRpb24sIGNvbnRleHQpO1xuXHRcblx0Y29uc3QgdGltZSA9IERhdGUubm93KCkgLSBzdGFydDtcblx0dG90YWxVbmlmeVRpbWUgKz0gdGltZTtcblx0XG5cdGlmICh0aW1lID4gMTApIHtcblx0XHRzbG93VW5pZnlDYWxscy5wdXNoKHtcblx0XHRcdHR5cGUxOiBgJHt0MS5raW5kfToke3QxLmtpbmQgPT09ICd2YXJpYWJsZScgPyB0MS5uYW1lIDogJz8nfWAsXG5cdFx0XHR0eXBlMjogYCR7dDIua2luZH06JHt0Mi5raW5kID09PSAndmFyaWFibGUnID8gdDIubmFtZSA6ICc/J31gLFxuXHRcdFx0dGltZVxuXHRcdH0pO1xuXHR9XG5cdFxuXHRpZiAodW5pZnlDYWxsQ291bnQgJSA1MDAwID09PSAwKSB7XG5cdFx0Y29uc29sZS53YXJuKGBVbmlmeTogJHt1bmlmeUNhbGxDb3VudH0gY2FsbHMsICR7dG90YWxVbmlmeVRpbWV9bXMgdG90YWwsICR7c2xvd1VuaWZ5Q2FsbHMubGVuZ3RofSBzbG93IGNhbGxzYCk7XG5cdFx0XG5cdFx0Ly8gU2hvdyB0b3AgY2FsbCBzb3VyY2VzXG5cdFx0Y29uc3QgdG9wU291cmNlcyA9IEFycmF5LmZyb20odW5pZnlDYWxsU291cmNlcy5lbnRyaWVzKCkpXG5cdFx0XHQuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pXG5cdFx0XHQuc2xpY2UoMCwgNSk7XG5cdFx0Y29uc29sZS53YXJuKCdUb3AgdW5pZnkgY2FsbCBzb3VyY2VzOicsIHRvcFNvdXJjZXMpO1xuXHRcdFxuXHRcdC8vIFNob3cgbW9zdCByZXBlYXRlZCB0eXBlIHBhdHRlcm5zXG5cdFx0Y29uc3QgdG9wUGF0dGVybnMgPSBBcnJheS5mcm9tKHVuaWZ5VHlwZVBhdHRlcm5zLmVudHJpZXMoKSlcblx0XHRcdC5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSlcblx0XHRcdC5zbGljZSgwLCA1KTtcblx0XHRjb25zb2xlLndhcm4oJ01vc3QgcmVwZWF0ZWQgdW5pZmljYXRpb25zOicsIHRvcFBhdHRlcm5zKTtcblx0fVxuXHRcblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIHVuaWZ5VW5pb24oXG5cdHMxOiBUeXBlLFxuXHRzMjogVHlwZSxcblx0c3RhdGU6IFR5cGVTdGF0ZSxcblx0bG9jYXRpb24/OiB7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfVxuKTogVHlwZVN0YXRlIHtcblx0aWYgKCFpc1R5cGVLaW5kKHMxLCAndW5pb24nKSB8fCAhaXNUeXBlS2luZChzMiwgJ3VuaW9uJykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3VuaWZ5VW5pb24gY2FsbGVkIHdpdGggbm9uLXVuaW9uIHR5cGVzJyk7XG5cdH1cblx0Ly8gRm9yIG5vdywgcmVxdWlyZSBleGFjdCBtYXRjaCBvZiB1bmlvbiB0eXBlc1xuXHRpZiAoczEudHlwZXMubGVuZ3RoICE9PSBzMi50eXBlcy5sZW5ndGgpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0Zm9ybWF0VHlwZUVycm9yKFxuXHRcdFx0XHRjcmVhdGVUeXBlRXJyb3IoXG5cdFx0XHRcdFx0YFVuaW9uIHR5cGUgbWlzbWF0Y2g6ICR7czEudHlwZXMubGVuZ3RofSB2cyAke3MyLnR5cGVzLmxlbmd0aH0gdHlwZXNgLFxuXHRcdFx0XHRcdHt9LFxuXHRcdFx0XHRcdGxvY2F0aW9uIHx8IHsgbGluZTogMSwgY29sdW1uOiAxIH1cblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdCk7XG5cdGxldCBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzMS50eXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdGN1cnJlbnRTdGF0ZSA9IHVuaWZ5KHMxLnR5cGVzW2ldLCBzMi50eXBlc1tpXSwgY3VycmVudFN0YXRlLCBsb2NhdGlvbik7XG5cdH1cblx0cmV0dXJuIGN1cnJlbnRTdGF0ZTtcbn1cblxuZnVuY3Rpb24gdW5pZnlQcmltaXRpdmUoXG5cdHMxOiBUeXBlLFxuXHRzMjogVHlwZSxcblx0c3RhdGU6IFR5cGVTdGF0ZSxcblx0bG9jYXRpb24/OiB7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfVxuKTogVHlwZVN0YXRlIHtcblx0aWYgKCFpc1R5cGVLaW5kKHMxLCAncHJpbWl0aXZlJykgfHwgIWlzVHlwZUtpbmQoczIsICdwcmltaXRpdmUnKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcigndW5pZnlQcmltaXRpdmUgY2FsbGVkIHdpdGggbm9uLXByaW1pdGl2ZSB0eXBlcycpO1xuXHR9XG5cdGlmIChzMS5uYW1lICE9PSBzMi5uYW1lKVxuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGZvcm1hdFR5cGVFcnJvcihcblx0XHRcdFx0b3BlcmF0b3JUeXBlRXJyb3IoJycsIHMxLCBzMiwgbG9jYXRpb24gfHwgeyBsaW5lOiAxLCBjb2x1bW46IDEgfSlcblx0XHRcdClcblx0XHQpO1xuXHRyZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIHVuaWZ5VW5pdChcblx0czE6IFR5cGUsXG5cdHMyOiBUeXBlLFxuXHRzdGF0ZTogVHlwZVN0YXRlLFxuXHRsb2NhdGlvbj86IHsgbGluZTogbnVtYmVyOyBjb2x1bW46IG51bWJlciB9XG4pOiBUeXBlU3RhdGUge1xuXHRpZiAoIWlzVHlwZUtpbmQoczEsICd1bml0JykgfHwgIWlzVHlwZUtpbmQoczIsICd1bml0JykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3VuaWZ5VW5pdCBjYWxsZWQgd2l0aCBub24tdW5pdCB0eXBlcycpO1xuXHR9XG5cdHJldHVybiBzdGF0ZTtcbn1cblxuLy8gLS0tIFVuaWZpY2F0aW9uIGhlbHBlcnMgLS0tXG5mdW5jdGlvbiB1bmlmeVZhcmlhYmxlKFxuXHRzMTogVHlwZSxcblx0czI6IFR5cGUsXG5cdHN0YXRlOiBUeXBlU3RhdGUsXG5cdGxvY2F0aW9uPzogeyBsaW5lOiBudW1iZXI7IGNvbHVtbjogbnVtYmVyIH1cbik6IFR5cGVTdGF0ZSB7XG5cdGlmICghaXNUeXBlS2luZChzMSwgJ3ZhcmlhYmxlJykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3VuaWZ5VmFyaWFibGUgY2FsbGVkIHdpdGggbm9uLXZhcmlhYmxlIHMxJyk7XG5cdH1cblx0Ly8gT3B0aW1pemVkIGNvbnN0cmFpbnQgY29sbGVjdGlvbiAtIGF2b2lkIGFycmF5IHNwcmVhZGluZ1xuXHRsZXQgY29uc3RyYWludHNUb0NoZWNrOiBDb25zdHJhaW50W10gPSBbXTtcblx0bGV0IHNlZW5WYXJzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cdGxldCBjdXJyZW50VmFyOiBUeXBlID0gczE7XG5cdHdoaWxlIChpc1R5cGVLaW5kKGN1cnJlbnRWYXIsICd2YXJpYWJsZScpKSB7XG5cdFx0aWYgKHNlZW5WYXJzLmhhcyhjdXJyZW50VmFyLm5hbWUpKSBicmVhaztcblx0XHRzZWVuVmFycy5hZGQoY3VycmVudFZhci5uYW1lKTtcblx0XHRpZiAoY3VycmVudFZhci5jb25zdHJhaW50cykge1xuXHRcdFx0Ly8gVXNlIGZvckVhY2ggaW5zdGVhZCBvZiBzcHJlYWQgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuXHRcdFx0Y3VycmVudFZhci5jb25zdHJhaW50cy5mb3JFYWNoKGMgPT4gY29uc3RyYWludHNUb0NoZWNrLnB1c2goYykpO1xuXHRcdH1cblx0XHRjb25zdCBuZXh0ID0gc3RhdGUuc3Vic3RpdHV0aW9uLmdldChjdXJyZW50VmFyLm5hbWUpO1xuXHRcdGlmICghbmV4dCkgYnJlYWs7XG5cdFx0Y3VycmVudFZhciA9IG5leHQ7XG5cdH1cblx0Ly8gSWYgczIgaXMgYSB2YXJpYWJsZSwgbWVyZ2UgYWxsIGNvbnN0cmFpbnRzIGludG8gaXRcblx0aWYgKGlzVHlwZUtpbmQoczIsICd2YXJpYWJsZScpKSB7XG5cdFx0czIuY29uc3RyYWludHMgPSBzMi5jb25zdHJhaW50cyB8fCBbXTtcblx0XHQvLyBPcHRpbWl6ZWQgY29uc3RyYWludCBtZXJnaW5nIC0gdXNlIGVmZmljaWVudCBjb25zdHJhaW50IGNvbXBhcmlzb25cblx0XHRmb3IgKGNvbnN0IGMgb2YgY29uc3RyYWludHNUb0NoZWNrKSB7XG5cdFx0XHRpZiAoIXMyLmNvbnN0cmFpbnRzLnNvbWUoZXhpc3RpbmcgPT4gY29uc3RyYWludHNFcXVhbChjLCBleGlzdGluZykpKSB7XG5cdFx0XHRcdHMyLmNvbnN0cmFpbnRzLnB1c2goYyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIE9jY3VycyBjaGVja1xuXHRpZiAob2NjdXJzSW4oczEubmFtZSwgczIpKVxuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGZvcm1hdFR5cGVFcnJvcihcblx0XHRcdFx0Y3JlYXRlVHlwZUVycm9yKFxuXHRcdFx0XHRcdGBPY2N1cnMgY2hlY2sgZmFpbGVkOiAke3MxLm5hbWV9IG9jY3VycyBpbiAke3R5cGVUb1N0cmluZyhcblx0XHRcdFx0XHRcdHMyLFxuXHRcdFx0XHRcdFx0c3RhdGUuc3Vic3RpdHV0aW9uXG5cdFx0XHRcdFx0KX1gLFxuXHRcdFx0XHRcdHt9LFxuXHRcdFx0XHRcdGxvY2F0aW9uIHx8IHsgbGluZTogMSwgY29sdW1uOiAxIH1cblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdCk7XG5cdGxldCBuZXdTdGF0ZSA9IHtcblx0XHQuLi5zdGF0ZSxcblx0XHRzdWJzdGl0dXRpb246IG1hcFNldChzdGF0ZS5zdWJzdGl0dXRpb24sIHMxLm5hbWUsIHMyKSxcblx0fTtcblx0Ly8gSWYgczIgaXMgbm90IGEgdmFyaWFibGUsIHByb3BhZ2F0ZSBvciBjaGVjayBjb25zdHJhaW50c1xuXHRpZiAoIWlzVHlwZUtpbmQoczIsICd2YXJpYWJsZScpKSB7XG5cdFx0Zm9yIChjb25zdCBjb25zdHJhaW50IG9mIGNvbnN0cmFpbnRzVG9DaGVjaykge1xuXHRcdFx0aWYgKGNvbnN0cmFpbnQua2luZCA9PT0gJ2hhc0ZpZWxkJyAmJiBpc1R5cGVLaW5kKHMyLCAncmVjb3JkJykpIHtcblx0XHRcdFx0bmV3U3RhdGUgPSB1bmlmeShcblx0XHRcdFx0XHRzMi5maWVsZHNbY29uc3RyYWludC5maWVsZF0sXG5cdFx0XHRcdFx0Y29uc3RyYWludC5maWVsZFR5cGUsXG5cdFx0XHRcdFx0bmV3U3RhdGUsXG5cdFx0XHRcdFx0bG9jYXRpb25cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSBpZiAoY29uc3RyYWludC5raW5kID09PSAnaXMnKSB7XG5cdFx0XHRcdGlmIChpc1R5cGVLaW5kKHMyLCAncHJpbWl0aXZlJykpIHtcblx0XHRcdFx0XHRpZiAoIXNhdGlzZmllc0NvbnN0cmFpbnQoczIsIGNvbnN0cmFpbnQuY29uc3RyYWludCkpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0Zm9ybWF0VHlwZUVycm9yKFxuXHRcdFx0XHRcdFx0XHRcdGNyZWF0ZVR5cGVFcnJvcihcblx0XHRcdFx0XHRcdFx0XHRcdGBUeXBlICR7dHlwZVRvU3RyaW5nKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuc3Vic3RpdHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHQpfSBkb2VzIG5vdCBzYXRpc2Z5IGNvbnN0cmFpbnQgJyR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0cmFpbnQuY29uc3RyYWludFxuXHRcdFx0XHRcdFx0XHRcdFx0fScuIFRoaXMgZXJyb3IgdHlwaWNhbGx5IG9jY3VycyB3aGVuIGF0dGVtcHRpbmcgdG8gdXNlIGEgcGFydGlhbCBmdW5jdGlvbiAob25lIHRoYXQgY2FuIGZhaWwpIGluIGFuIHVuc2FmZSBjb250ZXh0IGxpa2UgZnVuY3Rpb24gY29tcG9zaXRpb24uIENvbnNpZGVyIHVzaW5nIHRvdGFsIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBPcHRpb24gb3IgUmVzdWx0IHR5cGVzIGluc3RlYWQuYCxcblx0XHRcdFx0XHRcdFx0XHRcdHt9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bG9jYXRpb24gfHwgeyBsaW5lOiAxLCBjb2x1bW46IDEgfVxuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gUHJvcGFnYXRlIHRoZSBjb25zdHJhaW50IHJlY3Vyc2l2ZWx5IHRvIGFsbCB0eXBlIHZhcmlhYmxlcyBpbnNpZGUgczJcblx0XHRcdFx0XHRwcm9wYWdhdGVDb25zdHJhaW50VG9UeXBlKHMyLCBjb25zdHJhaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gRm9yIG90aGVyIGNvbnN0cmFpbnQga2luZHMsIHByb3BhZ2F0ZSByZWN1cnNpdmVseVxuXHRcdFx0XHRwcm9wYWdhdGVDb25zdHJhaW50VG9UeXBlKHMyLCBjb25zdHJhaW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIG5ld1N0YXRlO1xufVxuXG5sZXQgZnVuY3Rpb25VbmlmeUNvdW50ID0gMDtcbmxldCBmdW5jdGlvblVuaWZ5UGF0dGVybnMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG5mdW5jdGlvbiB1bmlmeUZ1bmN0aW9uKFxuXHRzMTogVHlwZSxcblx0czI6IFR5cGUsXG5cdHN0YXRlOiBUeXBlU3RhdGUsXG5cdGxvY2F0aW9uPzogeyBsaW5lOiBudW1iZXI7IGNvbHVtbjogbnVtYmVyIH1cbik6IFR5cGVTdGF0ZSB7XG5cdGlmICghaXNUeXBlS2luZChzMSwgJ2Z1bmN0aW9uJykgfHwgIWlzVHlwZUtpbmQoczIsICdmdW5jdGlvbicpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCd1bmlmeUZ1bmN0aW9uIGNhbGxlZCB3aXRoIG5vbi1mdW5jdGlvbiB0eXBlcycpO1xuXHR9XG5cdFxuXHRmdW5jdGlvblVuaWZ5Q291bnQrKztcblx0Y29uc3QgcGF0dGVybiA9IGAke3MxLnBhcmFtcy5sZW5ndGh9cF8ke3MyLnBhcmFtcy5sZW5ndGh9cGA7XG5cdGZ1bmN0aW9uVW5pZnlQYXR0ZXJucy5zZXQocGF0dGVybiwgKGZ1bmN0aW9uVW5pZnlQYXR0ZXJucy5nZXQocGF0dGVybikgfHwgMCkgKyAxKTtcblx0XG5cdGlmIChmdW5jdGlvblVuaWZ5Q291bnQgJSAxMDAwID09PSAwKSB7XG5cdFx0Y29uc29sZS53YXJuKGBGdW5jdGlvbiB1bmlmeTogJHtmdW5jdGlvblVuaWZ5Q291bnR9IGNhbGxzLCB0b3AgcGF0dGVybnM6YCwgXG5cdFx0XHRBcnJheS5mcm9tKGZ1bmN0aW9uVW5pZnlQYXR0ZXJucy5lbnRyaWVzKCkpLnNvcnQoKGEsYikgPT4gYlsxXSAtIGFbMV0pLnNsaWNlKDAsMykpO1xuXHR9XG5cblx0aWYgKHMxLnBhcmFtcy5sZW5ndGggIT09IHMyLnBhcmFtcy5sZW5ndGgpXG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0Zm9ybWF0VHlwZUVycm9yKFxuXHRcdFx0XHRmdW5jdGlvbkFwcGxpY2F0aW9uRXJyb3IoXG5cdFx0XHRcdFx0czEsXG5cdFx0XHRcdFx0czIsXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHR1bmRlZmluZWQsXG5cdFx0XHRcdFx0bG9jYXRpb24gfHwgeyBsaW5lOiAxLCBjb2x1bW46IDEgfVxuXHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0KTtcblxuXHRsZXQgY3VycmVudFN0YXRlID0gc3RhdGU7XG5cblx0Ly8gRmlyc3QsIHByb3BhZ2F0ZSBmdW5jdGlvbi1sZXZlbCBjb25zdHJhaW50cyB0byB0aGUgcmVsZXZhbnQgdHlwZSB2YXJpYWJsZXNcblx0aWYgKHMxLmNvbnN0cmFpbnRzKSB7XG5cdFx0Zm9yIChjb25zdCBjb25zdHJhaW50IG9mIHMxLmNvbnN0cmFpbnRzKSB7XG5cdFx0XHQvLyBQcm9wYWdhdGUgdG8gYWxsIHR5cGUgdmFyaWFibGVzIGluIHMxXG5cdFx0XHRwcm9wYWdhdGVDb25zdHJhaW50VG9UeXBlKHMxLCBjb25zdHJhaW50KTtcblx0XHR9XG5cdH1cblxuXHRpZiAoczIuY29uc3RyYWludHMpIHtcblx0XHRmb3IgKGNvbnN0IGNvbnN0cmFpbnQgb2YgczIuY29uc3RyYWludHMpIHtcblx0XHRcdC8vIFByb3BhZ2F0ZSB0byBhbGwgdHlwZSB2YXJpYWJsZXMgaW4gczJcblx0XHRcdHByb3BhZ2F0ZUNvbnN0cmFpbnRUb1R5cGUoczIsIGNvbnN0cmFpbnQpO1xuXHRcdH1cblx0fVxuXG5cdC8vIFRoZW4gdW5pZnkgcGFyYW1ldGVycyBhbmQgcmV0dXJuIHR5cGVzXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgczEucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0Ly8gU2tpcCBleHBlbnNpdmUgY29uc3RyYWludCBwcm9wYWdhdGlvbiBmb3Igbm9uLXZhcmlhYmxlc1xuXHRcdGNvbnN0IHMxdmFyID0gczEucGFyYW1zW2ldO1xuXHRcdGNvbnN0IHMydmFyID0gczIucGFyYW1zW2ldO1xuXHRcdGlmIChpc1R5cGVLaW5kKHMxdmFyLCAndmFyaWFibGUnKSAmJiBpc1R5cGVLaW5kKHMydmFyLCAndmFyaWFibGUnKSAmJiBcblx0XHQgICAgKHMxdmFyLmNvbnN0cmFpbnRzPy5sZW5ndGggfHwgczJ2YXIuY29uc3RyYWludHM/Lmxlbmd0aCkpIHtcblx0XHRcdHMxdmFyLmNvbnN0cmFpbnRzID0gczF2YXIuY29uc3RyYWludHMgfHwgW107XG5cdFx0XHRzMnZhci5jb25zdHJhaW50cyA9IHMydmFyLmNvbnN0cmFpbnRzIHx8IFtdO1xuXHRcdFx0Ly8gT3B0aW1pemVkIGNvbnN0cmFpbnQgbWVyZ2luZyB1c2luZyBlZmZpY2llbnQgY29tcGFyaXNvblxuXHRcdFx0Ly8gUHJvcGFnYXRlIHMxIC0+IHMyXG5cdFx0XHRmb3IgKGNvbnN0IGMgb2YgczF2YXIuY29uc3RyYWludHMpIHtcblx0XHRcdFx0aWYgKCFzMnZhci5jb25zdHJhaW50cy5zb21lKGV4aXN0aW5nID0+IGNvbnN0cmFpbnRzRXF1YWwoYywgZXhpc3RpbmcpKSkge1xuXHRcdFx0XHRcdHMydmFyLmNvbnN0cmFpbnRzLnB1c2goYyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFByb3BhZ2F0ZSBzMiAtPiBzMVxuXHRcdFx0Zm9yIChjb25zdCBjIG9mIHMydmFyLmNvbnN0cmFpbnRzKSB7XG5cdFx0XHRcdGlmICghczF2YXIuY29uc3RyYWludHMuc29tZShleGlzdGluZyA9PiBjb25zdHJhaW50c0VxdWFsKGMsIGV4aXN0aW5nKSkpIHtcblx0XHRcdFx0XHRzMXZhci5jb25zdHJhaW50cy5wdXNoKGMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGN1cnJlbnRTdGF0ZSA9IHVuaWZ5KHMxLnBhcmFtc1tpXSwgczIucGFyYW1zW2ldLCBjdXJyZW50U3RhdGUsIGxvY2F0aW9uKTtcblx0fVxuXHRjdXJyZW50U3RhdGUgPSB1bmlmeShzMS5yZXR1cm4sIHMyLnJldHVybiwgY3VycmVudFN0YXRlLCBsb2NhdGlvbik7XG5cblx0cmV0dXJuIGN1cnJlbnRTdGF0ZTtcbn1cblxuZnVuY3Rpb24gdW5pZnlMaXN0KFxuXHRzMTogVHlwZSxcblx0czI6IFR5cGUsXG5cdHN0YXRlOiBUeXBlU3RhdGUsXG5cdGxvY2F0aW9uPzogeyBsaW5lOiBudW1iZXI7IGNvbHVtbjogbnVtYmVyIH1cbik6IFR5cGVTdGF0ZSB7XG5cdGlmICghaXNUeXBlS2luZChzMSwgJ2xpc3QnKSB8fCAhaXNUeXBlS2luZChzMiwgJ2xpc3QnKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcigndW5pZnlMaXN0IGNhbGxlZCB3aXRoIG5vbi1saXN0IHR5cGVzJyk7XG5cdH1cblx0cmV0dXJuIHVuaWZ5KHMxLmVsZW1lbnQsIHMyLmVsZW1lbnQsIHN0YXRlLCBsb2NhdGlvbik7XG59XG5cbmZ1bmN0aW9uIHVuaWZ5VHVwbGUoXG5cdHMxOiBUeXBlLFxuXHRzMjogVHlwZSxcblx0c3RhdGU6IFR5cGVTdGF0ZSxcblx0bG9jYXRpb24/OiB7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfVxuKTogVHlwZVN0YXRlIHtcblx0aWYgKCFpc1R5cGVLaW5kKHMxLCAndHVwbGUnKSB8fCAhaXNUeXBlS2luZChzMiwgJ3R1cGxlJykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3VuaWZ5VHVwbGUgY2FsbGVkIHdpdGggbm9uLXR1cGxlIHR5cGVzJyk7XG5cdH1cblx0aWYgKHMxLmVsZW1lbnRzLmxlbmd0aCAhPT0gczIuZWxlbWVudHMubGVuZ3RoKVxuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGZvcm1hdFR5cGVFcnJvcihcblx0XHRcdFx0Y3JlYXRlVHlwZUVycm9yKFxuXHRcdFx0XHRcdGBUdXBsZSBsZW5ndGggbWlzbWF0Y2g6ICR7czEuZWxlbWVudHMubGVuZ3RofSB2cyAke3MyLmVsZW1lbnRzLmxlbmd0aH1gLFxuXHRcdFx0XHRcdHt9LFxuXHRcdFx0XHRcdGxvY2F0aW9uIHx8IHsgbGluZTogMSwgY29sdW1uOiAxIH1cblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdCk7XG5cdGxldCBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzMS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGN1cnJlbnRTdGF0ZSA9IHVuaWZ5KFxuXHRcdFx0czEuZWxlbWVudHNbaV0sXG5cdFx0XHRzMi5lbGVtZW50c1tpXSxcblx0XHRcdGN1cnJlbnRTdGF0ZSxcblx0XHRcdGxvY2F0aW9uXG5cdFx0KTtcblx0fVxuXHRyZXR1cm4gY3VycmVudFN0YXRlO1xufVxuXG5mdW5jdGlvbiB1bmlmeVZhcmlhbnQoXG5cdHMxOiBUeXBlLFxuXHRzMjogVHlwZSxcblx0c3RhdGU6IFR5cGVTdGF0ZSxcblx0bG9jYXRpb24/OiB7IGxpbmU6IG51bWJlcjsgY29sdW1uOiBudW1iZXIgfVxuKTogVHlwZVN0YXRlIHtcblx0aWYgKCFpc1R5cGVLaW5kKHMxLCAndmFyaWFudCcpIHx8ICFpc1R5cGVLaW5kKHMyLCAndmFyaWFudCcpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCd1bmlmeVZhcmlhbnQgY2FsbGVkIHdpdGggbm9uLXZhcmlhbnQgdHlwZXMnKTtcblx0fVxuXG5cdC8vIFZhcmlhbnQgdHlwZXMgbXVzdCBoYXZlIHRoZSBzYW1lIG5hbWUgKGUuZy4sIGJvdGggXCJPcHRpb25cIilcblx0aWYgKHMxLm5hbWUgIT09IHMyLm5hbWUpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRmb3JtYXRUeXBlRXJyb3IoXG5cdFx0XHRcdGNyZWF0ZVR5cGVFcnJvcihcblx0XHRcdFx0XHRgVmFyaWFudCBuYW1lIG1pc21hdGNoOiAke3MxLm5hbWV9IHZzICR7czIubmFtZX1gLFxuXHRcdFx0XHRcdHt9LFxuXHRcdFx0XHRcdGxvY2F0aW9uIHx8IHsgbGluZTogMSwgY29sdW1uOiAxIH1cblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdCk7XG5cdH1cblxuXHQvLyBWYXJpYW50IHR5cGVzIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgdHlwZSBhcmd1bWVudHNcblx0aWYgKHMxLmFyZ3MubGVuZ3RoICE9PSBzMi5hcmdzLmxlbmd0aCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdGZvcm1hdFR5cGVFcnJvcihcblx0XHRcdFx0Y3JlYXRlVHlwZUVycm9yKFxuXHRcdFx0XHRcdGBWYXJpYW50IGFyaXR5IG1pc21hdGNoOiAke3MxLm5hbWV9IGhhcyAke3MxLmFyZ3MubGVuZ3RofSB2cyAke3MyLmFyZ3MubGVuZ3RofSB0eXBlIGFyZ3VtZW50c2AsXG5cdFx0XHRcdFx0e30sXG5cdFx0XHRcdFx0bG9jYXRpb24gfHwgeyBsaW5lOiAxLCBjb2x1bW46IDEgfVxuXHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0KTtcblx0fVxuXG5cdC8vIFVuaWZ5IGNvcnJlc3BvbmRpbmcgdHlwZSBhcmd1bWVudHNcblx0bGV0IGN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IHMxLmFyZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRjdXJyZW50U3RhdGUgPSB1bmlmeShzMS5hcmdzW2ldLCBzMi5hcmdzW2ldLCBjdXJyZW50U3RhdGUsIGxvY2F0aW9uKTtcblx0fVxuXHRyZXR1cm4gY3VycmVudFN0YXRlO1xufVxuXG5mdW5jdGlvbiB1bmlmeVJlY29yZChcblx0czE6IFR5cGUsXG5cdHMyOiBUeXBlLFxuXHRzdGF0ZTogVHlwZVN0YXRlLFxuXHRsb2NhdGlvbj86IHsgbGluZTogbnVtYmVyOyBjb2x1bW46IG51bWJlciB9XG4pOiBUeXBlU3RhdGUge1xuXHRpZiAoIWlzVHlwZUtpbmQoczEsICdyZWNvcmQnKSB8fCAhaXNUeXBlS2luZChzMiwgJ3JlY29yZCcpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCd1bmlmeVJlY29yZCBjYWxsZWQgd2l0aCBub24tcmVjb3JkIHR5cGVzJyk7XG5cdH1cblx0Y29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhzMS5maWVsZHMpO1xuXHRsZXQgY3VycmVudFN0YXRlID0gc3RhdGU7XG5cdGZvciAoY29uc3Qga2V5IG9mIGtleXMxKSB7XG5cdFx0aWYgKCEoa2V5IGluIHMyLmZpZWxkcykpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdGZvcm1hdFR5cGVFcnJvcihcblx0XHRcdFx0XHRjcmVhdGVUeXBlRXJyb3IoXG5cdFx0XHRcdFx0XHRgUmVxdWlyZWQgZmllbGQgbWlzc2luZzogJHtrZXl9YCxcblx0XHRcdFx0XHRcdHt9LFxuXHRcdFx0XHRcdFx0bG9jYXRpb24gfHwgeyBsaW5lOiAxLCBjb2x1bW46IDEgfVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHRjdXJyZW50U3RhdGUgPSB1bmlmeShcblx0XHRcdHMxLmZpZWxkc1trZXldLFxuXHRcdFx0czIuZmllbGRzW2tleV0sXG5cdFx0XHRjdXJyZW50U3RhdGUsXG5cdFx0XHRsb2NhdGlvblxuXHRcdCk7XG5cdH1cblx0cmV0dXJuIGN1cnJlbnRTdGF0ZTtcbn1cbiJdLCJ2ZXJzaW9uIjozfQ==