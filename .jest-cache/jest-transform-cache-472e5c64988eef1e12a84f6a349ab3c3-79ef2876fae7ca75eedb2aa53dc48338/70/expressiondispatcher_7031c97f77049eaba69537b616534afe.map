{"file":"/workspace/src/typer/expression-dispatcher.ts","mappings":";;;AAAA,wDAAwD;AACxD,gCAKgB;AAChB,mCAAsE;AACtE,qDAa0B;AAC1B,iEAAuE;AACvE,yDAAmE;AAEnE,iCAAiC;AAC1B,MAAM,cAAc,GAAG,CAC7B,IAAgB,EAChB,KAAgB,EACH,EAAE;IACf,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;QACnB,KAAK,SAAS;YACb,OAAO,IAAA,4BAAW,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAEjC,KAAK,UAAU;YACd,OAAO,IAAA,iCAAgB,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAEtC,KAAK,UAAU;YACd,OAAO,IAAA,6BAAY,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAElC,KAAK,aAAa;YACjB,OAAO,IAAA,sCAAe,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAErC,KAAK,QAAQ;YACZ,OAAO,IAAA,2BAAU,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAEhC,KAAK,IAAI;YACR,OAAO,IAAA,uBAAM,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAE5B,KAAK,MAAM;YACV,OAAO,IAAA,yBAAQ,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAE9B,KAAK,QAAQ;YACZ,OAAO,IAAA,2BAAU,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAEhC,KAAK,OAAO;YACX,OAAO,IAAA,0BAAS,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAE/B,KAAK,UAAU;YACd,OAAO,IAAA,6BAAY,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAElC,KAAK,YAAY;YAChB,OAAO,IAAA,+BAAc,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAEpC,KAAK,MAAM;YACV,OAAO,IAAA,4BAAoB,EAAC,IAAA,cAAQ,GAAE,EAAE,KAAK,CAAC,CAAC;QAEhD,KAAK,iBAAiB;YACrB,OAAO,IAAA,qCAAkB,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAExC,KAAK,uBAAuB;YAC3B,OAAO,IAAA,yCAAwB,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAE9C,KAAK,sBAAsB;YAC1B,OAAO,IAAA,wCAAuB,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAE7C,KAAK,OAAO;YACX,OAAO,IAAA,4BAAS,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAE/B,KAAK,UAAU;YACd,OAAO,IAAA,mCAAY,EAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAElC;YACC,MAAM,IAAI,KAAK,CAAC,4BAA6B,IAAY,CAAC,IAAI,EAAE,CAAC,CAAC;IACpE,CAAC;AACF,CAAC,CAAC;AA3DW,QAAA,cAAc,kBA2DzB","names":[],"sources":["/workspace/src/typer/expression-dispatcher.ts"],"sourcesContent":["// Type expression dispatcher with proper error handling\nimport { \n\ttype Expression, \n\ttype Type,\n\ttype Effect,\n\tunitType\n} from '../ast';\nimport { TypeState, TypeResult, createPureTypeResult } from './types';\nimport {\n\ttypeLiteral,\n\ttypeVariableExpr,\n\ttypeFunction,\n\ttypeBinary,\n\ttypeIf,\n\ttypeList,\n\ttypeRecord,\n\ttypeTuple,\n\ttypeAccessor,\n\ttypeDefinition,\n\ttypeConstraintDefinition,\n\ttypeImplementDefinition,\n} from './type-inference';\nimport { typeApplication, typePipeline } from './function-application';\nimport { typeMatch, typeTypeDefinition } from './pattern-matching';\n\n// Main type inference dispatcher\nexport const typeExpression = (\n\texpr: Expression,\n\tstate: TypeState\n): TypeResult => {\n\tswitch (expr.kind) {\n\t\tcase 'literal':\n\t\t\treturn typeLiteral(expr, state);\n\n\t\tcase 'variable':\n\t\t\treturn typeVariableExpr(expr, state);\n\n\t\tcase 'function':\n\t\t\treturn typeFunction(expr, state);\n\n\t\tcase 'application':\n\t\t\treturn typeApplication(expr, state);\n\n\t\tcase 'binary':\n\t\t\treturn typeBinary(expr, state);\n\n\t\tcase 'if':\n\t\t\treturn typeIf(expr, state);\n\n\t\tcase 'list':\n\t\t\treturn typeList(expr, state);\n\n\t\tcase 'record':\n\t\t\treturn typeRecord(expr, state);\n\n\t\tcase 'tuple':\n\t\t\treturn typeTuple(expr, state);\n\n\t\tcase 'accessor':\n\t\t\treturn typeAccessor(expr, state);\n\n\t\tcase 'definition':\n\t\t\treturn typeDefinition(expr, state);\n\n\t\tcase 'unit':\n\t\t\treturn createPureTypeResult(unitType(), state);\n\n\t\tcase 'type-definition':\n\t\t\treturn typeTypeDefinition(expr, state);\n\n\t\tcase 'constraint-definition':\n\t\t\treturn typeConstraintDefinition(expr, state);\n\n\t\tcase 'implement-definition':\n\t\t\treturn typeImplementDefinition(expr, state);\n\n\t\tcase 'match':\n\t\t\treturn typeMatch(expr, state);\n\n\t\tcase 'pipeline':\n\t\t\treturn typePipeline(expr, state);\n\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown expression kind: ${(expr as any).kind}`);\n\t}\n};"],"version":3}