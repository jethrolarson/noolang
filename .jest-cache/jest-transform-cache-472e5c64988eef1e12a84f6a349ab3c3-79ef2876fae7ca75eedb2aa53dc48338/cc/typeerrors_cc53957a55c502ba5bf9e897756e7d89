64070277ccb91ce3ff2f339b35999c63
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTypeError = createTypeError;
exports.functionApplicationError = functionApplicationError;
exports.undefinedVariableError = undefinedVariableError;
exports.nonFunctionApplicationError = nonFunctionApplicationError;
exports.operatorTypeError = operatorTypeError;
exports.conditionTypeError = conditionTypeError;
exports.ifBranchTypeError = ifBranchTypeError;
exports.typeAnnotationError = typeAnnotationError;
exports.listElementTypeError = listElementTypeError;
exports.pipelineCompositionError = pipelineCompositionError;
exports.mutationTypeError = mutationTypeError;
exports.unificationError = unificationError;
exports.formatTypeError = formatTypeError;
const errors_1 = require("../errors");
const helpers_1 = require("./helpers");
function createTypeError(message, context, location) {
    let enhancedMessage = message;
    let suggestion = context?.suggestion;
    // Enhance message based on context
    if (context?.expectedType && context?.actualType) {
        enhancedMessage += `\n  Expected: ${typeToString(context.expectedType)}`;
        enhancedMessage += `\n  Got:      ${typeToString(context.actualType)}`;
    }
    // Add function-specific context
    if (context?.functionName) {
        enhancedMessage += `\n  Function: ${context.functionName}`;
    }
    // Add parameter-specific context
    if (context?.parameterIndex !== undefined) {
        enhancedMessage += `\n  Parameter ${context.parameterIndex + 1}`;
    }
    // Add operator context
    if (context?.operator) {
        enhancedMessage += `\n  Operator: ${context.operator}`;
    }
    // Add variable context
    if (context?.variableName) {
        enhancedMessage += `\n  Variable: ${context.variableName}`;
    }
    // Generate suggestions if not provided
    if (!suggestion) {
        suggestion = generateSuggestion(context);
    }
    return (0, errors_1.createError)("TypeError", enhancedMessage, location, context?.codeSnippet, suggestion);
}
function generateSuggestion(context) {
    if (!context)
        return "";
    // Function application errors
    if (context.functionName && context.expectedType && context.actualType) {
        if (context.parameterIndex !== undefined) {
            return `Check that argument ${context.parameterIndex + 1} matches the expected type. Consider adding a type annotation or using a different value.`;
        }
        return `Check that all arguments match the function's expected parameter types.`;
    }
    // Variable errors
    if (context.variableName) {
        return `Make sure '${context.variableName}' is defined before use. Check for typos or missing definitions.`;
    }
    // Operator errors
    if (context.operator) {
        return `The ${context.operator} operator expects specific types. Check that both operands are compatible.`;
    }
    // General type mismatch
    if (context.expectedType && context.actualType) {
        return `Consider adding a type annotation or using a value of the expected type.`;
    }
    return "Review the expression and ensure all types are compatible.";
}
// Enhanced error messages for common type errors
function functionApplicationError(funcType, argType, parameterIndex, functionName, location) {
    const message = `Type mismatch in function application`;
    return createTypeError(message, {
        expectedType: funcType,
        actualType: argType,
        functionName,
        parameterIndex,
        suggestion: `Argument ${parameterIndex + 1} has type ${typeToString(argType)} but the function expects ${typeToString(funcType)}. Consider using a different value or adding a type conversion.`,
    }, location);
}
function undefinedVariableError(variableName, location) {
    const message = `Undefined variable`;
    return createTypeError(message, {
        variableName,
        suggestion: `Define '${variableName}' before using it: ${variableName} = value`,
    }, location);
}
function nonFunctionApplicationError(type, location) {
    const message = `Cannot apply non-function type`;
    return createTypeError(message, {
        actualType: type,
        suggestion: `Only functions can be applied to arguments. Make sure you're calling a function, not a value.`,
    }, location);
}
function operatorTypeError(operator, expectedType, actualType, location) {
    const message = `Operator type mismatch`;
    return createTypeError(message, {
        operator,
        expectedType,
        actualType,
        suggestion: `The ${operator} operator expects ${typeToString(expectedType)} but got ${typeToString(actualType)}. Check your operand types.`,
    }, location);
}
function conditionTypeError(actualType, location) {
    const message = `Condition must be boolean`;
    return createTypeError(message, {
        actualType,
        suggestion: `Use a boolean expression (True/False) or a comparison that returns a boolean.`,
    }, location);
}
function ifBranchTypeError(thenType, elseType, location) {
    const message = `If branches must have the same type`;
    return createTypeError(message, {
        expectedType: thenType,
        actualType: elseType,
        suggestion: `Both branches of an if expression must return the same type. Consider adding type annotations or using compatible expressions.`,
    }, location);
}
function typeAnnotationError(expectedType, inferredType, location) {
    const message = `Type annotation mismatch`;
    return createTypeError(message, {
        expectedType,
        actualType: inferredType,
        suggestion: `The explicit type annotation doesn't match the inferred type. Either adjust the annotation or modify the expression.`,
    }, location);
}
function listElementTypeError(expectedType, actualType, location) {
    const message = `List elements must have the same type`;
    return createTypeError(message, {
        expectedType,
        actualType,
        suggestion: `All elements in a list must have the same type. Consider using a tuple for mixed types or ensuring all elements are compatible.`,
    }, location);
}
function pipelineCompositionError(outputType, inputType, location) {
    const message = `Pipeline composition type mismatch`;
    return createTypeError(message, {
        expectedType: inputType,
        actualType: outputType,
        suggestion: `The output type of the first function must match the input type of the second function in a pipeline.`,
    }, location);
}
function mutationTypeError(targetType, valueType, variableName, location) {
    const message = `Type mismatch in mutation`;
    return createTypeError(message, {
        expectedType: targetType,
        actualType: valueType,
        variableName,
        suggestion: `The new value must have the same type as the mutable variable '${variableName}'.`,
    }, location);
}
function unificationError(type1, type2, context, location) {
    let message = `Cannot unify types`;
    let suggestion = `Review the expression and ensure all types are compatible.`;
    // Add specific context based on the reason
    if (context.reason) {
        switch (context.reason) {
            case "constructor_application":
                message = `Constructor type mismatch`;
                suggestion = `This constructor expects different argument types. Check the ADT definition.`;
                break;
            case "function_application":
                message = `Function application type mismatch`;
                suggestion = `The function parameters don't match the provided arguments.`;
                break;
            case "operator_application":
                message = `Operator type mismatch`;
                suggestion = `The operator expects specific types. Check that both operands are compatible.`;
                break;
            case "if_branches":
                message = `If branch type mismatch`;
                suggestion = `Both branches of an if expression must return the same type.`;
                break;
            case "pattern_matching":
                message = `Pattern matching type mismatch`;
                suggestion = `The pattern doesn't match the expected type. Check the pattern structure.`;
                break;
            case "concrete_vs_variable":
                message = `Concrete type vs type variable conflict`;
                suggestion = `Trying to unify a concrete type with a type variable that's already constrained. This often happens with ADT constructors - check if you're using concrete types where type variables are expected.`;
                break;
        }
    }
    if (context.operation) {
        message += ` in ${context.operation}`;
    }
    if (context.hint) {
        suggestion = context.hint;
    }
    return createTypeError(message, {
        expectedType: type1,
        actualType: type2,
        suggestion,
    }, location);
}
// Helper function to convert types to strings (simplified version)
function typeToString(type) {
    switch (type.kind) {
        case "primitive":
            return type.name;
        case "variable":
            return type.name;
        case "function":
            const paramStr = type.params.map(typeToString).join(" ");
            const effectStr = (0, helpers_1.formatEffectsString)(type.effects);
            return `(${paramStr}) -> ${typeToString(type.return)}${effectStr}`;
        case "list":
            return `List ${typeToString(type.element)}`;
        case "tuple":
            return `(${type.elements.map(typeToString).join(" ")})`;
        case "record":
            return `{ ${Object.entries(type.fields)
                .map(([name, fieldType]) => `${name}: ${typeToString(fieldType)}`)
                .join(" ")} }`;
        case "variant":
            if (type.args.length === 0) {
                return type.name;
            }
            else {
                return `${type.name} ${type.args.map(typeToString).join(" ")}`;
            }
        case "unit":
            return "unit";
        case "unknown":
            return "?";
        default:
            return "unknown";
    }
}
// Enhanced error formatting for better readability
function formatTypeError(error) {
    let result = `\n${error.type}: ${error.message}`;
    if (error.location) {
        result += `\n  at line ${error.location.line}, column ${error.location.column}`;
    }
    if (error.context) {
        result += `\n\nCode:\n  ${error.context}`;
    }
    if (error.suggestion) {
        result += `\n\nðŸ’¡ ${error.suggestion}`;
    }
    return result;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFNBQVMsQ0FBQztJQUNuQixDQUFDO0FBQ0YsQ0FBQztBQUVELG1EQUFtRDtBQUNuRCxTQUFnQixlQUFlLENBQUMsS0FBbUI7SUFDbEQsSUFBSSxNQUFNLEdBQUcsS0FBSyxLQUFLLENBQUMsSUFBSSxLQUFLLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUVqRCxJQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNwQixNQUFNLElBQUksZUFBZSxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksWUFBWSxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ2pGLENBQUM7SUFFRCxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNuQixNQUFNLElBQUksZ0JBQWdCLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUMzQyxDQUFDO0lBRUQsSUFBSSxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDdEIsTUFBTSxJQUFJLFVBQVUsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ3hDLENBQUM7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNmLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL3dvcmtzcGFjZS9zcmMvdHlwZXIvdHlwZS1lcnJvcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBFeHByZXNzaW9uLCBUeXBlIH0gZnJvbSBcIi4uL2FzdFwiO1xuaW1wb3J0IHsgY3JlYXRlRXJyb3IsIHR5cGUgTm9vbGFuZ0Vycm9yLCB0eXBlIEVycm9yTG9jYXRpb24gfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBmb3JtYXRFZmZlY3RzU3RyaW5nIH0gZnJvbSBcIi4vaGVscGVyc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVFcnJvckNvbnRleHQge1xuXHRleHByZXNzaW9uPzogRXhwcmVzc2lvbjtcblx0ZXhwZWN0ZWRUeXBlPzogVHlwZTtcblx0YWN0dWFsVHlwZT86IFR5cGU7XG5cdGZ1bmN0aW9uTmFtZT86IHN0cmluZztcblx0cGFyYW1ldGVySW5kZXg/OiBudW1iZXI7XG5cdG9wZXJhdG9yPzogc3RyaW5nO1xuXHR2YXJpYWJsZU5hbWU/OiBzdHJpbmc7XG5cdHN1Z2dlc3Rpb24/OiBzdHJpbmc7XG5cdGNvZGVTbmlwcGV0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVHlwZUVycm9yKFxuXHRtZXNzYWdlOiBzdHJpbmcsXG5cdGNvbnRleHQ/OiBUeXBlRXJyb3JDb250ZXh0LFxuXHRsb2NhdGlvbj86IEVycm9yTG9jYXRpb24sXG4pOiBOb29sYW5nRXJyb3Ige1xuXHRsZXQgZW5oYW5jZWRNZXNzYWdlID0gbWVzc2FnZTtcblx0bGV0IHN1Z2dlc3Rpb24gPSBjb250ZXh0Py5zdWdnZXN0aW9uO1xuXG5cdC8vIEVuaGFuY2UgbWVzc2FnZSBiYXNlZCBvbiBjb250ZXh0XG5cdGlmIChjb250ZXh0Py5leHBlY3RlZFR5cGUgJiYgY29udGV4dD8uYWN0dWFsVHlwZSkge1xuXHRcdGVuaGFuY2VkTWVzc2FnZSArPSBgXFxuICBFeHBlY3RlZDogJHt0eXBlVG9TdHJpbmcoY29udGV4dC5leHBlY3RlZFR5cGUpfWA7XG5cdFx0ZW5oYW5jZWRNZXNzYWdlICs9IGBcXG4gIEdvdDogICAgICAke3R5cGVUb1N0cmluZyhjb250ZXh0LmFjdHVhbFR5cGUpfWA7XG5cdH1cblxuXHQvLyBBZGQgZnVuY3Rpb24tc3BlY2lmaWMgY29udGV4dFxuXHRpZiAoY29udGV4dD8uZnVuY3Rpb25OYW1lKSB7XG5cdFx0ZW5oYW5jZWRNZXNzYWdlICs9IGBcXG4gIEZ1bmN0aW9uOiAke2NvbnRleHQuZnVuY3Rpb25OYW1lfWA7XG5cdH1cblxuXHQvLyBBZGQgcGFyYW1ldGVyLXNwZWNpZmljIGNvbnRleHRcblx0aWYgKGNvbnRleHQ/LnBhcmFtZXRlckluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRlbmhhbmNlZE1lc3NhZ2UgKz0gYFxcbiAgUGFyYW1ldGVyICR7Y29udGV4dC5wYXJhbWV0ZXJJbmRleCArIDF9YDtcblx0fVxuXG5cdC8vIEFkZCBvcGVyYXRvciBjb250ZXh0XG5cdGlmIChjb250ZXh0Py5vcGVyYXRvcikge1xuXHRcdGVuaGFuY2VkTWVzc2FnZSArPSBgXFxuICBPcGVyYXRvcjogJHtjb250ZXh0Lm9wZXJhdG9yfWA7XG5cdH1cblxuXHQvLyBBZGQgdmFyaWFibGUgY29udGV4dFxuXHRpZiAoY29udGV4dD8udmFyaWFibGVOYW1lKSB7XG5cdFx0ZW5oYW5jZWRNZXNzYWdlICs9IGBcXG4gIFZhcmlhYmxlOiAke2NvbnRleHQudmFyaWFibGVOYW1lfWA7XG5cdH1cblxuXHQvLyBHZW5lcmF0ZSBzdWdnZXN0aW9ucyBpZiBub3QgcHJvdmlkZWRcblx0aWYgKCFzdWdnZXN0aW9uKSB7XG5cdFx0c3VnZ2VzdGlvbiA9IGdlbmVyYXRlU3VnZ2VzdGlvbihjb250ZXh0KTtcblx0fVxuXG5cdHJldHVybiBjcmVhdGVFcnJvcihcblx0XHRcIlR5cGVFcnJvclwiLFxuXHRcdGVuaGFuY2VkTWVzc2FnZSxcblx0XHRsb2NhdGlvbixcblx0XHRjb250ZXh0Py5jb2RlU25pcHBldCxcblx0XHRzdWdnZXN0aW9uLFxuXHQpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVN1Z2dlc3Rpb24oY29udGV4dD86IFR5cGVFcnJvckNvbnRleHQpOiBzdHJpbmcge1xuXHRpZiAoIWNvbnRleHQpIHJldHVybiBcIlwiO1xuXG5cdC8vIEZ1bmN0aW9uIGFwcGxpY2F0aW9uIGVycm9yc1xuXHRpZiAoY29udGV4dC5mdW5jdGlvbk5hbWUgJiYgY29udGV4dC5leHBlY3RlZFR5cGUgJiYgY29udGV4dC5hY3R1YWxUeXBlKSB7XG5cdFx0aWYgKGNvbnRleHQucGFyYW1ldGVySW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGBDaGVjayB0aGF0IGFyZ3VtZW50ICR7Y29udGV4dC5wYXJhbWV0ZXJJbmRleCArIDF9IG1hdGNoZXMgdGhlIGV4cGVjdGVkIHR5cGUuIENvbnNpZGVyIGFkZGluZyBhIHR5cGUgYW5ub3RhdGlvbiBvciB1c2luZyBhIGRpZmZlcmVudCB2YWx1ZS5gO1xuXHRcdH1cblx0XHRyZXR1cm4gYENoZWNrIHRoYXQgYWxsIGFyZ3VtZW50cyBtYXRjaCB0aGUgZnVuY3Rpb24ncyBleHBlY3RlZCBwYXJhbWV0ZXIgdHlwZXMuYDtcblx0fVxuXG5cdC8vIFZhcmlhYmxlIGVycm9yc1xuXHRpZiAoY29udGV4dC52YXJpYWJsZU5hbWUpIHtcblx0XHRyZXR1cm4gYE1ha2Ugc3VyZSAnJHtjb250ZXh0LnZhcmlhYmxlTmFtZX0nIGlzIGRlZmluZWQgYmVmb3JlIHVzZS4gQ2hlY2sgZm9yIHR5cG9zIG9yIG1pc3NpbmcgZGVmaW5pdGlvbnMuYDtcblx0fVxuXG5cdC8vIE9wZXJhdG9yIGVycm9yc1xuXHRpZiAoY29udGV4dC5vcGVyYXRvcikge1xuXHRcdHJldHVybiBgVGhlICR7Y29udGV4dC5vcGVyYXRvcn0gb3BlcmF0b3IgZXhwZWN0cyBzcGVjaWZpYyB0eXBlcy4gQ2hlY2sgdGhhdCBib3RoIG9wZXJhbmRzIGFyZSBjb21wYXRpYmxlLmA7XG5cdH1cblxuXHQvLyBHZW5lcmFsIHR5cGUgbWlzbWF0Y2hcblx0aWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuYWN0dWFsVHlwZSkge1xuXHRcdHJldHVybiBgQ29uc2lkZXIgYWRkaW5nIGEgdHlwZSBhbm5vdGF0aW9uIG9yIHVzaW5nIGEgdmFsdWUgb2YgdGhlIGV4cGVjdGVkIHR5cGUuYDtcblx0fVxuXG5cdHJldHVybiBcIlJldmlldyB0aGUgZXhwcmVzc2lvbiBhbmQgZW5zdXJlIGFsbCB0eXBlcyBhcmUgY29tcGF0aWJsZS5cIjtcbn1cblxuLy8gRW5oYW5jZWQgZXJyb3IgbWVzc2FnZXMgZm9yIGNvbW1vbiB0eXBlIGVycm9yc1xuZXhwb3J0IGZ1bmN0aW9uIGZ1bmN0aW9uQXBwbGljYXRpb25FcnJvcihcblx0ZnVuY1R5cGU6IFR5cGUsXG5cdGFyZ1R5cGU6IFR5cGUsXG5cdHBhcmFtZXRlckluZGV4OiBudW1iZXIsXG5cdGZ1bmN0aW9uTmFtZT86IHN0cmluZyxcblx0bG9jYXRpb24/OiBFcnJvckxvY2F0aW9uLFxuKTogTm9vbGFuZ0Vycm9yIHtcblx0Y29uc3QgbWVzc2FnZSA9IGBUeXBlIG1pc21hdGNoIGluIGZ1bmN0aW9uIGFwcGxpY2F0aW9uYDtcblx0cmV0dXJuIGNyZWF0ZVR5cGVFcnJvcihcblx0XHRtZXNzYWdlLFxuXHRcdHtcblx0XHRcdGV4cGVjdGVkVHlwZTogZnVuY1R5cGUsXG5cdFx0XHRhY3R1YWxUeXBlOiBhcmdUeXBlLFxuXHRcdFx0ZnVuY3Rpb25OYW1lLFxuXHRcdFx0cGFyYW1ldGVySW5kZXgsXG5cdFx0XHRzdWdnZXN0aW9uOiBgQXJndW1lbnQgJHtwYXJhbWV0ZXJJbmRleCArIDF9IGhhcyB0eXBlICR7dHlwZVRvU3RyaW5nKGFyZ1R5cGUpfSBidXQgdGhlIGZ1bmN0aW9uIGV4cGVjdHMgJHt0eXBlVG9TdHJpbmcoZnVuY1R5cGUpfS4gQ29uc2lkZXIgdXNpbmcgYSBkaWZmZXJlbnQgdmFsdWUgb3IgYWRkaW5nIGEgdHlwZSBjb252ZXJzaW9uLmAsXG5cdFx0fSxcblx0XHRsb2NhdGlvbixcblx0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuZGVmaW5lZFZhcmlhYmxlRXJyb3IoXG5cdHZhcmlhYmxlTmFtZTogc3RyaW5nLFxuXHRsb2NhdGlvbj86IEVycm9yTG9jYXRpb24sXG4pOiBOb29sYW5nRXJyb3Ige1xuXHRjb25zdCBtZXNzYWdlID0gYFVuZGVmaW5lZCB2YXJpYWJsZWA7XG5cdHJldHVybiBjcmVhdGVUeXBlRXJyb3IoXG5cdFx0bWVzc2FnZSxcblx0XHR7XG5cdFx0XHR2YXJpYWJsZU5hbWUsXG5cdFx0XHRzdWdnZXN0aW9uOiBgRGVmaW5lICcke3ZhcmlhYmxlTmFtZX0nIGJlZm9yZSB1c2luZyBpdDogJHt2YXJpYWJsZU5hbWV9ID0gdmFsdWVgLFxuXHRcdH0sXG5cdFx0bG9jYXRpb24sXG5cdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub25GdW5jdGlvbkFwcGxpY2F0aW9uRXJyb3IoXG5cdHR5cGU6IFR5cGUsXG5cdGxvY2F0aW9uPzogRXJyb3JMb2NhdGlvbixcbik6IE5vb2xhbmdFcnJvciB7XG5cdGNvbnN0IG1lc3NhZ2UgPSBgQ2Fubm90IGFwcGx5IG5vbi1mdW5jdGlvbiB0eXBlYDtcblx0cmV0dXJuIGNyZWF0ZVR5cGVFcnJvcihcblx0XHRtZXNzYWdlLFxuXHRcdHtcblx0XHRcdGFjdHVhbFR5cGU6IHR5cGUsXG5cdFx0XHRzdWdnZXN0aW9uOiBgT25seSBmdW5jdGlvbnMgY2FuIGJlIGFwcGxpZWQgdG8gYXJndW1lbnRzLiBNYWtlIHN1cmUgeW91J3JlIGNhbGxpbmcgYSBmdW5jdGlvbiwgbm90IGEgdmFsdWUuYCxcblx0XHR9LFxuXHRcdGxvY2F0aW9uLFxuXHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3BlcmF0b3JUeXBlRXJyb3IoXG5cdG9wZXJhdG9yOiBzdHJpbmcsXG5cdGV4cGVjdGVkVHlwZTogVHlwZSxcblx0YWN0dWFsVHlwZTogVHlwZSxcblx0bG9jYXRpb24/OiBFcnJvckxvY2F0aW9uLFxuKTogTm9vbGFuZ0Vycm9yIHtcblx0Y29uc3QgbWVzc2FnZSA9IGBPcGVyYXRvciB0eXBlIG1pc21hdGNoYDtcblx0cmV0dXJuIGNyZWF0ZVR5cGVFcnJvcihcblx0XHRtZXNzYWdlLFxuXHRcdHtcblx0XHRcdG9wZXJhdG9yLFxuXHRcdFx0ZXhwZWN0ZWRUeXBlLFxuXHRcdFx0YWN0dWFsVHlwZSxcblx0XHRcdHN1Z2dlc3Rpb246IGBUaGUgJHtvcGVyYXRvcn0gb3BlcmF0b3IgZXhwZWN0cyAke3R5cGVUb1N0cmluZyhleHBlY3RlZFR5cGUpfSBidXQgZ290ICR7dHlwZVRvU3RyaW5nKGFjdHVhbFR5cGUpfS4gQ2hlY2sgeW91ciBvcGVyYW5kIHR5cGVzLmAsXG5cdFx0fSxcblx0XHRsb2NhdGlvbixcblx0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmRpdGlvblR5cGVFcnJvcihcblx0YWN0dWFsVHlwZTogVHlwZSxcblx0bG9jYXRpb24/OiBFcnJvckxvY2F0aW9uLFxuKTogTm9vbGFuZ0Vycm9yIHtcblx0Y29uc3QgbWVzc2FnZSA9IGBDb25kaXRpb24gbXVzdCBiZSBib29sZWFuYDtcblx0cmV0dXJuIGNyZWF0ZVR5cGVFcnJvcihcblx0XHRtZXNzYWdlLFxuXHRcdHtcblx0XHRcdGFjdHVhbFR5cGUsXG5cdFx0XHRzdWdnZXN0aW9uOiBgVXNlIGEgYm9vbGVhbiBleHByZXNzaW9uIChUcnVlL0ZhbHNlKSBvciBhIGNvbXBhcmlzb24gdGhhdCByZXR1cm5zIGEgYm9vbGVhbi5gLFxuXHRcdH0sXG5cdFx0bG9jYXRpb24sXG5cdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpZkJyYW5jaFR5cGVFcnJvcihcblx0dGhlblR5cGU6IFR5cGUsXG5cdGVsc2VUeXBlOiBUeXBlLFxuXHRsb2NhdGlvbj86IEVycm9yTG9jYXRpb24sXG4pOiBOb29sYW5nRXJyb3Ige1xuXHRjb25zdCBtZXNzYWdlID0gYElmIGJyYW5jaGVzIG11c3QgaGF2ZSB0aGUgc2FtZSB0eXBlYDtcblx0cmV0dXJuIGNyZWF0ZVR5cGVFcnJvcihcblx0XHRtZXNzYWdlLFxuXHRcdHtcblx0XHRcdGV4cGVjdGVkVHlwZTogdGhlblR5cGUsXG5cdFx0XHRhY3R1YWxUeXBlOiBlbHNlVHlwZSxcblx0XHRcdHN1Z2dlc3Rpb246IGBCb3RoIGJyYW5jaGVzIG9mIGFuIGlmIGV4cHJlc3Npb24gbXVzdCByZXR1cm4gdGhlIHNhbWUgdHlwZS4gQ29uc2lkZXIgYWRkaW5nIHR5cGUgYW5ub3RhdGlvbnMgb3IgdXNpbmcgY29tcGF0aWJsZSBleHByZXNzaW9ucy5gLFxuXHRcdH0sXG5cdFx0bG9jYXRpb24sXG5cdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlQW5ub3RhdGlvbkVycm9yKFxuXHRleHBlY3RlZFR5cGU6IFR5cGUsXG5cdGluZmVycmVkVHlwZTogVHlwZSxcblx0bG9jYXRpb24/OiBFcnJvckxvY2F0aW9uLFxuKTogTm9vbGFuZ0Vycm9yIHtcblx0Y29uc3QgbWVzc2FnZSA9IGBUeXBlIGFubm90YXRpb24gbWlzbWF0Y2hgO1xuXHRyZXR1cm4gY3JlYXRlVHlwZUVycm9yKFxuXHRcdG1lc3NhZ2UsXG5cdFx0e1xuXHRcdFx0ZXhwZWN0ZWRUeXBlLFxuXHRcdFx0YWN0dWFsVHlwZTogaW5mZXJyZWRUeXBlLFxuXHRcdFx0c3VnZ2VzdGlvbjogYFRoZSBleHBsaWNpdCB0eXBlIGFubm90YXRpb24gZG9lc24ndCBtYXRjaCB0aGUgaW5mZXJyZWQgdHlwZS4gRWl0aGVyIGFkanVzdCB0aGUgYW5ub3RhdGlvbiBvciBtb2RpZnkgdGhlIGV4cHJlc3Npb24uYCxcblx0XHR9LFxuXHRcdGxvY2F0aW9uLFxuXHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdEVsZW1lbnRUeXBlRXJyb3IoXG5cdGV4cGVjdGVkVHlwZTogVHlwZSxcblx0YWN0dWFsVHlwZTogVHlwZSxcblx0bG9jYXRpb24/OiBFcnJvckxvY2F0aW9uLFxuKTogTm9vbGFuZ0Vycm9yIHtcblx0Y29uc3QgbWVzc2FnZSA9IGBMaXN0IGVsZW1lbnRzIG11c3QgaGF2ZSB0aGUgc2FtZSB0eXBlYDtcblx0cmV0dXJuIGNyZWF0ZVR5cGVFcnJvcihcblx0XHRtZXNzYWdlLFxuXHRcdHtcblx0XHRcdGV4cGVjdGVkVHlwZSxcblx0XHRcdGFjdHVhbFR5cGUsXG5cdFx0XHRzdWdnZXN0aW9uOiBgQWxsIGVsZW1lbnRzIGluIGEgbGlzdCBtdXN0IGhhdmUgdGhlIHNhbWUgdHlwZS4gQ29uc2lkZXIgdXNpbmcgYSB0dXBsZSBmb3IgbWl4ZWQgdHlwZXMgb3IgZW5zdXJpbmcgYWxsIGVsZW1lbnRzIGFyZSBjb21wYXRpYmxlLmAsXG5cdFx0fSxcblx0XHRsb2NhdGlvbixcblx0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBpcGVsaW5lQ29tcG9zaXRpb25FcnJvcihcblx0b3V0cHV0VHlwZTogVHlwZSxcblx0aW5wdXRUeXBlOiBUeXBlLFxuXHRsb2NhdGlvbj86IEVycm9yTG9jYXRpb24sXG4pOiBOb29sYW5nRXJyb3Ige1xuXHRjb25zdCBtZXNzYWdlID0gYFBpcGVsaW5lIGNvbXBvc2l0aW9uIHR5cGUgbWlzbWF0Y2hgO1xuXHRyZXR1cm4gY3JlYXRlVHlwZUVycm9yKFxuXHRcdG1lc3NhZ2UsXG5cdFx0e1xuXHRcdFx0ZXhwZWN0ZWRUeXBlOiBpbnB1dFR5cGUsXG5cdFx0XHRhY3R1YWxUeXBlOiBvdXRwdXRUeXBlLFxuXHRcdFx0c3VnZ2VzdGlvbjogYFRoZSBvdXRwdXQgdHlwZSBvZiB0aGUgZmlyc3QgZnVuY3Rpb24gbXVzdCBtYXRjaCB0aGUgaW5wdXQgdHlwZSBvZiB0aGUgc2Vjb25kIGZ1bmN0aW9uIGluIGEgcGlwZWxpbmUuYCxcblx0XHR9LFxuXHRcdGxvY2F0aW9uLFxuXHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbXV0YXRpb25UeXBlRXJyb3IoXG5cdHRhcmdldFR5cGU6IFR5cGUsXG5cdHZhbHVlVHlwZTogVHlwZSxcblx0dmFyaWFibGVOYW1lOiBzdHJpbmcsXG5cdGxvY2F0aW9uPzogRXJyb3JMb2NhdGlvbixcbik6IE5vb2xhbmdFcnJvciB7XG5cdGNvbnN0IG1lc3NhZ2UgPSBgVHlwZSBtaXNtYXRjaCBpbiBtdXRhdGlvbmA7XG5cdHJldHVybiBjcmVhdGVUeXBlRXJyb3IoXG5cdFx0bWVzc2FnZSxcblx0XHR7XG5cdFx0XHRleHBlY3RlZFR5cGU6IHRhcmdldFR5cGUsXG5cdFx0XHRhY3R1YWxUeXBlOiB2YWx1ZVR5cGUsXG5cdFx0XHR2YXJpYWJsZU5hbWUsXG5cdFx0XHRzdWdnZXN0aW9uOiBgVGhlIG5ldyB2YWx1ZSBtdXN0IGhhdmUgdGhlIHNhbWUgdHlwZSBhcyB0aGUgbXV0YWJsZSB2YXJpYWJsZSAnJHt2YXJpYWJsZU5hbWV9Jy5gLFxuXHRcdH0sXG5cdFx0bG9jYXRpb24sXG5cdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmlmaWNhdGlvbkVycm9yKFxuXHR0eXBlMTogVHlwZSxcblx0dHlwZTI6IFR5cGUsXG5cdGNvbnRleHQ6IHtcblx0XHRyZWFzb24/OiBzdHJpbmc7XG5cdFx0b3BlcmF0aW9uPzogc3RyaW5nO1xuXHRcdGV4cHJlc3Npb24/OiBFeHByZXNzaW9uO1xuXHRcdGhpbnQ/OiBzdHJpbmc7XG5cdH0sXG5cdGxvY2F0aW9uPzogRXJyb3JMb2NhdGlvbixcbik6IE5vb2xhbmdFcnJvciB7XG5cdGxldCBtZXNzYWdlID0gYENhbm5vdCB1bmlmeSB0eXBlc2A7XG5cdGxldCBzdWdnZXN0aW9uID0gYFJldmlldyB0aGUgZXhwcmVzc2lvbiBhbmQgZW5zdXJlIGFsbCB0eXBlcyBhcmUgY29tcGF0aWJsZS5gO1xuXG5cdC8vIEFkZCBzcGVjaWZpYyBjb250ZXh0IGJhc2VkIG9uIHRoZSByZWFzb25cblx0aWYgKGNvbnRleHQucmVhc29uKSB7XG5cdFx0c3dpdGNoIChjb250ZXh0LnJlYXNvbikge1xuXHRcdFx0Y2FzZSBcImNvbnN0cnVjdG9yX2FwcGxpY2F0aW9uXCI6XG5cdFx0XHRcdG1lc3NhZ2UgPSBgQ29uc3RydWN0b3IgdHlwZSBtaXNtYXRjaGA7XG5cdFx0XHRcdHN1Z2dlc3Rpb24gPSBgVGhpcyBjb25zdHJ1Y3RvciBleHBlY3RzIGRpZmZlcmVudCBhcmd1bWVudCB0eXBlcy4gQ2hlY2sgdGhlIEFEVCBkZWZpbml0aW9uLmA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImZ1bmN0aW9uX2FwcGxpY2F0aW9uXCI6XG5cdFx0XHRcdG1lc3NhZ2UgPSBgRnVuY3Rpb24gYXBwbGljYXRpb24gdHlwZSBtaXNtYXRjaGA7XG5cdFx0XHRcdHN1Z2dlc3Rpb24gPSBgVGhlIGZ1bmN0aW9uIHBhcmFtZXRlcnMgZG9uJ3QgbWF0Y2ggdGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5gO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJvcGVyYXRvcl9hcHBsaWNhdGlvblwiOlxuXHRcdFx0XHRtZXNzYWdlID0gYE9wZXJhdG9yIHR5cGUgbWlzbWF0Y2hgO1xuXHRcdFx0XHRzdWdnZXN0aW9uID0gYFRoZSBvcGVyYXRvciBleHBlY3RzIHNwZWNpZmljIHR5cGVzLiBDaGVjayB0aGF0IGJvdGggb3BlcmFuZHMgYXJlIGNvbXBhdGlibGUuYDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiaWZfYnJhbmNoZXNcIjpcblx0XHRcdFx0bWVzc2FnZSA9IGBJZiBicmFuY2ggdHlwZSBtaXNtYXRjaGA7XG5cdFx0XHRcdHN1Z2dlc3Rpb24gPSBgQm90aCBicmFuY2hlcyBvZiBhbiBpZiBleHByZXNzaW9uIG11c3QgcmV0dXJuIHRoZSBzYW1lIHR5cGUuYDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwicGF0dGVybl9tYXRjaGluZ1wiOlxuXHRcdFx0XHRtZXNzYWdlID0gYFBhdHRlcm4gbWF0Y2hpbmcgdHlwZSBtaXNtYXRjaGA7XG5cdFx0XHRcdHN1Z2dlc3Rpb24gPSBgVGhlIHBhdHRlcm4gZG9lc24ndCBtYXRjaCB0aGUgZXhwZWN0ZWQgdHlwZS4gQ2hlY2sgdGhlIHBhdHRlcm4gc3RydWN0dXJlLmA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImNvbmNyZXRlX3ZzX3ZhcmlhYmxlXCI6XG5cdFx0XHRcdG1lc3NhZ2UgPSBgQ29uY3JldGUgdHlwZSB2cyB0eXBlIHZhcmlhYmxlIGNvbmZsaWN0YDtcblx0XHRcdFx0c3VnZ2VzdGlvbiA9IGBUcnlpbmcgdG8gdW5pZnkgYSBjb25jcmV0ZSB0eXBlIHdpdGggYSB0eXBlIHZhcmlhYmxlIHRoYXQncyBhbHJlYWR5IGNvbnN0cmFpbmVkLiBUaGlzIG9mdGVuIGhhcHBlbnMgd2l0aCBBRFQgY29uc3RydWN0b3JzIC0gY2hlY2sgaWYgeW91J3JlIHVzaW5nIGNvbmNyZXRlIHR5cGVzIHdoZXJlIHR5cGUgdmFyaWFibGVzIGFyZSBleHBlY3RlZC5gO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHRpZiAoY29udGV4dC5vcGVyYXRpb24pIHtcblx0XHRtZXNzYWdlICs9IGAgaW4gJHtjb250ZXh0Lm9wZXJhdGlvbn1gO1xuXHR9XG5cblx0aWYgKGNvbnRleHQuaGludCkge1xuXHRcdHN1Z2dlc3Rpb24gPSBjb250ZXh0LmhpbnQ7XG5cdH1cblxuXHRyZXR1cm4gY3JlYXRlVHlwZUVycm9yKFxuXHRcdG1lc3NhZ2UsXG5cdFx0e1xuXHRcdFx0ZXhwZWN0ZWRUeXBlOiB0eXBlMSxcblx0XHRcdGFjdHVhbFR5cGU6IHR5cGUyLFxuXHRcdFx0c3VnZ2VzdGlvbixcblx0XHR9LFxuXHRcdGxvY2F0aW9uLFxuXHQpO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCB0eXBlcyB0byBzdHJpbmdzIChzaW1wbGlmaWVkIHZlcnNpb24pXG5mdW5jdGlvbiB0eXBlVG9TdHJpbmcodHlwZTogVHlwZSk6IHN0cmluZyB7XG5cdHN3aXRjaCAodHlwZS5raW5kKSB7XG5cdFx0Y2FzZSBcInByaW1pdGl2ZVwiOlxuXHRcdFx0cmV0dXJuIHR5cGUubmFtZTtcblx0XHRjYXNlIFwidmFyaWFibGVcIjpcblx0XHRcdHJldHVybiB0eXBlLm5hbWU7XG5cdFx0Y2FzZSBcImZ1bmN0aW9uXCI6XG5cdFx0XHRjb25zdCBwYXJhbVN0ciA9IHR5cGUucGFyYW1zLm1hcCh0eXBlVG9TdHJpbmcpLmpvaW4oXCIgXCIpO1xuXHRcdFx0Y29uc3QgZWZmZWN0U3RyID1cblx0XHRcdFx0Zm9ybWF0RWZmZWN0c1N0cmluZyh0eXBlLmVmZmVjdHMpO1xuXHRcdFx0cmV0dXJuIGAoJHtwYXJhbVN0cn0pIC0+ICR7dHlwZVRvU3RyaW5nKHR5cGUucmV0dXJuKX0ke2VmZmVjdFN0cn1gO1xuXHRcdGNhc2UgXCJsaXN0XCI6XG5cdFx0XHRyZXR1cm4gYExpc3QgJHt0eXBlVG9TdHJpbmcodHlwZS5lbGVtZW50KX1gO1xuXHRcdGNhc2UgXCJ0dXBsZVwiOlxuXHRcdFx0cmV0dXJuIGAoJHt0eXBlLmVsZW1lbnRzLm1hcCh0eXBlVG9TdHJpbmcpLmpvaW4oXCIgXCIpfSlgO1xuXHRcdGNhc2UgXCJyZWNvcmRcIjpcblx0XHRcdHJldHVybiBgeyAke09iamVjdC5lbnRyaWVzKHR5cGUuZmllbGRzKVxuXHRcdFx0XHQubWFwKChbbmFtZSwgZmllbGRUeXBlXSkgPT4gYCR7bmFtZX06ICR7dHlwZVRvU3RyaW5nKGZpZWxkVHlwZSl9YClcblx0XHRcdFx0LmpvaW4oXCIgXCIpfSB9YDtcblx0XHRjYXNlIFwidmFyaWFudFwiOlxuXHRcdFx0aWYgKHR5cGUuYXJncy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIHR5cGUubmFtZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBgJHt0eXBlLm5hbWV9ICR7dHlwZS5hcmdzLm1hcCh0eXBlVG9TdHJpbmcpLmpvaW4oXCIgXCIpfWA7XG5cdFx0XHR9XG5cdFx0Y2FzZSBcInVuaXRcIjpcblx0XHRcdHJldHVybiBcInVuaXRcIjtcblx0XHRjYXNlIFwidW5rbm93blwiOlxuXHRcdFx0cmV0dXJuIFwiP1wiO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gXCJ1bmtub3duXCI7XG5cdH1cbn1cblxuLy8gRW5oYW5jZWQgZXJyb3IgZm9ybWF0dGluZyBmb3IgYmV0dGVyIHJlYWRhYmlsaXR5XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VHlwZUVycm9yKGVycm9yOiBOb29sYW5nRXJyb3IpOiBzdHJpbmcge1xuXHRsZXQgcmVzdWx0ID0gYFxcbiR7ZXJyb3IudHlwZX06ICR7ZXJyb3IubWVzc2FnZX1gO1xuXG5cdGlmIChlcnJvci5sb2NhdGlvbikge1xuXHRcdHJlc3VsdCArPSBgXFxuICBhdCBsaW5lICR7ZXJyb3IubG9jYXRpb24ubGluZX0sIGNvbHVtbiAke2Vycm9yLmxvY2F0aW9uLmNvbHVtbn1gO1xuXHR9XG5cblx0aWYgKGVycm9yLmNvbnRleHQpIHtcblx0XHRyZXN1bHQgKz0gYFxcblxcbkNvZGU6XFxuICAke2Vycm9yLmNvbnRleHR9YDtcblx0fVxuXG5cdGlmIChlcnJvci5zdWdnZXN0aW9uKSB7XG5cdFx0cmVzdWx0ICs9IGBcXG5cXG7wn5KhICR7ZXJyb3Iuc3VnZ2VzdGlvbn1gO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cbiJdLCJ2ZXJzaW9uIjozfQ==