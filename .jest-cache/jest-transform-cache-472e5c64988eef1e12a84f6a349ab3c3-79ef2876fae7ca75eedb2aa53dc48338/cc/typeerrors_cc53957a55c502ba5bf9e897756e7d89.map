{"file":"/workspace/src/typer/type-errors.ts","mappings":"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","names":[],"sources":["/workspace/src/typer/type-errors.ts"],"sourcesContent":["import type { Expression, Type } from \"../ast\";\nimport { createError, type NoolangError, type ErrorLocation } from \"../errors\";\nimport { formatEffectsString } from \"./helpers\";\n\nexport interface TypeErrorContext {\n\texpression?: Expression;\n\texpectedType?: Type;\n\tactualType?: Type;\n\tfunctionName?: string;\n\tparameterIndex?: number;\n\toperator?: string;\n\tvariableName?: string;\n\tsuggestion?: string;\n\tcodeSnippet?: string;\n}\n\nexport function createTypeError(\n\tmessage: string,\n\tcontext?: TypeErrorContext,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tlet enhancedMessage = message;\n\tlet suggestion = context?.suggestion;\n\n\t// Enhance message based on context\n\tif (context?.expectedType && context?.actualType) {\n\t\tenhancedMessage += `\\n  Expected: ${typeToString(context.expectedType)}`;\n\t\tenhancedMessage += `\\n  Got:      ${typeToString(context.actualType)}`;\n\t}\n\n\t// Add function-specific context\n\tif (context?.functionName) {\n\t\tenhancedMessage += `\\n  Function: ${context.functionName}`;\n\t}\n\n\t// Add parameter-specific context\n\tif (context?.parameterIndex !== undefined) {\n\t\tenhancedMessage += `\\n  Parameter ${context.parameterIndex + 1}`;\n\t}\n\n\t// Add operator context\n\tif (context?.operator) {\n\t\tenhancedMessage += `\\n  Operator: ${context.operator}`;\n\t}\n\n\t// Add variable context\n\tif (context?.variableName) {\n\t\tenhancedMessage += `\\n  Variable: ${context.variableName}`;\n\t}\n\n\t// Generate suggestions if not provided\n\tif (!suggestion) {\n\t\tsuggestion = generateSuggestion(context);\n\t}\n\n\treturn createError(\n\t\t\"TypeError\",\n\t\tenhancedMessage,\n\t\tlocation,\n\t\tcontext?.codeSnippet,\n\t\tsuggestion,\n\t);\n}\n\nfunction generateSuggestion(context?: TypeErrorContext): string {\n\tif (!context) return \"\";\n\n\t// Function application errors\n\tif (context.functionName && context.expectedType && context.actualType) {\n\t\tif (context.parameterIndex !== undefined) {\n\t\t\treturn `Check that argument ${context.parameterIndex + 1} matches the expected type. Consider adding a type annotation or using a different value.`;\n\t\t}\n\t\treturn `Check that all arguments match the function's expected parameter types.`;\n\t}\n\n\t// Variable errors\n\tif (context.variableName) {\n\t\treturn `Make sure '${context.variableName}' is defined before use. Check for typos or missing definitions.`;\n\t}\n\n\t// Operator errors\n\tif (context.operator) {\n\t\treturn `The ${context.operator} operator expects specific types. Check that both operands are compatible.`;\n\t}\n\n\t// General type mismatch\n\tif (context.expectedType && context.actualType) {\n\t\treturn `Consider adding a type annotation or using a value of the expected type.`;\n\t}\n\n\treturn \"Review the expression and ensure all types are compatible.\";\n}\n\n// Enhanced error messages for common type errors\nexport function functionApplicationError(\n\tfuncType: Type,\n\targType: Type,\n\tparameterIndex: number,\n\tfunctionName?: string,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Type mismatch in function application`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType: funcType,\n\t\t\tactualType: argType,\n\t\t\tfunctionName,\n\t\t\tparameterIndex,\n\t\t\tsuggestion: `Argument ${parameterIndex + 1} has type ${typeToString(argType)} but the function expects ${typeToString(funcType)}. Consider using a different value or adding a type conversion.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function undefinedVariableError(\n\tvariableName: string,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Undefined variable`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\tvariableName,\n\t\t\tsuggestion: `Define '${variableName}' before using it: ${variableName} = value`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function nonFunctionApplicationError(\n\ttype: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Cannot apply non-function type`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\tactualType: type,\n\t\t\tsuggestion: `Only functions can be applied to arguments. Make sure you're calling a function, not a value.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function operatorTypeError(\n\toperator: string,\n\texpectedType: Type,\n\tactualType: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Operator type mismatch`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\toperator,\n\t\t\texpectedType,\n\t\t\tactualType,\n\t\t\tsuggestion: `The ${operator} operator expects ${typeToString(expectedType)} but got ${typeToString(actualType)}. Check your operand types.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function conditionTypeError(\n\tactualType: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Condition must be boolean`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\tactualType,\n\t\t\tsuggestion: `Use a boolean expression (True/False) or a comparison that returns a boolean.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function ifBranchTypeError(\n\tthenType: Type,\n\telseType: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `If branches must have the same type`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType: thenType,\n\t\t\tactualType: elseType,\n\t\t\tsuggestion: `Both branches of an if expression must return the same type. Consider adding type annotations or using compatible expressions.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function typeAnnotationError(\n\texpectedType: Type,\n\tinferredType: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Type annotation mismatch`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType,\n\t\t\tactualType: inferredType,\n\t\t\tsuggestion: `The explicit type annotation doesn't match the inferred type. Either adjust the annotation or modify the expression.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function listElementTypeError(\n\texpectedType: Type,\n\tactualType: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `List elements must have the same type`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType,\n\t\t\tactualType,\n\t\t\tsuggestion: `All elements in a list must have the same type. Consider using a tuple for mixed types or ensuring all elements are compatible.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function pipelineCompositionError(\n\toutputType: Type,\n\tinputType: Type,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Pipeline composition type mismatch`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType: inputType,\n\t\t\tactualType: outputType,\n\t\t\tsuggestion: `The output type of the first function must match the input type of the second function in a pipeline.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function mutationTypeError(\n\ttargetType: Type,\n\tvalueType: Type,\n\tvariableName: string,\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tconst message = `Type mismatch in mutation`;\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType: targetType,\n\t\t\tactualType: valueType,\n\t\t\tvariableName,\n\t\t\tsuggestion: `The new value must have the same type as the mutable variable '${variableName}'.`,\n\t\t},\n\t\tlocation,\n\t);\n}\n\nexport function unificationError(\n\ttype1: Type,\n\ttype2: Type,\n\tcontext: {\n\t\treason?: string;\n\t\toperation?: string;\n\t\texpression?: Expression;\n\t\thint?: string;\n\t},\n\tlocation?: ErrorLocation,\n): NoolangError {\n\tlet message = `Cannot unify types`;\n\tlet suggestion = `Review the expression and ensure all types are compatible.`;\n\n\t// Add specific context based on the reason\n\tif (context.reason) {\n\t\tswitch (context.reason) {\n\t\t\tcase \"constructor_application\":\n\t\t\t\tmessage = `Constructor type mismatch`;\n\t\t\t\tsuggestion = `This constructor expects different argument types. Check the ADT definition.`;\n\t\t\t\tbreak;\n\t\t\tcase \"function_application\":\n\t\t\t\tmessage = `Function application type mismatch`;\n\t\t\t\tsuggestion = `The function parameters don't match the provided arguments.`;\n\t\t\t\tbreak;\n\t\t\tcase \"operator_application\":\n\t\t\t\tmessage = `Operator type mismatch`;\n\t\t\t\tsuggestion = `The operator expects specific types. Check that both operands are compatible.`;\n\t\t\t\tbreak;\n\t\t\tcase \"if_branches\":\n\t\t\t\tmessage = `If branch type mismatch`;\n\t\t\t\tsuggestion = `Both branches of an if expression must return the same type.`;\n\t\t\t\tbreak;\n\t\t\tcase \"pattern_matching\":\n\t\t\t\tmessage = `Pattern matching type mismatch`;\n\t\t\t\tsuggestion = `The pattern doesn't match the expected type. Check the pattern structure.`;\n\t\t\t\tbreak;\n\t\t\tcase \"concrete_vs_variable\":\n\t\t\t\tmessage = `Concrete type vs type variable conflict`;\n\t\t\t\tsuggestion = `Trying to unify a concrete type with a type variable that's already constrained. This often happens with ADT constructors - check if you're using concrete types where type variables are expected.`;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (context.operation) {\n\t\tmessage += ` in ${context.operation}`;\n\t}\n\n\tif (context.hint) {\n\t\tsuggestion = context.hint;\n\t}\n\n\treturn createTypeError(\n\t\tmessage,\n\t\t{\n\t\t\texpectedType: type1,\n\t\t\tactualType: type2,\n\t\t\tsuggestion,\n\t\t},\n\t\tlocation,\n\t);\n}\n\n// Helper function to convert types to strings (simplified version)\nfunction typeToString(type: Type): string {\n\tswitch (type.kind) {\n\t\tcase \"primitive\":\n\t\t\treturn type.name;\n\t\tcase \"variable\":\n\t\t\treturn type.name;\n\t\tcase \"function\":\n\t\t\tconst paramStr = type.params.map(typeToString).join(\" \");\n\t\t\tconst effectStr =\n\t\t\t\tformatEffectsString(type.effects);\n\t\t\treturn `(${paramStr}) -> ${typeToString(type.return)}${effectStr}`;\n\t\tcase \"list\":\n\t\t\treturn `List ${typeToString(type.element)}`;\n\t\tcase \"tuple\":\n\t\t\treturn `(${type.elements.map(typeToString).join(\" \")})`;\n\t\tcase \"record\":\n\t\t\treturn `{ ${Object.entries(type.fields)\n\t\t\t\t.map(([name, fieldType]) => `${name}: ${typeToString(fieldType)}`)\n\t\t\t\t.join(\" \")} }`;\n\t\tcase \"variant\":\n\t\t\tif (type.args.length === 0) {\n\t\t\t\treturn type.name;\n\t\t\t} else {\n\t\t\t\treturn `${type.name} ${type.args.map(typeToString).join(\" \")}`;\n\t\t\t}\n\t\tcase \"unit\":\n\t\t\treturn \"unit\";\n\t\tcase \"unknown\":\n\t\t\treturn \"?\";\n\t\tdefault:\n\t\t\treturn \"unknown\";\n\t}\n}\n\n// Enhanced error formatting for better readability\nexport function formatTypeError(error: NoolangError): string {\n\tlet result = `\\n${error.type}: ${error.message}`;\n\n\tif (error.location) {\n\t\tresult += `\\n  at line ${error.location.line}, column ${error.location.column}`;\n\t}\n\n\tif (error.context) {\n\t\tresult += `\\n\\nCode:\\n  ${error.context}`;\n\t}\n\n\tif (error.suggestion) {\n\t\tresult += `\\n\\nðŸ’¡ ${error.suggestion}`;\n\t}\n\n\treturn result;\n}\n"],"version":3}