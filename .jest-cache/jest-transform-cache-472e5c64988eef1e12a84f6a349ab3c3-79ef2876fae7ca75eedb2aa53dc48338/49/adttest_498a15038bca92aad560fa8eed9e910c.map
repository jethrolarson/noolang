{"file":"/workspace/test/adt.test.ts","mappings":"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","names":[],"sources":["/workspace/test/adt.test.ts"],"sourcesContent":["import { describe, it, expect } from \"@jest/globals\";\nimport { Lexer } from \"../src/lexer\";\nimport { parse } from \"../src/parser/parser\";\nimport { Evaluator } from \"../src/evaluator\";\nimport { typeProgram } from '../src/typer';\nimport { typeToString } from '../src/typer/helpers';\n\n// Helper function to parse and evaluate Noolang code\nconst runNoolang = (source: string) => {\n  const lexer = new Lexer(source);\n  const tokens = lexer.tokenize();\n  const program = parse(tokens);\n\n  // Type check first\n  const typeResult = typeProgram(program);\n\n  // Then evaluate\n  const evaluator = new Evaluator();\n  const evalResult = evaluator.evaluateProgram(program);\n\n  return {\n    typeResult,\n    evalResult,\n    finalType: typeToString(typeResult.type, typeResult.state.substitution),\n    finalValue: evalResult.finalResult,\n  };\n};\n\ndescribe(\"Algebraic Data Types (ADTs)\", () => {\n  describe(\"Built-in Option Type\", () => {\n    it(\"should create Some values\", () => {\n      const result = runNoolang(`\n        x = Some 42;\n        x\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"Some\",\n        args: [{ tag: \"number\", value: 42 }],\n      });\n    });\n\n    it(\"should create None values\", () => {\n      const result = runNoolang(`\n        x = None;\n        x\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"None\",\n        args: [],\n      });\n    });\n\n    it(\"should pattern match on Some\", () => {\n      const result = runNoolang(`\n        x = Some 21;\n        result = match x with (Some y => y * 2; None => 0);\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 42 });\n    });\n\n    it(\"should pattern match on None\", () => {\n      const result = runNoolang(`\n        x = None;\n        result = match x with (Some y => y * 2; None => 99);\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 99 });\n    });\n\n    it(\"should handle nested Option values\", () => {\n      const result = runNoolang(`\n        nested = Some (Some 10);\n        result = match nested with (\n          Some inner => match inner with (Some value => value; None => 0);\n          None => -1\n        );\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 10 });\n    });\n  });\n\n  describe(\"Built-in Result Type\", () => {\n    it(\"should create Ok values\", () => {\n      const result = runNoolang(`\n        x = Ok 100;\n        x\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"Ok\",\n        args: [{ tag: \"number\", value: 100 }],\n      });\n    });\n\n    it(\"should create Err values\", () => {\n      const result = runNoolang(`\n        x = Err \"failed\";\n        x\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"Err\",\n        args: [{ tag: \"string\", value: \"failed\" }],\n      });\n    });\n\n    it(\"should pattern match on Ok\", () => {\n      const result = runNoolang(`\n        x = Ok 50;\n        result = match x with (Ok value => value + 10; Err msg => 0);\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 60 });\n    });\n\n    it(\"should pattern match on Err\", () => {\n      const result = runNoolang(`\n        x = Err \"oops\";\n        result = match x with (Ok value => value; Err msg => 404);\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 404 });\n    });\n  });\n\n  describe(\"Custom ADT Definitions\", () => {\n    it(\"should define and use a simple ADT\", () => {\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        favorite = Red;\n        favorite\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"Red\",\n        args: [],\n      });\n    });\n\n    it(\"should define ADT with parameters\", () => {\n      const result = runNoolang(`\n        type Point a = Point a a;\n        origin = Point 0 0;\n        origin\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"Point\",\n        args: [\n          { tag: \"number\", value: 0 },\n          { tag: \"number\", value: 0 },\n        ],\n      });\n    });\n\n    it(\"should pattern match on custom ADTs\", () => {\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        getColorCode = fn color => match color with (\n          Red => 1;\n          Green => 2;\n          Blue => 3\n        );\n        result = getColorCode Red;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 1 });\n    });\n\n    it.skip(\"should handle recursive ADTs\", () => {\n      // Skipped: Recursive ADTs need additional type system work for self-references\n      const result = runNoolang(`\n        type List a = Nil | Cons a (List a);\n        myList = Cons 1 (Cons 2 Nil);\n        getFirst = fn list => match list with (\n          Nil => 0;\n          Cons x xs => x\n        );\n        result = getFirst myList;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 1 });\n    });\n\n    it.skip(\"should handle complex pattern matching with variables\", () => {\n      // Skipped: Complex recursive pattern matching needs additional work\n      const result = runNoolang(`\n        type Tree a = Leaf a | Branch (Tree a) (Tree a);\n        tree = Branch (Leaf 5) (Leaf 10);\n        sumTree = fn t => match t with (\n          Leaf value => value;\n          Branch left right => (sumTree left) + (sumTree right)\n        );\n        result = sumTree tree;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 15 });\n    });\n  });\n\n  describe(\"Pattern Matching Features\", () => {\n    it(\"should handle wildcard patterns\", () => {\n      const result = runNoolang(`\n        type Maybe a = Just a | Nothing;\n        getValue = fn maybe => match maybe with (\n          Just x => x;\n          _ => 42\n        );\n        result = getValue Nothing;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 42 });\n    });\n\n    it(\"should handle literal patterns\", () => {\n      const result = runNoolang(\n        `type Status = Success | Error | Code Int; getStatusMessage = fn status => match status with (Success => \"ok\"; Error => \"fail\"; Code 404 => \"not found\"; Code x => \"unknown code\"); result = getStatusMessage (Code 404); result`,\n      );\n      expect(result.finalValue).toEqual({ tag: \"string\", value: \"not found\" });\n    });\n\n    it(\"should handle nested patterns\", () => {\n      const result = runNoolang(\n        `type Wrapper a = Wrap a; type Inner = Value Int; nested = Wrap (Value 123); extract = fn w => match w with (Wrap (Value n) => n; _ => 0); result = extract nested; result`,\n      );\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 123 });\n    });\n  });\n\n  describe(\"Type Checking\", () => {\n    it(\"should type check ADT constructors correctly\", () => {\n      const result = runNoolang(`\n        type Option a = Some a | None;\n        x = Some 42;\n        x\n      `);\n\n      // Should infer that x has type Option Int\n      expect(result.finalType).toMatch(/Option.*Int|variant.*Option/);\n    });\n\n    it(\"should enforce pattern exhaustiveness (implicit)\", () => {\n      // This should work - all patterns covered\n      const result = runNoolang(`\n        type Bool = True | False;\n        negate = fn b => match b with (True => False; False => True);\n        result = negate True;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"constructor\",\n        name: \"False\",\n        args: [],\n      });\n    });\n\n    it(\"should handle polymorphic ADTs\", () => {\n      const result = runNoolang(`\n        type Pair a b = Pair a b;\n        p = Pair 42 \"hello\";\n        getFirst = fn pair => match pair with (Pair x y => x);\n        result = getFirst p;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 42 });\n    });\n  });\n\n  describe(\"Error Cases\", () => {\n    it(\"should error on unknown constructor in patterns\", () => {\n      expect(() => {\n        runNoolang(`\n          type Color = Red | Green | Blue;\n          x = Red;\n          match x with (Yellow => 1; Red => 2)\n        `);\n      }).toThrow();\n    });\n\n    it(\"should handle partial constructor application\", () => {\n      const result = runNoolang(`\n        type Point = Point Int Int;\n        p = Point 1;  # Partial application - returns (Int) -> Point\n        p\n      `);\n\n      // Should return a function type since it's a partial application\n      expect(result.finalType).toMatch(/Int.*Point|function/);\n    });\n\n    it(\"should error when no pattern matches\", () => {\n      expect(() => {\n        const evaluator = new Evaluator();\n        const source = `\n          type Color = Red | Green | Blue;\n          x = Blue;\n          match x with (Red => 1; Green => 2)  # Missing Blue case\n        `;\n        const lexer = new Lexer(source);\n        const tokens = lexer.tokenize();\n        const program = parse(tokens);\n        evaluator.evaluateProgram(program);\n      }).toThrow(\"No pattern matched\");\n    });\n  });\n\n  describe(\"Integration with Built-in Functions\", () => {\n    it(\"should work with map and Option\", () => {\n      const result = runNoolang(`\n        options = [Some 1, None, Some 3];\n        extractValue = fn opt => match opt with (Some x => x; None => 0);\n        result = map extractValue options;\n        result\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"number\", value: 1 },\n          { tag: \"number\", value: 0 },\n          { tag: \"number\", value: 3 },\n        ],\n      });\n    });\n\n    it(\"should work with filter and custom ADTs\", () => {\n      const result = runNoolang(`\n        type Status = Active | Inactive;\n        items = [Active, Inactive, Active, Active];\n        isActive = fn status => match status with (Active => True; Inactive => False);\n        result = filter isActive items;\n        result\n      `);\n\n      expect(result.finalValue.tag).toBe(\"list\");\n      if (result.finalValue.tag === \"list\") {\n        expect(result.finalValue.values).toHaveLength(3);\n        result.finalValue.values.forEach((item: any) => {\n          expect(item).toEqual({\n            tag: \"constructor\",\n            name: \"Active\",\n            args: [],\n          });\n        });\n      }\n    });\n  });\n\n  describe(\"Multiple ADT Definitions\", () => {\n    it(\"should handle multiple ADT definitions in the same program\", () => {\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        colors = [Red, Green, Blue];\n        shapes = [Circle 3, Rectangle 5 4];\n        colors\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"constructor\", name: \"Red\", args: [] },\n          { tag: \"constructor\", name: \"Green\", args: [] },\n          { tag: \"constructor\", name: \"Blue\", args: [] },\n        ],\n      });\n    });\n\n    it(\"should handle pattern matching on different ADTs separately\", () => {\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        color_to_number Red\n      `);\n\n      expect(result.finalValue).toEqual({ tag: \"number\", value: 1 });\n    });\n\n    it(\"should now work with map and multiple ADTs (polymorphism fixed)\", () => {\n      // This test was previously failing due to lack of polymorphism in map\n      // Now that map is properly polymorphic, it should work\n      expect(() =>\n        runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        colors = [Red, Green, Blue];\n        shapes = [Circle 3, Rectangle 5 4];\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        color_numbers = map color_to_number colors;\n        areas = map calculate_area shapes;\n        color_numbers\n      `),\n      ).not.toThrow();\n    });\n\n    it(\"should work when ADTs are used in separate operations\", () => {\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        colors = [Red, Green, Blue];\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        color_numbers = map color_to_number colors;\n        color_numbers\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"number\", value: 1 },\n          { tag: \"number\", value: 2 },\n          { tag: \"number\", value: 3 },\n        ],\n      });\n    });\n\n    it(\"should work when shapes are processed separately\", () => {\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        shapes = [Circle 3, Rectangle 5 4];\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        areas = map calculate_area shapes;\n        areas\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"number\", value: 27 },\n          { tag: \"number\", value: 20 },\n        ],\n      });\n    });\n  });\n});\n"],"version":3}