{"file":"/workspace/test/adt_limitations.test.ts","mappings":"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","names":[],"sources":["/workspace/test/adt_limitations.test.ts"],"sourcesContent":["import { describe, it, expect } from \"@jest/globals\";\nimport { Lexer } from \"../src/lexer\";\nimport { parse } from \"../src/parser/parser\";\nimport { typeAndDecorate } from '../src/typer';\nimport { Evaluator } from \"../src/evaluator\";\nimport { typeToString } from '../src/typer/helpers';\n\n// Helper function to run Noolang code and get both value and type\nconst runNoolang = (code: string) => {\n  const lexer = new Lexer(code);\n  const tokens = lexer.tokenize();\n  const ast = parse(tokens);\n  const decoratedResult = typeAndDecorate(ast);\n  const evaluator = new Evaluator();\n  const result = evaluator.evaluateProgram(decoratedResult.program);\n\n  return {\n    finalValue: result.finalResult,\n    finalType: decoratedResult.state\n      ? typeToString(\n          decoratedResult.program.statements[\n            decoratedResult.program.statements.length - 1\n          ].type!,\n          decoratedResult.state.substitution,\n        )\n      : \"unknown\",\n  };\n};\n\ndescribe(\"ADT Language Limitations\", () => {\n  describe(\"Multiple ADT Definitions\", () => {\n    it(\"should now work with map and multiple ADTs (polymorphism fixed)\", () => {\n      // This test was previously failing due to lack of polymorphism in map\n      // Now that map is properly polymorphic, it should work\n      expect(() =>\n        runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        colors = [Red, Green, Blue];\n        shapes = [Circle 3, Rectangle 5 4];\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        color_numbers = map color_to_number colors;\n        areas = map calculate_area shapes;\n        color_numbers\n      `),\n      ).not.toThrow();\n    });\n\n    it(\"should work when ADTs are used in separate programs\", () => {\n      // This demonstrates the workaround: use ADTs in separate programs\n      const colorResult = runNoolang(`\n        type Color = Red | Green | Blue;\n        colors = [Red, Green, Blue];\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        color_numbers = map color_to_number colors;\n        color_numbers\n      `);\n\n      expect(colorResult.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"number\", value: 1 },\n          { tag: \"number\", value: 2 },\n          { tag: \"number\", value: 3 },\n        ],\n      });\n\n      const shapeResult = runNoolang(`\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        shapes = [Circle 3, Rectangle 5 4];\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        areas = map calculate_area shapes;\n        areas\n      `);\n\n      expect(shapeResult.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"number\", value: 27 },\n          { tag: \"number\", value: 20 },\n        ],\n      });\n    });\n\n    it(\"should work when ADTs are used sequentially without map\", () => {\n      // This shows that the issue is specifically with map + multiple ADTs\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        color_result = color_to_number Red;\n        shape_result = calculate_area (Circle 5);\n        { @color color_result, @shape shape_result }\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"record\",\n        fields: {\n          color: { tag: \"number\", value: 1 },\n          shape: { tag: \"number\", value: 75 },\n        },\n      });\n    });\n  });\n\n  describe(\"Root Cause Analysis\", () => {\n    it(\"should demonstrate that the type unification issue is now fixed\", () => {\n      // The issue was in the type system when it tried to unify\n      // type variables that had been associated with different ADT types\n      // This is now fixed with proper let-polymorphism for map\n      expect(() =>\n        runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        # This works fine - no type unification issues\n        colors = [Red, Green, Blue];\n        shapes = [Circle 3, Rectangle 5 4];\n        # This also works - separate operations\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        # This now works - map is properly polymorphic\n        color_numbers = map color_to_number colors;\n        areas = map calculate_area shapes;\n        color_numbers\n      `),\n      ).not.toThrow();\n    });\n  });\n\n  describe(\"Workarounds\", () => {\n    it(\"should work with separate type definitions\", () => {\n      // Workaround 1: Define ADTs in separate programs\n      const result1 = runNoolang(`\n        type Color = Red | Green | Blue;\n        colors = [Red, Green, Blue];\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        map color_to_number colors\n      `);\n\n      expect(result1.finalValue).toEqual({\n        tag: \"list\",\n        values: [\n          { tag: \"number\", value: 1 },\n          { tag: \"number\", value: 2 },\n          { tag: \"number\", value: 3 },\n        ],\n      });\n    });\n\n    it(\"should work with manual iteration instead of map\", () => {\n      // Workaround 2: Use manual iteration instead of map\n      const result = runNoolang(`\n        type Color = Red | Green | Blue;\n        type Shape a = Circle a | Rectangle a a | Triangle a a a;\n        color_to_number = fn color => match color with (Red => 1; Green => 2; Blue => 3);\n        calculate_area = fn shape => match shape with (Circle radius => radius * radius * 3; Rectangle width height => width * height; Triangle a b c => (a * b) / 2);\n        # Manual iteration instead of map\n        colors = [Red, Green, Blue];\n        shapes = [Circle 3, Rectangle 5 4];\n        color1 = color_to_number Red;\n        color2 = color_to_number Green;\n        color3 = color_to_number Blue;\n        shape1 = calculate_area (Circle 3);\n        shape2 = calculate_area (Rectangle 5 4);\n        { @colors [color1, color2, color3], @shapes [shape1, shape2] }\n      `);\n\n      expect(result.finalValue).toEqual({\n        tag: \"record\",\n        fields: {\n          colors: {\n            tag: \"list\",\n            values: [\n              { tag: \"number\", value: 1 },\n              { tag: \"number\", value: 2 },\n              { tag: \"number\", value: 3 },\n            ],\n          },\n          shapes: {\n            tag: \"list\",\n            values: [\n              { tag: \"number\", value: 27 },\n              { tag: \"number\", value: 20 },\n            ],\n          },\n        },\n      });\n    });\n  });\n});\n"],"version":3}