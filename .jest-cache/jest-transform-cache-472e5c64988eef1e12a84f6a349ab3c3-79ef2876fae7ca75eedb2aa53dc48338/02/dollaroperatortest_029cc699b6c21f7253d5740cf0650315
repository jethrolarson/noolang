9590088f1d9132fb1dc1a32e529168bc
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lexer_1 = require("../src/lexer");
const parser_1 = require("../src/parser/parser");
const evaluator_1 = require("../src/evaluator");
const typer_1 = require("../src/typer");
let evaluator;
function runCode(code) {
    const lexer = new lexer_1.Lexer(code);
    const tokens = lexer.tokenize();
    const ast = (0, parser_1.parse)(tokens);
    const decoratedResult = (0, typer_1.typeAndDecorate)(ast);
    return evaluator.evaluateProgram(decoratedResult.program);
}
// Type checking helper - simplified for now
function hasCorrectType(code, expectedKind) {
    try {
        const lexer = new lexer_1.Lexer(code);
        const tokens = lexer.tokenize();
        const ast = (0, parser_1.parse)(tokens);
        const decoratedResult = (0, typer_1.typeAndDecorate)(ast);
        // Just check if type decoration succeeded without errors
        return true;
    }
    catch (error) {
        return false;
    }
}
function unwrapValue(val) {
    if (val === null)
        return null;
    if (typeof val !== "object")
        return val;
    switch (val.tag) {
        case "number":
            return val.value;
        case "string":
            return val.value;
        case "constructor":
            if (val.name === "True")
                return true;
            if (val.name === "False")
                return false;
            return val;
        case "list":
            return val.values.map(unwrapValue);
        case "tuple":
            return val.values.map(unwrapValue);
        case "record": {
            const obj = {};
            for (const k in val.fields)
                obj[k] = unwrapValue(val.fields[k]);
            return obj;
        }
        default:
            return val;
    }
}
describe('Dollar Operator ($)', () => {
    beforeEach(() => {
        evaluator = new evaluator_1.Evaluator();
    });
    describe('Basic Function Application', () => {
        test('simple function application', () => {
            const result = runCode('(fn x => x * 2) $ 5');
            expect(unwrapValue(result.finalResult)).toBe(10);
        });
        test('curried function application', () => {
            const result = runCode('add = fn x y => x + y; (add $ 3) $ 5');
            expect(unwrapValue(result.finalResult)).toBe(8);
        });
        test('multiple arguments', () => {
            const result = runCode('mul = fn x y z => x * y * z; ((mul $ 2) $ 3) $ 4');
            expect(unwrapValue(result.finalResult)).toBe(24);
        });
    });
    describe('Right Associativity', () => {
        test('f $ g $ h should parse as f $ (g $ h)', () => {
            // This should be equivalent to: const $ (\x -> x + 1) $ 5
            // Which is: const ((\x -> x + 1) 5) = const 6 = \y -> 6
            const result = runCode('const = fn x y => x; f = fn x => x + 1; (const $ f $ 5) 999');
            // const gets f(5) = 6, so const $ f $ 5 = const 6, which when applied to 999 returns 6
            expect(unwrapValue(result.finalResult)).toBe(6);
        });
        test('right associativity with arithmetic', () => {
            // This tests: add $ (mul $ (2 $ 3)) which should work since $ is right-associative
            // But function-to-function application isn't what we want to test here
            // Let's test a simpler case: const $ (add $ 1) $ 2
            const result = runCode('const = fn x y => x; add = fn x y => x + y; (const $ (add $ 1)) $ 99');
            // const gets (add 1) which is a function, so const returns that function
            // The result should be a function, not a number. Let's test that it returns a function by applying it
            const result3 = runCode('const = fn x y => x; add = fn x y => x + y; ((const $ (add $ 1)) $ 99) 7');
            expect(unwrapValue(result3.finalResult)).toBe(8); // (add $ 1) 7 = 1 + 7 = 8
            // Better test: proper right associativity with valid functions  
            const result4 = runCode('const = fn x y => x; id = fn x => x; (const $ id $ 99) 123');
            expect(unwrapValue(result4.finalResult)).toBe(99); // const gets (id 99) = 99, so const 99 123 = 99
        });
    });
    describe('Precedence with Other Operators', () => {
        test('$ has lower precedence than |', () => {
            const result = runCode('add = fn x y => x + y; [1, 2] | map $ add 1');
            expect(unwrapValue(result.finalResult)).toEqual([2, 3]);
        });
        test('$ has lower precedence than function application', () => {
            const result = runCode('add = fn x y => x + y; map (add 1) $ [1, 2, 3]');
            expect(unwrapValue(result.finalResult)).toEqual([2, 3, 4]);
        });
        test('$ works with complex expressions', () => {
            const result = runCode('map (fn x => x * 2) $ filter (fn x => x > 5) $ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]');
            expect(unwrapValue(result.finalResult)).toEqual([12, 14, 16, 18, 20]);
        });
    });
    describe('Type Checking', () => {
        test('$ with built-in functions type checks correctly', () => {
            // Just verify it doesn't throw type errors
            expect(() => {
                runCode('add = fn x y => x + y; result = map $ add 1; result [1, 2, 3]');
            }).not.toThrow();
        });
        test('$ with user-defined functions type checks correctly', () => {
            expect(() => {
                runCode('add = fn x y => x + y; mymap = fn f list => map f list; result = mymap $ add 1; result [1, 2, 3]');
            }).not.toThrow();
        });
        test('$ creates partial application correctly', () => {
            const result = runCode('add = fn x y z => x + y + z; partialAdd = add $ 1; partialAdd 2 3');
            expect(unwrapValue(result.finalResult)).toBe(6);
        });
    });
    describe('Integration with Other Features', () => {
        test('$ with pipeline operators', () => {
            const result = runCode('add = fn x y => x + y; [1, 2, 3] | map $ add 10');
            expect(unwrapValue(result.finalResult)).toEqual([11, 12, 13]);
        });
        test('$ with records and accessors', () => {
            const result = runCode('person = { @name "Alice", @age 30 }; f = fn x => x; f $ person | @name');
            expect(unwrapValue(result.finalResult)).toBe("Alice");
        });
        test('$ with higher-order functions', () => {
            const result = runCode('compose = fn f g => fn x => f (g x); add1 = fn x => x + 1; mul2 = fn x => x * 2; ((compose $ add1) $ mul2) 5');
            expect(unwrapValue(result.finalResult)).toBe(11); // add1(mul2(5)) = add1(10) = 11
        });
        test('$ with constraint functions', () => {
            const result = runCode('(filter $ (fn x => x > 3)) $ [1, 2, 3, 4, 5]');
            expect(unwrapValue(result.finalResult)).toEqual([4, 5]);
        });
    });
    describe('Complex Chaining', () => {
        test('deep $ chaining', () => {
            const result = runCode('f = fn a b c d => a + b + c + d; (((f $ 1) $ 2) $ 3) $ 4');
            expect(unwrapValue(result.finalResult)).toBe(10);
        });
        test('$ with mixed operators', () => {
            const result = runCode('add = fn x y => x + y; opt = [10] | head; match opt with (Some x => (add $ x) $ 5; None => 0)');
            expect(unwrapValue(result.finalResult)).toBe(15);
        });
        test('$ in complex data flow', () => {
            const result = runCode(`
        process = fn f list => map f list;
        transform = fn x => x * 2 + 1;
        data = [1, 2, 3];
        data | process $ transform
      `);
            expect(unwrapValue(result.finalResult)).toEqual([3, 5, 7]);
        });
    });
    describe('Error Handling', () => {
        test('$ with non-function should error', () => {
            expect(() => {
                runCode('5 $ 3');
            }).toThrow();
        });
        test('$ with wrong arity should error appropriately', () => {
            // This should work - partial application
            expect(() => {
                const result = runCode('add = fn x y => x + y; add $ 1');
                // This should return a function, not throw
            }).not.toThrow();
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2UvdGVzdC9kb2xsYXItb3BlcmF0b3IudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMZXhlciB9IGZyb20gJy4uL3NyYy9sZXhlcic7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJy4uL3NyYy9wYXJzZXIvcGFyc2VyJztcbmltcG9ydCB7IEV2YWx1YXRvciB9IGZyb20gJy4uL3NyYy9ldmFsdWF0b3InO1xuaW1wb3J0IHsgdHlwZUFuZERlY29yYXRlIH0gZnJvbSAnLi4vc3JjL3R5cGVyJztcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSAnLi4vc3JjL2V2YWx1YXRvcic7XG5cbmxldCBldmFsdWF0b3I6IEV2YWx1YXRvcjtcblxuZnVuY3Rpb24gcnVuQ29kZShjb2RlOiBzdHJpbmcpIHtcbiAgY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoY29kZSk7XG4gIGNvbnN0IHRva2VucyA9IGxleGVyLnRva2VuaXplKCk7XG4gIGNvbnN0IGFzdCA9IHBhcnNlKHRva2Vucyk7XG4gIGNvbnN0IGRlY29yYXRlZFJlc3VsdCA9IHR5cGVBbmREZWNvcmF0ZShhc3QpO1xuICByZXR1cm4gZXZhbHVhdG9yLmV2YWx1YXRlUHJvZ3JhbShkZWNvcmF0ZWRSZXN1bHQucHJvZ3JhbSk7XG59XG5cbi8vIFR5cGUgY2hlY2tpbmcgaGVscGVyIC0gc2ltcGxpZmllZCBmb3Igbm93XG5mdW5jdGlvbiBoYXNDb3JyZWN0VHlwZShjb2RlOiBzdHJpbmcsIGV4cGVjdGVkS2luZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoY29kZSk7XG4gICAgY29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcbiAgICBjb25zdCBhc3QgPSBwYXJzZSh0b2tlbnMpO1xuICAgIGNvbnN0IGRlY29yYXRlZFJlc3VsdCA9IHR5cGVBbmREZWNvcmF0ZShhc3QpO1xuICAgIC8vIEp1c3QgY2hlY2sgaWYgdHlwZSBkZWNvcmF0aW9uIHN1Y2NlZWRlZCB3aXRob3V0IGVycm9yc1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndyYXBWYWx1ZSh2YWw6IFZhbHVlKTogYW55IHtcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIGlmICh0eXBlb2YgdmFsICE9PSBcIm9iamVjdFwiKSByZXR1cm4gdmFsO1xuICBzd2l0Y2ggKHZhbC50YWcpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gdmFsLnZhbHVlO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiB2YWwudmFsdWU7XG4gICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6XG4gICAgICBpZiAodmFsLm5hbWUgPT09IFwiVHJ1ZVwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh2YWwubmFtZSA9PT0gXCJGYWxzZVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIGNhc2UgXCJsaXN0XCI6XG4gICAgICByZXR1cm4gdmFsLnZhbHVlcy5tYXAodW53cmFwVmFsdWUpO1xuICAgIGNhc2UgXCJ0dXBsZVwiOlxuICAgICAgcmV0dXJuIHZhbC52YWx1ZXMubWFwKHVud3JhcFZhbHVlKTtcbiAgICBjYXNlIFwicmVjb3JkXCI6IHtcbiAgICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGsgaW4gdmFsLmZpZWxkcykgb2JqW2tdID0gdW53cmFwVmFsdWUodmFsLmZpZWxkc1trXSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbDtcbiAgfVxufVxuXG5kZXNjcmliZSgnRG9sbGFyIE9wZXJhdG9yICgkKScsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgZXZhbHVhdG9yID0gbmV3IEV2YWx1YXRvcigpO1xuICB9KTtcbiAgZGVzY3JpYmUoJ0Jhc2ljIEZ1bmN0aW9uIEFwcGxpY2F0aW9uJywgKCkgPT4ge1xuICAgIHRlc3QoJ3NpbXBsZSBmdW5jdGlvbiBhcHBsaWNhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bkNvZGUoJyhmbiB4ID0+IHggKiAyKSAkIDUnKTtcbiAgICAgIGV4cGVjdCh1bndyYXBWYWx1ZShyZXN1bHQuZmluYWxSZXN1bHQpKS50b0JlKDEwKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2N1cnJpZWQgZnVuY3Rpb24gYXBwbGljYXRpb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBydW5Db2RlKCdhZGQgPSBmbiB4IHkgPT4geCArIHk7IChhZGQgJCAzKSAkIDUnKTtcbiAgICAgIGV4cGVjdCh1bndyYXBWYWx1ZShyZXN1bHQuZmluYWxSZXN1bHQpKS50b0JlKDgpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnbXVsdGlwbGUgYXJndW1lbnRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuQ29kZSgnbXVsID0gZm4geCB5IHogPT4geCAqIHkgKiB6OyAoKG11bCAkIDIpICQgMykgJCA0Jyk7XG4gICAgICBleHBlY3QodW53cmFwVmFsdWUocmVzdWx0LmZpbmFsUmVzdWx0KSkudG9CZSgyNCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSaWdodCBBc3NvY2lhdGl2aXR5JywgKCkgPT4ge1xuICAgIHRlc3QoJ2YgJCBnICQgaCBzaG91bGQgcGFyc2UgYXMgZiAkIChnICQgaCknLCAoKSA9PiB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBiZSBlcXVpdmFsZW50IHRvOiBjb25zdCAkIChcXHggLT4geCArIDEpICQgNVxuICAgICAgLy8gV2hpY2ggaXM6IGNvbnN0ICgoXFx4IC0+IHggKyAxKSA1KSA9IGNvbnN0IDYgPSBcXHkgLT4gNlxuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuQ29kZSgnY29uc3QgPSBmbiB4IHkgPT4geDsgZiA9IGZuIHggPT4geCArIDE7IChjb25zdCAkIGYgJCA1KSA5OTknKTtcbiAgICAgIC8vIGNvbnN0IGdldHMgZig1KSA9IDYsIHNvIGNvbnN0ICQgZiAkIDUgPSBjb25zdCA2LCB3aGljaCB3aGVuIGFwcGxpZWQgdG8gOTk5IHJldHVybnMgNlxuICAgICAgZXhwZWN0KHVud3JhcFZhbHVlKHJlc3VsdC5maW5hbFJlc3VsdCkpLnRvQmUoNik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdyaWdodCBhc3NvY2lhdGl2aXR5IHdpdGggYXJpdGhtZXRpYycsICgpID0+IHtcbiAgICAgIC8vIFRoaXMgdGVzdHM6IGFkZCAkIChtdWwgJCAoMiAkIDMpKSB3aGljaCBzaG91bGQgd29yayBzaW5jZSAkIGlzIHJpZ2h0LWFzc29jaWF0aXZlXG4gICAgICAvLyBCdXQgZnVuY3Rpb24tdG8tZnVuY3Rpb24gYXBwbGljYXRpb24gaXNuJ3Qgd2hhdCB3ZSB3YW50IHRvIHRlc3QgaGVyZVxuICAgICAgLy8gTGV0J3MgdGVzdCBhIHNpbXBsZXIgY2FzZTogY29uc3QgJCAoYWRkICQgMSkgJCAyXG4gICAgICBjb25zdCByZXN1bHQgPSBydW5Db2RlKCdjb25zdCA9IGZuIHggeSA9PiB4OyBhZGQgPSBmbiB4IHkgPT4geCArIHk7IChjb25zdCAkIChhZGQgJCAxKSkgJCA5OScpO1xuICAgICAgLy8gY29uc3QgZ2V0cyAoYWRkIDEpIHdoaWNoIGlzIGEgZnVuY3Rpb24sIHNvIGNvbnN0IHJldHVybnMgdGhhdCBmdW5jdGlvblxuICAgICAgLy8gVGhlIHJlc3VsdCBzaG91bGQgYmUgYSBmdW5jdGlvbiwgbm90IGEgbnVtYmVyLiBMZXQncyB0ZXN0IHRoYXQgaXQgcmV0dXJucyBhIGZ1bmN0aW9uIGJ5IGFwcGx5aW5nIGl0XG4gICAgICBjb25zdCByZXN1bHQzID0gcnVuQ29kZSgnY29uc3QgPSBmbiB4IHkgPT4geDsgYWRkID0gZm4geCB5ID0+IHggKyB5OyAoKGNvbnN0ICQgKGFkZCAkIDEpKSAkIDk5KSA3Jyk7XG4gICAgICBleHBlY3QodW53cmFwVmFsdWUocmVzdWx0My5maW5hbFJlc3VsdCkpLnRvQmUoOCk7IC8vIChhZGQgJCAxKSA3ID0gMSArIDcgPSA4XG4gICAgICBcbiAgICAgIC8vIEJldHRlciB0ZXN0OiBwcm9wZXIgcmlnaHQgYXNzb2NpYXRpdml0eSB3aXRoIHZhbGlkIGZ1bmN0aW9ucyAgXG4gICAgICBjb25zdCByZXN1bHQ0ID0gcnVuQ29kZSgnY29uc3QgPSBmbiB4IHkgPT4geDsgaWQgPSBmbiB4ID0+IHg7IChjb25zdCAkIGlkICQgOTkpIDEyMycpO1xuICAgICAgZXhwZWN0KHVud3JhcFZhbHVlKHJlc3VsdDQuZmluYWxSZXN1bHQpKS50b0JlKDk5KTsgLy8gY29uc3QgZ2V0cyAoaWQgOTkpID0gOTksIHNvIGNvbnN0IDk5IDEyMyA9IDk5XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcmVjZWRlbmNlIHdpdGggT3RoZXIgT3BlcmF0b3JzJywgKCkgPT4ge1xuICAgIHRlc3QoJyQgaGFzIGxvd2VyIHByZWNlZGVuY2UgdGhhbiB8JywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuQ29kZSgnYWRkID0gZm4geCB5ID0+IHggKyB5OyBbMSwgMl0gfCBtYXAgJCBhZGQgMScpO1xuICAgICAgZXhwZWN0KHVud3JhcFZhbHVlKHJlc3VsdC5maW5hbFJlc3VsdCkpLnRvRXF1YWwoWzIsIDNdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJyQgaGFzIGxvd2VyIHByZWNlZGVuY2UgdGhhbiBmdW5jdGlvbiBhcHBsaWNhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bkNvZGUoJ2FkZCA9IGZuIHggeSA9PiB4ICsgeTsgbWFwIChhZGQgMSkgJCBbMSwgMiwgM10nKTtcbiAgICAgIGV4cGVjdCh1bndyYXBWYWx1ZShyZXN1bHQuZmluYWxSZXN1bHQpKS50b0VxdWFsKFsyLCAzLCA0XSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCckIHdvcmtzIHdpdGggY29tcGxleCBleHByZXNzaW9ucycsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bkNvZGUoJ21hcCAoZm4geCA9PiB4ICogMikgJCBmaWx0ZXIgKGZuIHggPT4geCA+IDUpICQgWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXScpO1xuICAgICAgZXhwZWN0KHVud3JhcFZhbHVlKHJlc3VsdC5maW5hbFJlc3VsdCkpLnRvRXF1YWwoWzEyLCAxNCwgMTYsIDE4LCAyMF0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnVHlwZSBDaGVja2luZycsICgpID0+IHtcbiAgICB0ZXN0KCckIHdpdGggYnVpbHQtaW4gZnVuY3Rpb25zIHR5cGUgY2hlY2tzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIC8vIEp1c3QgdmVyaWZ5IGl0IGRvZXNuJ3QgdGhyb3cgdHlwZSBlcnJvcnNcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIHJ1bkNvZGUoJ2FkZCA9IGZuIHggeSA9PiB4ICsgeTsgcmVzdWx0ID0gbWFwICQgYWRkIDE7IHJlc3VsdCBbMSwgMiwgM10nKTtcbiAgICAgIH0pLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCckIHdpdGggdXNlci1kZWZpbmVkIGZ1bmN0aW9ucyB0eXBlIGNoZWNrcyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBydW5Db2RlKCdhZGQgPSBmbiB4IHkgPT4geCArIHk7IG15bWFwID0gZm4gZiBsaXN0ID0+IG1hcCBmIGxpc3Q7IHJlc3VsdCA9IG15bWFwICQgYWRkIDE7IHJlc3VsdCBbMSwgMiwgM10nKTtcbiAgICAgIH0pLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCckIGNyZWF0ZXMgcGFydGlhbCBhcHBsaWNhdGlvbiBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBydW5Db2RlKCdhZGQgPSBmbiB4IHkgeiA9PiB4ICsgeSArIHo7IHBhcnRpYWxBZGQgPSBhZGQgJCAxOyBwYXJ0aWFsQWRkIDIgMycpO1xuICAgICAgZXhwZWN0KHVud3JhcFZhbHVlKHJlc3VsdC5maW5hbFJlc3VsdCkpLnRvQmUoNik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbnRlZ3JhdGlvbiB3aXRoIE90aGVyIEZlYXR1cmVzJywgKCkgPT4ge1xuICAgIHRlc3QoJyQgd2l0aCBwaXBlbGluZSBvcGVyYXRvcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBydW5Db2RlKCdhZGQgPSBmbiB4IHkgPT4geCArIHk7IFsxLCAyLCAzXSB8IG1hcCAkIGFkZCAxMCcpO1xuICAgICAgZXhwZWN0KHVud3JhcFZhbHVlKHJlc3VsdC5maW5hbFJlc3VsdCkpLnRvRXF1YWwoWzExLCAxMiwgMTNdKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJyQgd2l0aCByZWNvcmRzIGFuZCBhY2Nlc3NvcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBydW5Db2RlKCdwZXJzb24gPSB7IEBuYW1lIFwiQWxpY2VcIiwgQGFnZSAzMCB9OyBmID0gZm4geCA9PiB4OyBmICQgcGVyc29uIHwgQG5hbWUnKTtcbiAgICAgIGV4cGVjdCh1bndyYXBWYWx1ZShyZXN1bHQuZmluYWxSZXN1bHQpKS50b0JlKFwiQWxpY2VcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCckIHdpdGggaGlnaGVyLW9yZGVyIGZ1bmN0aW9ucycsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bkNvZGUoJ2NvbXBvc2UgPSBmbiBmIGcgPT4gZm4geCA9PiBmIChnIHgpOyBhZGQxID0gZm4geCA9PiB4ICsgMTsgbXVsMiA9IGZuIHggPT4geCAqIDI7ICgoY29tcG9zZSAkIGFkZDEpICQgbXVsMikgNScpO1xuICAgICAgZXhwZWN0KHVud3JhcFZhbHVlKHJlc3VsdC5maW5hbFJlc3VsdCkpLnRvQmUoMTEpOyAvLyBhZGQxKG11bDIoNSkpID0gYWRkMSgxMCkgPSAxMVxuICAgIH0pO1xuXG4gICAgdGVzdCgnJCB3aXRoIGNvbnN0cmFpbnQgZnVuY3Rpb25zJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuQ29kZSgnKGZpbHRlciAkIChmbiB4ID0+IHggPiAzKSkgJCBbMSwgMiwgMywgNCwgNV0nKTtcbiAgICAgIGV4cGVjdCh1bndyYXBWYWx1ZShyZXN1bHQuZmluYWxSZXN1bHQpKS50b0VxdWFsKFs0LCA1XSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb21wbGV4IENoYWluaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RlZXAgJCBjaGFpbmluZycsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJ1bkNvZGUoJ2YgPSBmbiBhIGIgYyBkID0+IGEgKyBiICsgYyArIGQ7ICgoKGYgJCAxKSAkIDIpICQgMykgJCA0Jyk7XG4gICAgICBleHBlY3QodW53cmFwVmFsdWUocmVzdWx0LmZpbmFsUmVzdWx0KSkudG9CZSgxMCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCckIHdpdGggbWl4ZWQgb3BlcmF0b3JzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuQ29kZSgnYWRkID0gZm4geCB5ID0+IHggKyB5OyBvcHQgPSBbMTBdIHwgaGVhZDsgbWF0Y2ggb3B0IHdpdGggKFNvbWUgeCA9PiAoYWRkICQgeCkgJCA1OyBOb25lID0+IDApJyk7XG4gICAgICBleHBlY3QodW53cmFwVmFsdWUocmVzdWx0LmZpbmFsUmVzdWx0KSkudG9CZSgxNSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCckIGluIGNvbXBsZXggZGF0YSBmbG93JywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcnVuQ29kZShgXG4gICAgICAgIHByb2Nlc3MgPSBmbiBmIGxpc3QgPT4gbWFwIGYgbGlzdDtcbiAgICAgICAgdHJhbnNmb3JtID0gZm4geCA9PiB4ICogMiArIDE7XG4gICAgICAgIGRhdGEgPSBbMSwgMiwgM107XG4gICAgICAgIGRhdGEgfCBwcm9jZXNzICQgdHJhbnNmb3JtXG4gICAgICBgKTtcbiAgICAgIGV4cGVjdCh1bndyYXBWYWx1ZShyZXN1bHQuZmluYWxSZXN1bHQpKS50b0VxdWFsKFszLCA1LCA3XSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICB0ZXN0KCckIHdpdGggbm9uLWZ1bmN0aW9uIHNob3VsZCBlcnJvcicsICgpID0+IHtcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIHJ1bkNvZGUoJzUgJCAzJyk7XG4gICAgICB9KS50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCckIHdpdGggd3JvbmcgYXJpdHkgc2hvdWxkIGVycm9yIGFwcHJvcHJpYXRlbHknLCAoKSA9PiB7XG4gICAgICAvLyBUaGlzIHNob3VsZCB3b3JrIC0gcGFydGlhbCBhcHBsaWNhdGlvblxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcnVuQ29kZSgnYWRkID0gZm4geCB5ID0+IHggKyB5OyBhZGQgJCAxJyk7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHJldHVybiBhIGZ1bmN0aW9uLCBub3QgdGhyb3dcbiAgICAgIH0pLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9