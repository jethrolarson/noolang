{"file":"/workspace/test/dollar-operator.test.ts","mappings":"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","names":[],"sources":["/workspace/test/dollar-operator.test.ts"],"sourcesContent":["import { Lexer } from '../src/lexer';\nimport { parse } from '../src/parser/parser';\nimport { Evaluator } from '../src/evaluator';\nimport { typeAndDecorate } from '../src/typer';\nimport { Value } from '../src/evaluator';\n\nlet evaluator: Evaluator;\n\nfunction runCode(code: string) {\n  const lexer = new Lexer(code);\n  const tokens = lexer.tokenize();\n  const ast = parse(tokens);\n  const decoratedResult = typeAndDecorate(ast);\n  return evaluator.evaluateProgram(decoratedResult.program);\n}\n\n// Type checking helper - simplified for now\nfunction hasCorrectType(code: string, expectedKind: string): boolean {\n  try {\n    const lexer = new Lexer(code);\n    const tokens = lexer.tokenize();\n    const ast = parse(tokens);\n    const decoratedResult = typeAndDecorate(ast);\n    // Just check if type decoration succeeded without errors\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction unwrapValue(val: Value): any {\n  if (val === null) return null;\n  if (typeof val !== \"object\") return val;\n  switch (val.tag) {\n    case \"number\":\n      return val.value;\n    case \"string\":\n      return val.value;\n    case \"constructor\":\n      if (val.name === \"True\") return true;\n      if (val.name === \"False\") return false;\n      return val;\n    case \"list\":\n      return val.values.map(unwrapValue);\n    case \"tuple\":\n      return val.values.map(unwrapValue);\n    case \"record\": {\n      const obj: any = {};\n      for (const k in val.fields) obj[k] = unwrapValue(val.fields[k]);\n      return obj;\n    }\n    default:\n      return val;\n  }\n}\n\ndescribe('Dollar Operator ($)', () => {\n  beforeEach(() => {\n    evaluator = new Evaluator();\n  });\n  describe('Basic Function Application', () => {\n    test('simple function application', () => {\n      const result = runCode('(fn x => x * 2) $ 5');\n      expect(unwrapValue(result.finalResult)).toBe(10);\n    });\n\n    test('curried function application', () => {\n      const result = runCode('add = fn x y => x + y; (add $ 3) $ 5');\n      expect(unwrapValue(result.finalResult)).toBe(8);\n    });\n\n    test('multiple arguments', () => {\n      const result = runCode('mul = fn x y z => x * y * z; ((mul $ 2) $ 3) $ 4');\n      expect(unwrapValue(result.finalResult)).toBe(24);\n    });\n  });\n\n  describe('Right Associativity', () => {\n    test('f $ g $ h should parse as f $ (g $ h)', () => {\n      // This should be equivalent to: const $ (\\x -> x + 1) $ 5\n      // Which is: const ((\\x -> x + 1) 5) = const 6 = \\y -> 6\n      const result = runCode('const = fn x y => x; f = fn x => x + 1; (const $ f $ 5) 999');\n      // const gets f(5) = 6, so const $ f $ 5 = const 6, which when applied to 999 returns 6\n      expect(unwrapValue(result.finalResult)).toBe(6);\n    });\n\n    test('right associativity with arithmetic', () => {\n      // This tests: add $ (mul $ (2 $ 3)) which should work since $ is right-associative\n      // But function-to-function application isn't what we want to test here\n      // Let's test a simpler case: const $ (add $ 1) $ 2\n      const result = runCode('const = fn x y => x; add = fn x y => x + y; (const $ (add $ 1)) $ 99');\n      // const gets (add 1) which is a function, so const returns that function\n      // The result should be a function, not a number. Let's test that it returns a function by applying it\n      const result3 = runCode('const = fn x y => x; add = fn x y => x + y; ((const $ (add $ 1)) $ 99) 7');\n      expect(unwrapValue(result3.finalResult)).toBe(8); // (add $ 1) 7 = 1 + 7 = 8\n      \n      // Better test: proper right associativity with valid functions  \n      const result4 = runCode('const = fn x y => x; id = fn x => x; (const $ id $ 99) 123');\n      expect(unwrapValue(result4.finalResult)).toBe(99); // const gets (id 99) = 99, so const 99 123 = 99\n    });\n  });\n\n  describe('Precedence with Other Operators', () => {\n    test('$ has lower precedence than |', () => {\n      const result = runCode('add = fn x y => x + y; [1, 2] | map $ add 1');\n      expect(unwrapValue(result.finalResult)).toEqual([2, 3]);\n    });\n\n    test('$ has lower precedence than function application', () => {\n      const result = runCode('add = fn x y => x + y; map (add 1) $ [1, 2, 3]');\n      expect(unwrapValue(result.finalResult)).toEqual([2, 3, 4]);\n    });\n\n    test('$ works with complex expressions', () => {\n      const result = runCode('map (fn x => x * 2) $ filter (fn x => x > 5) $ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]');\n      expect(unwrapValue(result.finalResult)).toEqual([12, 14, 16, 18, 20]);\n    });\n  });\n\n  describe('Type Checking', () => {\n    test('$ with built-in functions type checks correctly', () => {\n      // Just verify it doesn't throw type errors\n      expect(() => {\n        runCode('add = fn x y => x + y; result = map $ add 1; result [1, 2, 3]');\n      }).not.toThrow();\n    });\n\n    test('$ with user-defined functions type checks correctly', () => {\n      expect(() => {\n        runCode('add = fn x y => x + y; mymap = fn f list => map f list; result = mymap $ add 1; result [1, 2, 3]');\n      }).not.toThrow();\n    });\n\n    test('$ creates partial application correctly', () => {\n      const result = runCode('add = fn x y z => x + y + z; partialAdd = add $ 1; partialAdd 2 3');\n      expect(unwrapValue(result.finalResult)).toBe(6);\n    });\n  });\n\n  describe('Integration with Other Features', () => {\n    test('$ with pipeline operators', () => {\n      const result = runCode('add = fn x y => x + y; [1, 2, 3] | map $ add 10');\n      expect(unwrapValue(result.finalResult)).toEqual([11, 12, 13]);\n    });\n\n    test('$ with records and accessors', () => {\n      const result = runCode('person = { @name \"Alice\", @age 30 }; f = fn x => x; f $ person | @name');\n      expect(unwrapValue(result.finalResult)).toBe(\"Alice\");\n    });\n\n    test('$ with higher-order functions', () => {\n      const result = runCode('compose = fn f g => fn x => f (g x); add1 = fn x => x + 1; mul2 = fn x => x * 2; ((compose $ add1) $ mul2) 5');\n      expect(unwrapValue(result.finalResult)).toBe(11); // add1(mul2(5)) = add1(10) = 11\n    });\n\n    test('$ with constraint functions', () => {\n      const result = runCode('(filter $ (fn x => x > 3)) $ [1, 2, 3, 4, 5]');\n      expect(unwrapValue(result.finalResult)).toEqual([4, 5]);\n    });\n  });\n\n  describe('Complex Chaining', () => {\n    test('deep $ chaining', () => {\n      const result = runCode('f = fn a b c d => a + b + c + d; (((f $ 1) $ 2) $ 3) $ 4');\n      expect(unwrapValue(result.finalResult)).toBe(10);\n    });\n\n    test('$ with mixed operators', () => {\n      const result = runCode('add = fn x y => x + y; opt = [10] | head; match opt with (Some x => (add $ x) $ 5; None => 0)');\n      expect(unwrapValue(result.finalResult)).toBe(15);\n    });\n\n    test('$ in complex data flow', () => {\n      const result = runCode(`\n        process = fn f list => map f list;\n        transform = fn x => x * 2 + 1;\n        data = [1, 2, 3];\n        data | process $ transform\n      `);\n      expect(unwrapValue(result.finalResult)).toEqual([3, 5, 7]);\n    });\n  });\n\n  describe('Error Handling', () => {\n    test('$ with non-function should error', () => {\n      expect(() => {\n        runCode('5 $ 3');\n      }).toThrow();\n    });\n\n    test('$ with wrong arity should error appropriately', () => {\n      // This should work - partial application\n      expect(() => {\n        const result = runCode('add = fn x y => x + y; add $ 1');\n        // This should return a function, not throw\n      }).not.toThrow();\n    });\n  });\n});"],"version":3}