{"file":"/workspace/test/tuple.test.ts","mappings":"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","names":[],"sources":["/workspace/test/tuple.test.ts"],"sourcesContent":["import { Evaluator, Value } from \"../src/evaluator\";\nimport { parse } from \"../src/parser/parser\";\nimport { Lexer } from \"../src/lexer\";\n\nfunction unwrapValue(val: Value): any {\n  if (val === null) return null;\n  if (typeof val !== \"object\") return val;\n  switch (val.tag) {\n    case \"number\":\n      return val.value;\n    case \"string\":\n      return val.value;\n    case \"constructor\":\n      if (val.name === \"True\") return true;\n      if (val.name === \"False\") return false;\n      return val;\n    case \"list\":\n      return val.values.map(unwrapValue);\n    case \"tuple\":\n      return val.values.map(unwrapValue);\n    case \"record\": {\n      const obj: any = {};\n      for (const k in val.fields) obj[k] = unwrapValue(val.fields[k]);\n      return obj;\n    }\n    default:\n      return val;\n  }\n}\n\ndescribe(\"Tuple Native Functions\", () => {\n  const evaluateSource = (source: string) => {\n    const evaluator = new Evaluator();\n    const lexer = new Lexer(source);\n    return evaluator.evaluateProgram(parse(lexer.tokenize()));\n  };\n\n  describe(\"tupleLength\", () => {\n    test(\"length of empty tuple\", () => {\n      const source = \"tuple = {}; tupleLength tuple\";\n      // { } is now unit, not an empty tuple, so this should throw an error\n      expect(() => evaluateSource(source)).toThrow(\n        \"tupleLength requires a tuple\",\n      );\n    });\n    test(\"length of singleton tuple\", () => {\n      const source = \"tuple = { 1 }; tupleLength tuple\";\n      const result = evaluateSource(source);\n      expect(unwrapValue(result.finalResult)).toBe(1);\n    });\n    test(\"length of pair tuple\", () => {\n      const source = \"tuple = { 1, 2 }; tupleLength tuple\";\n      const result = evaluateSource(source);\n      expect(unwrapValue(result.finalResult)).toBe(2);\n    });\n  });\n\n  describe(\"tupleIsEmpty\", () => {\n    test(\"returns true for empty tuple\", () => {\n      const source = \"tuple = {}; tupleIsEmpty tuple\";\n      // { } is now unit, not an empty tuple, so this should throw an error\n      expect(() => evaluateSource(source)).toThrow(\n        \"tupleIsEmpty requires a tuple\",\n      );\n    });\n    test(\"returns false for non-empty tuple\", () => {\n      const source = \"tuple = { 1, 2, 3 }; tupleIsEmpty tuple\";\n      const result = evaluateSource(source);\n      expect(unwrapValue(result.finalResult)).toBe(false);\n    });\n  });\n});\n"],"version":3}