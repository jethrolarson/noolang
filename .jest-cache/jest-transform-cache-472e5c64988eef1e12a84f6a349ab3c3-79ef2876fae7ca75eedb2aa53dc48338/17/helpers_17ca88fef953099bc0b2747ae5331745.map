{"file":"/workspace/src/typer/helpers.ts","mappings":"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","names":[],"sources":["/workspace/src/typer/helpers.ts"],"sourcesContent":["import { type Type, functionType, typeVariable, type VariableType, type PrimitiveType, type FunctionType, type ListType, type TupleType, type RecordType, type UnionType, type VariantType, ConstraintExpr, Constraint, IsConstraint, HasFieldConstraint, ImplementsConstraint, CustomConstraint } from \"../ast\";\nimport { formatTypeError } from \"./type-errors\";\nimport { NoolangError } from \"../errors\";\nimport { substitute } from \"./substitute\";\nimport type { Effect } from \"../ast\";\n\ntype CodeLocation = {\n  line: number;\n  column: number;\n};\n\n// Helper: Extract location from expression or provide default\nexport const getExprLocation = (expr: {\n  location?: { start: CodeLocation };\n}): CodeLocation => ({\n  line: expr.location?.start.line || 1,\n  column: expr.location?.start.column || 1,\n});\n\n// Helper: Throw formatted type error with consistent pattern\nexport function throwTypeError(\n  errorFactory: (location: CodeLocation) => NoolangError,\n  location?: CodeLocation\n): never {\n  const loc = location || { line: 1, column: 1 };\n  throw new Error(formatTypeError(errorFactory(loc)));\n}\n\n// Helper: Format effects as string for type display\nexport function formatEffectsString(effects: Set<Effect>): string {\n  if (effects.size === 0) return \"\";\n  return ` ${Array.from(effects).map(e => `!${e}`).join(' ')}`;\n}\n\n// Helper: Create common function types\nexport const createUnaryFunctionType = (\n  paramType: Type,\n  returnType: Type\n): Type => functionType([paramType], returnType);\n\nexport const createBinaryFunctionType = (\n  param1Type: Type,\n  param2Type: Type,\n  returnType: Type\n): Type => functionType([param1Type, param2Type], returnType);\n\n// Helper: Create polymorphic function types with type variables\nexport const createPolymorphicUnaryFunction = (\n  paramVar: string,\n  returnVar: string\n): Type => functionType([typeVariable(paramVar)], typeVariable(returnVar));\n\nexport const createPolymorphicBinaryFunction = (\n  param1Var: string,\n  param2Var: string,\n  returnVar: string\n): Type =>\n  functionType(\n    [typeVariable(param1Var), typeVariable(param2Var)],\n    typeVariable(returnVar)\n  );\n\n\n// Utility: mapObject for mapping over record fields\nexport function mapObject<T, U>(\n  obj: { [k: string]: T },\n  fn: (v: T, k: string) => U,\n): { [k: string]: U } {\n  const result: { [k: string]: U } = {};\n  for (const k in obj) result[k] = fn(obj[k], k);\n  return result;\n}\n\n// Utility: mapSet for immutable Map updates - optimized to avoid copying large maps\nexport function mapSet<K, V>(map: Map<K, V>, key: K, value: V): Map<K, V> {\n  // For performance, avoid copying large maps unnecessarily\n  if (map.has(key) && map.get(key) === value) {\n    return map; // No change needed\n  }\n  const copy = new Map(map);\n  copy.set(key, value);\n  return copy;\n}\n\n// Utility: isTypeKind type guard\nexport function isTypeKind<T extends Type[\"kind\"]>(\n  t: Type,\n  kind: T,\n): t is Extract<Type, { kind: T }> {\n  return t.kind === kind;\n}\n\n\n// Cache for typesEqual to avoid repeated deep comparisons\nconst typesEqualCache = new Map<string, boolean>();\n\n// Check if two types are structurally equal\nexport const typesEqual = (t1: Type, t2: Type): boolean => {\n  // Quick reference equality check\n  if (t1 === t2) return true;\n  \n  if (t1.kind !== t2.kind) {\n    return false;\n  }\n  \n  // Simple cache for primitive/variable types\n  if ((t1.kind === 'primitive' || t1.kind === 'variable') && (t2.kind === 'primitive' || t2.kind === 'variable')) {\n    const key = `${t1.kind}:${(t1 as any).name}-${t2.kind}:${(t2 as any).name}`;\n    let cached = typesEqualCache.get(key);\n    if (cached !== undefined) return cached;\n    \n    const result = typesEqualUncached(t1, t2);\n    if (typesEqualCache.size < 500) {\n      typesEqualCache.set(key, result);\n    }\n    return result;\n  }\n  \n  return typesEqualUncached(t1, t2);\n};\n\nconst typesEqualUncached = (t1: Type, t2: Type): boolean => {\n\n  switch (t1.kind) {\n    case \"variable\":\n      return t1.name === (t2 as VariableType).name;\n\n    case \"primitive\":\n      return t1.name === (t2 as PrimitiveType).name;\n\n    case \"function\": {\n      const f2 = t2 as FunctionType;\n      if (t1.params.length !== f2.params.length) {\n        return false;\n      }\n      return (\n        t1.params.every((param, i) => typesEqual(param, f2.params[i])) &&\n        typesEqual(t1.return, f2.return)\n      );\n    }\n\n    case \"list\":\n      return typesEqual(t1.element, (t2 as ListType).element);\n\n    case \"tuple\": {\n      const t2_tuple = t2 as TupleType;\n      if (t1.elements.length !== t2_tuple.elements.length) {\n        return false;\n      }\n      return t1.elements.every((element, i) =>\n        typesEqual(element, t2_tuple.elements[i]),\n      );\n    }\n\n    case \"record\": {\n      const t2_record = t2 as RecordType;\n      const keys1 = Object.keys(t1.fields);\n      const keys2 = Object.keys(t2_record.fields);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) =>\n        typesEqual(t1.fields[key], t2_record.fields[key]),\n      );\n    }\n\n    case \"union\": {\n      const t2_union = t2 as UnionType;\n      if (t1.types.length !== t2_union.types.length) {\n        return false;\n      }\n      return t1.types.every((type, i) => typesEqual(type, t2_union.types[i]));\n    }\n\n    case \"unit\":\n      return true;\n\n    case \"variant\": {\n      const t2_variant = t2 as VariantType;\n      if (t1.name !== t2_variant.name) {\n        return false;\n      }\n      if (t1.args.length !== t2_variant.args.length) {\n        return false;\n      }\n      return t1.args.every((arg, i) => typesEqual(arg, t2_variant.args[i]));\n    }\n\n    default:\n      return false;\n  }\n};\n\n\n// Efficient type similarity check to avoid JSON.stringify (simplified for constraint comparison)\nexport const typesSimilar = (t1: Type, t2: Type): boolean => {\n\tif (t1.kind !== t2.kind) return false;\n\n\tswitch (t1.kind) {\n\t\tcase \"primitive\":\n\t\t\treturn t1.name === (t2 as PrimitiveType).name;\n\t\tcase \"variable\":\n\t\t\treturn t1.name === (t2 as VariableType).name;\n\t\tcase \"function\": {\n\t\t\tconst t2Func = t2 as FunctionType;\n\t\t\treturn (\n\t\t\t\tt1.params.length === t2Func.params.length &&\n\t\t\t\tt1.params.every((p, i) => typesSimilar(p, t2Func.params[i])) &&\n\t\t\t\ttypesSimilar(t1.return, t2Func.return)\n\t\t\t);\n\t\t}\n\t\tcase \"list\":\n\t\t\treturn typesSimilar(t1.element, (t2 as ListType).element);\n\t\tcase \"record\": {\n\t\t\tconst t2Record = t2 as RecordType;\n\t\t\tconst fields1 = Object.keys(t1.fields);\n\t\t\tconst fields2 = Object.keys(t2Record.fields);\n\t\t\treturn (\n\t\t\t\tfields1.length === fields2.length &&\n\t\t\t\tfields1.every(\n\t\t\t\t\t(f) =>\n\t\t\t\t\t\tf in t2Record.fields &&\n\t\t\t\t\t\ttypesSimilar(t1.fields[f], t2Record.fields[f]),\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\tcase \"tuple\": {\n\t\t\tconst t2Tuple = t2 as TupleType;\n\t\t\treturn (\n\t\t\t\tt1.elements.length === t2Tuple.elements.length &&\n\t\t\t\tt1.elements.every((e, i) => typesSimilar(e, t2Tuple.elements[i]))\n\t\t\t);\n\t\t}\n\t\tcase \"union\": {\n\t\t\tconst t2Union = t2 as UnionType;\n\t\t\treturn (\n\t\t\t\tt1.types.length === t2Union.types.length &&\n\t\t\t\tt1.types.every((type, i) => typesSimilar(type, t2Union.types[i]))\n\t\t\t);\n\t\t}\n\t\tdefault:\n\t\t\treturn false;\n\t}\n};\n\n// Efficient constraint comparison to replace expensive JSON.stringify\nexport const constraintsEqual = (c1: Constraint, c2: Constraint): boolean => {\n\tif (c1.kind !== c2.kind || c1.typeVar !== c2.typeVar) return false;\n\n\tswitch (c1.kind) {\n\t\tcase \"is\":\n\t\t\treturn c1.constraint === (c2 as IsConstraint).constraint;\n\t\tcase \"hasField\": {\n\t\t\tconst c2HasField = c2 as HasFieldConstraint;\n\t\t\treturn (\n\t\t\t\tc1.field === c2HasField.field &&\n\t\t\t\ttypesSimilar(c1.fieldType, c2HasField.fieldType)\n\t\t\t);\n\t\t}\n\t\tcase \"implements\":\n\t\t\treturn c1.interfaceName === (c2 as ImplementsConstraint).interfaceName;\n\t\tcase \"custom\":\n\t\t\treturn c1.constraint === (c2 as CustomConstraint).constraint;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n};\n\n// Helper function to propagate a constraint to matching type variables in a function type\nexport const propagateConstraintToTypeVariable = (\n\tfuncType: Type,\n\tconstraint: Constraint,\n): void => {\n\tif (funcType.kind !== \"function\") return;\n\n\t// Apply constraint to matching type variables in parameters\n\tfor (const param of funcType.params) {\n\t\tif (param.kind === \"variable\" && param.name === constraint.typeVar) {\n\t\t\tif (!param.constraints) {\n\t\t\t\tparam.constraints = [];\n\t\t\t}\n\t\t\t// Check if this constraint is already present\n\t\t\tconst existingConstraint = param.constraints.find((c) =>\n\t\t\t\tconstraintsEqual(c, constraint),\n\t\t\t);\n\t\t\tif (!existingConstraint) {\n\t\t\t\tparam.constraints.push(constraint);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Also apply to return type if it matches\n\tif (\n\t\tfuncType.return.kind === \"variable\" &&\n\t\tfuncType.return.name === constraint.typeVar\n\t) {\n\t\tif (!funcType.return.constraints) {\n\t\t\tfuncType.return.constraints = [];\n\t\t}\n\t\tconst existingConstraint = funcType.return.constraints.find((c) =>\n\t\t\tconstraintsEqual(c, constraint),\n\t\t);\n\t\tif (!existingConstraint) {\n\t\t\tfuncType.return.constraints.push(constraint);\n\t\t}\n\t}\n};\n\n// Utility function to convert type to string\nexport const typeToString = (\n\ttype: Type,\n\tsubstitution: Map<string, Type> = new Map(),\n\tshowConstraints: boolean = true,\n): string => {\n\tconst greek = [\n\t\t\"α\",\n\t\t\"β\",\n\t\t\"γ\",\n\t\t\"δ\",\n\t\t\"ε\",\n\t\t\"ζ\",\n\t\t\"η\",\n\t\t\"θ\",\n\t\t\"ι\",\n\t\t\"κ\",\n\t\t\"λ\",\n\t\t\"μ\",\n\t\t\"ν\",\n\t\t\"ξ\",\n\t\t\"ο\",\n\t\t\"π\",\n\t\t\"ρ\",\n\t\t\"σ\",\n\t\t\"τ\",\n\t\t\"υ\",\n\t\t\"φ\",\n\t\t\"χ\",\n\t\t\"ψ\",\n\t\t\"ω\",\n\t];\n\tconst mapping = new Map<string, string>();\n\tlet next = 0;\n\n\tfunction norm(t: Type): string {\n\t\tswitch (t.kind) {\n\t\t\tcase \"primitive\":\n\t\t\t\treturn t.name;\n\t\t\tcase \"function\": {\n\t\t\t\tconst paramStr = t.params.map(norm).join(\" \");\n\t\t\t\tconst effectStr = formatEffectsString(t.effects);\n\t\t\t\tconst baseType = `(${paramStr}) -> ${norm(t.return)}${effectStr}`;\n\n\t\t\t\tconst constraintStr =\n\t\t\t\t\tshowConstraints && t.constraints && t.constraints.length > 0\n\t\t\t\t\t\t? ` given ${\n\t\t\t\t\t\t\t\t(t as any).originalConstraint\n\t\t\t\t\t\t\t\t\t? formatConstraintExpr((t as any).originalConstraint)\n\t\t\t\t\t\t\t\t\t: deduplicateConstraints(t.constraints)\n\t\t\t\t\t\t\t\t\t\t\t.map(formatConstraint)\n\t\t\t\t\t\t\t\t\t\t\t.join(\" \")\n\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t: \"\";\n\t\t\t\treturn constraintStr ? `${baseType}${constraintStr}` : baseType;\n\t\t\t}\n\t\t\tcase \"variable\": {\n\t\t\t\tlet varStr = \"\";\n\t\t\t\tif (!mapping.has(t.name)) {\n\t\t\t\t\t// If the type variable name is a single letter, keep it as-is\n\t\t\t\t\t// This preserves explicit type annotations like 'a -> a'\n\t\t\t\t\tif (t.name.length === 1 && /^[a-z]$/.test(t.name)) {\n\t\t\t\t\t\tmapping.set(t.name, t.name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmapping.set(t.name, greek[next] || `t${next}`);\n\t\t\t\t\t\tnext++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: it's set if not defined above\n\t\t\t\tvarStr = mapping.get(t.name)!;\n\n\t\t\t\treturn varStr;\n\t\t\t}\n\t\t\tcase \"list\":\n\t\t\t\treturn `List ${norm(t.element)}`;\n\t\t\tcase \"tuple\":\n\t\t\t\treturn `(${t.elements.map(norm).join(\" \")})`;\n\t\t\tcase \"record\":\n\t\t\t\treturn `{ ${Object.entries(t.fields)\n\t\t\t\t\t.map(([name, fieldType]) => `${name}: ${norm(fieldType)}`)\n\t\t\t\t\t.join(\" \")} }`;\n\t\t\tcase \"union\":\n\t\t\t\treturn `(${t.types.map(norm).join(\" | \")})`;\n\t\t\tcase \"variant\":\n\t\t\t\tif (t.args.length === 0) {\n\t\t\t\t\treturn t.name;\n\t\t\t\t} else {\n\t\t\t\t\treturn `${t.name} ${t.args.map(norm).join(\" \")}`;\n\t\t\t\t}\n\t\t\tcase \"unit\":\n\t\t\t\treturn \"unit\";\n\t\t\tcase \"unknown\":\n\t\t\t\treturn \"?\";\n\t\t\tdefault:\n\t\t\t\treturn \"unknown\";\n\t\t}\n\t}\n\n\tfunction formatConstraint(c: Constraint): string {\n\t\tswitch (c.kind) {\n\t\t\tcase \"is\": {\n\t\t\t\t// Use the normalized variable name for consistency\n\t\t\t\tconst normalizedVarName = mapping.get(c.typeVar) || c.typeVar;\n\t\t\t\treturn `${normalizedVarName} is ${c.constraint}`;\n\t\t\t}\n\t\t\tcase \"hasField\": {\n\t\t\t\t// For hasField constraints, we need to use the normalized variable name\n\t\t\t\t// that matches the parameter it's constraining\n\t\t\t\tconst normalizedVarName2 = mapping.get(c.typeVar) || c.typeVar;\n\t\t\t\treturn `${normalizedVarName2} has field \"${c.field}\" of type ${norm(\n\t\t\t\t\tc.fieldType,\n\t\t\t\t)}`;\n\t\t\t}\n\t\t\tcase \"implements\": {\n\t\t\t\tconst normalizedVarName3 = mapping.get(c.typeVar) || c.typeVar;\n\t\t\t\treturn `${normalizedVarName3} implements ${c.interfaceName}`;\n\t\t\t}\n\t\t\tcase \"custom\": {\n\t\t\t\tconst normalizedVarName4 = mapping.get(c.typeVar) || c.typeVar;\n\t\t\t\treturn `${normalizedVarName4} satisfies ${c.constraint} ${c.args\n\t\t\t\t\t.map(norm)\n\t\t\t\t\t.join(\" \")}`;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn \"unknown constraint\";\n\t\t}\n\t}\n\n\tfunction formatConstraintExpr(expr: ConstraintExpr): string {\n\t\tswitch (expr.kind) {\n\t\t\tcase \"is\":\n\t\t\tcase \"hasField\":\n\t\t\tcase \"implements\":\n\t\t\tcase \"custom\":\n\t\t\t\treturn formatConstraint(expr);\n\t\t\tcase \"and\":\n\t\t\t\treturn `${formatConstraintExpr(expr.left)} and ${formatConstraintExpr(\n\t\t\t\t\texpr.right,\n\t\t\t\t)}`;\n\t\t\tcase \"or\":\n\t\t\t\treturn `${formatConstraintExpr(expr.left)} or ${formatConstraintExpr(\n\t\t\t\t\texpr.right,\n\t\t\t\t)}`;\n\t\t\tcase \"paren\":\n\t\t\t\treturn `(${formatConstraintExpr(expr.expr)})`;\n\t\t\tdefault:\n\t\t\t\treturn \"unknown constraint\";\n\t\t}\n\t}\n\n\t// Helper function to deduplicate constraints\n\tfunction deduplicateConstraints(constraints: Constraint[]): Constraint[] {\n\t\tconst result: Constraint[] = [];\n\n\t\tfor (const constraint of constraints) {\n\t\t\tconst isDuplicate = result.some((c) => constraintsEqual(c, constraint));\n\t\t\tif (!isDuplicate) {\n\t\t\t\tresult.push(constraint);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// Apply substitution to the type before normalizing\n\tconst substitutedType = substitute(type, substitution);\n\treturn norm(substitutedType);\n};\n\n// Check if a type variable occurs in a type (for occurs check)\nexport const occursIn = (varName: string, type: Type): boolean => {\n\tswitch (type.kind) {\n\t\tcase \"variable\":\n\t\t\treturn type.name === varName;\n\t\tcase \"function\":\n\t\t\treturn (\n\t\t\t\ttype.params.some((param) => occursIn(varName, param)) ||\n\t\t\t\toccursIn(varName, type.return)\n\t\t\t);\n\t\tcase \"list\":\n\t\t\treturn occursIn(varName, type.element);\n\t\tcase \"tuple\":\n\t\t\treturn type.elements.some((element) => occursIn(varName, element));\n\t\tcase \"record\":\n\t\t\treturn Object.values(type.fields).some((fieldType) =>\n\t\t\t\toccursIn(varName, fieldType),\n\t\t\t);\n\t\tcase \"union\":\n\t\t\treturn type.types.some((t) => occursIn(varName, t));\n\t\tcase \"variant\":\n\t\t\treturn type.args.some((arg) => occursIn(varName, arg));\n\t\tdefault:\n\t\t\treturn false;\n\t}\n};"],"version":3}