{"file":"/workspace/src/typer/pattern-matching.ts","mappings":"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","names":[],"sources":["/workspace/src/typer/pattern-matching.ts"],"sourcesContent":["import {\n\ttype TypeDefinitionExpression,\n\ttype MatchExpression,\n\ttype MatchCase,\n\ttype Pattern,\n\ttype Type,\n\ttypeVariable,\n\tfunctionType,\n\tunitType,\n\tintType,\n\tstringType,\n} from '../ast';\nimport { \n\ttype TypeState, \n\ttype TypeResult, \n\tcreateTypeResult, \n\tcreatePureTypeResult, \n\tunionEffects \n} from './types';\nimport { substitute } from './substitute';\nimport { unify } from './unify';\nimport { freshTypeVariable } from './type-operations';\nimport { typeExpression } from './expression-dispatcher';\nimport { isTypeKind, typeToString } from './helpers';\n\n// Type inference for ADT type definitions\nexport const typeTypeDefinition = (\n\texpr: TypeDefinitionExpression,\n\tstate: TypeState,\n): TypeResult => {\n\t// Register the ADT in the registry first to enable recursive references\n\tconst constructorMap = new Map<string, Type[]>();\n\n\t// Pre-register the ADT so recursive references work\n\tconst newRegistry = new Map(state.adtRegistry);\n\tnewRegistry.set(expr.name, {\n\t\ttypeParams: expr.typeParams,\n\t\tconstructors: constructorMap, // Will be filled\n\t});\n\n\t// Also add the ADT type constructor to the environment\n\tconst adtType = {\n\t\tkind: \"variant\" as const,\n\t\tname: expr.name,\n\t\targs: expr.typeParams.map((param) => typeVariable(param)),\n\t};\n\tconst envWithType = new Map(state.environment);\n\tenvWithType.set(expr.name, {\n\t\ttype: adtType,\n\t\tquantifiedVars: expr.typeParams,\n\t});\n\n\tstate = { ...state, adtRegistry: newRegistry, environment: envWithType };\n\n\t// Process each constructor\n\tfor (const _constructor of expr.constructors) {\n\t\tconstructorMap.set(_constructor.name, _constructor.args);\n\n\t\t// Add constructor to environment as a function\n\t\t// Constructor type: arg1 -> arg2 -> ... -> ADTType typeParams\n\t\tconst adtType: Type = {\n\t\t\tkind: \"variant\",\n\t\t\tname: expr.name,\n\t\t\targs: expr.typeParams.map((param) => typeVariable(param)),\n\t\t};\n\n\t\tlet constructorType: Type;\n\t\tif (_constructor.args.length === 0) {\n\t\t\t// Nullary constructor: just the ADT type\n\t\t\tconstructorType = adtType;\n\t\t} else {\n\t\t\t// N-ary constructor: function from args to ADT type\n\t\t\tconstructorType = functionType(_constructor.args, adtType);\n\t\t}\n\n\t\t// Add constructor to environment\n\t\tconst newEnv = new Map(state.environment);\n\t\tnewEnv.set(_constructor.name, {\n\t\t\ttype: constructorType,\n\t\t\tquantifiedVars: expr.typeParams,\n\t\t});\n\t\tstate = { ...state, environment: newEnv };\n\t}\n\n\t// Update ADT registry with completed constructor map\n\tconst finalRegistry = new Map(state.adtRegistry);\n\tfinalRegistry.set(expr.name, {\n\t\ttypeParams: expr.typeParams,\n\t\tconstructors: constructorMap,\n\t});\n\n\t// Type definitions return unit and update state\n\treturn createPureTypeResult(\n\t\tunitType(),\n\t\t{ ...state, adtRegistry: finalRegistry }\n\t);\n};\n\n// Type inference for match expressions\nexport const typeMatch = (\n\texpr: MatchExpression,\n\tstate: TypeState,\n): TypeResult => {\n\t// Type the expression being matched\n\tconst exprResult = typeExpression(expr.expression, state);\n\tlet currentState = exprResult.state;\n\n\t// Type each case and ensure they all return the same type\n\tif (expr.cases.length === 0) {\n\t\tthrow new Error(\"Match expression must have at least one case\");\n\t}\n\n\t// Type first case to get result type\n\tconst firstCaseResult = typeMatchCase(\n\t\texpr.cases[0],\n\t\texprResult.type,\n\t\tcurrentState,\n\t);\n\tcurrentState = firstCaseResult.state;\n\tlet resultType = firstCaseResult.type;\n\tlet allEffects = unionEffects(exprResult.effects, firstCaseResult.effects);\n\n\t// Type remaining cases and unify with result type\n\tfor (let i = 1; i < expr.cases.length; i++) {\n\t\tconst caseResult = typeMatchCase(\n\t\t\texpr.cases[i],\n\t\t\texprResult.type,\n\t\t\tcurrentState,\n\t\t);\n\t\tcurrentState = caseResult.state;\n\t\tallEffects = unionEffects(allEffects, caseResult.effects);\n\n\t\t// Unify case result type with overall result type\n\t\tcurrentState = unify(\n\t\t\tresultType,\n\t\t\tcaseResult.type,\n\t\t\tcurrentState,\n\t\t\texpr.cases[i].location.start,\n\t\t);\n\t\tresultType = substitute(resultType, currentState.substitution);\n\t}\n\n\treturn createTypeResult(resultType, allEffects, currentState);\n};\n\n// Type a single match case\nconst typeMatchCase = (\n\tmatchCase: MatchCase,\n\tmatchedType: Type,\n\tstate: TypeState,\n): TypeResult => {\n\t// Type the pattern and get bindings\n\tconst patternResult = typePattern(matchCase.pattern, matchedType, state);\n\n\t// Create new environment with pattern bindings\n\tconst newEnv = new Map(patternResult.state.environment);\n\tfor (const [name, type] of patternResult.bindings) {\n\t\tnewEnv.set(name, { type, quantifiedVars: [] });\n\t}\n\n\tconst envState = { ...patternResult.state, environment: newEnv };\n\n\t// Type the expression with pattern bindings in scope\n\treturn typeExpression(matchCase.expression, envState);\n};\n\n// Type a pattern and return bindings\nconst typePattern = (\n\tpattern: Pattern,\n\texpectedType: Type,\n\tstate: TypeState,\n): { state: TypeState; bindings: Map<string, Type> } => {\n\tconst bindings = new Map<string, Type>();\n\n\tswitch (pattern.kind) {\n\t\tcase \"wildcard\":\n\t\t\t// Wildcard matches anything, no bindings\n\t\t\treturn { state, bindings };\n\n\t\tcase \"variable\":\n\t\t\t// Variable binds to the expected type\n\t\t\tbindings.set(pattern.name, expectedType);\n\t\t\treturn { state, bindings };\n\n\t\tcase \"constructor\": {\n\t\t\t// Constructor pattern matching with type variable handling\n\t\t\tlet actualType = expectedType;\n\t\t\tlet currentState = state;\n\n\t\t\t// If expected type is a type variable, we need to find the ADT from the constructor\n\t\t\tif (isTypeKind(expectedType, \"variable\")) {\n\t\t\t\t// Find which ADT this constructor belongs to\n\t\t\t\tlet foundAdt: string | null = null;\n\t\t\t\tfor (const [adtName, adtInfo] of state.adtRegistry) {\n\t\t\t\t\tif (adtInfo.constructors.has(pattern.name)) {\n\t\t\t\t\t\tfoundAdt = adtName;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!foundAdt) {\n\t\t\t\t\tthrow new Error(`Unknown constructor: ${pattern.name}`);\n\t\t\t\t}\n\n\t\t\t\t// Create the ADT type with fresh type variables for type parameters\n\t\t\t\tconst adtInfo = state.adtRegistry.get(foundAdt)!;\n\t\t\t\tconst typeArgs: Type[] = [];\n\t\t\t\tconst substitution = new Map<string, Type>();\n\t\t\t\tfor (let i = 0; i < adtInfo.typeParams.length; i++) {\n\t\t\t\t\tconst [freshVar, nextState] = freshTypeVariable(currentState);\n\t\t\t\t\ttypeArgs.push(freshVar);\n\t\t\t\t\tsubstitution.set(adtInfo.typeParams[i], freshVar);\n\t\t\t\t\tcurrentState = nextState;\n\t\t\t\t}\n\t\t\t\tactualType = { kind: \"variant\", name: foundAdt, args: typeArgs };\n\n\t\t\t\t// Unify the type variable with the ADT type\n\t\t\t\tcurrentState = unify(expectedType, actualType, currentState, undefined);\n\t\t\t} else if (!isTypeKind(expectedType, \"variant\")) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Pattern expects constructor but got ${typeToString(\n\t\t\t\t\t\texpectedType,\n\t\t\t\t\t\tstate.substitution,\n\t\t\t\t\t)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Look up constructor in ADT registry\n\t\t\tif (!isTypeKind(actualType, \"variant\")) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Internal error: actualType should be variant but got ${actualType.kind}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst adtInfo = state.adtRegistry.get(actualType.name);\n\t\t\tif (!adtInfo) {\n\t\t\t\tthrow new Error(`Unknown ADT: ${actualType.name}`);\n\t\t\t}\n\n\t\t\tconst constructorArgs = adtInfo.constructors.get(pattern.name);\n\t\t\tif (!constructorArgs) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Unknown constructor: ${pattern.name} for ADT ${actualType.name}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Create a substitution from type parameters to actual type arguments\n\t\t\tconst paramSubstitution = new Map<string, Type>();\n\t\t\tfor (let i = 0; i < adtInfo.typeParams.length; i++) {\n\t\t\t\tparamSubstitution.set(adtInfo.typeParams[i], actualType.args[i]);\n\t\t\t}\n\n\t\t\t// Substitute type parameters with actual type arguments\n\t\t\tconst substitutedArgs = constructorArgs.map((arg) =>\n\t\t\t\tsubstitute(arg, paramSubstitution),\n\t\t\t);\n\n\t\t\t// Check argument count\n\t\t\tif (pattern.args.length !== substitutedArgs.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Constructor ${pattern.name} expects ${substitutedArgs.length} arguments but got ${pattern.args.length}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Type each argument pattern\n\t\t\tfor (let i = 0; i < pattern.args.length; i++) {\n\t\t\t\tconst argResult = typePattern(\n\t\t\t\t\tpattern.args[i],\n\t\t\t\t\tsubstitutedArgs[i],\n\t\t\t\t\tcurrentState,\n\t\t\t\t);\n\t\t\t\tcurrentState = argResult.state;\n\n\t\t\t\t// Merge bindings\n\t\t\t\tfor (const [name, type] of argResult.bindings) {\n\t\t\t\t\tbindings.set(name, type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { state: currentState, bindings };\n\t\t}\n\n\t\tcase \"literal\": {\n\t\t\t// Literal patterns need to match the expected type\n\t\t\tlet literalType: Type;\n\t\t\tif (typeof pattern.value === \"number\") {\n\t\t\t\tliteralType = intType();\n\t\t\t} else if (typeof pattern.value === \"string\") {\n\t\t\t\tliteralType = stringType();\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Unsupported literal pattern: ${pattern.value}`);\n\t\t\t}\n\n\t\t\tconst unifiedState = unify(\n\t\t\t\texpectedType,\n\t\t\t\tliteralType,\n\t\t\t\tstate,\n\t\t\t\tpattern.location.start,\n\t\t\t);\n\t\t\treturn { state: unifiedState, bindings };\n\t\t}\n\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported pattern kind: ${(pattern as Pattern).kind}`);\n\t}\n};"],"version":3}