{"file":"/workspace/src/evaluator.ts","mappings":"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","names":[],"sources":["/workspace/src/evaluator.ts"],"sourcesContent":["import * as defaultFs from \"node:fs\";\nimport * as defaultPath from \"node:path\";\nimport type {\n\tExpression,\n\tProgram,\n\tLiteralExpression,\n\tVariableExpression,\n\tFunctionExpression,\n\tApplicationExpression,\n\tPipelineExpression,\n\tBinaryExpression,\n\tIfExpression,\n\tDefinitionExpression,\n\tImportExpression,\n\tRecordExpression,\n\tAccessorExpression,\n\tTypeDefinitionExpression,\n\tMatchExpression,\n\tPattern,\n\tWhereExpression,\n\tMutableDefinitionExpression,\n\tMutationExpression,\n} from \"./ast\";\nimport { createError } from \"./errors\";\nimport { formatValue } from \"./format\";\nimport { Lexer } from \"./lexer\";\nimport { parse } from \"./parser/parser\";\n\n// Value types (Phase 6: functions and native functions as tagged union)\nexport type Value =\n\t| { tag: \"number\"; value: number }\n\t| { tag: \"string\"; value: string }\n\t| { tag: \"tuple\"; values: Value[] }\n\t| { tag: \"list\"; values: Value[] }\n\t| { tag: \"record\"; fields: { [key: string]: Value } }\n\t| { tag: \"function\"; fn: (...args: Value[]) => Value }\n\t| { tag: \"native\"; name: string; fn: unknown }\n\t| { tag: \"constructor\"; name: string; args: Value[] }\n\t| { tag: \"unit\" };\n\n// --- Mutable Cell type ---\nexport type Cell = { cell: true; value: Value };\nexport const isCell = (val: any): val is Cell =>\n\tval && typeof val === \"object\" && val.cell === true && \"value\" in val;\n\nexport const createCell = (value: Value): Cell => ({ cell: true, value });\n\nexport const isNumber = (\n\tvalue: Value,\n): value is { tag: \"number\"; value: number } => value.tag === \"number\";\n\nexport const createNumber = (value: number): Value => ({\n\ttag: \"number\",\n\tvalue,\n});\n\nexport const isString = (\n\tvalue: Value,\n): value is { tag: \"string\"; value: string } => value.tag === \"string\";\n\nexport const createString = (value: string): Value => ({\n\ttag: \"string\",\n\tvalue,\n});\n\nexport const createTrue = (): Value => ({\n\ttag: \"constructor\",\n\tname: \"True\",\n\targs: [],\n});\n\nexport const createFalse = (): Value => ({\n\ttag: \"constructor\",\n\tname: \"False\",\n\targs: [],\n});\n\nexport const createBool = (value: boolean): Value =>\n\tcreateConstructor(value ? \"True\" : \"False\", []);\n\nexport const isBool = (\n\tvalue: Value,\n): value is { tag: \"constructor\"; name: \"True\" | \"False\"; args: [] } =>\n\tvalue.tag === \"constructor\" &&\n\t(value.name === \"True\" || value.name === \"False\");\n\nexport const boolValue = (value: Value): boolean => {\n\tif (value.tag === \"constructor\" && value.name === \"True\") return true;\n\tif (value.tag === \"constructor\" && value.name === \"False\") return false;\n\tthrow new Error(`Expected Bool constructor, got ${value.tag}`);\n};\n\nexport const isList = (\n\tvalue: Value,\n): value is { tag: \"list\"; values: Value[] } => value.tag === \"list\";\n\nexport const createList = (values: Value[]): Value => ({ tag: \"list\", values });\n\nexport const isRecord = (\n\tvalue: Value,\n): value is { tag: \"record\"; fields: { [key: string]: Value } } =>\n\tvalue.tag === \"record\";\n\nexport const createRecord = (fields: { [key: string]: Value }): Value => ({\n\ttag: \"record\",\n\tfields,\n});\n\nexport const isFunction = (\n\tvalue: Value,\n): value is { tag: \"function\"; fn: (...args: Value[]) => Value } =>\n\tvalue.tag === \"function\";\n\nexport const createFunction = (fn: (...args: Value[]) => Value): Value => ({\n\ttag: \"function\",\n\tfn,\n});\n\nexport const isNativeFunction = (\n\tvalue: Value,\n): value is { tag: \"native\"; name: string; fn: (...args: Value[]) => Value } =>\n\tvalue.tag === \"native\";\n\nexport const createNativeFunction = (name: string, fn: any): Value => {\n\tconst wrap = (fn: any, curriedName: string): Value => ({\n\t\ttag: \"native\",\n\t\tname: curriedName,\n\t\tfn: (...args: Value[]) => {\n\t\t\tconst result = fn(...args);\n\t\t\tif (typeof result === \"function\") {\n\t\t\t\treturn wrap(result, curriedName + \"_curried\");\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t});\n\treturn wrap(fn, name);\n};\n\nexport const isTuple = (\n\tvalue: Value,\n): value is { tag: \"tuple\"; values: Value[] } => value.tag === \"tuple\";\n\nexport const createTuple = (values: Value[]): Value => ({\n\ttag: \"tuple\",\n\tvalues,\n});\n\nexport const isUnit = (value: Value): value is { tag: \"unit\" } =>\n\tvalue.tag === \"unit\";\n\nexport const createUnit = (): Value => ({ tag: \"unit\" });\n\nexport const isConstructor = (\n\tvalue: Value,\n): value is { tag: \"constructor\"; name: string; args: Value[] } =>\n\tvalue.tag === \"constructor\";\n\nexport const createConstructor = (name: string, args: Value[]): Value => ({\n\ttag: \"constructor\",\n\tname,\n\targs,\n});\n\nexport type ExecutionStep = {\n\texpression: string;\n\tresult: Value;\n\ttype?: string;\n\tlocation?: { line: number; column: number };\n};\n\nexport type ProgramResult = {\n\tfinalResult: Value;\n\texecutionTrace: ExecutionStep[];\n\tenvironment: Map<string, Value>;\n};\n\nexport type Environment = Map<string, Value | Cell>;\n\n// Helper to flatten semicolon-separated binary expressions into individual statements\nconst flattenStatements = (expr: Expression): Expression[] => {\n\tif (expr.kind === \"binary\" && expr.operator === \";\") {\n\t\treturn [...flattenStatements(expr.left), ...flattenStatements(expr.right)];\n\t}\n\treturn [expr];\n};\n\nexport class Evaluator {\n\t\tpublic environment: Environment;\n\t\tprivate environmentStack: Environment[]; // Stack for efficient scoping\n\t\tprivate currentFileDir?: string; // Track the directory of the current file being evaluated\n\t\tprivate fs: typeof defaultFs;\n\t\tprivate path: typeof defaultPath;\n\n\t\tconstructor(opts?: {\n\t\t\tfs?: typeof defaultFs;\n\t\t\tpath?: typeof defaultPath;\n\t\t}) {\n\t\t\tthis.fs = opts?.fs ?? defaultFs;\n\t\t\tthis.path = opts?.path ?? defaultPath;\n\t\t\tthis.environment = new Map();\n\t\t\tthis.environmentStack = [];\n\t\t\tthis.initializeBuiltins();\n\t\t\tthis.loadStdlib();\n\t\t}\n\n\t\tprivate initializeBuiltins(): void {\n\t\t\t// Arithmetic operations\n\t\t\tthis.environment.set(\n\t\t\t\t'+',\n\t\t\t\tcreateNativeFunction('+', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b))\n\t\t\t\t\t\treturn createNumber(a.value + b.value);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot add ${a?.tag || 'unit'} and ${b?.tag || 'unit'}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'-',\n\t\t\t\tcreateNativeFunction('-', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b))\n\t\t\t\t\t\treturn createNumber(a.value - b.value);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot subtract ${b?.tag || 'unit'} from ${a?.tag || 'unit'}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'*',\n\t\t\t\tcreateNativeFunction('*', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b))\n\t\t\t\t\t\treturn createNumber(a.value * b.value);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot multiply ${a?.tag || 'unit'} and ${b?.tag || 'unit'}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'/',\n\t\t\t\tcreateNativeFunction('/', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) {\n\t\t\t\t\t\tif (b.value === 0) {\n\t\t\t\t\t\t\tconst error = createError(\n\t\t\t\t\t\t\t\t'RuntimeError',\n\t\t\t\t\t\t\t\t'Division by zero',\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t`${a.value} / ${b.value}`,\n\t\t\t\t\t\t\t\t'Check that the divisor is not zero before dividing'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn createNumber(a.value / b.value);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot divide ${a?.tag || 'unit'} by ${b?.tag || 'unit'}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Comparison operations\n\t\t\tthis.environment.set(\n\t\t\t\t'==',\n\t\t\t\tcreateNativeFunction('==', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) {\n\t\t\t\t\t\treturn createBool(a.value === b.value);\n\t\t\t\t\t} else if (isString(a) && isString(b)) {\n\t\t\t\t\t\treturn createBool(a.value === b.value);\n\t\t\t\t\t} else if (isBool(a) && isBool(b)) {\n\t\t\t\t\t\treturn createBool(boolValue(a) === boolValue(b));\n\t\t\t\t\t} else if (isUnit(a) && isUnit(b)) {\n\t\t\t\t\t\treturn createTrue();\n\t\t\t\t\t} else if (isUnit(a) || isUnit(b)) {\n\t\t\t\t\t\treturn createFalse();\n\t\t\t\t\t}\n\t\t\t\t\treturn createFalse();\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'!=',\n\t\t\t\tcreateNativeFunction('!=', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) {\n\t\t\t\t\t\treturn createBool(a.value !== b.value);\n\t\t\t\t\t} else if (isString(a) && isString(b)) {\n\t\t\t\t\t\treturn createBool(a.value !== b.value);\n\t\t\t\t\t} else if (isBool(a) && isBool(b)) {\n\t\t\t\t\t\treturn createBool(boolValue(a) !== boolValue(b));\n\t\t\t\t\t} else if (isUnit(a) && isUnit(b)) {\n\t\t\t\t\t\treturn createFalse();\n\t\t\t\t\t} else if (isUnit(a) || isUnit(b)) {\n\t\t\t\t\t\treturn createTrue();\n\t\t\t\t\t}\n\t\t\t\t\treturn createTrue();\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'<',\n\t\t\t\tcreateNativeFunction('<', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) return createBool(a.value < b.value);\n\t\t\t\t\tthrow new Error(`Cannot compare ${typeof a} and ${typeof b}`);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'>',\n\t\t\t\tcreateNativeFunction('>', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) return createBool(a.value > b.value);\n\t\t\t\t\tthrow new Error(`Cannot compare ${typeof a} and ${typeof b}`);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'<=',\n\t\t\t\tcreateNativeFunction('<=', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) return createBool(a.value <= b.value);\n\t\t\t\t\tthrow new Error(`Cannot compare ${typeof a} and ${typeof b}`);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'>=',\n\t\t\t\tcreateNativeFunction('>=', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b)) return createBool(a.value >= b.value);\n\t\t\t\t\tthrow new Error(`Cannot compare ${typeof a} and ${typeof b}`);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Pipeline operator\n\t\t\tthis.environment.set(\n\t\t\t\t'|',\n\t\t\t\tcreateNativeFunction('|', (value: Value) => (func: Value) => {\n\t\t\t\t\tif (isFunction(func)) return func.fn(value);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot apply non-function in thrush: ${func?.tag || 'unit'}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Left-to-right composition\n\t\t\tthis.environment.set(\n\t\t\t\t'|>',\n\t\t\t\tcreateNativeFunction('|>', (f: Value) => (g: Value) => {\n\t\t\t\t\tif (isFunction(f) && isFunction(g)) {\n\t\t\t\t\t\treturn createFunction((x: Value) => g.fn(f.fn(x)));\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot compose non-functions: ${f?.tag || 'unit'} and ${\n\t\t\t\t\t\t\tg?.tag || 'unit'\n\t\t\t\t\t\t}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Right-to-left composition\n\t\t\tthis.environment.set(\n\t\t\t\t'<|',\n\t\t\t\tcreateNativeFunction('<|', (f: Value) => (g: Value) => {\n\t\t\t\t\tif (isFunction(f) && isFunction(g)) {\n\t\t\t\t\t\treturn createFunction((x: Value) => f.fn(g.fn(x)));\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot compose non-functions: ${f?.tag || 'unit'} and ${\n\t\t\t\t\t\t\tg?.tag || 'unit'\n\t\t\t\t\t\t}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Semicolon operator\n\t\t\tthis.environment.set(\n\t\t\t\t';',\n\t\t\t\tcreateNativeFunction(';', (_left: Value) => (right: Value) => right)\n\t\t\t);\n\n\t\t\t// Dollar operator (low precedence function application)\n\t\t\tthis.environment.set(\n\t\t\t\t'$',\n\t\t\t\tcreateNativeFunction('$', (func: Value) => (arg: Value) => {\n\t\t\t\t\tif (isFunction(func)) return func.fn(arg);\n\t\t\t\t\tif (isNativeFunction(func)) return func.fn(arg);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot apply non-function in dollar operator: ${\n\t\t\t\t\t\t\tfunc?.tag || 'unit'\n\t\t\t\t\t\t}`\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// List operations - minimal built-ins for self-hosted functions\n\t\t\tthis.environment.set(\n\t\t\t\t'list_get',\n\t\t\t\tcreateNativeFunction('list_get', (index: Value) => (list: Value) => {\n\t\t\t\t\tif (isNumber(index) && isList(list)) {\n\t\t\t\t\t\tconst idx = index.value;\n\t\t\t\t\t\tif (idx >= 0 && idx < list.values.length) {\n\t\t\t\t\t\t\treturn list.values[idx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('list_get: invalid index or not a list');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// List operations\n\t\t\tthis.environment.set(\n\t\t\t\t'tail',\n\t\t\t\tcreateNativeFunction('tail', (list: Value) => {\n\t\t\t\t\tif (isList(list) && list.values.length > 0)\n\t\t\t\t\t\treturn createList(list.values.slice(1));\n\t\t\t\t\tthrow new Error('Cannot get tail of empty list or non-list');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'cons',\n\t\t\t\tcreateNativeFunction('cons', (head: Value) => (tail: Value) => {\n\t\t\t\t\tif (isList(tail)) return createList([head, ...tail.values]);\n\t\t\t\t\tthrow new Error('Second argument to cons must be a list');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// List utility functions\n\t\t\tthis.environment.set(\n\t\t\t\t'map',\n\t\t\t\tcreateNativeFunction('map', (func: Value) => (list: Value) => {\n\t\t\t\t\tif (isFunction(func) && isList(list)) {\n\t\t\t\t\t\treturn createList(list.values.map((item: Value) => func.fn(item)));\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('map requires a function and a list');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'filter',\n\t\t\t\tcreateNativeFunction('filter', (pred: Value) => (list: Value) => {\n\t\t\t\t\tif (isFunction(pred) && isList(list)) {\n\t\t\t\t\t\treturn createList(\n\t\t\t\t\t\t\tlist.values.filter((item: Value) => {\n\t\t\t\t\t\t\t\tconst result = pred.fn(item);\n\t\t\t\t\t\t\t\tif (isBool(result)) {\n\t\t\t\t\t\t\t\t\treturn boolValue(result);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// For non-boolean results, treat as truthy/falsy\n\t\t\t\t\t\t\t\treturn !isUnit(result);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('filter requires a predicate function and a list');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'reduce',\n\t\t\t\tcreateNativeFunction(\n\t\t\t\t\t'reduce',\n\t\t\t\t\t(func: Value) => (initial: Value) => (list: Value) => {\n\t\t\t\t\t\tif (isFunction(func) && isList(list)) {\n\t\t\t\t\t\t\treturn list.values.reduce((acc: Value, item: Value) => {\n\t\t\t\t\t\t\t\tconst partial = func.fn(acc);\n\t\t\t\t\t\t\t\tif (isFunction(partial)) {\n\t\t\t\t\t\t\t\t\treturn partial.fn(item);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t'reduce function must return a function after first argument'\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}, initial);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'reduce requires a function, initial value, and a list'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'length',\n\t\t\t\tcreateNativeFunction('length', (list: Value) => {\n\t\t\t\t\tif (isList(list)) return createNumber(list.values.length);\n\t\t\t\t\tthrow new Error('length requires a list');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'isEmpty',\n\t\t\t\tcreateNativeFunction('isEmpty', (list: Value) => {\n\t\t\t\t\tif (isList(list)) return createBool(list.values.length === 0);\n\t\t\t\t\tthrow new Error('isEmpty requires a list');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'append',\n\t\t\t\tcreateNativeFunction('append', (list1: Value) => (list2: Value) => {\n\t\t\t\t\tif (isList(list1) && isList(list2))\n\t\t\t\t\t\treturn createList([...list1.values, ...list2.values]);\n\t\t\t\t\tthrow new Error('append requires two lists');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Math utilities\n\t\t\tthis.environment.set(\n\t\t\t\t'abs',\n\t\t\t\tcreateNativeFunction('abs', (n: Value) => {\n\t\t\t\t\tif (isNumber(n)) return createNumber(Math.abs(n.value));\n\t\t\t\t\tthrow new Error('abs requires a number');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'max',\n\t\t\t\tcreateNativeFunction('max', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b))\n\t\t\t\t\t\treturn createNumber(Math.max(a.value, b.value));\n\t\t\t\t\tthrow new Error('max requires two numbers');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'min',\n\t\t\t\tcreateNativeFunction('min', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isNumber(a) && isNumber(b))\n\t\t\t\t\t\treturn createNumber(Math.min(a.value, b.value));\n\t\t\t\t\tthrow new Error('min requires two numbers');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Effectful functions\n\t\t\tthis.environment.set(\n\t\t\t\t'print',\n\t\t\t\tcreateNativeFunction('print', (value: Value) => {\n\t\t\t\t\tconsole.log(formatValue(value));\n\t\t\t\t\treturn value; // Return the value that was printed\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// String utilities\n\t\t\tthis.environment.set(\n\t\t\t\t'concat',\n\t\t\t\tcreateNativeFunction('concat', (a: Value) => (b: Value) => {\n\t\t\t\t\tif (isString(a) && isString(b))\n\t\t\t\t\t\treturn createString(a.value + b.value);\n\t\t\t\t\tthrow new Error('concat requires two strings');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'toString',\n\t\t\t\tcreateNativeFunction('toString', (value: Value) =>\n\t\t\t\t\tcreateString(valueToString(value))\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// Record utilities\n\t\t\tthis.environment.set(\n\t\t\t\t'hasKey',\n\t\t\t\tcreateNativeFunction('hasKey', (record: Value) => (key: Value) => {\n\t\t\t\t\tif (isRecord(record) && isString(key)) {\n\t\t\t\t\t\treturn createBool(key.value in record.fields);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('hasKey requires a record and a string key');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'hasValue',\n\t\t\t\tcreateNativeFunction('hasValue', (record: Value) => (value: Value) => {\n\t\t\t\t\tif (isRecord(record)) {\n\t\t\t\t\t\treturn createBool(Object.values(record.fields).includes(value));\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('hasValue requires a record');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'set',\n\t\t\t\tcreateNativeFunction(\n\t\t\t\t\t'set',\n\t\t\t\t\t(accessor: Value) => (record: Value) => (newValue: Value) => {\n\t\t\t\t\t\tif (isNativeFunction(accessor) && isRecord(record)) {\n\t\t\t\t\t\t\t// For now, just handle simple field accessors\n\t\t\t\t\t\t\tconst field = accessor.name?.replace('@', '');\n\t\t\t\t\t\t\tif (field) {\n\t\t\t\t\t\t\t\treturn createRecord({ ...record.fields, [field]: newValue });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new Error('set requires an accessor, record, and new value');\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// Tuple operations\n\t\t\tthis.environment.set(\n\t\t\t\t'tupleLength',\n\t\t\t\tcreateNativeFunction('tupleLength', (tuple: Value) => {\n\t\t\t\t\tif (isTuple(tuple)) {\n\t\t\t\t\t\treturn createNumber(tuple.values.length);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('tupleLength requires a tuple');\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.environment.set(\n\t\t\t\t'tupleIsEmpty',\n\t\t\t\tcreateNativeFunction('tupleIsEmpty', (tuple: Value) => {\n\t\t\t\t\tif (isTuple(tuple)) {\n\t\t\t\t\t\treturn createBool(tuple.values.length === 0);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('tupleIsEmpty requires a tuple');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Built-in ADT constructors are now self-hosted in stdlib.noo\n\n\t\t\t// Option utility functions\n\t\t\tthis.environment.set(\n\t\t\t\t'isSome',\n\t\t\t\tcreateNativeFunction('isSome', (option: Value) => {\n\t\t\t\t\tif (isConstructor(option) && option.name === 'Some') {\n\t\t\t\t\t\treturn createTrue();\n\t\t\t\t\t} else if (isConstructor(option) && option.name === 'None') {\n\t\t\t\t\t\treturn createFalse();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('isSome requires an Option value');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'isNone',\n\t\t\t\tcreateNativeFunction('isNone', (option: Value) => {\n\t\t\t\t\tif (isConstructor(option) && option.name === 'None') {\n\t\t\t\t\t\treturn createTrue();\n\t\t\t\t\t} else if (isConstructor(option) && option.name === 'Some') {\n\t\t\t\t\t\treturn createFalse();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('isNone requires an Option value');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'unwrap',\n\t\t\t\tcreateNativeFunction('unwrap', (option: Value) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tisConstructor(option) &&\n\t\t\t\t\t\toption.name === 'Some' &&\n\t\t\t\t\t\toption.args.length === 1\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn option.args[0];\n\t\t\t\t\t} else if (isConstructor(option) && option.name === 'None') {\n\t\t\t\t\t\tthrow new Error('Cannot unwrap None value');\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('unwrap requires a Some value');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Result utility functions\n\t\t\tthis.environment.set(\n\t\t\t\t'isOk',\n\t\t\t\tcreateNativeFunction('isOk', (result: Value) => {\n\t\t\t\t\tif (isConstructor(result) && result.name === 'Ok') {\n\t\t\t\t\t\treturn createTrue();\n\t\t\t\t\t} else if (isConstructor(result) && result.name === 'Err') {\n\t\t\t\t\t\treturn createFalse();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('isOk requires a Result value');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'isErr',\n\t\t\t\tcreateNativeFunction('isErr', (result: Value) => {\n\t\t\t\t\tif (isConstructor(result) && result.name === 'Err') {\n\t\t\t\t\t\treturn createTrue();\n\t\t\t\t\t} else if (isConstructor(result) && result.name === 'Ok') {\n\t\t\t\t\t\treturn createFalse();\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error('isErr requires a Result value');\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Missing builtin implementations\n\t\t\tthis.environment.set(\n\t\t\t\t'println',\n\t\t\t\tcreateNativeFunction('println', (value: Value) => {\n\t\t\t\t\tconsole.log(valueToString(value));\n\t\t\t\t\treturn value;\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'readFile',\n\t\t\t\tcreateNativeFunction('readFile', (path: Value) => {\n\t\t\t\t\tif (!isString(path)) {\n\t\t\t\t\t\tthrow new Error('readFile requires a string path');\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst content = this.fs.readFileSync(path.value, 'utf-8');\n\t\t\t\t\t\treturn createString(content);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthrow new Error(`Failed to read file: ${error}`);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'writeFile',\n\t\t\t\tcreateNativeFunction('writeFile', (path: Value) => (content: Value) => {\n\t\t\t\t\tif (!isString(path)) {\n\t\t\t\t\t\tthrow new Error('writeFile requires a string path');\n\t\t\t\t\t}\n\t\t\t\t\tif (!isString(content)) {\n\t\t\t\t\t\tthrow new Error('writeFile requires string content');\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.fs.writeFileSync(path.value, content.value);\n\t\t\t\t\t\treturn createUnit();\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthrow new Error(`Failed to write file: ${error}`);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'log',\n\t\t\t\tcreateNativeFunction('log', (message: Value) => {\n\t\t\t\t\tif (!isString(message)) {\n\t\t\t\t\t\tthrow new Error('log requires a string message');\n\t\t\t\t\t}\n\t\t\t\t\tconsole.log(`[LOG] ${message.value}`);\n\t\t\t\t\treturn createUnit();\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'random',\n\t\t\t\tcreateNativeFunction('random', () => {\n\t\t\t\t\treturn createNumber(\n\t\t\t\t\t\tMath.floor(Math.random() * Number.MAX_SAFE_INTEGER)\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'randomRange',\n\t\t\t\tcreateNativeFunction('randomRange', (min: Value) => (max: Value) => {\n\t\t\t\t\tif (!isNumber(min) || !isNumber(max)) {\n\t\t\t\t\t\tthrow new Error('randomRange requires number arguments');\n\t\t\t\t\t}\n\t\t\t\t\tconst minVal = Math.min(min.value, max.value);\n\t\t\t\t\tconst maxVal = Math.max(min.value, max.value);\n\t\t\t\t\treturn createNumber(\n\t\t\t\t\t\tMath.floor(Math.random() * (maxVal - minVal + 1)) + minVal\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'mutSet',\n\t\t\t\tcreateNativeFunction('mutSet', (ref: Value) => (value: Value) => {\n\t\t\t\t\tif (!isCell(ref)) {\n\t\t\t\t\t\tthrow new Error('mutSet requires a mutable reference');\n\t\t\t\t\t}\n\t\t\t\t\tref.value = value;\n\t\t\t\t\treturn createUnit();\n\t\t\t\t})\n\t\t\t);\n\n\t\t\tthis.environment.set(\n\t\t\t\t'mutGet',\n\t\t\t\tcreateNativeFunction('mutGet', (ref: Value) => {\n\t\t\t\t\tif (!isCell(ref)) {\n\t\t\t\t\t\tthrow new Error('mutGet requires a mutable reference');\n\t\t\t\t\t}\n\t\t\t\t\treturn ref.value;\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\tprivate loadStdlib(): void {\n\t\t\t// Try multiple possible paths for stdlib.noo\n\t\t\tconst possiblePaths = [\n\t\t\t\tthis.path.join(__dirname, '..', 'stdlib.noo'),\n\t\t\t\tthis.path.join(process.cwd(), 'stdlib.noo'),\n\t\t\t\tthis.path.join(process.cwd(), 'src', '..', 'stdlib.noo'),\n\t\t\t];\n\n\n\n\t\t\tlet stdlibPath: string | null = null;\n\t\t\tfor (const path of possiblePaths) {\n\t\t\t\tif (this.fs.existsSync(path)) {\n\t\t\t\t\tstdlibPath = path;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!stdlibPath) {\n\t\t\t\tconst msg = `[Noolang ERROR] Could not find stdlib.noo in any of these paths:\\n  ${possiblePaths.join(\n\t\t\t\t\t'\\n  '\n\t\t\t\t)}`;\n\t\t\t\tconsole.error(msg);\n\t\t\t\tthrow new Error(msg);\n\t\t\t}\n\t\t\tconst stdlibContent = this.fs.readFileSync(stdlibPath, 'utf-8');\n\t\t\tconst lexer = new Lexer(stdlibContent);\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tconst stdlibProgram = parse(tokens);\n\t\t\tconst allStatements: Expression[] = [];\n\t\t\tfor (const statement of stdlibProgram.statements) {\n\t\t\t\tallStatements.push(...flattenStatements(statement));\n\t\t\t}\n\t\t\tfor (const statement of allStatements) {\n\t\t\t\tthis.evaluateExpression(statement);\n\t\t\t}\n\t\t}\n\n\t\tevaluateProgram(program: Program, filePath?: string): ProgramResult {\n\t\t\tif (filePath) {\n\t\t\t\tthis.currentFileDir = this.path.dirname(this.path.resolve(filePath));\n\t\t\t}\n\n\t\t\tconst executionTrace: ExecutionStep[] = [];\n\n\t\t\tif (program.statements.length === 0) {\n\t\t\t\treturn {\n\t\t\t\t\tfinalResult: createList([]),\n\t\t\t\t\texecutionTrace,\n\t\t\t\t\tenvironment: new Map(\n\t\t\t\t\t\tArray.from(this.environment.entries()).map(([k, v]) => [\n\t\t\t\t\t\t\tk,\n\t\t\t\t\t\t\tisCell(v) ? v.value : v,\n\t\t\t\t\t\t]),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tlet finalResult: Value = createList([]);\n\n\t\t\tfor (const statement of program.statements) {\n\t\t\t\tconst result = this.evaluateExpression(statement);\n\n\t\t\t\t// Add to execution trace\n\t\t\t\texecutionTrace.push({\n\t\t\t\t\texpression: this.expressionToString(statement),\n\t\t\t\t\tresult: result,\n\t\t\t\t\tlocation: {\n\t\t\t\t\t\tline: statement.location.start.line,\n\t\t\t\t\t\tcolumn: statement.location.start.column,\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tfinalResult = result;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tfinalResult,\n\t\t\t\texecutionTrace,\n\t\t\t\tenvironment: new Map(\n\t\t\t\t\tArray.from(this.environment.entries()).map(([k, v]) => [\n\t\t\t\t\t\tk,\n\t\t\t\t\t\tisCell(v) ? v.value : v,\n\t\t\t\t\t]),\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\n\t\tprivate evaluateDefinition(def: DefinitionExpression): Value {\n\t\t\t// Check if this definition might be recursive by looking for the name in the value\n\t\t\tconst isRecursive = this.containsVariable(def.value, def.name);\n\n\t\t\tif (isRecursive) {\n\t\t\t\t// For recursive definitions, we need a placeholder that gets updated\n\t\t\t\tconst cell = createCell(createUnit());\n\t\t\t\tthis.environment.set(def.name, cell);\n\t\t\t\tconst value = this.evaluateExpression(def.value);\n\t\t\t\tcell.value = value;\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\t// For non-recursive definitions, store the value directly\n\t\t\t\tconst value = this.evaluateExpression(def.value);\n\t\t\t\tthis.environment.set(def.name, value);\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluateMutableDefinition(\n\t\t\texpr: MutableDefinitionExpression,\n\t\t): Value {\n\t\t\t// Evaluate the right-hand side\n\t\t\tconst value = this.evaluateExpression(expr.value);\n\t\t\t// Store a cell in the environment\n\t\t\tthis.environment.set(expr.name, createCell(value));\n\t\t\treturn value;\n\t\t}\n\n\t\tprivate evaluateMutation(expr: MutationExpression): Value {\n\t\t\t// Look up the variable in the environment\n\t\t\tconst cell = this.environment.get(expr.target);\n\t\t\tif (!isCell(cell)) {\n\t\t\t\tthrow new Error(`Cannot mutate non-mutable variable: ${expr.target}`);\n\t\t\t}\n\t\t\t// Evaluate the new value\n\t\t\tconst value = this.evaluateExpression(expr.value);\n\t\t\t// Update the cell's value\n\t\t\tcell.value = value;\n\t\t\treturn value;\n\t\t}\n\n\t\tevaluateExpression(expr: Expression): Value {\n\t\t\tswitch (expr.kind) {\n\t\t\t\tcase \"literal\":\n\t\t\t\t\treturn this.evaluateLiteral(expr);\n\n\t\t\t\tcase \"variable\":\n\t\t\t\t\treturn this.evaluateVariable(expr);\n\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn this.evaluateFunction(expr);\n\n\t\t\t\tcase \"application\":\n\t\t\t\t\treturn this.evaluateApplication(expr);\n\n\t\t\t\tcase \"pipeline\":\n\t\t\t\t\treturn this.evaluatePipeline(expr);\n\n\t\t\t\tcase \"binary\":\n\t\t\t\t\treturn this.evaluateBinary(expr);\n\n\t\t\t\tcase \"if\":\n\t\t\t\t\treturn this.evaluateIf(expr);\n\n\t\t\t\tcase \"definition\":\n\t\t\t\t\treturn this.evaluateDefinition(expr);\n\n\t\t\t\tcase \"mutable-definition\":\n\t\t\t\t\treturn this.evaluateMutableDefinition(expr);\n\n\t\t\t\tcase \"mutation\":\n\t\t\t\t\treturn this.evaluateMutation(expr);\n\n\t\t\t\tcase \"import\":\n\t\t\t\t\treturn this.evaluateImport(expr);\n\n\t\t\t\tcase \"record\":\n\t\t\t\t\treturn this.evaluateRecord(expr);\n\n\t\t\t\tcase \"accessor\":\n\t\t\t\t\treturn this.evaluateAccessor(expr);\n\n\t\t\t\tcase \"tuple\": {\n\t\t\t\t\t// Evaluate all elements and return a tagged tuple value\n\t\t\t\t\tconst elements = expr.elements.map((e) => {\n\t\t\t\t\t\tlet val = this.evaluateExpression(e);\n\t\t\t\t\t\tif (isCell(val)) val = val.value;\n\t\t\t\t\t\treturn val;\n\t\t\t\t\t});\n\t\t\t\t\treturn createTuple(elements);\n\t\t\t\t}\n\t\t\t\tcase \"unit\": {\n\t\t\t\t\t// Return unit value\n\t\t\t\t\treturn createUnit();\n\t\t\t\t}\n\t\t\t\tcase \"list\": {\n\t\t\t\t\t// Evaluate all elements and return a tagged list value\n\t\t\t\t\tconst elements = expr.elements.map((e) => {\n\t\t\t\t\t\tlet val = this.evaluateExpression(e);\n\t\t\t\t\t\tif (isCell(val)) val = val.value;\n\t\t\t\t\t\treturn val;\n\t\t\t\t\t});\n\t\t\t\t\treturn createList(elements);\n\t\t\t\t}\n\t\t\t\tcase \"where\": {\n\t\t\t\t\treturn this.evaluateWhere(expr);\n\t\t\t\t}\n\t\t\t\tcase \"typed\":\n\t\t\t\t\t// Type annotations are erased at runtime; just evaluate the inner expression\n\t\t\t\t\treturn this.evaluateExpression(expr.expression);\n\t\t\t\tcase \"constrained\":\n\t\t\t\t\t// Constraint annotations are erased at runtime; just evaluate the inner expression\n\t\t\t\t\treturn this.evaluateExpression(expr.expression);\n\t\t\t\tcase \"type-definition\":\n\t\t\t\t\treturn this.evaluateTypeDefinition(expr as TypeDefinitionExpression);\n\t\t\t\tcase \"match\":\n\t\t\t\t\treturn this.evaluateMatch(expr as MatchExpression);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unknown expression kind: ${(expr as Expression).kind}`,\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluateLiteral(expr: LiteralExpression): Value {\n\t\t\tif (Array.isArray(expr.value)) {\n\t\t\t\t// If it's a list, evaluate each element\n\t\t\t\treturn createList(\n\t\t\t\t\texpr.value.map((element) => {\n\t\t\t\t\t\tif (element && typeof element === \"object\" && \"kind\" in element) {\n\t\t\t\t\t\t\t// It's an AST node, evaluate it\n\t\t\t\t\t\t\treturn this.evaluateExpression(element as Expression);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// It's already a value\n\t\t\t\t\t\t\treturn element;\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert primitive values to tagged values\n\t\t\tif (typeof expr.value === \"number\") {\n\t\t\t\treturn createNumber(expr.value);\n\t\t\t} else if (typeof expr.value === \"string\") {\n\t\t\t\treturn createString(expr.value);\n\t\t\t} else if (expr.value === null) {\n\t\t\t\t// Handle unit literals (null in AST represents unit)\n\t\t\t\treturn createUnit();\n\t\t\t}\n\n\t\t\t// Should not reach here anymore since we removed boolean literals\n\t\t\tthrow new Error(`Unsupported literal value: ${expr.value}`);\n\t\t}\n\n\t\tprivate evaluateVariable(expr: VariableExpression): Value {\n\t\t\tconst value = this.environment.get(expr.name);\n\t\t\tif (value === undefined) {\n\t\t\t\tconst error = createError(\n\t\t\t\t\t\"RuntimeError\",\n\t\t\t\t\t`Undefined variable: ${expr.name}`,\n\t\t\t\t\t{\n\t\t\t\t\t\tline: expr.location.start.line,\n\t\t\t\t\t\tcolumn: expr.location.start.column,\n\t\t\t\t\t\tstart: expr.location.start.line,\n\t\t\t\t\t\tend: expr.location.end.line,\n\t\t\t\t\t},\n\t\t\t\t\texpr.name,\n\t\t\t\t\t`Define the variable before using it: ${expr.name} = value`,\n\t\t\t\t);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\t// If it's a cell, return its value\n\t\t\tif (isCell(value)) {\n\t\t\t\treturn value.value;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tprivate evaluateFunction(expr: FunctionExpression): Value {\n\t\t\tconst self = this;\n\t\t\t// Create a closure that captures the current environment\n\t\t\tconst closureEnv = new Map(this.environment);\n\n\t\t\tfunction createCurriedFunction(\n\t\t\t\tparams: string[],\n\t\t\t\tbody: Expression,\n\t\t\t): Value {\n\t\t\t\treturn createFunction((arg: Value) => {\n\t\t\t\t\t// Create a new environment for this function call\n\t\t\t\t\tconst callEnv = new Map(closureEnv);\n\n\t\t\t\t\t// Set the parameter in the call environment\n\t\t\t\t\tconst param = params[0];\n\t\t\t\t\tcallEnv.set(param, arg);\n\n\t\t\t\t\tlet result: Value;\n\t\t\t\t\tif (params.length === 1) {\n\t\t\t\t\t\t// Use environment stacking for efficient scoping\n\t\t\t\t\t\tresult = self.withNewEnvironment(() => {\n\t\t\t\t\t\t\tself.environment = callEnv;\n\t\t\t\t\t\t\treturn self.evaluateExpression(body);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Create a function that captures the current parameter\n\t\t\t\t\t\tconst remainingParams = params.slice(1);\n\n\t\t\t\t\t\tconst nextFunction = createFunction((nextArg: Value) => {\n\t\t\t\t\t\t\tconst nextCallEnv = new Map(callEnv);\n\t\t\t\t\t\t\tnextCallEnv.set(remainingParams[0], nextArg);\n\n\t\t\t\t\t\t\tif (remainingParams.length === 1) {\n\t\t\t\t\t\t\t\treturn self.withNewEnvironment(() => {\n\t\t\t\t\t\t\t\t\tself.environment = nextCallEnv;\n\t\t\t\t\t\t\t\t\treturn self.evaluateExpression(body);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Continue currying for remaining parameters\n\t\t\t\t\t\t\t\tconst remainingFunction = self.withNewEnvironment(() => {\n\t\t\t\t\t\t\t\t\tself.environment = nextCallEnv;\n\t\t\t\t\t\t\t\t\treturn self.evaluateFunction({\n\t\t\t\t\t\t\t\t\t\t...expr,\n\t\t\t\t\t\t\t\t\t\tparams: remainingParams,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif (isFunction(remainingFunction)) {\n\t\t\t\t\t\t\t\t\treturn remainingFunction.fn(nextArg);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t`Expected function but got: ${typeof remainingFunction}`,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tresult = nextFunction;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn createCurriedFunction(expr.params, expr.body);\n\t\t}\n\n\t\tprivate evaluateApplication(expr: ApplicationExpression): Value {\n\t\t\tconst func = this.evaluateExpression(expr.func);\n\n\t\t\t// Only apply the function to the arguments present in the AST\n\t\t\tconst args = expr.args;\n\n\t\t\tif (isFunction(func)) {\n\t\t\t\t// Handle tagged function application\n\t\t\t\tlet result: any = func.fn;\n\n\t\t\t\tfor (const argExpr of args) {\n\t\t\t\t\tlet arg = this.evaluateExpression(argExpr);\n\t\t\t\t\tif (isCell(arg)) arg = arg.value;\n\t\t\t\t\tif (typeof result === \"function\") {\n\t\t\t\t\t\tresult = result(arg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Cannot apply argument to non-function: ${typeof result}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t} else if (isNativeFunction(func)) {\n\t\t\t\t// Handle native function application\n\t\t\t\tlet result: any = func.fn;\n\n\t\t\t\tfor (const argExpr of args) {\n\t\t\t\t\tlet arg = this.evaluateExpression(argExpr);\n\t\t\t\t\tif (isCell(arg)) arg = arg.value;\n\t\t\t\t\tif (typeof result === \"function\") {\n\t\t\t\t\t\tresult = result(arg);\n\t\t\t\t\t} else if (isFunction(result)) {\n\t\t\t\t\t\tresult = result.fn(arg);\n\t\t\t\t\t} else if (isNativeFunction(result)) {\n\t\t\t\t\t\tresult = result.fn(arg);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Cannot apply argument to non-function: ${typeof result}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Cannot apply non-function: ${typeof func} (${func?.tag || \"unknown\"})`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluatePipeline(expr: PipelineExpression): Value {\n\t\t\t// Pipeline should be function composition, not function application\n\t\t\t// For a pipeline like f |> g |> h, we want to compose them as h(g(f(x)))\n\n\t\t\tif (expr.steps.length === 1) {\n\t\t\t\treturn this.evaluateExpression(expr.steps[0]);\n\t\t\t}\n\n\t\t\t// Start with the first function\n\t\t\tlet composed = this.evaluateExpression(expr.steps[0]);\n\n\t\t\t// Compose with each subsequent function\n\t\t\tfor (let i = 1; i < expr.steps.length; i++) {\n\t\t\t\tconst nextFunc = this.evaluateExpression(expr.steps[i]);\n\n\t\t\t\tif (isFunction(composed) && isFunction(nextFunc)) {\n\t\t\t\t\t// Compose: nextFunc(composed(x))\n\t\t\t\t\tconst composedFn = composed as {\n\t\t\t\t\t\ttag: \"function\";\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tconst nextFuncFn = nextFunc as {\n\t\t\t\t\t\ttag: \"function\";\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tcomposed = createFunction((x: Value) =>\n\t\t\t\t\t\tnextFuncFn.fn(composedFn.fn(x)),\n\t\t\t\t\t);\n\t\t\t\t} else if (isNativeFunction(composed) && isNativeFunction(nextFunc)) {\n\t\t\t\t\t// Compose: nextFunc(composed(x))\n\t\t\t\t\tconst composedFn = composed as {\n\t\t\t\t\t\ttag: \"native\";\n\t\t\t\t\t\tname: string;\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tconst nextFuncFn = nextFunc as {\n\t\t\t\t\t\ttag: \"native\";\n\t\t\t\t\t\tname: string;\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tcomposed = createFunction((x: Value) =>\n\t\t\t\t\t\tnextFuncFn.fn(composedFn.fn(x)),\n\t\t\t\t\t);\n\t\t\t\t} else if (isFunction(composed) && isNativeFunction(nextFunc)) {\n\t\t\t\t\t// Compose: nextFunc(composed(x))\n\t\t\t\t\tconst composedFn = composed as {\n\t\t\t\t\t\ttag: \"function\";\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tconst nextFuncFn = nextFunc as {\n\t\t\t\t\t\ttag: \"native\";\n\t\t\t\t\t\tname: string;\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tcomposed = createFunction((x: Value) =>\n\t\t\t\t\t\tnextFuncFn.fn(composedFn.fn(x)),\n\t\t\t\t\t);\n\t\t\t\t} else if (isNativeFunction(composed) && isFunction(nextFunc)) {\n\t\t\t\t\t// Compose: nextFunc(composed(x))\n\t\t\t\t\tconst composedFn = composed as {\n\t\t\t\t\t\ttag: \"native\";\n\t\t\t\t\t\tname: string;\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tconst nextFuncFn = nextFunc as {\n\t\t\t\t\t\ttag: \"function\";\n\t\t\t\t\t\tfn: (...args: Value[]) => Value;\n\t\t\t\t\t};\n\t\t\t\t\tcomposed = createFunction((x: Value) =>\n\t\t\t\t\t\tnextFuncFn.fn(composedFn.fn(x)),\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot compose non-functions in pipeline: ${valueToString(\n\t\t\t\t\t\t\tcomposed,\n\t\t\t\t\t\t)} and ${valueToString(nextFunc)}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn composed;\n\t\t}\n\n\t\tprivate evaluateBinary(expr: BinaryExpression): Value {\n\t\t\tif (expr.operator === ';') {\n\t\t\t\t// Handle semicolon operator (sequence)\n\t\t\t\t// Evaluate left expression and discard result\n\t\t\t\tthis.evaluateExpression(expr.left);\n\t\t\t\t// Evaluate and return right expression\n\t\t\t\treturn this.evaluateExpression(expr.right);\n\t\t\t} else if (expr.operator === '|') {\n\t\t\t\t// Handle thrush operator\n\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\n\t\t\t\tif (isFunction(right)) {\n\t\t\t\t\treturn right.fn(left);\n\t\t\t\t} else if (isNativeFunction(right)) {\n\t\t\t\t\treturn right.fn(left);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot apply non-function in thrush: ${valueToString(right)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === '|>') {\n\t\t\t\t// Handle pipeline operator (left-to-right composition)\n\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\n\t\t\t\tif (isFunction(left) && isFunction(right)) {\n\t\t\t\t\t// Left-to-right composition: g(f(x))\n\t\t\t\t\treturn createFunction((x: Value) => right.fn(left.fn(x)));\n\t\t\t\t} else if (isNativeFunction(left) && isNativeFunction(right)) {\n\t\t\t\t\t// Left-to-right composition: g(f(x))\n\t\t\t\t\treturn createFunction((x: Value) => right.fn(left.fn(x)));\n\t\t\t\t} else if (isFunction(left) && isNativeFunction(right)) {\n\t\t\t\t\t// Left-to-right composition: g(f(x))\n\t\t\t\t\treturn createFunction((x: Value) => right.fn(left.fn(x)));\n\t\t\t\t} else if (isNativeFunction(left) && isFunction(right)) {\n\t\t\t\t\t// Left-to-right composition: g(f(x))\n\t\t\t\t\treturn createFunction((x: Value) => right.fn(left.fn(x)));\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot compose non-functions in pipeline: ${valueToString(\n\t\t\t\t\t\t\tleft\n\t\t\t\t\t\t)} and ${valueToString(right)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === '<|') {\n\t\t\t\t// Handle right-to-left composition operator\n\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\n\t\t\t\tif (isFunction(left) && isFunction(right)) {\n\t\t\t\t\t// Right-to-left: f(g(x))\n\t\t\t\t\treturn createFunction((x: Value) => left.fn(right.fn(x)));\n\t\t\t\t} else if (isNativeFunction(left) && isNativeFunction(right)) {\n\t\t\t\t\t// Right-to-left: f(g(x))\n\t\t\t\t\treturn createFunction((x: Value) => left.fn(right.fn(x)));\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot compose non-functions: ${valueToString(\n\t\t\t\t\t\t\tleft\n\t\t\t\t\t\t)} and ${valueToString(right)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Handle other binary operators (arithmetic, comparison, etc.)\n\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\tconst leftVal = isCell(left) ? left.value : left;\n\t\t\t\tconst rightVal = isCell(right) ? right.value : right;\n\n\t\t\t\tconst operator = this.environment.get(expr.operator);\n\t\t\t\tconst operatorVal = isCell(operator) ? operator.value : operator;\n\t\t\t\tif (operatorVal && isNativeFunction(operatorVal)) {\n\t\t\t\t\tconst fn: any = operatorVal.fn(leftVal);\n\t\t\t\t\tif (typeof fn === 'function') {\n\t\t\t\t\t\treturn fn(rightVal);\n\t\t\t\t\t} else if (isFunction(fn)) {\n\t\t\t\t\t\treturn fn.fn(rightVal);\n\t\t\t\t\t} else if (isNativeFunction(fn)) {\n\t\t\t\t\t\treturn fn.fn(rightVal);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Operator ${expr.operator} did not return a function`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(`Unknown operator: ${expr.operator}`);\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluateIf(expr: IfExpression): Value {\n\t\t\tconst condition = this.evaluateExpression(expr.condition);\n\n\t\t\t// Check if condition is truthy - handle tagged boolean values\n\t\t\tlet isTruthy = false;\n\t\t\tif (isBool(condition)) {\n\t\t\t\tisTruthy = boolValue(condition);\n\t\t\t} else if (isNumber(condition)) {\n\t\t\t\tisTruthy = condition.value !== 0;\n\t\t\t} else if (isString(condition)) {\n\t\t\t\tisTruthy = condition.value !== \"\";\n\t\t\t} else if (isUnit(condition)) {\n\t\t\t\tisTruthy = true;\n\t\t\t} else {\n\t\t\t\t// For other types (functions, lists, records), consider them truthy\n\t\t\t\tisTruthy = true;\n\t\t\t}\n\n\t\t\tif (isTruthy) {\n\t\t\t\treturn this.evaluateExpression(expr.then);\n\t\t\t} else {\n\t\t\t\treturn this.evaluateExpression(expr.else);\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluateImport(expr: ImportExpression): Value {\n\t\t\ttry {\n\t\t\t\tconst filePath = expr.path.endsWith(\".noo\")\n\t\t\t\t\t? expr.path\n\t\t\t\t\t: `${expr.path}.noo`;\n\n\t\t\t\tlet fullPath: string;\n\t\t\t\tif (this.path.isAbsolute(filePath)) {\n\t\t\t\t\tfullPath = filePath;\n\t\t\t\t} else if (this.currentFileDir) {\n\t\t\t\t\tfullPath = this.path.resolve(this.currentFileDir, filePath);\n\t\t\t\t} else {\n\t\t\t\t\tfullPath = this.path.resolve(filePath);\n\t\t\t\t}\n\n\t\t\t\tconst content = this.fs.readFileSync(fullPath, \"utf8\");\n\t\t\t\tconst lexer = new Lexer(content);\n\t\t\t\tconst tokens = lexer.tokenize();\n\t\t\t\tconst program = parse(tokens);\n\t\t\t\tconst tempEvaluator = new Evaluator({ fs: this.fs, path: this.path });\n\t\t\t\tconst result = tempEvaluator.evaluateProgram(program, fullPath);\n\t\t\t\treturn result.finalResult;\n\t\t\t} catch (error) {\n\t\t\t\tlet errorMessage: string;\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\terrorMessage = error.message;\n\t\t\t\t\tif (error.stack) {\n\t\t\t\t\t\terrorMessage += \"\\nStack trace:\\n\" + error.stack;\n\t\t\t\t\t}\n\t\t\t\t} else if (typeof error === \"object\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\terrorMessage = JSON.stringify(error, null, 2);\n\t\t\t\t\t} catch (_e) {\n\t\t\t\t\t\terrorMessage = String(error);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrorMessage = String(error);\n\t\t\t\t}\n\t\t\t\tconst cwd = process.cwd();\n\t\t\t\tconst filePath = expr.path.endsWith(\".noo\")\n\t\t\t\t\t? expr.path\n\t\t\t\t\t: `${expr.path}.noo`;\n\n\t\t\t\tlet fullPath: string;\n\t\t\t\tif (this.path.isAbsolute(filePath)) {\n\t\t\t\t\tfullPath = filePath;\n\t\t\t\t} else if (this.currentFileDir) {\n\t\t\t\t\tfullPath = this.path.resolve(this.currentFileDir, filePath);\n\t\t\t\t} else {\n\t\t\t\t\tfullPath = this.path.resolve(filePath);\n\t\t\t\t}\n\n\t\t\t\tconst structuredError = createError(\n\t\t\t\t\t\"ImportError\",\n\t\t\t\t\t`Failed to import '${\n\t\t\t\t\t\texpr.path\n\t\t\t\t\t}': ${errorMessage}\\n  Tried to resolve: ${fullPath}\\n  Current working directory: ${cwd}\\n  Importing file directory: ${\n\t\t\t\t\t\tthis.currentFileDir || \"unknown\"\n\t\t\t\t\t}\\n  Suggestion: Use a path relative to the importing file, e.g., 'math_functions' or '../std/math'`,\n\t\t\t\t\t{\n\t\t\t\t\t\tline: expr.location.start.line,\n\t\t\t\t\t\tcolumn: expr.location.start.column,\n\t\t\t\t\t\tstart: expr.location.start.line,\n\t\t\t\t\t\tend: expr.location.end.line,\n\t\t\t\t\t},\n\t\t\t\t\t`import \"${expr.path}\"`,\n\t\t\t\t\t\"Check that the file exists and can be parsed, and that the path is correct relative to the importing file.\",\n\t\t\t\t);\n\t\t\t\tthrow structuredError;\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluateRecord(expr: RecordExpression): Value {\n\t\t\tconst record: { [key: string]: Value } = {};\n\t\t\tfor (const field of expr.fields) {\n\t\t\t\tlet val = this.evaluateExpression(field.value);\n\t\t\t\tif (isCell(val)) val = val.value;\n\t\t\t\trecord[field.name] = val;\n\t\t\t}\n\t\t\treturn createRecord(record);\n\t\t}\n\n\t\tprivate evaluateAccessor(expr: AccessorExpression): Value {\n\t\t\t// Return a function that takes a record and returns the field value\n\t\t\treturn createNativeFunction(`@${expr.field}`, (record: Value): Value => {\n\t\t\t\tif (isRecord(record)) {\n\t\t\t\t\tconst field = expr.field;\n\t\t\t\t\tif (field in record.fields) {\n\t\t\t\t\t\treturn record.fields[field];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new Error(`Field '${expr.field}' not found in record`);\n\t\t\t});\n\t\t}\n\n\t\tprivate evaluateWhere(expr: WhereExpression): Value {\n\t\t\t// Use environment stacking for where clause\n\t\t\treturn this.withNewEnvironment(() => {\n\t\t\t\t// Evaluate all definitions in the where clause\n\t\t\t\tfor (const def of expr.definitions) {\n\t\t\t\t\tif (def.kind === \"definition\") {\n\t\t\t\t\t\tconst value = this.evaluateExpression(def.value);\n\t\t\t\t\t\tthis.environment.set(def.name, value);\n\t\t\t\t\t} else if (def.kind === \"mutable-definition\") {\n\t\t\t\t\t\tconst value = this.evaluateExpression(def.value);\n\t\t\t\t\t\tthis.environment.set(def.name, createCell(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Evaluate the main expression\n\t\t\t\treturn this.evaluateExpression(expr.main);\n\t\t\t});\n\t\t}\n\n\t\tprivate containsVariable(expr: Expression, varName: string): boolean {\n\t\t\tswitch (expr.kind) {\n\t\t\t\tcase \"variable\":\n\t\t\t\t\treturn expr.name === varName;\n\t\t\t\tcase \"function\":\n\t\t\t\t\t// Don't check function parameters\n\t\t\t\t\treturn this.containsVariable(expr.body, varName);\n\t\t\t\tcase \"application\":\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.containsVariable(expr.func, varName) ||\n\t\t\t\t\t\texpr.args.some((arg) => this.containsVariable(arg, varName))\n\t\t\t\t\t);\n\t\t\t\tcase \"binary\":\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.containsVariable(expr.left, varName) ||\n\t\t\t\t\t\tthis.containsVariable(expr.right, varName)\n\t\t\t\t\t);\n\t\t\t\tcase \"if\":\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.containsVariable(expr.condition, varName) ||\n\t\t\t\t\t\tthis.containsVariable(expr.then, varName) ||\n\t\t\t\t\t\tthis.containsVariable(expr.else, varName)\n\t\t\t\t\t);\n\t\t\t\tcase \"definition\":\n\t\t\t\t\treturn this.containsVariable(expr.value, varName);\n\t\t\t\tcase \"mutable-definition\":\n\t\t\t\t\treturn this.containsVariable(expr.value, varName);\n\t\t\t\tcase \"mutation\":\n\t\t\t\t\treturn (\n\t\t\t\t\t\texpr.target === varName ||\n\t\t\t\t\t\tthis.containsVariable(expr.value, varName)\n\t\t\t\t\t);\n\t\t\t\tcase \"record\":\n\t\t\t\t\treturn expr.fields.some((field) =>\n\t\t\t\t\t\tthis.containsVariable(field.value, varName),\n\t\t\t\t\t);\n\t\t\t\tcase \"tuple\":\n\t\t\t\t\treturn expr.elements.some((element) =>\n\t\t\t\t\t\tthis.containsVariable(element, varName),\n\t\t\t\t\t);\n\t\t\t\tcase \"list\":\n\t\t\t\t\treturn expr.elements.some((element) =>\n\t\t\t\t\t\tthis.containsVariable(element, varName),\n\t\t\t\t\t);\n\t\t\t\tcase \"pipeline\":\n\t\t\t\t\treturn expr.steps.some((step) =>\n\t\t\t\t\t\tthis.containsVariable(step, varName),\n\t\t\t\t\t);\n\t\t\t\tcase \"import\":\n\t\t\t\tcase \"accessor\":\n\t\t\t\tcase \"literal\":\n\t\t\t\tcase \"unit\":\n\t\t\t\tcase \"typed\":\n\t\t\t\t\treturn false;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Efficient environment stack management\n\t\tprivate pushEnvironment(): void {\n\t\t\tthis.environmentStack.push(this.environment);\n\t\t\tthis.environment = new Map(this.environment);\n\t\t}\n\n\t\tprivate popEnvironment(): void {\n\t\t\tif (this.environmentStack[0]) {\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: we checked\n\t\t\t\tthis.environment = this.environmentStack.pop()!;\n\t\t\t}\n\t\t}\n\n\t\tprivate withNewEnvironment<T>(fn: () => T): T {\n\t\t\tthis.pushEnvironment();\n\t\t\ttry {\n\t\t\t\treturn fn();\n\t\t\t} finally {\n\t\t\t\tthis.popEnvironment();\n\t\t\t}\n\t\t}\n\n\t\t// Get the current environment (useful for debugging)\n\t\tgetEnvironment(): Map<string, Value> {\n\t\t\treturn new Map(\n\t\t\t\tArray.from(this.environment.entries()).map(([k, v]) => [\n\t\t\t\t\tk,\n\t\t\t\t\tisCell(v) ? v.value : v,\n\t\t\t\t]),\n\t\t\t);\n\t\t}\n\n\t\tprivate expressionToString(expr: Expression): string {\n\t\t\tswitch (expr.kind) {\n\t\t\t\tcase \"literal\":\n\t\t\t\t\tif (Array.isArray(expr.value)) {\n\t\t\t\t\t\treturn `[${expr.value\n\t\t\t\t\t\t\t.map((e) => this.expressionToString(e as Expression))\n\t\t\t\t\t\t\t.join(\" \")}]`;\n\t\t\t\t\t}\n\t\t\t\t\treturn String(expr.value);\n\t\t\t\tcase \"variable\":\n\t\t\t\t\treturn expr.name;\n\t\t\t\tcase \"function\":\n\t\t\t\t\treturn `fn ${expr.params.join(\" \")} => ${this.expressionToString(\n\t\t\t\t\t\texpr.body,\n\t\t\t\t\t)}`;\n\t\t\t\tcase \"application\":\n\t\t\t\t\treturn `${this.expressionToString(expr.func)} ${expr.args\n\t\t\t\t\t\t.map((arg) => this.expressionToString(arg))\n\t\t\t\t\t\t.join(\" \")}`;\n\t\t\t\tcase \"pipeline\":\n\t\t\t\t\treturn expr.steps\n\t\t\t\t\t\t.map((step) => this.expressionToString(step))\n\t\t\t\t\t\t.join(\" | \");\n\t\t\t\tcase \"binary\":\n\t\t\t\t\treturn `${this.expressionToString(expr.left)} ${\n\t\t\t\t\t\texpr.operator\n\t\t\t\t\t} ${this.expressionToString(expr.right)}`;\n\t\t\t\tcase \"if\":\n\t\t\t\t\treturn `if ${this.expressionToString(\n\t\t\t\t\t\texpr.condition,\n\t\t\t\t\t)} then ${this.expressionToString(\n\t\t\t\t\t\texpr.then,\n\t\t\t\t\t)} else ${this.expressionToString(expr.else)}`;\n\t\t\t\tcase \"definition\":\n\t\t\t\t\treturn `${expr.name} = ${this.expressionToString(expr.value)}`;\n\t\t\t\tcase \"mutable-definition\":\n\t\t\t\t\treturn `${expr.name} = ${this.expressionToString(expr.value)}`;\n\t\t\t\tcase \"mutation\":\n\t\t\t\t\treturn `mut ${expr.target} = ${this.expressionToString(expr.value)}`;\n\t\t\t\tcase \"import\":\n\t\t\t\t\treturn `import \"${expr.path}\"`;\n\t\t\t\tcase \"record\":\n\t\t\t\t\treturn `{ ${expr.fields\n\t\t\t\t\t\t.map(\n\t\t\t\t\t\t\t(field) =>\n\t\t\t\t\t\t\t\t`${field.name} = ${this.expressionToString(field.value)}`,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.join(\", \")} }`;\n\t\t\t\tcase \"accessor\":\n\t\t\t\t\treturn `@${expr.field}`;\n\t\t\t\tcase \"where\":\n\t\t\t\t\treturn `${this.expressionToString(expr.main)} where (${expr.definitions\n\t\t\t\t\t\t.map((d) => this.expressionToString(d))\n\t\t\t\t\t\t.join(\"; \")})`;\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"unknown\";\n\t\t\t}\n\t\t}\n\n\t\tprivate evaluateTypeDefinition(expr: TypeDefinitionExpression): Value {\n\t\t\t// Type definitions add constructors to the environment\n\t\t\tfor (const _constructor of expr.constructors) {\n\t\t\t\tif (_constructor.args.length === 0) {\n\t\t\t\t\t// Nullary constructor: just create the constructor value\n\t\t\t\t\tconst constructorValue = {\n\t\t\t\t\t\ttag: \"constructor\",\n\t\t\t\t\t\tname: _constructor.name,\n\t\t\t\t\t\targs: [],\n\t\t\t\t\t} as Value;\n\t\t\t\t\tthis.environment.set(_constructor.name, constructorValue);\n\t\t\t\t} else {\n\t\t\t\t\t// Create a simple constructor function that collects all arguments\n\t\t\t\t\tconst createCurriedConstructor = (arity: number, name: string) => {\n\t\t\t\t\t\tconst collectArgs = (collectedArgs: Value[] = []): Value => {\n\t\t\t\t\t\t\treturn createFunction((nextArg: Value) => {\n\t\t\t\t\t\t\t\tconst newArgs = [...collectedArgs, nextArg];\n\t\t\t\t\t\t\t\tif (newArgs.length === arity) {\n\t\t\t\t\t\t\t\t\treturn { tag: \"constructor\", name, args: newArgs } as Value;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn collectArgs(newArgs);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn collectArgs();\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.environment.set(\n\t\t\t\t\t\t_constructor.name,\n\t\t\t\t\t\tcreateCurriedConstructor(\n\t\t\t\t\t\t\t_constructor.args.length,\n\t\t\t\t\t\t\t_constructor.name,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Type definitions evaluate to unit\n\t\t\treturn createUnit();\n\t\t}\n\n\t\tprivate evaluateMatch(expr: MatchExpression): Value {\n\t\t\t// Evaluate the expression being matched\n\t\t\tconst value = this.evaluateExpression(expr.expression);\n\n\t\t\t// Try each case until one matches\n\t\t\tfor (const matchCase of expr.cases) {\n\t\t\t\tconst matchResult = this.tryMatchPattern(matchCase.pattern, value);\n\t\t\t\tif (matchResult.matched) {\n\t\t\t\t\t// Use environment stacking for pattern bindings\n\t\t\t\t\treturn this.withNewEnvironment(() => {\n\t\t\t\t\t\t// Add bindings to environment\n\t\t\t\t\t\tfor (const [name, boundValue] of matchResult.bindings) {\n\t\t\t\t\t\t\tthis.environment.set(name, boundValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Evaluate the case expression\n\t\t\t\t\t\treturn this.evaluateExpression(matchCase.expression);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new Error(\"No pattern matched in match expression\");\n\t\t}\n\n\t\tprivate tryMatchPattern(\n\t\t\tpattern: Pattern,\n\t\t\tvalue: Value,\n\t\t): { matched: boolean; bindings: Map<string, Value> } {\n\t\t\tconst bindings = new Map<string, Value>();\n\n\t\t\tswitch (pattern.kind) {\n\t\t\t\tcase \"wildcard\":\n\t\t\t\t\t// Wildcard always matches\n\t\t\t\t\treturn { matched: true, bindings };\n\n\t\t\t\tcase \"variable\":\n\t\t\t\t\t// Variable always matches and binds the value\n\t\t\t\t\tbindings.set(pattern.name, value);\n\t\t\t\t\treturn { matched: true, bindings };\n\n\t\t\t\tcase \"constructor\": {\n\t\t\t\t\t// Constructor pattern only matches constructor values\n\t\t\t\t\tif (value.tag !== \"constructor\") {\n\t\t\t\t\t\treturn { matched: false, bindings };\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check constructor name\n\t\t\t\t\tif (value.name !== pattern.name) {\n\t\t\t\t\t\treturn { matched: false, bindings };\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check argument count\n\t\t\t\t\tif (pattern.args.length !== value.args.length) {\n\t\t\t\t\t\treturn { matched: false, bindings };\n\t\t\t\t\t}\n\n\t\t\t\t\t// Match each argument\n\t\t\t\t\tfor (let i = 0; i < pattern.args.length; i++) {\n\t\t\t\t\t\tconst argMatch = this.tryMatchPattern(\n\t\t\t\t\t\t\tpattern.args[i],\n\t\t\t\t\t\t\tvalue.args[i],\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!argMatch.matched) {\n\t\t\t\t\t\t\treturn { matched: false, bindings };\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Merge bindings\n\t\t\t\t\t\tfor (const [name, boundValue] of argMatch.bindings) {\n\t\t\t\t\t\t\tbindings.set(name, boundValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { matched: true, bindings };\n\t\t\t\t}\n\n\t\t\t\tcase \"literal\": {\n\t\t\t\t\t// Literal pattern matches if values are equal\n\t\t\t\t\tlet matches = false;\n\n\t\t\t\t\tif (typeof pattern.value === \"number\" && isNumber(value)) {\n\t\t\t\t\t\tmatches = pattern.value === value.value;\n\t\t\t\t\t} else if (typeof pattern.value === \"string\" && isString(value)) {\n\t\t\t\t\t\tmatches = pattern.value === value.value;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { matched: matches, bindings };\n\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unsupported pattern kind: ${(pattern as Pattern).kind}`,\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n// Move valueToString to a standalone function\nfunction valueToString(value: Value): string {\n\tif (isNumber(value)) {\n\t\treturn String(value.value);\n\t} else if (isString(value)) {\n\t\treturn `\"${value.value}\"`;\n\t} else if (isBool(value)) {\n\t\treturn boolValue(value) ? \"True\" : \"False\";\n\t} else if (isList(value)) {\n\t\treturn `[${value.values.map(valueToString).join(\"; \")}]`;\n\t} else if (isTuple(value)) {\n\t\treturn `{${value.values.map(valueToString).join(\"; \")}}`;\n\t} else if (isRecord(value)) {\n\t\tconst fields = Object.entries(value.fields)\n\t\t\t.map(([k, v]) => `@${k} ${valueToString(v)}`)\n\t\t\t.join(\"; \");\n\t\treturn `{${fields}}`;\n\t} else if (isFunction(value)) {\n\t\treturn \"<function>\";\n\t} else if (isNativeFunction(value)) {\n\t\treturn `<native:${value.name}>`;\n\t} else if (isConstructor(value)) {\n\t\tif (value.args.length === 0) {\n\t\t\treturn value.name;\n\t\t} else {\n\t\t\treturn `${value.name} ${value.args.map(valueToString).join(\" \")}`;\n\t\t}\n\t} else if (isUnit(value)) {\n\t\treturn \"unit\";\n\t}\n\treturn \"[object Object]\";\n}\n"],"version":3}