{"file":"/workspace/src/typer/__tests__/constraint-resolution.test.ts","mappings":"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","names":[],"sources":["/workspace/src/typer/__tests__/constraint-resolution.test.ts"],"sourcesContent":["import { \n  createConstraintRegistry, \n  addConstraintDefinition, \n  addConstraintImplementation,\n  type ConstraintSignature,\n  type ConstraintImplementation\n} from '../types';\nimport { createTypeState } from '../type-operations';\nimport { \n  tryResolveConstraintFunction,\n  decorateEnvironmentWithConstraintFunctions,\n  resolveConstraintVariable,\n  createConstraintFunctionType\n} from '../constraint-resolution';\nimport { intType, stringType, functionType, listTypeWithElement } from '../../ast';\n\ndescribe('Constraint Resolution', () => {\n  test('should resolve constraint function calls', () => {\n    const state = createTypeState();\n    \n    // Add Show constraint\n    const showSignature: ConstraintSignature = {\n      name: 'Show',\n      typeParam: 'a',\n      functions: new Map([\n        ['show', functionType([intType()], stringType())]\n      ])\n    };\n    addConstraintDefinition(state.constraintRegistry, 'Show', showSignature);\n    \n    // Add Int implementation\n    const intImpl: ConstraintImplementation = {\n      functions: new Map([\n        ['show', {\n          type: functionType([intType()], stringType()),\n          quantifiedVars: [],\n          effects: new Set()\n        }]\n      ])\n    };\n    addConstraintImplementation(state.constraintRegistry, 'Show', 'Int', intImpl);\n    \n    // Try to resolve a constraint function call\n    const argTypes = [intType()];\n    const resolution = tryResolveConstraintFunction(\n      'show',\n      [], // args expressions (not used in current implementation)\n      argTypes,\n      state\n    );\n    \n    expect(resolution.resolved).toBe(true);\n    expect(resolution.specializedName).toBe('__Show_show_Int');\n    expect(resolution.typeScheme).toBeTruthy();\n  });\n\n  test('should detect constraint variables', () => {\n    const state = createTypeState();\n    \n    // Add Show constraint\n    const showSignature: ConstraintSignature = {\n      name: 'Show',\n      typeParam: 'a',\n      functions: new Map([\n        ['show', functionType([intType()], stringType())]\n      ])\n    };\n    addConstraintDefinition(state.constraintRegistry, 'Show', showSignature);\n    \n    // Test constraint variable detection\n    const resolution = resolveConstraintVariable('show', state);\n    \n    expect(resolution.resolved).toBe(true);\n    expect(resolution.needsResolution).toBe(true);\n    expect(resolution.constraintName).toBe('Show');\n    expect(resolution.functionName).toBe('show');\n  });\n\n  test('should create constraint function types', () => {\n    const state = createTypeState();\n    \n    // Add Show constraint\n    const showSignature: ConstraintSignature = {\n      name: 'Show',\n      typeParam: 'a',\n      functions: new Map([\n        ['show', functionType([intType()], stringType())]\n      ])\n    };\n    addConstraintDefinition(state.constraintRegistry, 'Show', showSignature);\n    \n    // Create constraint function type\n    const constraintType = createConstraintFunctionType('Show', 'show', state);\n    \n    expect(constraintType.kind).toBe('function');\n    if (constraintType.kind === 'function') {\n      expect(constraintType.params).toHaveLength(1);\n      expect(constraintType.params[0]).toEqual(intType());\n      expect(constraintType.return).toEqual(stringType());\n    }\n  });\n\n  test('should decorate environment with specialized functions', () => {\n    const state = createTypeState();\n    \n    // Add Show constraint and implementation\n    const showSignature: ConstraintSignature = {\n      name: 'Show',\n      typeParam: 'a',\n      functions: new Map([\n        ['show', functionType([intType()], stringType())]\n      ])\n    };\n    addConstraintDefinition(state.constraintRegistry, 'Show', showSignature);\n    \n    const intImpl: ConstraintImplementation = {\n      functions: new Map([\n        ['show', {\n          type: functionType([intType()], stringType()),\n          quantifiedVars: [],\n          effects: new Set()\n        }]\n      ])\n    };\n    addConstraintImplementation(state.constraintRegistry, 'Show', 'Int', intImpl);\n    \n    // Decorate environment\n    const decoratedState = decorateEnvironmentWithConstraintFunctions(state);\n    \n    // Check that specialized function was added\n    const specializedName = '__Show_show_Int';\n    expect(decoratedState.environment.has(specializedName)).toBe(true);\n    \n    const specializedScheme = decoratedState.environment.get(specializedName);\n    expect(specializedScheme).toBeTruthy();\n    expect(specializedScheme?.type.kind).toBe('function');\n  });\n\n  test('should handle multiple constraints and implementations', () => {\n    const state = createTypeState();\n    \n    // Add Show constraint\n    const showSignature: ConstraintSignature = {\n      name: 'Show',\n      typeParam: 'a',\n      functions: new Map([\n        ['show', functionType([intType()], stringType())]\n      ])\n    };\n    addConstraintDefinition(state.constraintRegistry, 'Show', showSignature);\n    \n    // Add Eq constraint\n    const eqSignature: ConstraintSignature = {\n      name: 'Eq',\n      typeParam: 'a',\n      functions: new Map([\n        ['equals', functionType([intType(), intType()], stringType())]\n      ])\n    };\n    addConstraintDefinition(state.constraintRegistry, 'Eq', eqSignature);\n    \n    // Add implementations for both\n    const showImpl: ConstraintImplementation = {\n      functions: new Map([\n        ['show', {\n          type: functionType([intType()], stringType()),\n          quantifiedVars: [],\n          effects: new Set()\n        }]\n      ])\n    };\n    addConstraintImplementation(state.constraintRegistry, 'Show', 'Int', showImpl);\n    \n    const eqImpl: ConstraintImplementation = {\n      functions: new Map([\n        ['equals', {\n          type: functionType([intType(), intType()], stringType()),\n          quantifiedVars: [],\n          effects: new Set()\n        }]\n      ])\n    };\n    addConstraintImplementation(state.constraintRegistry, 'Eq', 'Int', eqImpl);\n    \n    // Test resolution for both\n    const showResolution = tryResolveConstraintFunction('show', [], [intType()], state);\n    const eqResolution = tryResolveConstraintFunction('equals', [], [intType(), intType()], state);\n    \n    expect(showResolution.resolved).toBe(true);\n    expect(showResolution.specializedName).toBe('__Show_show_Int');\n    \n    expect(eqResolution.resolved).toBe(true);\n    expect(eqResolution.specializedName).toBe('__Eq_equals_Int');\n  });\n\n  test('should fail to resolve when no implementation exists', () => {\n    const state = createTypeState();\n    \n    // Add Show constraint but no implementation\n    const showSignature: ConstraintSignature = {\n      name: 'Show',\n      typeParam: 'a',\n      functions: new Map([\n        ['show', functionType([intType()], stringType())]\n      ])\n    };\n    addConstraintDefinition(state.constraintRegistry, 'Show', showSignature);\n    \n    // Try to resolve without implementation\n    const resolution = tryResolveConstraintFunction('show', [], [intType()], state);\n    \n    expect(resolution.resolved).toBe(false);\n    expect(resolution.specializedName).toBeUndefined();\n  });\n});"],"version":3}