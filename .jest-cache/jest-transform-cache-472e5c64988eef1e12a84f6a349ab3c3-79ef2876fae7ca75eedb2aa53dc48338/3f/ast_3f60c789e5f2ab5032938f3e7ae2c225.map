{"file":"/workspace/src/ast.ts","mappings":"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","names":[],"sources":["/workspace/src/ast.ts"],"sourcesContent":["// AST types for Noolang\n\nexport type Position = {\n\tline: number;\n\tcolumn: number;\n};\n\nexport type Location = {\n\tstart: Position;\n\tend: Position;\n};\n\n// Type system\nexport type Effect =\n\t| 'log'\n\t| 'read'\n\t| 'write'\n\t| 'state'\n\t| 'time'\n\t| 'rand'\n\t| 'ffi'\n\t| 'async';\n\n// Type constraints for constrained polymorphism\nexport type Constraint =\n\t| { kind: 'is'; typeVar: string; constraint: string } // a is Collection\n\t| { kind: 'hasField'; typeVar: string; field: string; fieldType: Type } // a has field \"length\" of type Int\n\t| { kind: 'implements'; typeVar: string; interfaceName: string } // a implements Show\n\t| { kind: 'custom'; typeVar: string; constraint: string; args: Type[] }; // a satisfies MyConstraint T1 T2\n\nexport type ConstraintExpr =\n\t| Constraint\n\t| { kind: 'and'; left: ConstraintExpr; right: ConstraintExpr }\n\t| { kind: 'or'; left: ConstraintExpr; right: ConstraintExpr }\n\t| { kind: 'paren'; expr: ConstraintExpr };\n\n// Extracted type definitions\nexport type PrimitiveType = {\n\tkind: 'primitive';\n\tname: 'Int' | 'String' | 'Bool' | 'List';\n};\n\nexport type FunctionType = {\n\tkind: 'function';\n\tparams: Type[];\n\treturn: Type;\n\teffects: Set<Effect>;\n\tconstraints?: Constraint[];\n};\n\nexport type VariableType = {\n\tkind: 'variable';\n\tname: string;\n\tconstraints?: Constraint[];\n};\n\nexport type ListType = {\n\tkind: 'list';\n\telement: Type;\n};\n\nexport type UnionType = {\n\tkind: 'union';\n\ttypes: Type[];\n};\n\nexport type VariantType = {\n\tkind: 'variant';\n\tname: string;\n\targs: Type[];\n};\n\nexport type ADTType = {\n\tkind: 'adt';\n\tname: string;\n\ttypeParams: string[];\n\tconstructors: ConstructorDefinition[];\n};\n\nexport type UnitType = {\n\tkind: 'unit';\n};\n\nexport type UnknownType = {\n\tkind: 'unknown';\n};\n\nexport type Type =\n\t| PrimitiveType\n\t| FunctionType\n\t| VariableType\n\t| ListType\n\t| TupleType\n\t| RecordType\n\t| UnionType\n\t| VariantType\n\t| ADTType\n\t| UnitType\n\t| UnknownType;\n\n// Expressions\nexport type Expression =\n\t| LiteralExpression\n\t| VariableExpression\n\t| FunctionExpression\n\t| ApplicationExpression\n\t| PipelineExpression\n\t| BinaryExpression\n\t| IfExpression\n\t| DefinitionExpression\n\t| MutableDefinitionExpression\n\t| MutationExpression\n\t| ImportExpression\n\t| RecordExpression\n\t| TupleExpression\n\t| UnitExpression\n\t| AccessorExpression\n\t| TypedExpression\n\t| ConstrainedExpression\n\t| ListExpression\n\t| WhereExpression\n\t| TypeDefinitionExpression\n\t| MatchExpression\n\t| ConstraintDefinitionExpression\n\t| ImplementDefinitionExpression\n\t| FFIExpression;\n\nexport interface LiteralExpression {\n\tkind: 'literal';\n\tvalue: number | string | boolean | Expression[] | null; // null represents unit\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface VariableExpression {\n\tkind: 'variable';\n\tname: string;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface FunctionExpression {\n\tkind: 'function';\n\tparams: string[];\n\tbody: Expression;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface ApplicationExpression {\n\tkind: 'application';\n\tfunc: Expression;\n\targs: Expression[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface PipelineExpression {\n\tkind: 'pipeline';\n\tsteps: Expression[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface BinaryExpression {\n\tkind: 'binary';\n\toperator:\n\t\t| '+'\n\t\t| '-'\n\t\t| '*'\n\t\t| '/'\n\t\t| '=='\n\t\t| '!='\n\t\t| '<'\n\t\t| '>'\n\t\t| '<='\n\t\t| '>='\n\t\t| '|'\n\t\t| '|>'\n\t\t| '<|'\n\t\t| ';'\n\t\t| '$';\n\tleft: Expression;\n\tright: Expression;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface IfExpression {\n\tkind: 'if';\n\tcondition: Expression;\n\tthen: Expression;\n\telse: Expression;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface DefinitionExpression {\n\tkind: 'definition';\n\tname: string;\n\tvalue: Expression;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface MutableDefinitionExpression {\n\tkind: 'mutable-definition';\n\tname: string;\n\tvalue: Expression;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface MutationExpression {\n\tkind: 'mutation';\n\ttarget: string;\n\tvalue: Expression;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface ImportExpression {\n\tkind: 'import';\n\tpath: string;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport type RecordExpression = {\n\tkind: 'record';\n\tfields: FieldExpression[];\n\ttype?: Type;\n\tlocation: Location;\n};\n\nexport interface FieldExpression {\n\tname: string;\n\tvalue: Expression;\n}\n\nexport interface AccessorExpression {\n\tkind: 'accessor';\n\tfield: string;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface FFIExpression {\n\tkind: 'ffi';\n\tmodule: string;\n\tfunctionName: string;\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface TupleExpression {\n\tkind: 'tuple';\n\telements: Expression[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface UnitExpression {\n\tkind: 'unit';\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface TypedExpression {\n\tkind: 'typed';\n\texpression: Expression;\n\ttype: Type;\n\tlocation: Location;\n}\n\nexport interface ConstrainedExpression {\n\tkind: 'constrained';\n\texpression: Expression;\n\ttype: Type;\n\tconstraint: ConstraintExpr;\n\tlocation: Location;\n}\n\nexport interface ListExpression {\n\tkind: 'list';\n\telements: Expression[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface WhereExpression {\n\tkind: 'where';\n\tmain: Expression;\n\tdefinitions: (DefinitionExpression | MutableDefinitionExpression)[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\n// ADT Constructor definition\nexport interface ConstructorDefinition {\n\tname: string;\n\targs: Type[];\n\tlocation: Location;\n}\n\n// ADT Type definition\nexport interface TypeDefinitionExpression {\n\tkind: 'type-definition';\n\tname: string;\n\ttypeParams: string[]; // Type parameters like 'a' in Option a\n\tconstructors: ConstructorDefinition[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\n// Pattern in pattern matching\nexport type Pattern =\n\t| { kind: 'constructor'; name: string; args: Pattern[]; location: Location }\n\t| { kind: 'variable'; name: string; location: Location }\n\t| { kind: 'literal'; value: number | string | boolean; location: Location }\n\t| { kind: 'wildcard'; location: Location };\n\n// Pattern matching case\nexport interface MatchCase {\n\tpattern: Pattern;\n\texpression: Expression;\n\tlocation: Location;\n}\n\n// Match expression\nexport interface MatchExpression {\n\tkind: 'match';\n\texpression: Expression;\n\tcases: MatchCase[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\n// Constraint definition for trait system\nexport interface ConstraintDefinitionExpression {\n\tkind: 'constraint-definition';\n\tname: string;\n\ttypeParam: string;\n\tfunctions: ConstraintFunction[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface ConstraintFunction {\n\tname: string;\n\ttypeParams: string[];\n\ttype: Type;\n\tlocation: Location;\n}\n\n// Implement definition for trait system\nexport interface ImplementDefinitionExpression {\n\tkind: 'implement-definition';\n\tconstraintName: string;\n\ttypeName: string;\n\timplementations: ImplementationFunction[];\n\ttype?: Type;\n\tlocation: Location;\n}\n\nexport interface ImplementationFunction {\n\tname: string;\n\tvalue: Expression;\n\tlocation: Location;\n}\n\n// Program\nexport interface Program {\n\tstatements: Expression[];\n\tlocation: Location;\n}\n\n// Utility functions\nexport const createLocation = (start: Position, end: Position): Location => ({\n\tstart,\n\tend,\n});\n\nexport const createPosition = (line: number, column: number): Position => ({\n\tline,\n\tcolumn,\n});\n\n// Type constructors\nexport const intType = (): PrimitiveType => ({\n\tkind: 'primitive',\n\tname: 'Int',\n});\nexport const numberType = (): PrimitiveType => ({\n\tkind: 'primitive',\n\tname: 'Int',\n}); // Alias for backwards compatibility\nexport const stringType = (): PrimitiveType => ({\n\tkind: 'primitive',\n\tname: 'String',\n});\nexport const boolType = (): VariantType => ({\n\tkind: 'variant',\n\tname: 'Bool',\n\targs: [],\n});\nexport const listType = (): PrimitiveType => ({\n\tkind: 'primitive',\n\tname: 'List',\n});\nexport const functionType = (\n\tparams: Type[],\n\treturnType: Type,\n\teffects: Set<Effect> = new Set()\n): FunctionType => ({\n\tkind: 'function',\n\tparams,\n\treturn: returnType,\n\teffects,\n});\nexport const typeVariable = (name: string): VariableType => ({\n\tkind: 'variable',\n\tname,\n});\nexport const unknownType = (): UnknownType => ({ kind: 'unknown' });\n\n// New type constructors\nexport const listTypeWithElement = (element: Type): ListType => ({\n\tkind: 'list',\n\telement,\n});\n\nexport type TupleType = {\n\tkind: 'tuple';\n\telements: Type[];\n};\n\nexport const tupleType = (elements: Type[]): TupleType => ({\n\tkind: 'tuple',\n\telements,\n});\n\n// Add tuple type constructor for Tuple T1 T2 syntax\nexport const tupleTypeConstructor = (elementTypes: Type[]): TupleType => ({\n\tkind: 'tuple',\n\telements: elementTypes,\n});\n\nexport type RecordType = {\n\tkind: 'record';\n\tfields: { [key: string]: Type };\n};\n\nexport const recordType = (fields: { [key: string]: Type }): RecordType => ({\n\tkind: 'record',\n\tfields,\n});\n\n// Constructor functions for new types\nexport const primitiveType = (\n\tname: 'Int' | 'String' | 'Bool' | 'List'\n): PrimitiveType => ({\n\tkind: 'primitive',\n\tname,\n});\n\nexport const variableType = (\n\tname: string,\n\tconstraints?: Constraint[]\n): VariableType => ({\n\tkind: 'variable',\n\tname,\n\tconstraints,\n});\n\nexport const unionType = (types: Type[]): UnionType => ({\n\tkind: 'union',\n\ttypes,\n});\n\nexport const variantType = (name: string, args: Type[]): VariantType => ({\n\tkind: 'variant',\n\tname,\n\targs,\n});\n\nexport const adtType = (\n\tname: string,\n\ttypeParams: string[],\n\tconstructors: ConstructorDefinition[]\n): ADTType => ({\n\tkind: 'adt',\n\tname,\n\ttypeParams,\n\tconstructors,\n});\n\nexport const unitType = (): UnitType => ({ kind: 'unit' });\n\n// Helper functions to create ADT variant types\nexport const optionType = (element: Type): VariantType => ({\n\tkind: 'variant',\n\tname: 'Option',\n\targs: [element],\n});\n\nexport const resultType = (success: Type, error: Type): VariantType => ({\n\tkind: 'variant',\n\tname: 'Result',\n\targs: [success, error],\n});\n\n// Convenience functions for common types\nexport const optionInt = (): VariantType => optionType(intType());\nexport const resultString = (error: Type): VariantType =>\n\tresultType(stringType(), error);\n\nexport type HasFieldConstraint = {\n\tkind: 'hasField';\n\ttypeVar: string;\n\tfield: string;\n\tfieldType: Type;\n};\n\nexport type IsConstraint = {\n\tkind: 'is';\n\ttypeVar: string;\n\tconstraint: string;\n};\n\n// Constraint helper functions\nexport const isConstraint = (\n\ttypeVar: string,\n\tconstraint: string\n): IsConstraint => ({\n\tkind: 'is',\n\ttypeVar,\n\tconstraint,\n});\n\nexport const hasFieldConstraint = (\n\ttypeVar: string,\n\tfield: string,\n\tfieldType: Type\n): HasFieldConstraint => ({\n\tkind: 'hasField',\n\ttypeVar,\n\tfield,\n\tfieldType,\n});\n\nexport type ImplementsConstraint = {\n\tkind: 'implements';\n\ttypeVar: string;\n\tinterfaceName: string;\n};\n\nexport const implementsConstraint = (\n\ttypeVar: string,\n\tinterfaceName: string\n): ImplementsConstraint => ({\n\tkind: 'implements',\n\ttypeVar,\n\tinterfaceName,\n});\n\nexport type CustomConstraint = {\n\tkind: 'custom';\n\ttypeVar: string;\n\tconstraint: string;\n\targs: Type[];\n};\n\nexport const customConstraint = (\n\ttypeVar: string,\n\tconstraint: string,\n\targs: Type[]\n): CustomConstraint => ({\n\tkind: 'custom',\n\ttypeVar,\n\tconstraint,\n\targs,\n});\n\n// Constrained type variable\nexport const constrainedTypeVariable = (\n\tname: string,\n\tconstraints: Constraint[]\n): VariableType => ({\n\tkind: 'variable',\n\tname,\n\tconstraints,\n});\n\n// Constrained function type\nexport const constrainedFunctionType = (\n\tparams: Type[],\n\treturnType: Type,\n\teffects: Set<Effect> = new Set(),\n\tconstraints: Constraint[] = []\n): FunctionType => ({\n\tkind: 'function',\n\tparams,\n\treturn: returnType,\n\teffects,\n\tconstraints,\n});\n"],"version":3}