{"file":"/workspace/src/typer/types.ts","mappings":"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","names":[],"sources":["/workspace/src/typer/types.ts"],"sourcesContent":["import type { Constraint, Type, Effect } from \"../ast\";\n\n// ADT registry for tracking defined algebraic data types\nexport type ADTRegistry = Map<\n\tstring,\n\t{\n\t\ttypeParams: string[];\n\t\tconstructors: Map<string, Type[]>; // constructor name -> arg types\n\t}\n>;\n\n// Constraint system types for trait support\nexport type ConstraintSignature = {\n\tname: string;\n\ttypeParam: string;\n\tfunctions: Map<string, Type>; // function name -> type signature\n};\n\nexport type ConstraintImplementation = {\n\tfunctions: Map<string, TypeScheme>; // function name -> implementation\n};\n\nexport type ConstraintRegistry = Map<string, {\n\tsignature: ConstraintSignature;\n\timplementations: Map<string, ConstraintImplementation>; // type name -> implementation\n}>;\n\n// Type scheme for let-polymorphism\nexport type TypeScheme = {\n\ttype: Type;\n\tquantifiedVars: string[];\n\teffects?: Set<Effect>; // Effects for values that have effects\n};\n\nexport type TypeEnvironment = Map<string, TypeScheme> & {\n\tconstraints?: ConstraintRegistry;\n};\n\n// Functional state for type inference\nexport type TypeState = {\n\tenvironment: TypeEnvironment;\n\tsubstitution: Map<string, Type>;\n\tcounter: number;\n\tconstraints: Constraint[]; // Track constraints during inference\n\tadtRegistry: ADTRegistry; // Track ADT definitions\n\taccessorCache: Map<string, Type>; // Cache accessor types by field name\n\tconstraintRegistry: ConstraintRegistry; // Track constraint definitions and implementations\n};\n\n// Type inference result with separated effects\nexport type TypeResult = {\n\ttype: Type;\n\teffects: Set<Effect>;\n\tstate: TypeState;\n};\n\n// Effect manipulation helpers\nexport const emptyEffects = (): Set<Effect> => new Set();\n\nexport const singleEffect = (effect: Effect): Set<Effect> => new Set([effect]);\n\nexport const unionEffects = (...effectSets: Set<Effect>[]): Set<Effect> => {\n\tconst result = new Set<Effect>();\n\tfor (const effects of effectSets) {\n\t\tfor (const effect of effects) {\n\t\t\tresult.add(effect);\n\t\t}\n\t}\n\treturn result;\n};\n\nexport const createTypeResult = (type: Type, effects: Set<Effect>, state: TypeState): TypeResult => ({\n\ttype,\n\teffects,\n\tstate,\n});\n\nexport const createPureTypeResult = (type: Type, state: TypeState): TypeResult => ({\n\ttype,\n\teffects: emptyEffects(),\n\tstate,\n});\n\n// Constraint registry helpers\nexport const createConstraintRegistry = (): ConstraintRegistry => new Map();\n\nexport const addConstraintDefinition = (\n\tregistry: ConstraintRegistry,\n\tname: string,\n\tsignature: ConstraintSignature\n): void => {\n\tregistry.set(name, {\n\t\tsignature,\n\t\timplementations: new Map()\n\t});\n};\n\nexport const addConstraintImplementation = (\n\tregistry: ConstraintRegistry,\n\tconstraintName: string,\n\ttypeName: string,\n\timplementation: ConstraintImplementation\n): boolean => {\n\tconst constraint = registry.get(constraintName);\n\tif (!constraint) {\n\t\treturn false; // Constraint not defined\n\t}\n\tconstraint.implementations.set(typeName, implementation);\n\treturn true;\n};\n\nexport const resolveConstraintFunction = (\n\tregistry: ConstraintRegistry,\n\tconstraintName: string,\n\tfunctionName: string,\n\tconcreteType: Type\n): TypeScheme | null => {\n\tconst constraint = registry.get(constraintName);\n\tif (!constraint) {\n\t\treturn null;\n\t}\n\t\n\t// Convert type to string for lookup\n\tconst typeName = typeToString(concreteType);\n\tconst impl = constraint.implementations.get(typeName);\n\treturn impl?.functions.get(functionName) || null;\n};\n\n// Helper to get constraint signature\nexport const getConstraintSignature = (\n\tregistry: ConstraintRegistry,\n\tconstraintName: string\n): ConstraintSignature | null => {\n\treturn registry.get(constraintName)?.signature || null;\n};\n\n// Helper function to convert Type to string for registry keys\nconst typeToString = (type: Type): string => {\n\tswitch (type.kind) {\n\t\tcase \"primitive\":\n\t\t\treturn type.name;\n\t\tcase \"variable\":\n\t\t\treturn type.name;\n\t\tcase \"list\":\n\t\t\treturn `List ${typeToString(type.element)}`;\n\t\tcase \"tuple\":\n\t\t\treturn `{${type.elements.map(typeToString).join(\", \")}}`;\n\t\tcase \"record\":\n\t\t\tconst fields = Object.entries(type.fields)\n\t\t\t\t.map(([k, v]) => `${k}: ${typeToString(v)}`)\n\t\t\t\t.join(\", \");\n\t\t\treturn `{${fields}}`;\n\t\tcase \"function\":\n\t\t\tconst params = type.params.map(typeToString).join(\" -> \");\n\t\t\treturn `${params} -> ${typeToString(type.return)}`;\n\t\tcase \"union\":\n\t\t\treturn type.types.map(typeToString).join(\" | \");\n\t\tcase \"variant\":\n\t\t\treturn type.args.length > 0 \n\t\t\t\t? `${type.name} ${type.args.map(typeToString).join(\" \")}`\n\t\t\t\t: type.name;\n\t\tcase \"adt\":\n\t\t\treturn type.name;\n\t\tcase \"unit\":\n\t\t\treturn \"Unit\";\n\t\tcase \"unknown\":\n\t\t\treturn \"?\";\n\t\tdefault:\n\t\t\treturn \"Unknown\";\n\t}\n};\n"],"version":3}