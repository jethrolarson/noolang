{"file":"/workspace/test/print_type_pollution.test.ts","mappings":"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","names":[],"sources":["/workspace/test/print_type_pollution.test.ts"],"sourcesContent":["import { Lexer } from '../src/lexer';\nimport { parse } from '../src/parser/parser';\nimport { typeAndDecorate } from '../src/typer';\nimport { createTypeState } from '../src/typer/type-operations';\nimport { initializeBuiltins } from '../src/typer/builtins';\n\ndescribe('Polymorphic Function Type Pollution', () => {\n\ttest('print should remain polymorphic between uses', () => {\n\t\t// Initialize fresh type state for each test\n\t\tlet state = createTypeState();\n\t\tstate = initializeBuiltins(state);\n\n\t\t// First, use print with integer\n\t\tconst lexer1 = new Lexer('print 1');\n\t\tconst tokens1 = lexer1.tokenize();\n\t\tconst program1 = parse(tokens1);\n\n\t\tconst result1 = typeAndDecorate(program1, state);\n\t\tstate = result1.state;\n\t\t\n\t\t// Print should work with Int - check if this succeeds\n\t\texpect(() => result1).not.toThrow();\n\n\t\t// Now use print with string - this should also work\n\t\tconst lexer2 = new Lexer('print \"hello\"');\n\t\tconst tokens2 = lexer2.tokenize();\n\t\tconst program2 = parse(tokens2);\n\n\t\t// This should not throw - print should be polymorphic\n\t\texpect(() => {\n\t\t\tconst result2 = typeAndDecorate(program2, state);\n\t\t}).not.toThrow();\n\t});\n\n\ttest('simulate REPL behavior - alternating print types', () => {\n\t\t// Simulate REPL state persistence\n\t\tlet state = createTypeState();\n\t\tstate = initializeBuiltins(state);\n\n\t\t// First REPL input: print 1\n\t\tconst lexer1 = new Lexer('print 1');\n\t\tconst tokens1 = lexer1.tokenize();\n\t\tconst program1 = parse(tokens1);\n\t\tconst result1 = typeAndDecorate(program1, state);\n\t\tstate = result1.state; // Persist state like REPL does\n\n\t\t// Second REPL input: print \"hi\" - this should work\n\t\tconst lexer2 = new Lexer('print \"hi\"');\n\t\tconst tokens2 = lexer2.tokenize();\n\t\tconst program2 = parse(tokens2);\n\t\t\n\t\t// This is where the bug manifests - print gets \"stuck\" on Int type\n\t\texpect(() => {\n\t\t\tconst result2 = typeAndDecorate(program2, state);\n\t\t\tstate = result2.state;\n\t\t}).not.toThrow();\n\n\t\t// Third REPL input: print 42 - should work again\n\t\tconst lexer3 = new Lexer('print 42');\n\t\tconst tokens3 = lexer3.tokenize();\n\t\tconst program3 = parse(tokens3);\n\t\t\n\t\texpect(() => {\n\t\t\tconst result3 = typeAndDecorate(program3, state);\n\t\t}).not.toThrow();\n\t});\n\n\ttest('other polymorphic functions should not have type pollution', () => {\n\t\tlet state = createTypeState();\n\t\tstate = initializeBuiltins(state);\n\n\t\t// Test == operator with different types\n\t\tconst eq1 = typeAndDecorate(parse(new Lexer('1 == 1').tokenize()), state);\n\t\tstate = eq1.state;\n\t\t\n\t\texpect(() => {\n\t\t\tconst eq2 = typeAndDecorate(parse(new Lexer('\"a\" == \"b\"').tokenize()), state);\n\t\t\tstate = eq2.state;\n\t\t}).not.toThrow();\n\n\t\t// Test toString with different types\n\t\texpect(() => {\n\t\t\tconst toString1 = typeAndDecorate(parse(new Lexer('toString 42').tokenize()), state);\n\t\t\tstate = toString1.state;\n\t\t}).not.toThrow();\n\n\t\texpect(() => {\n\t\t\tconst toString2 = typeAndDecorate(parse(new Lexer('toString \"hello\"').tokenize()), state);\n\t\t}).not.toThrow();\n\t});\n\n\ttest('list functions should remain polymorphic', () => {\n\t\tlet state = createTypeState();\n\t\tstate = initializeBuiltins(state);\n\n\t\t// Test with list of integers (using cons to build lists)\n\t\tconst list1 = typeAndDecorate(parse(new Lexer('cons 1 (cons 2 (cons 3 []))').tokenize()), state);\n\t\tstate = list1.state;\n\n\t\t// Test toString with different input again - should work  \n\t\texpect(() => {\n\t\t\tconst toString3 = typeAndDecorate(parse(new Lexer('toString 100').tokenize()), state);\n\t\t}).not.toThrow();\n\t});\n});"],"version":3}