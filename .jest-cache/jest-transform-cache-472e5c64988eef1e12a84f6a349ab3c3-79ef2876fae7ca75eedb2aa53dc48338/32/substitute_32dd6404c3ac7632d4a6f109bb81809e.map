{"file":"/workspace/src/typer/substitute.ts","mappings":"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","names":[],"sources":["/workspace/src/typer/substitute.ts"],"sourcesContent":["import { type Type, type Constraint } from \"../ast\";\nimport { mapObject } from \"./helpers\";\n\n// Performance tracking for substitute\nlet substituteCallCount = 0;\nlet totalSubstituteTime = 0;\n\n// Cache for substitution results to avoid repeated work\nconst substituteCache = new Map<string, Type>();\n\n// Apply substitution to a type\nexport const substitute = (\n\ttype: Type,\n\tsubstitution: Map<string, Type>,\n): Type => {\n\tconst startTime = Date.now();\n\tsubstituteCallCount++;\n\t\n\tlet result: Type;\n\t// Generate cache key - only for type variables as they're most common\n\tif (type.kind === 'variable' && substitution.size < 20) {\n\t\tconst cacheKey = `${type.name}:${Array.from(substitution.entries()).map(([k,v]) => `${k}=${v.kind}`).join(',')}`;\n\t\tconst cached = substituteCache.get(cacheKey);\n\t\tif (cached) {\n\t\t\tresult = cached;\n\t\t} else {\n\t\t\tresult = substituteWithCache(type, substitution, new Set());\n\t\t\tif (substituteCache.size < 1000) { // Prevent unbounded cache growth\n\t\t\t\tsubstituteCache.set(cacheKey, result);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tresult = substituteWithCache(type, substitution, new Set());\n\t}\n\t\n\tconst elapsed = Date.now() - startTime;\n\ttotalSubstituteTime += elapsed;\n\t\n\t// Stats tracking (disabled for clean output)\n\t\n\treturn result;\n};\n\nconst substituteWithCache = (\n\ttype: Type,\n\tsubstitution: Map<string, Type>,\n\tseen: Set<string>,\n): Type => {\n\tswitch (type.kind) {\n\t\tcase \"variable\": {\n\t\t\tif (seen.has(type.name)) {\n\t\t\t\t// Cycle detected, return original variable\n\t\t\t\treturn type;\n\t\t\t}\n\t\t\tconst sub = substitution.get(type.name);\n\t\t\tif (sub) {\n\t\t\t\tseen.add(type.name);\n\t\t\t\tconst result = substituteWithCache(sub, substitution, seen);\n\t\t\t\tseen.delete(type.name);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\treturn type;\n\t\t}\n\t\tcase \"function\":\n\t\t\treturn {\n\t\t\t\t...type,\n\t\t\t\tparams: type.params.map((param) =>\n\t\t\t\t\tsubstituteWithCache(param, substitution, seen),\n\t\t\t\t),\n\t\t\t\treturn: substituteWithCache(type.return, substitution, seen),\n\t\t\t\tconstraints: type.constraints?.map((c) =>\n\t\t\t\t\tsubstituteConstraint(c, substitution),\n\t\t\t\t),\n\t\t\t};\n\t\tcase \"list\":\n\t\t\treturn {\n\t\t\t\t...type,\n\t\t\t\telement: substituteWithCache(type.element, substitution, seen),\n\t\t\t};\n\t\tcase \"tuple\":\n\t\t\treturn {\n\t\t\t\t...type,\n\t\t\t\telements: type.elements.map((el) =>\n\t\t\t\t\tsubstituteWithCache(el, substitution, seen),\n\t\t\t\t),\n\t\t\t};\n\t\tcase \"record\":\n\t\t\treturn {\n\t\t\t\t...type,\n\t\t\t\tfields: mapObject(type.fields, (v, k) =>\n\t\t\t\t\tsubstituteWithCache(v, substitution, seen),\n\t\t\t\t),\n\t\t\t};\n\t\tcase \"union\":\n\t\t\treturn {\n\t\t\t\t...type,\n\t\t\t\ttypes: type.types.map((t) =>\n\t\t\t\t\tsubstituteWithCache(t, substitution, seen),\n\t\t\t\t),\n\t\t\t};\n\t\tcase \"variant\":\n\t\t\treturn {\n\t\t\t\t...type,\n\t\t\t\targs: type.args.map((arg) =>\n\t\t\t\t\tsubstituteWithCache(arg, substitution, seen),\n\t\t\t\t),\n\t\t\t};\n\t\tdefault:\n\t\t\treturn type;\n\t}\n};\n\n// Apply substitution to a constraint\nexport const substituteConstraint = (\n\tconstraint: Constraint,\n\tsubstitution: Map<string, Type>,\n): Constraint => {\n\tswitch (constraint.kind) {\n\t\tcase \"is\":\n\t\t\treturn constraint; // No substitution needed for is constraints\n\t\tcase \"hasField\":\n\t\t\treturn {\n\t\t\t\t...constraint,\n\t\t\t\tfieldType: substitute(constraint.fieldType, substitution),\n\t\t\t};\n\t\tcase \"implements\":\n\t\t\treturn constraint; // No substitution needed for implements constraints\n\t\tcase \"custom\":\n\t\t\treturn {\n\t\t\t\t...constraint,\n\t\t\t\targs: constraint.args.map((arg) => substitute(arg, substitution)),\n\t\t\t};\n\t\tdefault:\n\t\t\treturn constraint;\n\t}\n};"],"version":3}