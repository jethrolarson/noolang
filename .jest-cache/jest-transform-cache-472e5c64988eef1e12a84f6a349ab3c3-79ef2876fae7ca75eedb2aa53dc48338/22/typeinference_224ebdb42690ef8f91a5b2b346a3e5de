f363ded97710b7c9eff9c50500037c3c
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeImplementDefinition = exports.typeConstraintDefinition = exports.typeConstrained = exports.typeTyped = exports.typeWhere = exports.typeList = exports.typeTuple = exports.typeAccessor = exports.typeRecord = exports.typeImport = exports.typeMutation = exports.typeMutableDefinition = exports.typeBinary = exports.typeIf = exports.typeDefinition = exports.typeFunction = exports.typeVariableExpr = exports.typeLiteral = void 0;
const ast_1 = require("../ast");
const type_errors_1 = require("./type-errors");
const helpers_1 = require("./helpers");
const unify_1 = require("./unify");
const substitute_1 = require("./substitute");
const expression_dispatcher_1 = require("./expression-dispatcher");
const types_1 = require("./types");
const constraints_1 = require("./constraints");
const type_operations_1 = require("./type-operations");
// Note: Main typeExpression is now in expression-dispatcher.ts
// This file only contains the individual type inference functions
// Type inference for literals
const typeLiteral = (expr, state) => {
    const value = expr.value;
    if (typeof value === 'number') {
        return (0, types_1.createPureTypeResult)((0, ast_1.intType)(), state);
    }
    else if (typeof value === 'string') {
        return (0, types_1.createPureTypeResult)((0, ast_1.stringType)(), state);
    }
    else {
        return (0, types_1.createPureTypeResult)((0, ast_1.unknownType)(), state);
    }
};
exports.typeLiteral = typeLiteral;
// Type inference for variables
const typeVariableExpr = (expr, state) => {
    const scheme = state.environment.get(expr.name);
    if (!scheme) {
        // Check if this is a constraint function before throwing error
        const { resolveConstraintVariable, createConstraintFunctionType } = require('./constraint-resolution');
        const constraintResult = resolveConstraintVariable(expr.name, state);
        if (constraintResult.resolved && constraintResult.needsResolution) {
            // This is a constraint function - create its type
            const constraintType = createConstraintFunctionType(constraintResult.constraintName, constraintResult.functionName, state);
            return (0, types_1.createPureTypeResult)(constraintType, state);
        }
        (0, helpers_1.throwTypeError)(location => (0, type_errors_1.undefinedVariableError)(expr.name, location), (0, helpers_1.getExprLocation)(expr));
    }
    const [instantiatedType, newState] = (0, type_operations_1.instantiate)(scheme, state);
    // Handle effects from TypeScheme
    const effects = scheme.effects || (0, types_1.emptyEffects)();
    return (0, types_1.createTypeResult)(instantiatedType, effects, newState);
};
exports.typeVariableExpr = typeVariableExpr;
// Helper function to count parameters in a function type
const countFunctionParams = (type) => {
    if (type.kind !== 'function')
        return 0;
    return type.params.length + countFunctionParams(type.return);
};
// Flatten a constraint expression into a list of atomic constraints
const flattenConstraintExpr = (expr) => {
    switch (expr.kind) {
        case 'is':
            // Validate constraint name
            (0, constraints_1.validateConstraintName)(expr.constraint);
            return [expr];
        case 'hasField':
        case 'implements':
        case 'custom':
            return [expr];
        case 'and':
            return [
                ...flattenConstraintExpr(expr.left),
                ...flattenConstraintExpr(expr.right),
            ];
        case 'or':
            return [
                ...flattenConstraintExpr(expr.left),
                ...flattenConstraintExpr(expr.right),
            ];
        case 'paren':
            return flattenConstraintExpr(expr.expr);
        default:
            return [];
    }
};
// Collect free variables used in an expression
const collectFreeVars = (expr, boundVars = new Set()) => {
    const freeVars = new Set();
    const walk = (e, bound) => {
        switch (e.kind) {
            case 'variable':
                if (!bound.has(e.name)) {
                    freeVars.add(e.name);
                }
                break;
            case 'function':
                // Parameters are bound in the function body
                const newBound = new Set([...bound, ...e.params]);
                walk(e.body, newBound);
                break;
            case 'definition':
                // The defined name is bound for the value expression
                const defBound = new Set([...bound, e.name]);
                walk(e.value, defBound);
                break;
            case 'application':
                walk(e.func, bound);
                e.args.forEach(arg => walk(arg, bound));
                break;
            case 'binary':
                walk(e.left, bound);
                walk(e.right, bound);
                // Operator is also a free variable
                if (!bound.has(e.operator)) {
                    freeVars.add(e.operator);
                }
                break;
            case 'if':
                walk(e.condition, bound);
                walk(e.then, bound);
                walk(e.else, bound);
                break;
            // Add other expression types as needed
            default:
                // For other types, recursively walk any sub-expressions
                // This is a simplified approach - in practice you'd handle each type
                break;
        }
    };
    walk(expr, boundVars);
    return freeVars;
};
// Update typeFunction to use closure culling
const typeFunction = (expr, state) => {
    // Collect free variables used in the function body
    const boundParams = new Set(expr.params);
    const freeVars = collectFreeVars(expr.body, boundParams);
    // Create a minimal environment with only what's needed
    const functionEnv = new Map();
    // Always include built-ins and stdlib essentials  
    const essentials = [
        '+',
        '-',
        '*',
        '/',
        '==',
        '!=',
        '<',
        '>',
        '<=',
        '>=',
        '|',
        '|>',
        '<|',
        ';',
        '$',
        'if',
        'length',
        'head',
        'tail',
        'map',
        'filter',
        'reduce',
        'isEmpty',
        'append',
        'concat',
        'toString',
        'abs',
        'max',
        'min',
        'print',
        'println',
        'readFile',
        'writeFile',
        'log',
        'random',
        'randomRange',
        'mutSet',
        'mutGet',
        'hasKey',
        'hasValue',
        'set',
        'tupleLength',
        'tupleIsEmpty',
        'list_get',
        'True',
        'False',
        'None',
        'Some',
        'Ok',
        'Err',
        'Bool',
        'Option',
        'Result',
    ];
    for (const essential of essentials) {
        if (state.environment.has(essential)) {
            functionEnv.set(essential, state.environment.get(essential));
        }
    }
    // Include only the free variables actually used
    for (const freeVar of freeVars) {
        if (state.environment.has(freeVar)) {
            functionEnv.set(freeVar, state.environment.get(freeVar));
        }
    }
    // Closure optimization: using minimal environment
    let currentState = { ...state, environment: functionEnv };
    const paramTypes = [];
    for (const param of expr.params) {
        const [paramType, nextState] = (0, type_operations_1.freshTypeVariable)(currentState);
        functionEnv.set(param, { type: paramType, quantifiedVars: [] });
        paramTypes.push(paramType);
        currentState = { ...nextState, environment: functionEnv };
    }
    // Type the function body with the function-local environment
    const bodyResult = (0, expression_dispatcher_1.typeExpression)(expr.body, currentState);
    currentState = bodyResult.state;
    // Decorate the function body with its inferred type
    expr.body.type = bodyResult.type;
    // Restore the original environment for the outer scope
    currentState = { ...currentState, environment: state.environment };
    // Special handling for constrained function bodies
    let funcType;
    if (expr.body.kind === 'constrained') {
        const constrainedBody = expr.body;
        const constraints = flattenConstraintExpr(constrainedBody.constraint);
        // If the constrained body has an explicit function type, use it as the innermost type
        if (constrainedBody.type.kind === 'function') {
            funcType = constrainedBody.type;
            // Apply constraints to this function type
            if (constraints.length > 0) {
                funcType.constraints = constraints;
                // Store the original constraint expression for display purposes
                funcType.originalConstraint = constrainedBody.constraint;
                // CRITICAL: Also propagate constraints to type variables in parameters
                // This ensures constraint validation works during function application
                for (const constraint of constraints) {
                    if (constraint.kind === 'is') {
                        (0, helpers_1.propagateConstraintToTypeVariable)(funcType, constraint);
                    }
                }
            }
            // If we have more parameters than the explicit type accounts for, wrap it
            const explicitParamCount = countFunctionParams(constrainedBody.type);
            const actualParamCount = paramTypes.length;
            if (actualParamCount > explicitParamCount) {
                // Wrap the explicit function type with additional parameter layers
                for (let i = actualParamCount - explicitParamCount - 1; i >= 0; i--) {
                    funcType = (0, ast_1.functionType)([paramTypes[i]], funcType);
                }
            }
        }
        else {
            // Build function type normally and apply constraints
            funcType = bodyResult.type;
            for (let i = paramTypes.length - 1; i >= 0; i--) {
                funcType = (0, ast_1.functionType)([paramTypes[i]], funcType);
            }
            if (constraints.length > 0 && funcType.kind === 'function') {
                funcType.constraints = constraints;
            }
        }
    }
    else {
        // Build the function type normally
        funcType = bodyResult.type;
        for (let i = paramTypes.length - 1; i >= 0; i--) {
            funcType = (0, ast_1.functionType)([paramTypes[i]], funcType);
        }
    }
    return (0, types_1.createTypeResult)(funcType, bodyResult.effects, currentState);
};
exports.typeFunction = typeFunction;
// Type inference for definitions
const typeDefinition = (expr, state) => {
    let currentState = state;
    // Add placeholder for recursion before inferring the value
    const [placeholderType, newState] = (0, type_operations_1.freshTypeVariable)(currentState);
    currentState = newState;
    const tempEnv = (0, helpers_1.mapSet)(currentState.environment, expr.name, {
        type: placeholderType,
        quantifiedVars: [],
    });
    currentState = { ...currentState, environment: tempEnv };
    // Type the value
    const valueResult = (0, expression_dispatcher_1.typeExpression)(expr.value, currentState);
    currentState = valueResult.state;
    // Decorate the value with its inferred type
    expr.value.type = valueResult.type;
    // Unify placeholder with actual type for recursion
    currentState = (0, unify_1.unify)(placeholderType, valueResult.type, currentState, (0, helpers_1.getExprLocation)(expr));
    // Remove the just-defined variable from the environment for generalization
    const envForGen = new Map(currentState.environment);
    envForGen.delete(expr.name);
    // Generalize the type before storing in the environment (apply substitution!)
    const scheme = (0, type_operations_1.generalize)(valueResult.type, envForGen, currentState.substitution);
    // Add to environment with generalized type
    const finalEnv = (0, helpers_1.mapSet)(currentState.environment, expr.name, scheme);
    currentState = { ...currentState, environment: finalEnv };
    // Freshen type variables for the definition's value (thread state)
    const [finalType, finalState] = (0, type_operations_1.freshenTypeVariables)(valueResult.type, new Map(), currentState);
    return (0, types_1.createTypeResult)(finalType, valueResult.effects, finalState);
};
exports.typeDefinition = typeDefinition;
// Type inference for if expressions
const typeIf = (expr, state) => {
    let currentState = state;
    // Type condition
    const conditionResult = (0, expression_dispatcher_1.typeExpression)(expr.condition, currentState);
    currentState = conditionResult.state;
    // Unify condition with boolean
    currentState = (0, unify_1.unify)(conditionResult.type, (0, ast_1.boolType)(), currentState, (0, helpers_1.getExprLocation)(expr));
    // Type then branch
    const thenResult = (0, expression_dispatcher_1.typeExpression)(expr.then, currentState);
    currentState = thenResult.state;
    // Type else branch
    const elseResult = (0, expression_dispatcher_1.typeExpression)(expr.else, currentState);
    currentState = elseResult.state;
    // Unify then and else types
    currentState = (0, unify_1.unify)(thenResult.type, elseResult.type, currentState, (0, helpers_1.getExprLocation)(expr));
    // Apply substitution to get final type
    const finalType = (0, substitute_1.substitute)(thenResult.type, currentState.substitution);
    return (0, types_1.createTypeResult)(finalType, (0, types_1.unionEffects)(conditionResult.effects, thenResult.effects, elseResult.effects), currentState);
};
exports.typeIf = typeIf;
// Type inference for binary expressions
const typeBinary = (expr, state) => {
    // Special handling for semicolon operator (sequence) - flatten to avoid O(n²) re-evaluation
    if (expr.operator === ';') {
        // Flatten the semicolon sequence and process each statement exactly once
        const statements = (0, type_operations_1.flattenStatements)(expr);
        let currentState = state;
        let finalType = null;
        let allEffects = (0, types_1.emptyEffects)();
        for (const statement of statements) {
            const result = (0, expression_dispatcher_1.typeExpression)(statement, currentState);
            currentState = result.state;
            finalType = result.type;
            allEffects = (0, types_1.unionEffects)(allEffects, result.effects);
        }
        return (0, types_1.createTypeResult)(finalType || (0, ast_1.unitType)(), allEffects, currentState);
    }
    let currentState = state;
    // Type left operand
    const leftResult = (0, expression_dispatcher_1.typeExpression)(expr.left, currentState);
    currentState = leftResult.state;
    // Type right operand
    const rightResult = (0, expression_dispatcher_1.typeExpression)(expr.right, currentState);
    currentState = rightResult.state;
    // Special handling for thrush operator (|) - function application
    if (expr.operator === '|') {
        // Thrush: a | b means b(a) - apply right function to left value
        if (rightResult.type.kind !== 'function') {
            (0, helpers_1.throwTypeError)(location => (0, type_errors_1.nonFunctionApplicationError)(rightResult.type, location), (0, helpers_1.getExprLocation)(expr));
        }
        // Check that the function can take the left value as its first argument
        if (rightResult.type.params.length < 1) {
            throw new Error(`Thrush operator requires function with at least one parameter, got ${rightResult.type.params.length}`);
        }
        currentState = (0, unify_1.unify)(rightResult.type.params[0], leftResult.type, currentState, (0, helpers_1.getExprLocation)(expr));
        // Return the function's return type (which may be a partially applied function)
        return (0, types_1.createTypeResult)(rightResult.type.return, (0, types_1.unionEffects)(leftResult.effects, rightResult.effects), currentState);
    }
    // Special handling for dollar operator ($) - low precedence function application
    if (expr.operator === '$') {
        // Dollar: a $ b means a(b) - apply left function to right value
        // Delegate to the same logic as regular function application
        const { typeApplication } = require('./function-application');
        // Create a synthetic ApplicationExpression for a $ b
        const syntheticApp = {
            kind: 'application',
            func: expr.left,
            args: [expr.right],
            location: expr.location
        };
        return typeApplication(syntheticApp, currentState);
    }
    // Get operator type from environment
    const operatorScheme = currentState.environment.get(expr.operator);
    if (!operatorScheme) {
        throw new Error(`Unknown operator: ${expr.operator}`);
    }
    const [operatorType, newState] = (0, type_operations_1.instantiate)(operatorScheme, currentState);
    currentState = newState;
    // Create fresh type variable for result
    const [resultType, finalState] = (0, type_operations_1.freshTypeVariable)(currentState);
    currentState = finalState;
    // Build expected function type
    const expectedType = (0, ast_1.functionType)([leftResult.type, rightResult.type], resultType);
    // Unify operator type with expected type
    currentState = (0, unify_1.unify)(operatorType, expectedType, currentState, (0, helpers_1.getExprLocation)(expr), {
        reason: 'operator_application',
        operation: `applying operator ${expr.operator}`,
        hint: `The ${expr.operator} operator expects compatible operand types. Left operand: ${(0, helpers_1.typeToString)(leftResult.type, currentState.substitution)}, Right operand: ${(0, helpers_1.typeToString)(rightResult.type, currentState.substitution)}.`,
    });
    // Apply substitution to get final result type
    const [finalResultType, finalResultState] = (0, type_operations_1.freshenTypeVariables)(resultType, new Map(), currentState);
    return (0, types_1.createTypeResult)(finalResultType, (0, types_1.unionEffects)(leftResult.effects, rightResult.effects), finalResultState);
};
exports.typeBinary = typeBinary;
// Type inference for mutable definitions
const typeMutableDefinition = (expr, state) => {
    // Handle mutable definitions similar to regular definitions
    const valueResult = (0, expression_dispatcher_1.typeExpression)(expr.value, state);
    const newEnv = (0, helpers_1.mapSet)(state.environment, expr.name, {
        type: valueResult.type,
        quantifiedVars: [],
    });
    return (0, types_1.createTypeResult)(valueResult.type, valueResult.effects, { ...valueResult.state, environment: newEnv });
};
exports.typeMutableDefinition = typeMutableDefinition;
// Type inference for mutations
const typeMutation = (expr, state) => {
    // For mutations, we need to check that the target exists and the value type matches
    const targetScheme = state.environment.get(expr.target);
    if (!targetScheme) {
        (0, helpers_1.throwTypeError)(location => (0, type_errors_1.undefinedVariableError)(expr.target, location), (0, helpers_1.getExprLocation)(expr));
    }
    const valueResult = (0, expression_dispatcher_1.typeExpression)(expr.value, state);
    const newState = (0, unify_1.unify)(targetScheme.type, valueResult.type, valueResult.state, (0, helpers_1.getExprLocation)(expr));
    return (0, types_1.createTypeResult)((0, ast_1.unitType)(), valueResult.effects, newState); // Mutations return unit
};
exports.typeMutation = typeMutation;
// Type inference for imports
const typeImport = (expr, state) => {
    // For now, assume imports return a record type
    return (0, types_1.createPureTypeResult)((0, ast_1.recordType)({}), state);
};
exports.typeImport = typeImport;
// Type inference for records
const typeRecord = (expr, state) => {
    const fields = {};
    let currentState = state;
    let allEffects = (0, types_1.emptyEffects)();
    for (const field of expr.fields) {
        const fieldResult = (0, expression_dispatcher_1.typeExpression)(field.value, currentState);
        fields[field.name] = fieldResult.type;
        currentState = fieldResult.state;
        allEffects = (0, types_1.unionEffects)(allEffects, fieldResult.effects);
    }
    return (0, types_1.createTypeResult)((0, ast_1.recordType)(fields), allEffects, currentState);
};
exports.typeRecord = typeRecord;
// Type inference for accessors
const typeAccessor = (expr, state) => {
    // Check cache first
    const fieldName = expr.field;
    const cachedType = state.accessorCache.get(fieldName);
    if (cachedType) {
        return (0, types_1.createPureTypeResult)(cachedType, state);
    }
    // Accessors return functions that take any record with the required field and return the field type
    // @bar should have type {bar: a, ...} -> a (allows extra fields)
    // Use a fresh type variable for the field type
    const [fieldType, nextState] = (0, type_operations_1.freshTypeVariable)(state);
    // Create a simple type variable for the record (no constraints on the variable itself)
    const [recordVar, finalState] = (0, type_operations_1.freshTypeVariable)(nextState);
    // Create a function type with constraints attached to the function type
    const funcType = (0, ast_1.functionType)([recordVar], fieldType);
    // Add the constraint directly to the parameter variable
    if (recordVar.kind === 'variable') {
        recordVar.constraints = [
            (0, ast_1.hasFieldConstraint)(recordVar.name, fieldName, fieldType),
        ];
    }
    // Cache the result for future use
    const resultState = {
        ...finalState,
        accessorCache: new Map(finalState.accessorCache).set(fieldName, funcType),
    };
    return (0, types_1.createPureTypeResult)(funcType, resultState);
};
exports.typeAccessor = typeAccessor;
// Type inference for tuples
const typeTuple = (expr, state) => {
    const elements = [];
    let currentState = state;
    let allEffects = (0, types_1.emptyEffects)();
    for (const element of expr.elements) {
        const elementResult = (0, expression_dispatcher_1.typeExpression)(element, currentState);
        elements.push(elementResult.type);
        currentState = elementResult.state;
        allEffects = (0, types_1.unionEffects)(allEffects, elementResult.effects);
    }
    return (0, types_1.createTypeResult)((0, ast_1.tupleType)(elements), allEffects, currentState);
};
exports.typeTuple = typeTuple;
// Type inference for lists
const typeList = (expr, state) => {
    if (expr.elements.length === 0) {
        // Empty list - we can't infer the element type
        return (0, types_1.createPureTypeResult)((0, ast_1.listTypeWithElement)((0, ast_1.typeVariable)('a')), state);
    }
    // Infer the type from the first element
    let currentState = state;
    const firstElementResult = (0, expression_dispatcher_1.typeExpression)(expr.elements[0], currentState);
    currentState = firstElementResult.state;
    const firstElementType = firstElementResult.type;
    let allEffects = firstElementResult.effects;
    // Check that all elements have the same type
    for (let i = 1; i < expr.elements.length; i++) {
        const elementResult = (0, expression_dispatcher_1.typeExpression)(expr.elements[i], currentState);
        currentState = elementResult.state;
        allEffects = (0, types_1.unionEffects)(allEffects, elementResult.effects);
        currentState = (0, unify_1.unify)(firstElementType, elementResult.type, currentState, {
            line: expr.location?.start.line || 1,
            column: expr.location?.start.column || 1,
        });
    }
    // Apply substitution to get the resolved element type
    const resolvedElementType = (0, substitute_1.substitute)(firstElementType, currentState.substitution);
    return (0, types_1.createTypeResult)((0, ast_1.listTypeWithElement)(resolvedElementType), allEffects, currentState);
};
exports.typeList = typeList;
// Type inference for where expressions
const typeWhere = (expr, state) => {
    // Create a new type environment with the where-clause definitions
    let whereEnv = new Map(state.environment);
    let currentState = { ...state, environment: whereEnv };
    // Type all definitions in the where clause
    for (const def of expr.definitions) {
        if (def.kind === 'definition') {
            const definitionDef = def;
            const valueResult = (0, expression_dispatcher_1.typeExpression)(definitionDef.value, currentState);
            currentState = valueResult.state;
            // Generalize with respect to the current whereEnv (excluding the new binding)
            const tempEnv = new Map(currentState.environment);
            tempEnv.delete(definitionDef.name);
            const scheme = (0, type_operations_1.generalize)(valueResult.type, tempEnv, currentState.substitution);
            whereEnv = (0, helpers_1.mapSet)(currentState.environment, definitionDef.name, scheme);
            currentState = { ...currentState, environment: whereEnv };
        }
        else if (def.kind === 'mutable-definition') {
            const mutableDef = def;
            const valueResult = (0, expression_dispatcher_1.typeExpression)(mutableDef.value, currentState);
            currentState = valueResult.state;
            whereEnv = (0, helpers_1.mapSet)(currentState.environment, mutableDef.name, {
                type: valueResult.type,
                quantifiedVars: [],
            });
            currentState = { ...currentState, environment: whereEnv };
        }
    }
    // Type the main expression
    const resultResult = (0, expression_dispatcher_1.typeExpression)(expr.main, currentState);
    return (0, types_1.createTypeResult)(resultResult.type, resultResult.effects, resultResult.state);
};
exports.typeWhere = typeWhere;
// Type inference for typed expressions
const typeTyped = (expr, state) => {
    // For typed expressions, validate that the explicit type matches the inferred type
    const inferredResult = (0, expression_dispatcher_1.typeExpression)(expr.expression, state);
    const explicitType = expr.type;
    const newState = (0, unify_1.unify)(inferredResult.type, explicitType, inferredResult.state, {
        line: expr.location?.start.line || 1,
        column: expr.location?.start.column || 1,
    });
    return (0, types_1.createTypeResult)(explicitType, inferredResult.effects, newState); // Use the explicit type
};
exports.typeTyped = typeTyped;
// Type inference for constrained expressions
const typeConstrained = (expr, state) => {
    // For constrained expressions, validate that the explicit type matches the inferred type
    const inferredResult = (0, expression_dispatcher_1.typeExpression)(expr.expression, state);
    const explicitType = expr.type;
    let currentState = (0, unify_1.unify)(inferredResult.type, explicitType, inferredResult.state, {
        line: expr.location?.start.line || 1,
        column: expr.location?.start.column || 1,
    });
    // Special case: if this constrained expression is inside a function body,
    // the constraint should apply to the function type, not to this expression
    // For now, we'll just return the explicit type without applying constraints here
    // The constraint will be handled at the function level
    // Return the explicit type without constraints applied
    return (0, types_1.createTypeResult)(explicitType, inferredResult.effects, currentState);
};
exports.typeConstrained = typeConstrained;
// Type constraint definition
const typeConstraintDefinition = (expr, state) => {
    const { name, typeParam, functions } = expr;
    // Create constraint signature
    const functionMap = new Map();
    for (const func of functions) {
        // Type the function signature, substituting the constraint type parameter
        const funcType = func.type;
        functionMap.set(func.name, funcType);
    }
    const signature = {
        name,
        typeParam,
        functions: functionMap,
    };
    // Add to constraint registry
    (0, types_1.addConstraintDefinition)(state.constraintRegistry, name, signature);
    // Constraint definitions have unit type
    return (0, types_1.createPureTypeResult)((0, ast_1.unitType)(), state);
};
exports.typeConstraintDefinition = typeConstraintDefinition;
// Type implement definition  
const typeImplementDefinition = (expr, state) => {
    const { constraintName, typeName, implementations } = expr;
    // Check if constraint exists
    const constraintSig = (0, types_1.getConstraintSignature)(state.constraintRegistry, constraintName);
    if (!constraintSig) {
        throw new Error(`Constraint '${constraintName}' not defined`);
    }
    // Type each implementation
    const implementationMap = new Map();
    let currentState = state;
    let allEffects = (0, types_1.emptyEffects)();
    for (const impl of implementations) {
        // Check if function is required by constraint
        const requiredType = constraintSig.functions.get(impl.name);
        if (!requiredType) {
            throw new Error(`Function '${impl.name}' not required by constraint '${constraintName}'`);
        }
        // Type the implementation
        const implResult = (0, expression_dispatcher_1.typeExpression)(impl.value, currentState);
        currentState = implResult.state;
        allEffects = (0, types_1.unionEffects)(allEffects, implResult.effects);
        // TODO: Check that implementation type matches required type
        // For now, we'll trust the implementation
        // Store in implementation map
        implementationMap.set(impl.name, {
            type: implResult.type,
            quantifiedVars: [], // TODO: compute quantified variables
            effects: implResult.effects,
        });
    }
    // Check that all required functions are implemented
    for (const [funcName] of constraintSig.functions) {
        if (!implementationMap.has(funcName)) {
            throw new Error(`Missing implementation for '${funcName}' in implementation of '${constraintName}' for '${typeName}'`);
        }
    }
    // Create constraint implementation
    const implementation = {
        functions: implementationMap,
    };
    // Add to constraint registry
    const success = (0, types_1.addConstraintImplementation)(currentState.constraintRegistry, constraintName, typeName, implementation);
    if (!success) {
        throw new Error(`Failed to add implementation of '${constraintName}' for '${typeName}'`);
    }
    // Implement definitions have unit type
    return (0, types_1.createTypeResult)((0, ast_1.unitType)(), allEffects, currentState);
};
exports.typeImplementDefinition = typeImplementDefinition;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztRQUN4SCxDQUFDO0lBQ0YsQ0FBQztJQUVELG1DQUFtQztJQUNuQyxNQUFNLGNBQWMsR0FBNkI7UUFDaEQsU0FBUyxFQUFFLGlCQUFpQjtLQUM1QixDQUFDO0lBRUYsNkJBQTZCO0lBQzdCLE1BQU0sT0FBTyxHQUFHLElBQUEsbUNBQTJCLEVBQzFDLFlBQVksQ0FBQyxrQkFBa0IsRUFDL0IsY0FBYyxFQUNkLFFBQVEsRUFDUixjQUFjLENBQ2QsQ0FBQztJQUVGLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNkLE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQW9DLGNBQWMsVUFBVSxRQUFRLEdBQUcsQ0FBQyxDQUFDO0lBQzFGLENBQUM7SUFFRCx1Q0FBdUM7SUFDdkMsT0FBTyxJQUFBLHdCQUFnQixFQUFDLElBQUEsY0FBUSxHQUFFLEVBQUUsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO0FBQy9ELENBQUMsQ0FBQztBQWxFVyxRQUFBLHVCQUF1QiwyQkFrRWxDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2Uvc3JjL3R5cGVyL3R5cGUtaW5mZXJlbmNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdHR5cGUgRXhwcmVzc2lvbixcblx0dHlwZSBMaXRlcmFsRXhwcmVzc2lvbixcblx0dHlwZSBWYXJpYWJsZUV4cHJlc3Npb24sXG5cdHR5cGUgRnVuY3Rpb25FeHByZXNzaW9uLFxuXHR0eXBlIEJpbmFyeUV4cHJlc3Npb24sXG5cdHR5cGUgSWZFeHByZXNzaW9uLFxuXHR0eXBlIERlZmluaXRpb25FeHByZXNzaW9uLFxuXHR0eXBlIE11dGFibGVEZWZpbml0aW9uRXhwcmVzc2lvbixcblx0dHlwZSBNdXRhdGlvbkV4cHJlc3Npb24sXG5cdHR5cGUgSW1wb3J0RXhwcmVzc2lvbixcblx0dHlwZSBSZWNvcmRFeHByZXNzaW9uLFxuXHR0eXBlIEFjY2Vzc29yRXhwcmVzc2lvbixcblx0dHlwZSBMaXN0RXhwcmVzc2lvbixcblx0dHlwZSBUdXBsZUV4cHJlc3Npb24sXG5cdHR5cGUgV2hlcmVFeHByZXNzaW9uLFxuXHR0eXBlIFR5cGVkRXhwcmVzc2lvbixcblx0dHlwZSBDb25zdHJhaW5lZEV4cHJlc3Npb24sXG5cdHR5cGUgQ29uc3RyYWludEV4cHIsXG5cdHR5cGUgQ29uc3RyYWludERlZmluaXRpb25FeHByZXNzaW9uLFxuXHR0eXBlIEltcGxlbWVudERlZmluaXRpb25FeHByZXNzaW9uLFxuXHR0eXBlIFR5cGUsXG5cdHR5cGUgQ29uc3RyYWludCxcblx0aW50VHlwZSxcblx0c3RyaW5nVHlwZSxcblx0Ym9vbFR5cGUsXG5cdGZ1bmN0aW9uVHlwZSxcblx0dHlwZVZhcmlhYmxlLFxuXHR1bmtub3duVHlwZSxcblx0dW5pdFR5cGUsXG5cdGxpc3RUeXBlV2l0aEVsZW1lbnQsXG5cdHR1cGxlVHlwZSxcblx0cmVjb3JkVHlwZSxcblx0aGFzRmllbGRDb25zdHJhaW50LFxufSBmcm9tICcuLi9hc3QnO1xuaW1wb3J0IHtcblx0dW5kZWZpbmVkVmFyaWFibGVFcnJvcixcblx0bm9uRnVuY3Rpb25BcHBsaWNhdGlvbkVycm9yLFxufSBmcm9tICcuL3R5cGUtZXJyb3JzJztcbmltcG9ydCB7XG5cdGdldEV4cHJMb2NhdGlvbixcblx0dGhyb3dUeXBlRXJyb3IsXG5cdG1hcFNldCxcblx0dHlwZVRvU3RyaW5nLFxuXHRwcm9wYWdhdGVDb25zdHJhaW50VG9UeXBlVmFyaWFibGUsXG59IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyB1bmlmeSB9IGZyb20gJy4vdW5pZnknO1xuaW1wb3J0IHsgc3Vic3RpdHV0ZSB9IGZyb20gJy4vc3Vic3RpdHV0ZSc7XG5pbXBvcnQgeyB0eXBlRXhwcmVzc2lvbiB9IGZyb20gJy4vZXhwcmVzc2lvbi1kaXNwYXRjaGVyJztcbmltcG9ydCB7XG5cdHR5cGUgVHlwZVN0YXRlLFxuXHR0eXBlIFR5cGVSZXN1bHQsXG5cdGNyZWF0ZVB1cmVUeXBlUmVzdWx0LFxuXHRjcmVhdGVUeXBlUmVzdWx0LFxuXHR1bmlvbkVmZmVjdHMsXG5cdGVtcHR5RWZmZWN0cyxcblx0YWRkQ29uc3RyYWludERlZmluaXRpb24sXG5cdGFkZENvbnN0cmFpbnRJbXBsZW1lbnRhdGlvbixcblx0Z2V0Q29uc3RyYWludFNpZ25hdHVyZSxcblx0dHlwZSBDb25zdHJhaW50U2lnbmF0dXJlLFxuXHR0eXBlIENvbnN0cmFpbnRJbXBsZW1lbnRhdGlvbixcblx0dHlwZSBUeXBlU2NoZW1lLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHZhbGlkYXRlQ29uc3RyYWludE5hbWUgfSBmcm9tICcuL2NvbnN0cmFpbnRzJztcbmltcG9ydCB7IGZyZXNoVHlwZVZhcmlhYmxlLCBnZW5lcmFsaXplLCBpbnN0YW50aWF0ZSwgZnJlc2hlblR5cGVWYXJpYWJsZXMsIGZsYXR0ZW5TdGF0ZW1lbnRzIH0gZnJvbSAnLi90eXBlLW9wZXJhdGlvbnMnO1xuXG4vLyBOb3RlOiBNYWluIHR5cGVFeHByZXNzaW9uIGlzIG5vdyBpbiBleHByZXNzaW9uLWRpc3BhdGNoZXIudHNcbi8vIFRoaXMgZmlsZSBvbmx5IGNvbnRhaW5zIHRoZSBpbmRpdmlkdWFsIHR5cGUgaW5mZXJlbmNlIGZ1bmN0aW9uc1xuXG4vLyBUeXBlIGluZmVyZW5jZSBmb3IgbGl0ZXJhbHNcbmV4cG9ydCBjb25zdCB0eXBlTGl0ZXJhbCA9IChcblx0ZXhwcjogTGl0ZXJhbEV4cHJlc3Npb24sXG5cdHN0YXRlOiBUeXBlU3RhdGVcbik6IFR5cGVSZXN1bHQgPT4ge1xuXHRjb25zdCB2YWx1ZSA9IGV4cHIudmFsdWU7XG5cblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcblx0XHRyZXR1cm4gY3JlYXRlUHVyZVR5cGVSZXN1bHQoaW50VHlwZSgpLCBzdGF0ZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiBjcmVhdGVQdXJlVHlwZVJlc3VsdChzdHJpbmdUeXBlKCksIHN0YXRlKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gY3JlYXRlUHVyZVR5cGVSZXN1bHQodW5rbm93blR5cGUoKSwgc3RhdGUpO1xuXHR9XG59O1xuXG4vLyBUeXBlIGluZmVyZW5jZSBmb3IgdmFyaWFibGVzXG5leHBvcnQgY29uc3QgdHlwZVZhcmlhYmxlRXhwciA9IChcblx0ZXhwcjogVmFyaWFibGVFeHByZXNzaW9uLFxuXHRzdGF0ZTogVHlwZVN0YXRlXG4pOiBUeXBlUmVzdWx0ID0+IHtcblx0Y29uc3Qgc2NoZW1lID0gc3RhdGUuZW52aXJvbm1lbnQuZ2V0KGV4cHIubmFtZSk7XG5cdGlmICghc2NoZW1lKSB7XG5cdFx0Ly8gQ2hlY2sgaWYgdGhpcyBpcyBhIGNvbnN0cmFpbnQgZnVuY3Rpb24gYmVmb3JlIHRocm93aW5nIGVycm9yXG5cdFx0Y29uc3QgeyByZXNvbHZlQ29uc3RyYWludFZhcmlhYmxlLCBjcmVhdGVDb25zdHJhaW50RnVuY3Rpb25UeXBlIH0gPSByZXF1aXJlKCcuL2NvbnN0cmFpbnQtcmVzb2x1dGlvbicpO1xuXHRcdGNvbnN0IGNvbnN0cmFpbnRSZXN1bHQgPSByZXNvbHZlQ29uc3RyYWludFZhcmlhYmxlKGV4cHIubmFtZSwgc3RhdGUpO1xuXHRcdFxuXHRcdGlmIChjb25zdHJhaW50UmVzdWx0LnJlc29sdmVkICYmIGNvbnN0cmFpbnRSZXN1bHQubmVlZHNSZXNvbHV0aW9uKSB7XG5cdFx0XHQvLyBUaGlzIGlzIGEgY29uc3RyYWludCBmdW5jdGlvbiAtIGNyZWF0ZSBpdHMgdHlwZVxuXHRcdFx0Y29uc3QgY29uc3RyYWludFR5cGUgPSBjcmVhdGVDb25zdHJhaW50RnVuY3Rpb25UeXBlKFxuXHRcdFx0XHRjb25zdHJhaW50UmVzdWx0LmNvbnN0cmFpbnROYW1lISxcblx0XHRcdFx0Y29uc3RyYWludFJlc3VsdC5mdW5jdGlvbk5hbWUhLFxuXHRcdFx0XHRzdGF0ZVxuXHRcdFx0KTtcblx0XHRcdHJldHVybiBjcmVhdGVQdXJlVHlwZVJlc3VsdChjb25zdHJhaW50VHlwZSwgc3RhdGUpO1xuXHRcdH1cblx0XHRcblx0XHR0aHJvd1R5cGVFcnJvcihcblx0XHRcdGxvY2F0aW9uID0+IHVuZGVmaW5lZFZhcmlhYmxlRXJyb3IoZXhwci5uYW1lLCBsb2NhdGlvbiksXG5cdFx0XHRnZXRFeHByTG9jYXRpb24oZXhwcilcblx0XHQpO1xuXHR9XG5cblx0Y29uc3QgW2luc3RhbnRpYXRlZFR5cGUsIG5ld1N0YXRlXSA9IGluc3RhbnRpYXRlKHNjaGVtZSwgc3RhdGUpO1xuXG5cdC8vIEhhbmRsZSBlZmZlY3RzIGZyb20gVHlwZVNjaGVtZVxuXHRjb25zdCBlZmZlY3RzID0gc2NoZW1lLmVmZmVjdHMgfHwgZW1wdHlFZmZlY3RzKCk7XG5cdHJldHVybiBjcmVhdGVUeXBlUmVzdWx0KGluc3RhbnRpYXRlZFR5cGUsIGVmZmVjdHMsIG5ld1N0YXRlKTtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjb3VudCBwYXJhbWV0ZXJzIGluIGEgZnVuY3Rpb24gdHlwZVxuY29uc3QgY291bnRGdW5jdGlvblBhcmFtcyA9ICh0eXBlOiBUeXBlKTogbnVtYmVyID0+IHtcblx0aWYgKHR5cGUua2luZCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIDA7XG5cdHJldHVybiB0eXBlLnBhcmFtcy5sZW5ndGggKyBjb3VudEZ1bmN0aW9uUGFyYW1zKHR5cGUucmV0dXJuKTtcbn07XG5cbi8vIEZsYXR0ZW4gYSBjb25zdHJhaW50IGV4cHJlc3Npb24gaW50byBhIGxpc3Qgb2YgYXRvbWljIGNvbnN0cmFpbnRzXG5jb25zdCBmbGF0dGVuQ29uc3RyYWludEV4cHIgPSAoZXhwcjogQ29uc3RyYWludEV4cHIpOiBDb25zdHJhaW50W10gPT4ge1xuXHRzd2l0Y2ggKGV4cHIua2luZCkge1xuXHRcdGNhc2UgJ2lzJzpcblx0XHRcdC8vIFZhbGlkYXRlIGNvbnN0cmFpbnQgbmFtZVxuXHRcdFx0dmFsaWRhdGVDb25zdHJhaW50TmFtZShleHByLmNvbnN0cmFpbnQpO1xuXHRcdFx0cmV0dXJuIFtleHByXTtcblx0XHRjYXNlICdoYXNGaWVsZCc6XG5cdFx0Y2FzZSAnaW1wbGVtZW50cyc6XG5cdFx0Y2FzZSAnY3VzdG9tJzpcblx0XHRcdHJldHVybiBbZXhwcl07XG5cdFx0Y2FzZSAnYW5kJzpcblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdC4uLmZsYXR0ZW5Db25zdHJhaW50RXhwcihleHByLmxlZnQpLFxuXHRcdFx0XHQuLi5mbGF0dGVuQ29uc3RyYWludEV4cHIoZXhwci5yaWdodCksXG5cdFx0XHRdO1xuXHRcdGNhc2UgJ29yJzpcblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdC4uLmZsYXR0ZW5Db25zdHJhaW50RXhwcihleHByLmxlZnQpLFxuXHRcdFx0XHQuLi5mbGF0dGVuQ29uc3RyYWludEV4cHIoZXhwci5yaWdodCksXG5cdFx0XHRdO1xuXHRcdGNhc2UgJ3BhcmVuJzpcblx0XHRcdHJldHVybiBmbGF0dGVuQ29uc3RyYWludEV4cHIoZXhwci5leHByKTtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIFtdO1xuXHR9XG59O1xuXG4vLyBDb2xsZWN0IGZyZWUgdmFyaWFibGVzIHVzZWQgaW4gYW4gZXhwcmVzc2lvblxuY29uc3QgY29sbGVjdEZyZWVWYXJzID0gKGV4cHI6IEV4cHJlc3Npb24sIGJvdW5kVmFyczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCkpOiBTZXQ8c3RyaW5nPiA9PiB7XG5cdGNvbnN0IGZyZWVWYXJzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cdFxuXHRjb25zdCB3YWxrID0gKGU6IEV4cHJlc3Npb24sIGJvdW5kOiBTZXQ8c3RyaW5nPikgPT4ge1xuXHRcdHN3aXRjaCAoZS5raW5kKSB7XG5cdFx0XHRjYXNlICd2YXJpYWJsZSc6XG5cdFx0XHRcdGlmICghYm91bmQuaGFzKGUubmFtZSkpIHtcblx0XHRcdFx0XHRmcmVlVmFycy5hZGQoZS5uYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2Z1bmN0aW9uJzpcblx0XHRcdFx0Ly8gUGFyYW1ldGVycyBhcmUgYm91bmQgaW4gdGhlIGZ1bmN0aW9uIGJvZHlcblx0XHRcdFx0Y29uc3QgbmV3Qm91bmQgPSBuZXcgU2V0KFsuLi5ib3VuZCwgLi4uZS5wYXJhbXNdKTtcblx0XHRcdFx0d2FsayhlLmJvZHksIG5ld0JvdW5kKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdkZWZpbml0aW9uJzpcblx0XHRcdFx0Ly8gVGhlIGRlZmluZWQgbmFtZSBpcyBib3VuZCBmb3IgdGhlIHZhbHVlIGV4cHJlc3Npb25cblx0XHRcdFx0Y29uc3QgZGVmQm91bmQgPSBuZXcgU2V0KFsuLi5ib3VuZCwgZS5uYW1lXSk7XG5cdFx0XHRcdHdhbGsoZS52YWx1ZSwgZGVmQm91bmQpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2FwcGxpY2F0aW9uJzpcblx0XHRcdFx0d2FsayhlLmZ1bmMsIGJvdW5kKTtcblx0XHRcdFx0ZS5hcmdzLmZvckVhY2goYXJnID0+IHdhbGsoYXJnLCBib3VuZCkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2JpbmFyeSc6XG5cdFx0XHRcdHdhbGsoZS5sZWZ0LCBib3VuZCk7XG5cdFx0XHRcdHdhbGsoZS5yaWdodCwgYm91bmQpO1xuXHRcdFx0XHQvLyBPcGVyYXRvciBpcyBhbHNvIGEgZnJlZSB2YXJpYWJsZVxuXHRcdFx0XHRpZiAoIWJvdW5kLmhhcyhlLm9wZXJhdG9yKSkge1xuXHRcdFx0XHRcdGZyZWVWYXJzLmFkZChlLm9wZXJhdG9yKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2lmJzpcblx0XHRcdFx0d2FsayhlLmNvbmRpdGlvbiwgYm91bmQpO1xuXHRcdFx0XHR3YWxrKGUudGhlbiwgYm91bmQpO1xuXHRcdFx0XHR3YWxrKGUuZWxzZSwgYm91bmQpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdC8vIEFkZCBvdGhlciBleHByZXNzaW9uIHR5cGVzIGFzIG5lZWRlZFxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Ly8gRm9yIG90aGVyIHR5cGVzLCByZWN1cnNpdmVseSB3YWxrIGFueSBzdWItZXhwcmVzc2lvbnNcblx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgYXBwcm9hY2ggLSBpbiBwcmFjdGljZSB5b3UnZCBoYW5kbGUgZWFjaCB0eXBlXG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fTtcblx0XG5cdHdhbGsoZXhwciwgYm91bmRWYXJzKTtcblx0cmV0dXJuIGZyZWVWYXJzO1xufTtcblxuLy8gVXBkYXRlIHR5cGVGdW5jdGlvbiB0byB1c2UgY2xvc3VyZSBjdWxsaW5nXG5leHBvcnQgY29uc3QgdHlwZUZ1bmN0aW9uID0gKFxuXHRleHByOiBGdW5jdGlvbkV4cHJlc3Npb24sXG5cdHN0YXRlOiBUeXBlU3RhdGVcbik6IFR5cGVSZXN1bHQgPT4ge1xuXHQvLyBDb2xsZWN0IGZyZWUgdmFyaWFibGVzIHVzZWQgaW4gdGhlIGZ1bmN0aW9uIGJvZHlcblx0Y29uc3QgYm91bmRQYXJhbXMgPSBuZXcgU2V0KGV4cHIucGFyYW1zKTtcblx0Y29uc3QgZnJlZVZhcnMgPSBjb2xsZWN0RnJlZVZhcnMoZXhwci5ib2R5LCBib3VuZFBhcmFtcyk7XG5cdFxuXHQvLyBDcmVhdGUgYSBtaW5pbWFsIGVudmlyb25tZW50IHdpdGggb25seSB3aGF0J3MgbmVlZGVkXG5cdGNvbnN0IGZ1bmN0aW9uRW52ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcblx0XG5cdC8vIEFsd2F5cyBpbmNsdWRlIGJ1aWx0LWlucyBhbmQgc3RkbGliIGVzc2VudGlhbHMgIFxuXHRjb25zdCBlc3NlbnRpYWxzID0gW1xuXHRcdCcrJyxcblx0XHQnLScsXG5cdFx0JyonLFxuXHRcdCcvJyxcblx0XHQnPT0nLFxuXHRcdCchPScsXG5cdFx0JzwnLFxuXHRcdCc+Jyxcblx0XHQnPD0nLFxuXHRcdCc+PScsXG5cdFx0J3wnLFxuXHRcdCd8PicsXG5cdFx0Jzx8Jyxcblx0XHQnOycsXG5cdFx0JyQnLFxuXHRcdCdpZicsXG5cdFx0J2xlbmd0aCcsXG5cdFx0J2hlYWQnLFxuXHRcdCd0YWlsJyxcblx0XHQnbWFwJyxcblx0XHQnZmlsdGVyJyxcblx0XHQncmVkdWNlJyxcblx0XHQnaXNFbXB0eScsXG5cdFx0J2FwcGVuZCcsXG5cdFx0J2NvbmNhdCcsXG5cdFx0J3RvU3RyaW5nJyxcblx0XHQnYWJzJyxcblx0XHQnbWF4Jyxcblx0XHQnbWluJyxcblx0XHQncHJpbnQnLFxuXHRcdCdwcmludGxuJyxcblx0XHQncmVhZEZpbGUnLFxuXHRcdCd3cml0ZUZpbGUnLFxuXHRcdCdsb2cnLFxuXHRcdCdyYW5kb20nLFxuXHRcdCdyYW5kb21SYW5nZScsXG5cdFx0J211dFNldCcsXG5cdFx0J211dEdldCcsXG5cdFx0J2hhc0tleScsXG5cdFx0J2hhc1ZhbHVlJyxcblx0XHQnc2V0Jyxcblx0XHQndHVwbGVMZW5ndGgnLFxuXHRcdCd0dXBsZUlzRW1wdHknLFxuXHRcdCdsaXN0X2dldCcsXG5cdFx0J1RydWUnLFxuXHRcdCdGYWxzZScsXG5cdFx0J05vbmUnLFxuXHRcdCdTb21lJyxcblx0XHQnT2snLFxuXHRcdCdFcnInLFxuXHRcdCdCb29sJyxcblx0XHQnT3B0aW9uJyxcblx0XHQnUmVzdWx0Jyxcblx0XTtcblx0Zm9yIChjb25zdCBlc3NlbnRpYWwgb2YgZXNzZW50aWFscykge1xuXHRcdGlmIChzdGF0ZS5lbnZpcm9ubWVudC5oYXMoZXNzZW50aWFsKSkge1xuXHRcdFx0ZnVuY3Rpb25FbnYuc2V0KGVzc2VudGlhbCwgc3RhdGUuZW52aXJvbm1lbnQuZ2V0KGVzc2VudGlhbCkhKTtcblx0XHR9XG5cdH1cblx0XG5cdC8vIEluY2x1ZGUgb25seSB0aGUgZnJlZSB2YXJpYWJsZXMgYWN0dWFsbHkgdXNlZFxuXHRmb3IgKGNvbnN0IGZyZWVWYXIgb2YgZnJlZVZhcnMpIHtcblx0XHRpZiAoc3RhdGUuZW52aXJvbm1lbnQuaGFzKGZyZWVWYXIpKSB7XG5cdFx0XHRmdW5jdGlvbkVudi5zZXQoZnJlZVZhciwgc3RhdGUuZW52aXJvbm1lbnQuZ2V0KGZyZWVWYXIpISk7XG5cdFx0fVxuXHR9XG5cdFxuXHQvLyBDbG9zdXJlIG9wdGltaXphdGlvbjogdXNpbmcgbWluaW1hbCBlbnZpcm9ubWVudFxuXHRcblx0bGV0IGN1cnJlbnRTdGF0ZSA9IHsgLi4uc3RhdGUsIGVudmlyb25tZW50OiBmdW5jdGlvbkVudiB9O1xuXG5cdGNvbnN0IHBhcmFtVHlwZXM6IFR5cGVbXSA9IFtdO1xuXHRmb3IgKGNvbnN0IHBhcmFtIG9mIGV4cHIucGFyYW1zKSB7XG5cdFx0Y29uc3QgW3BhcmFtVHlwZSwgbmV4dFN0YXRlXSA9IGZyZXNoVHlwZVZhcmlhYmxlKGN1cnJlbnRTdGF0ZSk7XG5cdFx0ZnVuY3Rpb25FbnYuc2V0KHBhcmFtLCB7IHR5cGU6IHBhcmFtVHlwZSwgcXVhbnRpZmllZFZhcnM6IFtdIH0pO1xuXHRcdHBhcmFtVHlwZXMucHVzaChwYXJhbVR5cGUpO1xuXHRcdGN1cnJlbnRTdGF0ZSA9IHsgLi4ubmV4dFN0YXRlLCBlbnZpcm9ubWVudDogZnVuY3Rpb25FbnYgfTtcblx0fVxuXG5cdC8vIFR5cGUgdGhlIGZ1bmN0aW9uIGJvZHkgd2l0aCB0aGUgZnVuY3Rpb24tbG9jYWwgZW52aXJvbm1lbnRcblx0Y29uc3QgYm9keVJlc3VsdCA9IHR5cGVFeHByZXNzaW9uKGV4cHIuYm9keSwgY3VycmVudFN0YXRlKTtcblx0Y3VycmVudFN0YXRlID0gYm9keVJlc3VsdC5zdGF0ZTtcblxuXHQvLyBEZWNvcmF0ZSB0aGUgZnVuY3Rpb24gYm9keSB3aXRoIGl0cyBpbmZlcnJlZCB0eXBlXG5cdGV4cHIuYm9keS50eXBlID0gYm9keVJlc3VsdC50eXBlO1xuXG5cdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGVudmlyb25tZW50IGZvciB0aGUgb3V0ZXIgc2NvcGVcblx0Y3VycmVudFN0YXRlID0geyAuLi5jdXJyZW50U3RhdGUsIGVudmlyb25tZW50OiBzdGF0ZS5lbnZpcm9ubWVudCB9O1xuXG5cdC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGNvbnN0cmFpbmVkIGZ1bmN0aW9uIGJvZGllc1xuXHRsZXQgZnVuY1R5cGU6IFR5cGU7XG5cblx0aWYgKGV4cHIuYm9keS5raW5kID09PSAnY29uc3RyYWluZWQnKSB7XG5cdFx0Y29uc3QgY29uc3RyYWluZWRCb2R5ID0gZXhwci5ib2R5IGFzIENvbnN0cmFpbmVkRXhwcmVzc2lvbjtcblx0XHRjb25zdCBjb25zdHJhaW50cyA9IGZsYXR0ZW5Db25zdHJhaW50RXhwcihjb25zdHJhaW5lZEJvZHkuY29uc3RyYWludCk7XG5cblx0XHQvLyBJZiB0aGUgY29uc3RyYWluZWQgYm9keSBoYXMgYW4gZXhwbGljaXQgZnVuY3Rpb24gdHlwZSwgdXNlIGl0IGFzIHRoZSBpbm5lcm1vc3QgdHlwZVxuXHRcdGlmIChjb25zdHJhaW5lZEJvZHkudHlwZS5raW5kID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRmdW5jVHlwZSA9IGNvbnN0cmFpbmVkQm9keS50eXBlO1xuXG5cdFx0XHQvLyBBcHBseSBjb25zdHJhaW50cyB0byB0aGlzIGZ1bmN0aW9uIHR5cGVcblx0XHRcdGlmIChjb25zdHJhaW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGZ1bmNUeXBlLmNvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG5cdFx0XHRcdC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBjb25zdHJhaW50IGV4cHJlc3Npb24gZm9yIGRpc3BsYXkgcHVycG9zZXNcblx0XHRcdFx0KGZ1bmNUeXBlIGFzIGFueSkub3JpZ2luYWxDb25zdHJhaW50ID0gY29uc3RyYWluZWRCb2R5LmNvbnN0cmFpbnQ7XG5cblx0XHRcdFx0Ly8gQ1JJVElDQUw6IEFsc28gcHJvcGFnYXRlIGNvbnN0cmFpbnRzIHRvIHR5cGUgdmFyaWFibGVzIGluIHBhcmFtZXRlcnNcblx0XHRcdFx0Ly8gVGhpcyBlbnN1cmVzIGNvbnN0cmFpbnQgdmFsaWRhdGlvbiB3b3JrcyBkdXJpbmcgZnVuY3Rpb24gYXBwbGljYXRpb25cblx0XHRcdFx0Zm9yIChjb25zdCBjb25zdHJhaW50IG9mIGNvbnN0cmFpbnRzKSB7XG5cdFx0XHRcdFx0aWYgKGNvbnN0cmFpbnQua2luZCA9PT0gJ2lzJykge1xuXHRcdFx0XHRcdFx0cHJvcGFnYXRlQ29uc3RyYWludFRvVHlwZVZhcmlhYmxlKGZ1bmNUeXBlLCBjb25zdHJhaW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBtb3JlIHBhcmFtZXRlcnMgdGhhbiB0aGUgZXhwbGljaXQgdHlwZSBhY2NvdW50cyBmb3IsIHdyYXAgaXRcblx0XHRcdGNvbnN0IGV4cGxpY2l0UGFyYW1Db3VudCA9IGNvdW50RnVuY3Rpb25QYXJhbXMoY29uc3RyYWluZWRCb2R5LnR5cGUpO1xuXHRcdFx0Y29uc3QgYWN0dWFsUGFyYW1Db3VudCA9IHBhcmFtVHlwZXMubGVuZ3RoO1xuXHRcdFx0aWYgKGFjdHVhbFBhcmFtQ291bnQgPiBleHBsaWNpdFBhcmFtQ291bnQpIHtcblx0XHRcdFx0Ly8gV3JhcCB0aGUgZXhwbGljaXQgZnVuY3Rpb24gdHlwZSB3aXRoIGFkZGl0aW9uYWwgcGFyYW1ldGVyIGxheWVyc1xuXHRcdFx0XHRmb3IgKGxldCBpID0gYWN0dWFsUGFyYW1Db3VudCAtIGV4cGxpY2l0UGFyYW1Db3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0ZnVuY1R5cGUgPSBmdW5jdGlvblR5cGUoW3BhcmFtVHlwZXNbaV1dLCBmdW5jVHlwZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQnVpbGQgZnVuY3Rpb24gdHlwZSBub3JtYWxseSBhbmQgYXBwbHkgY29uc3RyYWludHNcblx0XHRcdGZ1bmNUeXBlID0gYm9keVJlc3VsdC50eXBlO1xuXHRcdFx0Zm9yIChsZXQgaSA9IHBhcmFtVHlwZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0ZnVuY1R5cGUgPSBmdW5jdGlvblR5cGUoW3BhcmFtVHlwZXNbaV1dLCBmdW5jVHlwZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29uc3RyYWludHMubGVuZ3RoID4gMCAmJiBmdW5jVHlwZS5raW5kID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGZ1bmNUeXBlLmNvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIEJ1aWxkIHRoZSBmdW5jdGlvbiB0eXBlIG5vcm1hbGx5XG5cdFx0ZnVuY1R5cGUgPSBib2R5UmVzdWx0LnR5cGU7XG5cdFx0Zm9yIChsZXQgaSA9IHBhcmFtVHlwZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGZ1bmNUeXBlID0gZnVuY3Rpb25UeXBlKFtwYXJhbVR5cGVzW2ldXSwgZnVuY1R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjcmVhdGVUeXBlUmVzdWx0KGZ1bmNUeXBlLCBib2R5UmVzdWx0LmVmZmVjdHMsIGN1cnJlbnRTdGF0ZSk7XG59O1xuXG4vLyBUeXBlIGluZmVyZW5jZSBmb3IgZGVmaW5pdGlvbnNcbmV4cG9ydCBjb25zdCB0eXBlRGVmaW5pdGlvbiA9IChcblx0ZXhwcjogRGVmaW5pdGlvbkV4cHJlc3Npb24sXG5cdHN0YXRlOiBUeXBlU3RhdGVcbik6IFR5cGVSZXN1bHQgPT4ge1xuXHRsZXQgY3VycmVudFN0YXRlID0gc3RhdGU7XG5cblx0Ly8gQWRkIHBsYWNlaG9sZGVyIGZvciByZWN1cnNpb24gYmVmb3JlIGluZmVycmluZyB0aGUgdmFsdWVcblx0Y29uc3QgW3BsYWNlaG9sZGVyVHlwZSwgbmV3U3RhdGVdID0gZnJlc2hUeXBlVmFyaWFibGUoY3VycmVudFN0YXRlKTtcblx0Y3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG5cblx0Y29uc3QgdGVtcEVudiA9IG1hcFNldChjdXJyZW50U3RhdGUuZW52aXJvbm1lbnQsIGV4cHIubmFtZSwge1xuXHRcdHR5cGU6IHBsYWNlaG9sZGVyVHlwZSxcblx0XHRxdWFudGlmaWVkVmFyczogW10sXG5cdH0pO1xuXHRjdXJyZW50U3RhdGUgPSB7IC4uLmN1cnJlbnRTdGF0ZSwgZW52aXJvbm1lbnQ6IHRlbXBFbnYgfTtcblxuXHQvLyBUeXBlIHRoZSB2YWx1ZVxuXHRjb25zdCB2YWx1ZVJlc3VsdCA9IHR5cGVFeHByZXNzaW9uKGV4cHIudmFsdWUsIGN1cnJlbnRTdGF0ZSk7XG5cdGN1cnJlbnRTdGF0ZSA9IHZhbHVlUmVzdWx0LnN0YXRlO1xuXG5cdC8vIERlY29yYXRlIHRoZSB2YWx1ZSB3aXRoIGl0cyBpbmZlcnJlZCB0eXBlXG5cdGV4cHIudmFsdWUudHlwZSA9IHZhbHVlUmVzdWx0LnR5cGU7XG5cblx0Ly8gVW5pZnkgcGxhY2Vob2xkZXIgd2l0aCBhY3R1YWwgdHlwZSBmb3IgcmVjdXJzaW9uXG5cdGN1cnJlbnRTdGF0ZSA9IHVuaWZ5KFxuXHRcdHBsYWNlaG9sZGVyVHlwZSxcblx0XHR2YWx1ZVJlc3VsdC50eXBlLFxuXHRcdGN1cnJlbnRTdGF0ZSxcblx0XHRnZXRFeHByTG9jYXRpb24oZXhwcilcblx0KTtcblxuXHQvLyBSZW1vdmUgdGhlIGp1c3QtZGVmaW5lZCB2YXJpYWJsZSBmcm9tIHRoZSBlbnZpcm9ubWVudCBmb3IgZ2VuZXJhbGl6YXRpb25cblx0Y29uc3QgZW52Rm9yR2VuID0gbmV3IE1hcChjdXJyZW50U3RhdGUuZW52aXJvbm1lbnQpO1xuXHRlbnZGb3JHZW4uZGVsZXRlKGV4cHIubmFtZSk7XG5cblx0Ly8gR2VuZXJhbGl6ZSB0aGUgdHlwZSBiZWZvcmUgc3RvcmluZyBpbiB0aGUgZW52aXJvbm1lbnQgKGFwcGx5IHN1YnN0aXR1dGlvbiEpXG5cdGNvbnN0IHNjaGVtZSA9IGdlbmVyYWxpemUoXG5cdFx0dmFsdWVSZXN1bHQudHlwZSxcblx0XHRlbnZGb3JHZW4sXG5cdFx0Y3VycmVudFN0YXRlLnN1YnN0aXR1dGlvblxuXHQpO1xuXG5cdC8vIEFkZCB0byBlbnZpcm9ubWVudCB3aXRoIGdlbmVyYWxpemVkIHR5cGVcblx0Y29uc3QgZmluYWxFbnYgPSBtYXBTZXQoY3VycmVudFN0YXRlLmVudmlyb25tZW50LCBleHByLm5hbWUsIHNjaGVtZSk7XG5cdGN1cnJlbnRTdGF0ZSA9IHsgLi4uY3VycmVudFN0YXRlLCBlbnZpcm9ubWVudDogZmluYWxFbnYgfTtcblxuXHQvLyBGcmVzaGVuIHR5cGUgdmFyaWFibGVzIGZvciB0aGUgZGVmaW5pdGlvbidzIHZhbHVlICh0aHJlYWQgc3RhdGUpXG5cdGNvbnN0IFtmaW5hbFR5cGUsIGZpbmFsU3RhdGVdID0gZnJlc2hlblR5cGVWYXJpYWJsZXMoXG5cdFx0dmFsdWVSZXN1bHQudHlwZSxcblx0XHRuZXcgTWFwKCksXG5cdFx0Y3VycmVudFN0YXRlXG5cdCk7XG5cdHJldHVybiBjcmVhdGVUeXBlUmVzdWx0KGZpbmFsVHlwZSwgdmFsdWVSZXN1bHQuZWZmZWN0cywgZmluYWxTdGF0ZSk7XG59O1xuXG4vLyBUeXBlIGluZmVyZW5jZSBmb3IgaWYgZXhwcmVzc2lvbnNcbmV4cG9ydCBjb25zdCB0eXBlSWYgPSAoZXhwcjogSWZFeHByZXNzaW9uLCBzdGF0ZTogVHlwZVN0YXRlKTogVHlwZVJlc3VsdCA9PiB7XG5cdGxldCBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblxuXHQvLyBUeXBlIGNvbmRpdGlvblxuXHRjb25zdCBjb25kaXRpb25SZXN1bHQgPSB0eXBlRXhwcmVzc2lvbihleHByLmNvbmRpdGlvbiwgY3VycmVudFN0YXRlKTtcblx0Y3VycmVudFN0YXRlID0gY29uZGl0aW9uUmVzdWx0LnN0YXRlO1xuXG5cdC8vIFVuaWZ5IGNvbmRpdGlvbiB3aXRoIGJvb2xlYW5cblx0Y3VycmVudFN0YXRlID0gdW5pZnkoXG5cdFx0Y29uZGl0aW9uUmVzdWx0LnR5cGUsXG5cdFx0Ym9vbFR5cGUoKSxcblx0XHRjdXJyZW50U3RhdGUsXG5cdFx0Z2V0RXhwckxvY2F0aW9uKGV4cHIpXG5cdCk7XG5cblx0Ly8gVHlwZSB0aGVuIGJyYW5jaFxuXHRjb25zdCB0aGVuUmVzdWx0ID0gdHlwZUV4cHJlc3Npb24oZXhwci50aGVuLCBjdXJyZW50U3RhdGUpO1xuXHRjdXJyZW50U3RhdGUgPSB0aGVuUmVzdWx0LnN0YXRlO1xuXG5cdC8vIFR5cGUgZWxzZSBicmFuY2hcblx0Y29uc3QgZWxzZVJlc3VsdCA9IHR5cGVFeHByZXNzaW9uKGV4cHIuZWxzZSwgY3VycmVudFN0YXRlKTtcblx0Y3VycmVudFN0YXRlID0gZWxzZVJlc3VsdC5zdGF0ZTtcblxuXHQvLyBVbmlmeSB0aGVuIGFuZCBlbHNlIHR5cGVzXG5cdGN1cnJlbnRTdGF0ZSA9IHVuaWZ5KFxuXHRcdHRoZW5SZXN1bHQudHlwZSxcblx0XHRlbHNlUmVzdWx0LnR5cGUsXG5cdFx0Y3VycmVudFN0YXRlLFxuXHRcdGdldEV4cHJMb2NhdGlvbihleHByKVxuXHQpO1xuXG5cdC8vIEFwcGx5IHN1YnN0aXR1dGlvbiB0byBnZXQgZmluYWwgdHlwZVxuXHRjb25zdCBmaW5hbFR5cGUgPSBzdWJzdGl0dXRlKHRoZW5SZXN1bHQudHlwZSwgY3VycmVudFN0YXRlLnN1YnN0aXR1dGlvbik7XG5cblx0cmV0dXJuIGNyZWF0ZVR5cGVSZXN1bHQoZmluYWxUeXBlLCB1bmlvbkVmZmVjdHMoY29uZGl0aW9uUmVzdWx0LmVmZmVjdHMsIHRoZW5SZXN1bHQuZWZmZWN0cywgZWxzZVJlc3VsdC5lZmZlY3RzKSwgY3VycmVudFN0YXRlKTtcbn07XG5cbi8vIFR5cGUgaW5mZXJlbmNlIGZvciBiaW5hcnkgZXhwcmVzc2lvbnNcbmV4cG9ydCBjb25zdCB0eXBlQmluYXJ5ID0gKFxuXHRleHByOiBCaW5hcnlFeHByZXNzaW9uLFxuXHRzdGF0ZTogVHlwZVN0YXRlXG4pOiBUeXBlUmVzdWx0ID0+IHtcblx0Ly8gU3BlY2lhbCBoYW5kbGluZyBmb3Igc2VtaWNvbG9uIG9wZXJhdG9yIChzZXF1ZW5jZSkgLSBmbGF0dGVuIHRvIGF2b2lkIE8obsKyKSByZS1ldmFsdWF0aW9uXG5cdGlmIChleHByLm9wZXJhdG9yID09PSAnOycpIHtcblx0XHQvLyBGbGF0dGVuIHRoZSBzZW1pY29sb24gc2VxdWVuY2UgYW5kIHByb2Nlc3MgZWFjaCBzdGF0ZW1lbnQgZXhhY3RseSBvbmNlXG5cdFx0Y29uc3Qgc3RhdGVtZW50cyA9IGZsYXR0ZW5TdGF0ZW1lbnRzKGV4cHIpO1xuXHRcdGxldCBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblx0XHRsZXQgZmluYWxUeXBlID0gbnVsbDtcblx0XHRsZXQgYWxsRWZmZWN0cyA9IGVtcHR5RWZmZWN0cygpO1xuXG5cdFx0Zm9yIChjb25zdCBzdGF0ZW1lbnQgb2Ygc3RhdGVtZW50cykge1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdHlwZUV4cHJlc3Npb24oc3RhdGVtZW50LCBjdXJyZW50U3RhdGUpO1xuXHRcdFx0Y3VycmVudFN0YXRlID0gcmVzdWx0LnN0YXRlO1xuXHRcdFx0ZmluYWxUeXBlID0gcmVzdWx0LnR5cGU7XG5cdFx0XHRhbGxFZmZlY3RzID0gdW5pb25FZmZlY3RzKGFsbEVmZmVjdHMsIHJlc3VsdC5lZmZlY3RzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlVHlwZVJlc3VsdChmaW5hbFR5cGUgfHwgdW5pdFR5cGUoKSwgYWxsRWZmZWN0cywgY3VycmVudFN0YXRlKTtcblx0fVxuXG5cdGxldCBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblxuXHQvLyBUeXBlIGxlZnQgb3BlcmFuZFxuXHRjb25zdCBsZWZ0UmVzdWx0ID0gdHlwZUV4cHJlc3Npb24oZXhwci5sZWZ0LCBjdXJyZW50U3RhdGUpO1xuXHRjdXJyZW50U3RhdGUgPSBsZWZ0UmVzdWx0LnN0YXRlO1xuXG5cdC8vIFR5cGUgcmlnaHQgb3BlcmFuZFxuXHRjb25zdCByaWdodFJlc3VsdCA9IHR5cGVFeHByZXNzaW9uKGV4cHIucmlnaHQsIGN1cnJlbnRTdGF0ZSk7XG5cdGN1cnJlbnRTdGF0ZSA9IHJpZ2h0UmVzdWx0LnN0YXRlO1xuXG5cdC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIHRocnVzaCBvcGVyYXRvciAofCkgLSBmdW5jdGlvbiBhcHBsaWNhdGlvblxuXHRpZiAoZXhwci5vcGVyYXRvciA9PT0gJ3wnKSB7XG5cdFx0Ly8gVGhydXNoOiBhIHwgYiBtZWFucyBiKGEpIC0gYXBwbHkgcmlnaHQgZnVuY3Rpb24gdG8gbGVmdCB2YWx1ZVxuXHRcdGlmIChyaWdodFJlc3VsdC50eXBlLmtpbmQgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRocm93VHlwZUVycm9yKFxuXHRcdFx0XHRsb2NhdGlvbiA9PiBub25GdW5jdGlvbkFwcGxpY2F0aW9uRXJyb3IocmlnaHRSZXN1bHQudHlwZSwgbG9jYXRpb24pLFxuXHRcdFx0XHRnZXRFeHByTG9jYXRpb24oZXhwcilcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgdGhhdCB0aGUgZnVuY3Rpb24gY2FuIHRha2UgdGhlIGxlZnQgdmFsdWUgYXMgaXRzIGZpcnN0IGFyZ3VtZW50XG5cdFx0aWYgKHJpZ2h0UmVzdWx0LnR5cGUucGFyYW1zLmxlbmd0aCA8IDEpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0YFRocnVzaCBvcGVyYXRvciByZXF1aXJlcyBmdW5jdGlvbiB3aXRoIGF0IGxlYXN0IG9uZSBwYXJhbWV0ZXIsIGdvdCAke3JpZ2h0UmVzdWx0LnR5cGUucGFyYW1zLmxlbmd0aH1gXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGN1cnJlbnRTdGF0ZSA9IHVuaWZ5KFxuXHRcdFx0cmlnaHRSZXN1bHQudHlwZS5wYXJhbXNbMF0sXG5cdFx0XHRsZWZ0UmVzdWx0LnR5cGUsXG5cdFx0XHRjdXJyZW50U3RhdGUsXG5cdFx0XHRnZXRFeHByTG9jYXRpb24oZXhwcilcblx0XHQpO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBmdW5jdGlvbidzIHJldHVybiB0eXBlICh3aGljaCBtYXkgYmUgYSBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbilcblx0XHRyZXR1cm4gY3JlYXRlVHlwZVJlc3VsdChcblx0XHRcdHJpZ2h0UmVzdWx0LnR5cGUucmV0dXJuLFxuXHRcdFx0dW5pb25FZmZlY3RzKGxlZnRSZXN1bHQuZWZmZWN0cywgcmlnaHRSZXN1bHQuZWZmZWN0cyksXG5cdFx0XHRjdXJyZW50U3RhdGVcblx0XHQpO1xuXHR9XG5cblx0Ly8gU3BlY2lhbCBoYW5kbGluZyBmb3IgZG9sbGFyIG9wZXJhdG9yICgkKSAtIGxvdyBwcmVjZWRlbmNlIGZ1bmN0aW9uIGFwcGxpY2F0aW9uXG5cdGlmIChleHByLm9wZXJhdG9yID09PSAnJCcpIHtcblx0XHQvLyBEb2xsYXI6IGEgJCBiIG1lYW5zIGEoYikgLSBhcHBseSBsZWZ0IGZ1bmN0aW9uIHRvIHJpZ2h0IHZhbHVlXG5cdFx0Ly8gRGVsZWdhdGUgdG8gdGhlIHNhbWUgbG9naWMgYXMgcmVndWxhciBmdW5jdGlvbiBhcHBsaWNhdGlvblxuXHRcdGNvbnN0IHsgdHlwZUFwcGxpY2F0aW9uIH0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uLWFwcGxpY2F0aW9uJyk7XG5cdFx0XG5cdFx0Ly8gQ3JlYXRlIGEgc3ludGhldGljIEFwcGxpY2F0aW9uRXhwcmVzc2lvbiBmb3IgYSAkIGJcblx0XHRjb25zdCBzeW50aGV0aWNBcHA6IGltcG9ydCgnLi4vYXN0JykuQXBwbGljYXRpb25FeHByZXNzaW9uID0ge1xuXHRcdFx0a2luZDogJ2FwcGxpY2F0aW9uJyxcblx0XHRcdGZ1bmM6IGV4cHIubGVmdCxcblx0XHRcdGFyZ3M6IFtleHByLnJpZ2h0XSxcblx0XHRcdGxvY2F0aW9uOiBleHByLmxvY2F0aW9uXG5cdFx0fTtcblx0XHRcblx0XHRyZXR1cm4gdHlwZUFwcGxpY2F0aW9uKHN5bnRoZXRpY0FwcCwgY3VycmVudFN0YXRlKTtcblx0fVxuXG5cdC8vIEdldCBvcGVyYXRvciB0eXBlIGZyb20gZW52aXJvbm1lbnRcblx0Y29uc3Qgb3BlcmF0b3JTY2hlbWUgPSBjdXJyZW50U3RhdGUuZW52aXJvbm1lbnQuZ2V0KGV4cHIub3BlcmF0b3IpO1xuXHRpZiAoIW9wZXJhdG9yU2NoZW1lKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9wZXJhdG9yOiAke2V4cHIub3BlcmF0b3J9YCk7XG5cdH1cblxuXHRjb25zdCBbb3BlcmF0b3JUeXBlLCBuZXdTdGF0ZV0gPSBpbnN0YW50aWF0ZShvcGVyYXRvclNjaGVtZSwgY3VycmVudFN0YXRlKTtcblx0Y3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG5cblx0Ly8gQ3JlYXRlIGZyZXNoIHR5cGUgdmFyaWFibGUgZm9yIHJlc3VsdFxuXHRjb25zdCBbcmVzdWx0VHlwZSwgZmluYWxTdGF0ZV0gPSBmcmVzaFR5cGVWYXJpYWJsZShjdXJyZW50U3RhdGUpO1xuXHRjdXJyZW50U3RhdGUgPSBmaW5hbFN0YXRlO1xuXG5cdC8vIEJ1aWxkIGV4cGVjdGVkIGZ1bmN0aW9uIHR5cGVcblx0Y29uc3QgZXhwZWN0ZWRUeXBlID0gZnVuY3Rpb25UeXBlKFxuXHRcdFtsZWZ0UmVzdWx0LnR5cGUsIHJpZ2h0UmVzdWx0LnR5cGVdLFxuXHRcdHJlc3VsdFR5cGVcblx0KTtcblxuXHQvLyBVbmlmeSBvcGVyYXRvciB0eXBlIHdpdGggZXhwZWN0ZWQgdHlwZVxuXHRjdXJyZW50U3RhdGUgPSB1bmlmeShcblx0XHRvcGVyYXRvclR5cGUsXG5cdFx0ZXhwZWN0ZWRUeXBlLFxuXHRcdGN1cnJlbnRTdGF0ZSxcblx0XHRnZXRFeHByTG9jYXRpb24oZXhwciksXG5cdFx0e1xuXHRcdFx0cmVhc29uOiAnb3BlcmF0b3JfYXBwbGljYXRpb24nLFxuXHRcdFx0b3BlcmF0aW9uOiBgYXBwbHlpbmcgb3BlcmF0b3IgJHtleHByLm9wZXJhdG9yfWAsXG5cdFx0XHRoaW50OiBgVGhlICR7XG5cdFx0XHRcdGV4cHIub3BlcmF0b3Jcblx0XHRcdH0gb3BlcmF0b3IgZXhwZWN0cyBjb21wYXRpYmxlIG9wZXJhbmQgdHlwZXMuIExlZnQgb3BlcmFuZDogJHt0eXBlVG9TdHJpbmcoXG5cdFx0XHRcdGxlZnRSZXN1bHQudHlwZSxcblx0XHRcdFx0Y3VycmVudFN0YXRlLnN1YnN0aXR1dGlvblxuXHRcdFx0KX0sIFJpZ2h0IG9wZXJhbmQ6ICR7dHlwZVRvU3RyaW5nKFxuXHRcdFx0XHRyaWdodFJlc3VsdC50eXBlLFxuXHRcdFx0XHRjdXJyZW50U3RhdGUuc3Vic3RpdHV0aW9uXG5cdFx0XHQpfS5gLFxuXHRcdH1cblx0KTtcblxuXHQvLyBBcHBseSBzdWJzdGl0dXRpb24gdG8gZ2V0IGZpbmFsIHJlc3VsdCB0eXBlXG5cdGNvbnN0IFtmaW5hbFJlc3VsdFR5cGUsIGZpbmFsUmVzdWx0U3RhdGVdID0gZnJlc2hlblR5cGVWYXJpYWJsZXMoXG5cdFx0cmVzdWx0VHlwZSxcblx0XHRuZXcgTWFwKCksXG5cdFx0Y3VycmVudFN0YXRlXG5cdCk7XG5cblx0cmV0dXJuIGNyZWF0ZVR5cGVSZXN1bHQoXG5cdFx0ZmluYWxSZXN1bHRUeXBlLFxuXHRcdHVuaW9uRWZmZWN0cyhsZWZ0UmVzdWx0LmVmZmVjdHMsIHJpZ2h0UmVzdWx0LmVmZmVjdHMpLFxuXHRcdGZpbmFsUmVzdWx0U3RhdGVcblx0KTtcbn07XG5cbi8vIFR5cGUgaW5mZXJlbmNlIGZvciBtdXRhYmxlIGRlZmluaXRpb25zXG5leHBvcnQgY29uc3QgdHlwZU11dGFibGVEZWZpbml0aW9uID0gKFxuXHRleHByOiBNdXRhYmxlRGVmaW5pdGlvbkV4cHJlc3Npb24sXG5cdHN0YXRlOiBUeXBlU3RhdGVcbik6IFR5cGVSZXN1bHQgPT4ge1xuXHQvLyBIYW5kbGUgbXV0YWJsZSBkZWZpbml0aW9ucyBzaW1pbGFyIHRvIHJlZ3VsYXIgZGVmaW5pdGlvbnNcblx0Y29uc3QgdmFsdWVSZXN1bHQgPSB0eXBlRXhwcmVzc2lvbihleHByLnZhbHVlLCBzdGF0ZSk7XG5cdGNvbnN0IG5ld0VudiA9IG1hcFNldChzdGF0ZS5lbnZpcm9ubWVudCwgZXhwci5uYW1lLCB7XG5cdFx0dHlwZTogdmFsdWVSZXN1bHQudHlwZSxcblx0XHRxdWFudGlmaWVkVmFyczogW10sXG5cdH0pO1xuXHRyZXR1cm4gY3JlYXRlVHlwZVJlc3VsdChcblx0XHR2YWx1ZVJlc3VsdC50eXBlLCBcblx0XHR2YWx1ZVJlc3VsdC5lZmZlY3RzLCBcblx0XHR7IC4uLnZhbHVlUmVzdWx0LnN0YXRlLCBlbnZpcm9ubWVudDogbmV3RW52IH1cblx0KTtcbn07XG5cbi8vIFR5cGUgaW5mZXJlbmNlIGZvciBtdXRhdGlvbnNcbmV4cG9ydCBjb25zdCB0eXBlTXV0YXRpb24gPSAoXG5cdGV4cHI6IE11dGF0aW9uRXhwcmVzc2lvbixcblx0c3RhdGU6IFR5cGVTdGF0ZVxuKTogVHlwZVJlc3VsdCA9PiB7XG5cdC8vIEZvciBtdXRhdGlvbnMsIHdlIG5lZWQgdG8gY2hlY2sgdGhhdCB0aGUgdGFyZ2V0IGV4aXN0cyBhbmQgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlc1xuXHRjb25zdCB0YXJnZXRTY2hlbWUgPSBzdGF0ZS5lbnZpcm9ubWVudC5nZXQoZXhwci50YXJnZXQpO1xuXHRpZiAoIXRhcmdldFNjaGVtZSkge1xuXHRcdHRocm93VHlwZUVycm9yKFxuXHRcdFx0bG9jYXRpb24gPT4gdW5kZWZpbmVkVmFyaWFibGVFcnJvcihleHByLnRhcmdldCwgbG9jYXRpb24pLFxuXHRcdFx0Z2V0RXhwckxvY2F0aW9uKGV4cHIpXG5cdFx0KTtcblx0fVxuXG5cdGNvbnN0IHZhbHVlUmVzdWx0ID0gdHlwZUV4cHJlc3Npb24oZXhwci52YWx1ZSwgc3RhdGUpO1xuXHRjb25zdCBuZXdTdGF0ZSA9IHVuaWZ5KFxuXHRcdHRhcmdldFNjaGVtZS50eXBlLFxuXHRcdHZhbHVlUmVzdWx0LnR5cGUsXG5cdFx0dmFsdWVSZXN1bHQuc3RhdGUsXG5cdFx0Z2V0RXhwckxvY2F0aW9uKGV4cHIpXG5cdCk7XG5cblx0cmV0dXJuIGNyZWF0ZVR5cGVSZXN1bHQodW5pdFR5cGUoKSwgdmFsdWVSZXN1bHQuZWZmZWN0cywgbmV3U3RhdGUpOyAvLyBNdXRhdGlvbnMgcmV0dXJuIHVuaXRcbn07XG5cbi8vIFR5cGUgaW5mZXJlbmNlIGZvciBpbXBvcnRzXG5leHBvcnQgY29uc3QgdHlwZUltcG9ydCA9IChcblx0ZXhwcjogSW1wb3J0RXhwcmVzc2lvbixcblx0c3RhdGU6IFR5cGVTdGF0ZVxuKTogVHlwZVJlc3VsdCA9PiB7XG5cdC8vIEZvciBub3csIGFzc3VtZSBpbXBvcnRzIHJldHVybiBhIHJlY29yZCB0eXBlXG5cdHJldHVybiBjcmVhdGVQdXJlVHlwZVJlc3VsdChyZWNvcmRUeXBlKHt9KSwgc3RhdGUpO1xufTtcblxuLy8gVHlwZSBpbmZlcmVuY2UgZm9yIHJlY29yZHNcbmV4cG9ydCBjb25zdCB0eXBlUmVjb3JkID0gKFxuXHRleHByOiBSZWNvcmRFeHByZXNzaW9uLFxuXHRzdGF0ZTogVHlwZVN0YXRlXG4pOiBUeXBlUmVzdWx0ID0+IHtcblx0Y29uc3QgZmllbGRzOiB7IFtrZXk6IHN0cmluZ106IFR5cGUgfSA9IHt9O1xuXHRsZXQgY3VycmVudFN0YXRlID0gc3RhdGU7XG5cdGxldCBhbGxFZmZlY3RzID0gZW1wdHlFZmZlY3RzKCk7XG5cblx0Zm9yIChjb25zdCBmaWVsZCBvZiBleHByLmZpZWxkcykge1xuXHRcdGNvbnN0IGZpZWxkUmVzdWx0ID0gdHlwZUV4cHJlc3Npb24oZmllbGQudmFsdWUsIGN1cnJlbnRTdGF0ZSk7XG5cdFx0ZmllbGRzW2ZpZWxkLm5hbWVdID0gZmllbGRSZXN1bHQudHlwZTtcblx0XHRjdXJyZW50U3RhdGUgPSBmaWVsZFJlc3VsdC5zdGF0ZTtcblx0XHRhbGxFZmZlY3RzID0gdW5pb25FZmZlY3RzKGFsbEVmZmVjdHMsIGZpZWxkUmVzdWx0LmVmZmVjdHMpO1xuXHR9XG5cblx0cmV0dXJuIGNyZWF0ZVR5cGVSZXN1bHQocmVjb3JkVHlwZShmaWVsZHMpLCBhbGxFZmZlY3RzLCBjdXJyZW50U3RhdGUpO1xufTtcblxuLy8gVHlwZSBpbmZlcmVuY2UgZm9yIGFjY2Vzc29yc1xuZXhwb3J0IGNvbnN0IHR5cGVBY2Nlc3NvciA9IChcblx0ZXhwcjogQWNjZXNzb3JFeHByZXNzaW9uLFxuXHRzdGF0ZTogVHlwZVN0YXRlXG4pOiBUeXBlUmVzdWx0ID0+IHtcblx0Ly8gQ2hlY2sgY2FjaGUgZmlyc3Rcblx0Y29uc3QgZmllbGROYW1lID0gZXhwci5maWVsZDtcblx0Y29uc3QgY2FjaGVkVHlwZSA9IHN0YXRlLmFjY2Vzc29yQ2FjaGUuZ2V0KGZpZWxkTmFtZSk7XG5cdGlmIChjYWNoZWRUeXBlKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZVB1cmVUeXBlUmVzdWx0KGNhY2hlZFR5cGUsIHN0YXRlKTtcblx0fVxuXG5cdC8vIEFjY2Vzc29ycyByZXR1cm4gZnVuY3Rpb25zIHRoYXQgdGFrZSBhbnkgcmVjb3JkIHdpdGggdGhlIHJlcXVpcmVkIGZpZWxkIGFuZCByZXR1cm4gdGhlIGZpZWxkIHR5cGVcblx0Ly8gQGJhciBzaG91bGQgaGF2ZSB0eXBlIHtiYXI6IGEsIC4uLn0gLT4gYSAoYWxsb3dzIGV4dHJhIGZpZWxkcylcblx0Ly8gVXNlIGEgZnJlc2ggdHlwZSB2YXJpYWJsZSBmb3IgdGhlIGZpZWxkIHR5cGVcblx0Y29uc3QgW2ZpZWxkVHlwZSwgbmV4dFN0YXRlXSA9IGZyZXNoVHlwZVZhcmlhYmxlKHN0YXRlKTtcblx0Ly8gQ3JlYXRlIGEgc2ltcGxlIHR5cGUgdmFyaWFibGUgZm9yIHRoZSByZWNvcmQgKG5vIGNvbnN0cmFpbnRzIG9uIHRoZSB2YXJpYWJsZSBpdHNlbGYpXG5cdGNvbnN0IFtyZWNvcmRWYXIsIGZpbmFsU3RhdGVdID0gZnJlc2hUeXBlVmFyaWFibGUobmV4dFN0YXRlKTtcblx0Ly8gQ3JlYXRlIGEgZnVuY3Rpb24gdHlwZSB3aXRoIGNvbnN0cmFpbnRzIGF0dGFjaGVkIHRvIHRoZSBmdW5jdGlvbiB0eXBlXG5cdGNvbnN0IGZ1bmNUeXBlID0gZnVuY3Rpb25UeXBlKFtyZWNvcmRWYXJdLCBmaWVsZFR5cGUpO1xuXHQvLyBBZGQgdGhlIGNvbnN0cmFpbnQgZGlyZWN0bHkgdG8gdGhlIHBhcmFtZXRlciB2YXJpYWJsZVxuXHRpZiAocmVjb3JkVmFyLmtpbmQgPT09ICd2YXJpYWJsZScpIHtcblx0XHRyZWNvcmRWYXIuY29uc3RyYWludHMgPSBbXG5cdFx0XHRoYXNGaWVsZENvbnN0cmFpbnQocmVjb3JkVmFyLm5hbWUsIGZpZWxkTmFtZSwgZmllbGRUeXBlKSxcblx0XHRdO1xuXHR9XG5cblx0Ly8gQ2FjaGUgdGhlIHJlc3VsdCBmb3IgZnV0dXJlIHVzZVxuXHRjb25zdCByZXN1bHRTdGF0ZSA9IHtcblx0XHQuLi5maW5hbFN0YXRlLFxuXHRcdGFjY2Vzc29yQ2FjaGU6IG5ldyBNYXAoZmluYWxTdGF0ZS5hY2Nlc3NvckNhY2hlKS5zZXQoZmllbGROYW1lLCBmdW5jVHlwZSksXG5cdH07XG5cblx0cmV0dXJuIGNyZWF0ZVB1cmVUeXBlUmVzdWx0KGZ1bmNUeXBlLCByZXN1bHRTdGF0ZSk7XG59O1xuXG4vLyBUeXBlIGluZmVyZW5jZSBmb3IgdHVwbGVzXG5leHBvcnQgY29uc3QgdHlwZVR1cGxlID0gKFxuXHRleHByOiBUdXBsZUV4cHJlc3Npb24sXG5cdHN0YXRlOiBUeXBlU3RhdGVcbik6IFR5cGVSZXN1bHQgPT4ge1xuXHRjb25zdCBlbGVtZW50czogVHlwZVtdID0gW107XG5cdGxldCBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblx0bGV0IGFsbEVmZmVjdHMgPSBlbXB0eUVmZmVjdHMoKTtcblxuXHRmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZXhwci5lbGVtZW50cykge1xuXHRcdGNvbnN0IGVsZW1lbnRSZXN1bHQgPSB0eXBlRXhwcmVzc2lvbihlbGVtZW50LCBjdXJyZW50U3RhdGUpO1xuXHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudFJlc3VsdC50eXBlKTtcblx0XHRjdXJyZW50U3RhdGUgPSBlbGVtZW50UmVzdWx0LnN0YXRlO1xuXHRcdGFsbEVmZmVjdHMgPSB1bmlvbkVmZmVjdHMoYWxsRWZmZWN0cywgZWxlbWVudFJlc3VsdC5lZmZlY3RzKTtcblx0fVxuXG5cdHJldHVybiBjcmVhdGVUeXBlUmVzdWx0KHR1cGxlVHlwZShlbGVtZW50cyksIGFsbEVmZmVjdHMsIGN1cnJlbnRTdGF0ZSk7XG59O1xuXG4vLyBUeXBlIGluZmVyZW5jZSBmb3IgbGlzdHNcbmV4cG9ydCBjb25zdCB0eXBlTGlzdCA9IChcblx0ZXhwcjogTGlzdEV4cHJlc3Npb24sXG5cdHN0YXRlOiBUeXBlU3RhdGVcbik6IFR5cGVSZXN1bHQgPT4ge1xuXHRpZiAoZXhwci5lbGVtZW50cy5sZW5ndGggPT09IDApIHtcblx0XHQvLyBFbXB0eSBsaXN0IC0gd2UgY2FuJ3QgaW5mZXIgdGhlIGVsZW1lbnQgdHlwZVxuXHRcdHJldHVybiBjcmVhdGVQdXJlVHlwZVJlc3VsdChsaXN0VHlwZVdpdGhFbGVtZW50KHR5cGVWYXJpYWJsZSgnYScpKSwgc3RhdGUpO1xuXHR9XG5cblx0Ly8gSW5mZXIgdGhlIHR5cGUgZnJvbSB0aGUgZmlyc3QgZWxlbWVudFxuXHRsZXQgY3VycmVudFN0YXRlID0gc3RhdGU7XG5cdGNvbnN0IGZpcnN0RWxlbWVudFJlc3VsdCA9IHR5cGVFeHByZXNzaW9uKGV4cHIuZWxlbWVudHNbMF0sIGN1cnJlbnRTdGF0ZSk7XG5cdGN1cnJlbnRTdGF0ZSA9IGZpcnN0RWxlbWVudFJlc3VsdC5zdGF0ZTtcblx0Y29uc3QgZmlyc3RFbGVtZW50VHlwZSA9IGZpcnN0RWxlbWVudFJlc3VsdC50eXBlO1xuXHRsZXQgYWxsRWZmZWN0cyA9IGZpcnN0RWxlbWVudFJlc3VsdC5lZmZlY3RzO1xuXG5cdC8vIENoZWNrIHRoYXQgYWxsIGVsZW1lbnRzIGhhdmUgdGhlIHNhbWUgdHlwZVxuXHRmb3IgKGxldCBpID0gMTsgaSA8IGV4cHIuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBlbGVtZW50UmVzdWx0ID0gdHlwZUV4cHJlc3Npb24oZXhwci5lbGVtZW50c1tpXSwgY3VycmVudFN0YXRlKTtcblx0XHRjdXJyZW50U3RhdGUgPSBlbGVtZW50UmVzdWx0LnN0YXRlO1xuXHRcdGFsbEVmZmVjdHMgPSB1bmlvbkVmZmVjdHMoYWxsRWZmZWN0cywgZWxlbWVudFJlc3VsdC5lZmZlY3RzKTtcblx0XHRjdXJyZW50U3RhdGUgPSB1bmlmeShmaXJzdEVsZW1lbnRUeXBlLCBlbGVtZW50UmVzdWx0LnR5cGUsIGN1cnJlbnRTdGF0ZSwge1xuXHRcdFx0bGluZTogZXhwci5sb2NhdGlvbj8uc3RhcnQubGluZSB8fCAxLFxuXHRcdFx0Y29sdW1uOiBleHByLmxvY2F0aW9uPy5zdGFydC5jb2x1bW4gfHwgMSxcblx0XHR9KTtcblx0fVxuXG5cdC8vIEFwcGx5IHN1YnN0aXR1dGlvbiB0byBnZXQgdGhlIHJlc29sdmVkIGVsZW1lbnQgdHlwZVxuXHRjb25zdCByZXNvbHZlZEVsZW1lbnRUeXBlID0gc3Vic3RpdHV0ZShcblx0XHRmaXJzdEVsZW1lbnRUeXBlLFxuXHRcdGN1cnJlbnRTdGF0ZS5zdWJzdGl0dXRpb25cblx0KTtcblx0cmV0dXJuIGNyZWF0ZVR5cGVSZXN1bHQoXG5cdFx0bGlzdFR5cGVXaXRoRWxlbWVudChyZXNvbHZlZEVsZW1lbnRUeXBlKSxcblx0XHRhbGxFZmZlY3RzLFxuXHRcdGN1cnJlbnRTdGF0ZVxuXHQpO1xufTtcblxuLy8gVHlwZSBpbmZlcmVuY2UgZm9yIHdoZXJlIGV4cHJlc3Npb25zXG5leHBvcnQgY29uc3QgdHlwZVdoZXJlID0gKFxuXHRleHByOiBXaGVyZUV4cHJlc3Npb24sXG5cdHN0YXRlOiBUeXBlU3RhdGVcbik6IFR5cGVSZXN1bHQgPT4ge1xuXHQvLyBDcmVhdGUgYSBuZXcgdHlwZSBlbnZpcm9ubWVudCB3aXRoIHRoZSB3aGVyZS1jbGF1c2UgZGVmaW5pdGlvbnNcblx0bGV0IHdoZXJlRW52ID0gbmV3IE1hcChzdGF0ZS5lbnZpcm9ubWVudCk7XG5cdGxldCBjdXJyZW50U3RhdGUgPSB7IC4uLnN0YXRlLCBlbnZpcm9ubWVudDogd2hlcmVFbnYgfTtcblxuXHQvLyBUeXBlIGFsbCBkZWZpbml0aW9ucyBpbiB0aGUgd2hlcmUgY2xhdXNlXG5cdGZvciAoY29uc3QgZGVmIG9mIGV4cHIuZGVmaW5pdGlvbnMpIHtcblx0XHRpZiAoKGRlZiBhcyBEZWZpbml0aW9uRXhwcmVzc2lvbikua2luZCA9PT0gJ2RlZmluaXRpb24nKSB7XG5cdFx0XHRjb25zdCBkZWZpbml0aW9uRGVmID0gZGVmIGFzIERlZmluaXRpb25FeHByZXNzaW9uO1xuXHRcdFx0Y29uc3QgdmFsdWVSZXN1bHQgPSB0eXBlRXhwcmVzc2lvbihkZWZpbml0aW9uRGVmLnZhbHVlLCBjdXJyZW50U3RhdGUpO1xuXHRcdFx0Y3VycmVudFN0YXRlID0gdmFsdWVSZXN1bHQuc3RhdGU7XG5cblx0XHRcdC8vIEdlbmVyYWxpemUgd2l0aCByZXNwZWN0IHRvIHRoZSBjdXJyZW50IHdoZXJlRW52IChleGNsdWRpbmcgdGhlIG5ldyBiaW5kaW5nKVxuXHRcdFx0Y29uc3QgdGVtcEVudiA9IG5ldyBNYXAoY3VycmVudFN0YXRlLmVudmlyb25tZW50KTtcblx0XHRcdHRlbXBFbnYuZGVsZXRlKGRlZmluaXRpb25EZWYubmFtZSk7XG5cdFx0XHRjb25zdCBzY2hlbWUgPSBnZW5lcmFsaXplKFxuXHRcdFx0XHR2YWx1ZVJlc3VsdC50eXBlLFxuXHRcdFx0XHR0ZW1wRW52LFxuXHRcdFx0XHRjdXJyZW50U3RhdGUuc3Vic3RpdHV0aW9uXG5cdFx0XHQpO1xuXG5cdFx0XHR3aGVyZUVudiA9IG1hcFNldChjdXJyZW50U3RhdGUuZW52aXJvbm1lbnQsIGRlZmluaXRpb25EZWYubmFtZSwgc2NoZW1lKTtcblx0XHRcdGN1cnJlbnRTdGF0ZSA9IHsgLi4uY3VycmVudFN0YXRlLCBlbnZpcm9ubWVudDogd2hlcmVFbnYgfTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0KGRlZiBhcyBNdXRhYmxlRGVmaW5pdGlvbkV4cHJlc3Npb24pLmtpbmQgPT09ICdtdXRhYmxlLWRlZmluaXRpb24nXG5cdFx0KSB7XG5cdFx0XHRjb25zdCBtdXRhYmxlRGVmID0gZGVmIGFzIE11dGFibGVEZWZpbml0aW9uRXhwcmVzc2lvbjtcblx0XHRcdGNvbnN0IHZhbHVlUmVzdWx0ID0gdHlwZUV4cHJlc3Npb24obXV0YWJsZURlZi52YWx1ZSwgY3VycmVudFN0YXRlKTtcblx0XHRcdGN1cnJlbnRTdGF0ZSA9IHZhbHVlUmVzdWx0LnN0YXRlO1xuXG5cdFx0XHR3aGVyZUVudiA9IG1hcFNldChjdXJyZW50U3RhdGUuZW52aXJvbm1lbnQsIG11dGFibGVEZWYubmFtZSwge1xuXHRcdFx0XHR0eXBlOiB2YWx1ZVJlc3VsdC50eXBlLFxuXHRcdFx0XHRxdWFudGlmaWVkVmFyczogW10sXG5cdFx0XHR9KTtcblx0XHRcdGN1cnJlbnRTdGF0ZSA9IHsgLi4uY3VycmVudFN0YXRlLCBlbnZpcm9ubWVudDogd2hlcmVFbnYgfTtcblx0XHR9XG5cdH1cblxuXHQvLyBUeXBlIHRoZSBtYWluIGV4cHJlc3Npb25cblx0Y29uc3QgcmVzdWx0UmVzdWx0ID0gdHlwZUV4cHJlc3Npb24oZXhwci5tYWluLCBjdXJyZW50U3RhdGUpO1xuXG5cdHJldHVybiBjcmVhdGVUeXBlUmVzdWx0KHJlc3VsdFJlc3VsdC50eXBlLCByZXN1bHRSZXN1bHQuZWZmZWN0cywgcmVzdWx0UmVzdWx0LnN0YXRlKTtcbn07XG5cbi8vIFR5cGUgaW5mZXJlbmNlIGZvciB0eXBlZCBleHByZXNzaW9uc1xuZXhwb3J0IGNvbnN0IHR5cGVUeXBlZCA9IChcblx0ZXhwcjogVHlwZWRFeHByZXNzaW9uLFxuXHRzdGF0ZTogVHlwZVN0YXRlXG4pOiBUeXBlUmVzdWx0ID0+IHtcblx0Ly8gRm9yIHR5cGVkIGV4cHJlc3Npb25zLCB2YWxpZGF0ZSB0aGF0IHRoZSBleHBsaWNpdCB0eXBlIG1hdGNoZXMgdGhlIGluZmVycmVkIHR5cGVcblx0Y29uc3QgaW5mZXJyZWRSZXN1bHQgPSB0eXBlRXhwcmVzc2lvbihleHByLmV4cHJlc3Npb24sIHN0YXRlKTtcblx0Y29uc3QgZXhwbGljaXRUeXBlID0gZXhwci50eXBlO1xuXG5cdGNvbnN0IG5ld1N0YXRlID0gdW5pZnkoXG5cdFx0aW5mZXJyZWRSZXN1bHQudHlwZSxcblx0XHRleHBsaWNpdFR5cGUsXG5cdFx0aW5mZXJyZWRSZXN1bHQuc3RhdGUsXG5cdFx0e1xuXHRcdFx0bGluZTogZXhwci5sb2NhdGlvbj8uc3RhcnQubGluZSB8fCAxLFxuXHRcdFx0Y29sdW1uOiBleHByLmxvY2F0aW9uPy5zdGFydC5jb2x1bW4gfHwgMSxcblx0XHR9XG5cdCk7XG5cblx0cmV0dXJuIGNyZWF0ZVR5cGVSZXN1bHQoZXhwbGljaXRUeXBlLCBpbmZlcnJlZFJlc3VsdC5lZmZlY3RzLCBuZXdTdGF0ZSk7IC8vIFVzZSB0aGUgZXhwbGljaXQgdHlwZVxufTtcblxuLy8gVHlwZSBpbmZlcmVuY2UgZm9yIGNvbnN0cmFpbmVkIGV4cHJlc3Npb25zXG5leHBvcnQgY29uc3QgdHlwZUNvbnN0cmFpbmVkID0gKFxuXHRleHByOiBDb25zdHJhaW5lZEV4cHJlc3Npb24sXG5cdHN0YXRlOiBUeXBlU3RhdGVcbik6IFR5cGVSZXN1bHQgPT4ge1xuXHQvLyBGb3IgY29uc3RyYWluZWQgZXhwcmVzc2lvbnMsIHZhbGlkYXRlIHRoYXQgdGhlIGV4cGxpY2l0IHR5cGUgbWF0Y2hlcyB0aGUgaW5mZXJyZWQgdHlwZVxuXHRjb25zdCBpbmZlcnJlZFJlc3VsdCA9IHR5cGVFeHByZXNzaW9uKGV4cHIuZXhwcmVzc2lvbiwgc3RhdGUpO1xuXHRjb25zdCBleHBsaWNpdFR5cGUgPSBleHByLnR5cGU7XG5cblx0bGV0IGN1cnJlbnRTdGF0ZSA9IHVuaWZ5KFxuXHRcdGluZmVycmVkUmVzdWx0LnR5cGUsXG5cdFx0ZXhwbGljaXRUeXBlLFxuXHRcdGluZmVycmVkUmVzdWx0LnN0YXRlLFxuXHRcdHtcblx0XHRcdGxpbmU6IGV4cHIubG9jYXRpb24/LnN0YXJ0LmxpbmUgfHwgMSxcblx0XHRcdGNvbHVtbjogZXhwci5sb2NhdGlvbj8uc3RhcnQuY29sdW1uIHx8IDEsXG5cdFx0fVxuXHQpO1xuXG5cdC8vIFNwZWNpYWwgY2FzZTogaWYgdGhpcyBjb25zdHJhaW5lZCBleHByZXNzaW9uIGlzIGluc2lkZSBhIGZ1bmN0aW9uIGJvZHksXG5cdC8vIHRoZSBjb25zdHJhaW50IHNob3VsZCBhcHBseSB0byB0aGUgZnVuY3Rpb24gdHlwZSwgbm90IHRvIHRoaXMgZXhwcmVzc2lvblxuXHQvLyBGb3Igbm93LCB3ZSdsbCBqdXN0IHJldHVybiB0aGUgZXhwbGljaXQgdHlwZSB3aXRob3V0IGFwcGx5aW5nIGNvbnN0cmFpbnRzIGhlcmVcblx0Ly8gVGhlIGNvbnN0cmFpbnQgd2lsbCBiZSBoYW5kbGVkIGF0IHRoZSBmdW5jdGlvbiBsZXZlbFxuXG5cdC8vIFJldHVybiB0aGUgZXhwbGljaXQgdHlwZSB3aXRob3V0IGNvbnN0cmFpbnRzIGFwcGxpZWRcblx0cmV0dXJuIGNyZWF0ZVR5cGVSZXN1bHQoZXhwbGljaXRUeXBlLCBpbmZlcnJlZFJlc3VsdC5lZmZlY3RzLCBjdXJyZW50U3RhdGUpO1xufTtcblxuLy8gVHlwZSBjb25zdHJhaW50IGRlZmluaXRpb25cbmV4cG9ydCBjb25zdCB0eXBlQ29uc3RyYWludERlZmluaXRpb24gPSAoXG5cdGV4cHI6IENvbnN0cmFpbnREZWZpbml0aW9uRXhwcmVzc2lvbixcblx0c3RhdGU6IFR5cGVTdGF0ZSxcbik6IFR5cGVSZXN1bHQgPT4ge1xuXHRjb25zdCB7IG5hbWUsIHR5cGVQYXJhbSwgZnVuY3Rpb25zIH0gPSBleHByO1xuXHRcblx0Ly8gQ3JlYXRlIGNvbnN0cmFpbnQgc2lnbmF0dXJlXG5cdGNvbnN0IGZ1bmN0aW9uTWFwID0gbmV3IE1hcDxzdHJpbmcsIFR5cGU+KCk7XG5cdFxuXHRmb3IgKGNvbnN0IGZ1bmMgb2YgZnVuY3Rpb25zKSB7XG5cdFx0Ly8gVHlwZSB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlLCBzdWJzdGl0dXRpbmcgdGhlIGNvbnN0cmFpbnQgdHlwZSBwYXJhbWV0ZXJcblx0XHRjb25zdCBmdW5jVHlwZSA9IGZ1bmMudHlwZTtcblx0XHRmdW5jdGlvbk1hcC5zZXQoZnVuYy5uYW1lLCBmdW5jVHlwZSk7XG5cdH1cblx0XG5cdGNvbnN0IHNpZ25hdHVyZTogQ29uc3RyYWludFNpZ25hdHVyZSA9IHtcblx0XHRuYW1lLFxuXHRcdHR5cGVQYXJhbSxcblx0XHRmdW5jdGlvbnM6IGZ1bmN0aW9uTWFwLFxuXHR9O1xuXHRcblx0Ly8gQWRkIHRvIGNvbnN0cmFpbnQgcmVnaXN0cnlcblx0YWRkQ29uc3RyYWludERlZmluaXRpb24oc3RhdGUuY29uc3RyYWludFJlZ2lzdHJ5LCBuYW1lLCBzaWduYXR1cmUpO1xuXHRcblx0Ly8gQ29uc3RyYWludCBkZWZpbml0aW9ucyBoYXZlIHVuaXQgdHlwZVxuXHRyZXR1cm4gY3JlYXRlUHVyZVR5cGVSZXN1bHQodW5pdFR5cGUoKSwgc3RhdGUpO1xufTtcblxuLy8gVHlwZSBpbXBsZW1lbnQgZGVmaW5pdGlvbiAgXG5leHBvcnQgY29uc3QgdHlwZUltcGxlbWVudERlZmluaXRpb24gPSAoXG5cdGV4cHI6IEltcGxlbWVudERlZmluaXRpb25FeHByZXNzaW9uLFxuXHRzdGF0ZTogVHlwZVN0YXRlLFxuKTogVHlwZVJlc3VsdCA9PiB7XG5cdGNvbnN0IHsgY29uc3RyYWludE5hbWUsIHR5cGVOYW1lLCBpbXBsZW1lbnRhdGlvbnMgfSA9IGV4cHI7XG5cdFxuXHQvLyBDaGVjayBpZiBjb25zdHJhaW50IGV4aXN0c1xuXHRjb25zdCBjb25zdHJhaW50U2lnID0gZ2V0Q29uc3RyYWludFNpZ25hdHVyZShzdGF0ZS5jb25zdHJhaW50UmVnaXN0cnksIGNvbnN0cmFpbnROYW1lKTtcblx0aWYgKCFjb25zdHJhaW50U2lnKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBDb25zdHJhaW50ICcke2NvbnN0cmFpbnROYW1lfScgbm90IGRlZmluZWRgKTtcblx0fVxuXHRcblx0Ly8gVHlwZSBlYWNoIGltcGxlbWVudGF0aW9uXG5cdGNvbnN0IGltcGxlbWVudGF0aW9uTWFwID0gbmV3IE1hcDxzdHJpbmcsIFR5cGVTY2hlbWU+KCk7XG5cdGxldCBjdXJyZW50U3RhdGUgPSBzdGF0ZTtcblx0bGV0IGFsbEVmZmVjdHMgPSBlbXB0eUVmZmVjdHMoKTtcblx0XG5cdGZvciAoY29uc3QgaW1wbCBvZiBpbXBsZW1lbnRhdGlvbnMpIHtcblx0XHQvLyBDaGVjayBpZiBmdW5jdGlvbiBpcyByZXF1aXJlZCBieSBjb25zdHJhaW50XG5cdFx0Y29uc3QgcmVxdWlyZWRUeXBlID0gY29uc3RyYWludFNpZy5mdW5jdGlvbnMuZ2V0KGltcGwubmFtZSk7XG5cdFx0aWYgKCFyZXF1aXJlZFR5cGUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gJyR7aW1wbC5uYW1lfScgbm90IHJlcXVpcmVkIGJ5IGNvbnN0cmFpbnQgJyR7Y29uc3RyYWludE5hbWV9J2ApO1xuXHRcdH1cblx0XHRcblx0XHQvLyBUeXBlIHRoZSBpbXBsZW1lbnRhdGlvblxuXHRcdGNvbnN0IGltcGxSZXN1bHQgPSB0eXBlRXhwcmVzc2lvbihpbXBsLnZhbHVlLCBjdXJyZW50U3RhdGUpO1xuXHRcdGN1cnJlbnRTdGF0ZSA9IGltcGxSZXN1bHQuc3RhdGU7XG5cdFx0YWxsRWZmZWN0cyA9IHVuaW9uRWZmZWN0cyhhbGxFZmZlY3RzLCBpbXBsUmVzdWx0LmVmZmVjdHMpO1xuXHRcdFxuXHRcdC8vIFRPRE86IENoZWNrIHRoYXQgaW1wbGVtZW50YXRpb24gdHlwZSBtYXRjaGVzIHJlcXVpcmVkIHR5cGVcblx0XHQvLyBGb3Igbm93LCB3ZSdsbCB0cnVzdCB0aGUgaW1wbGVtZW50YXRpb25cblx0XHRcblx0XHQvLyBTdG9yZSBpbiBpbXBsZW1lbnRhdGlvbiBtYXBcblx0XHRpbXBsZW1lbnRhdGlvbk1hcC5zZXQoaW1wbC5uYW1lLCB7XG5cdFx0XHR0eXBlOiBpbXBsUmVzdWx0LnR5cGUsXG5cdFx0XHRxdWFudGlmaWVkVmFyczogW10sIC8vIFRPRE86IGNvbXB1dGUgcXVhbnRpZmllZCB2YXJpYWJsZXNcblx0XHRcdGVmZmVjdHM6IGltcGxSZXN1bHQuZWZmZWN0cyxcblx0XHR9KTtcblx0fVxuXHRcblx0Ly8gQ2hlY2sgdGhhdCBhbGwgcmVxdWlyZWQgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZFxuXHRmb3IgKGNvbnN0IFtmdW5jTmFtZV0gb2YgY29uc3RyYWludFNpZy5mdW5jdGlvbnMpIHtcblx0XHRpZiAoIWltcGxlbWVudGF0aW9uTWFwLmhhcyhmdW5jTmFtZSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBpbXBsZW1lbnRhdGlvbiBmb3IgJyR7ZnVuY05hbWV9JyBpbiBpbXBsZW1lbnRhdGlvbiBvZiAnJHtjb25zdHJhaW50TmFtZX0nIGZvciAnJHt0eXBlTmFtZX0nYCk7XG5cdFx0fVxuXHR9XG5cdFxuXHQvLyBDcmVhdGUgY29uc3RyYWludCBpbXBsZW1lbnRhdGlvblxuXHRjb25zdCBpbXBsZW1lbnRhdGlvbjogQ29uc3RyYWludEltcGxlbWVudGF0aW9uID0ge1xuXHRcdGZ1bmN0aW9uczogaW1wbGVtZW50YXRpb25NYXAsXG5cdH07XG5cdFxuXHQvLyBBZGQgdG8gY29uc3RyYWludCByZWdpc3RyeVxuXHRjb25zdCBzdWNjZXNzID0gYWRkQ29uc3RyYWludEltcGxlbWVudGF0aW9uKFxuXHRcdGN1cnJlbnRTdGF0ZS5jb25zdHJhaW50UmVnaXN0cnksIFxuXHRcdGNvbnN0cmFpbnROYW1lLCBcblx0XHR0eXBlTmFtZSwgXG5cdFx0aW1wbGVtZW50YXRpb25cblx0KTtcblx0XG5cdGlmICghc3VjY2Vzcykge1xuXHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGFkZCBpbXBsZW1lbnRhdGlvbiBvZiAnJHtjb25zdHJhaW50TmFtZX0nIGZvciAnJHt0eXBlTmFtZX0nYCk7XG5cdH1cblx0XG5cdC8vIEltcGxlbWVudCBkZWZpbml0aW9ucyBoYXZlIHVuaXQgdHlwZVxuXHRyZXR1cm4gY3JlYXRlVHlwZVJlc3VsdCh1bml0VHlwZSgpLCBhbGxFZmZlY3RzLCBjdXJyZW50U3RhdGUpO1xufTsiXSwidmVyc2lvbiI6M30=