{"file":"/workspace/src/typer/type-inference.ts","mappings":"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","names":[],"sources":["/workspace/src/typer/type-inference.ts"],"sourcesContent":["import {\n\ttype Expression,\n\ttype LiteralExpression,\n\ttype VariableExpression,\n\ttype FunctionExpression,\n\ttype BinaryExpression,\n\ttype IfExpression,\n\ttype DefinitionExpression,\n\ttype MutableDefinitionExpression,\n\ttype MutationExpression,\n\ttype ImportExpression,\n\ttype RecordExpression,\n\ttype AccessorExpression,\n\ttype ListExpression,\n\ttype TupleExpression,\n\ttype WhereExpression,\n\ttype TypedExpression,\n\ttype ConstrainedExpression,\n\ttype ConstraintExpr,\n\ttype ConstraintDefinitionExpression,\n\ttype ImplementDefinitionExpression,\n\ttype Type,\n\ttype Constraint,\n\tintType,\n\tstringType,\n\tboolType,\n\tfunctionType,\n\ttypeVariable,\n\tunknownType,\n\tunitType,\n\tlistTypeWithElement,\n\ttupleType,\n\trecordType,\n\thasFieldConstraint,\n} from '../ast';\nimport {\n\tundefinedVariableError,\n\tnonFunctionApplicationError,\n} from './type-errors';\nimport {\n\tgetExprLocation,\n\tthrowTypeError,\n\tmapSet,\n\ttypeToString,\n\tpropagateConstraintToTypeVariable,\n} from './helpers';\nimport { unify } from './unify';\nimport { substitute } from './substitute';\nimport { typeExpression } from './expression-dispatcher';\nimport {\n\ttype TypeState,\n\ttype TypeResult,\n\tcreatePureTypeResult,\n\tcreateTypeResult,\n\tunionEffects,\n\temptyEffects,\n\taddConstraintDefinition,\n\taddConstraintImplementation,\n\tgetConstraintSignature,\n\ttype ConstraintSignature,\n\ttype ConstraintImplementation,\n\ttype TypeScheme,\n} from './types';\nimport { validateConstraintName } from './constraints';\nimport { freshTypeVariable, generalize, instantiate, freshenTypeVariables, flattenStatements } from './type-operations';\n\n// Note: Main typeExpression is now in expression-dispatcher.ts\n// This file only contains the individual type inference functions\n\n// Type inference for literals\nexport const typeLiteral = (\n\texpr: LiteralExpression,\n\tstate: TypeState\n): TypeResult => {\n\tconst value = expr.value;\n\n\tif (typeof value === 'number') {\n\t\treturn createPureTypeResult(intType(), state);\n\t} else if (typeof value === 'string') {\n\t\treturn createPureTypeResult(stringType(), state);\n\t} else {\n\t\treturn createPureTypeResult(unknownType(), state);\n\t}\n};\n\n// Type inference for variables\nexport const typeVariableExpr = (\n\texpr: VariableExpression,\n\tstate: TypeState\n): TypeResult => {\n\tconst scheme = state.environment.get(expr.name);\n\tif (!scheme) {\n\t\t// Check if this is a constraint function before throwing error\n\t\tconst { resolveConstraintVariable, createConstraintFunctionType } = require('./constraint-resolution');\n\t\tconst constraintResult = resolveConstraintVariable(expr.name, state);\n\t\t\n\t\tif (constraintResult.resolved && constraintResult.needsResolution) {\n\t\t\t// This is a constraint function - create its type\n\t\t\tconst constraintType = createConstraintFunctionType(\n\t\t\t\tconstraintResult.constraintName!,\n\t\t\t\tconstraintResult.functionName!,\n\t\t\t\tstate\n\t\t\t);\n\t\t\treturn createPureTypeResult(constraintType, state);\n\t\t}\n\t\t\n\t\tthrowTypeError(\n\t\t\tlocation => undefinedVariableError(expr.name, location),\n\t\t\tgetExprLocation(expr)\n\t\t);\n\t}\n\n\tconst [instantiatedType, newState] = instantiate(scheme, state);\n\n\t// Handle effects from TypeScheme\n\tconst effects = scheme.effects || emptyEffects();\n\treturn createTypeResult(instantiatedType, effects, newState);\n};\n\n// Helper function to count parameters in a function type\nconst countFunctionParams = (type: Type): number => {\n\tif (type.kind !== 'function') return 0;\n\treturn type.params.length + countFunctionParams(type.return);\n};\n\n// Flatten a constraint expression into a list of atomic constraints\nconst flattenConstraintExpr = (expr: ConstraintExpr): Constraint[] => {\n\tswitch (expr.kind) {\n\t\tcase 'is':\n\t\t\t// Validate constraint name\n\t\t\tvalidateConstraintName(expr.constraint);\n\t\t\treturn [expr];\n\t\tcase 'hasField':\n\t\tcase 'implements':\n\t\tcase 'custom':\n\t\t\treturn [expr];\n\t\tcase 'and':\n\t\t\treturn [\n\t\t\t\t...flattenConstraintExpr(expr.left),\n\t\t\t\t...flattenConstraintExpr(expr.right),\n\t\t\t];\n\t\tcase 'or':\n\t\t\treturn [\n\t\t\t\t...flattenConstraintExpr(expr.left),\n\t\t\t\t...flattenConstraintExpr(expr.right),\n\t\t\t];\n\t\tcase 'paren':\n\t\t\treturn flattenConstraintExpr(expr.expr);\n\t\tdefault:\n\t\t\treturn [];\n\t}\n};\n\n// Collect free variables used in an expression\nconst collectFreeVars = (expr: Expression, boundVars: Set<string> = new Set()): Set<string> => {\n\tconst freeVars = new Set<string>();\n\t\n\tconst walk = (e: Expression, bound: Set<string>) => {\n\t\tswitch (e.kind) {\n\t\t\tcase 'variable':\n\t\t\t\tif (!bound.has(e.name)) {\n\t\t\t\t\tfreeVars.add(e.name);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'function':\n\t\t\t\t// Parameters are bound in the function body\n\t\t\t\tconst newBound = new Set([...bound, ...e.params]);\n\t\t\t\twalk(e.body, newBound);\n\t\t\t\tbreak;\n\t\t\tcase 'definition':\n\t\t\t\t// The defined name is bound for the value expression\n\t\t\t\tconst defBound = new Set([...bound, e.name]);\n\t\t\t\twalk(e.value, defBound);\n\t\t\t\tbreak;\n\t\t\tcase 'application':\n\t\t\t\twalk(e.func, bound);\n\t\t\t\te.args.forEach(arg => walk(arg, bound));\n\t\t\t\tbreak;\n\t\t\tcase 'binary':\n\t\t\t\twalk(e.left, bound);\n\t\t\t\twalk(e.right, bound);\n\t\t\t\t// Operator is also a free variable\n\t\t\t\tif (!bound.has(e.operator)) {\n\t\t\t\t\tfreeVars.add(e.operator);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'if':\n\t\t\t\twalk(e.condition, bound);\n\t\t\t\twalk(e.then, bound);\n\t\t\t\twalk(e.else, bound);\n\t\t\t\tbreak;\n\t\t\t// Add other expression types as needed\n\t\t\tdefault:\n\t\t\t\t// For other types, recursively walk any sub-expressions\n\t\t\t\t// This is a simplified approach - in practice you'd handle each type\n\t\t\t\tbreak;\n\t\t}\n\t};\n\t\n\twalk(expr, boundVars);\n\treturn freeVars;\n};\n\n// Update typeFunction to use closure culling\nexport const typeFunction = (\n\texpr: FunctionExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// Collect free variables used in the function body\n\tconst boundParams = new Set(expr.params);\n\tconst freeVars = collectFreeVars(expr.body, boundParams);\n\t\n\t// Create a minimal environment with only what's needed\n\tconst functionEnv = new Map<string, any>();\n\t\n\t// Always include built-ins and stdlib essentials  \n\tconst essentials = [\n\t\t'+',\n\t\t'-',\n\t\t'*',\n\t\t'/',\n\t\t'==',\n\t\t'!=',\n\t\t'<',\n\t\t'>',\n\t\t'<=',\n\t\t'>=',\n\t\t'|',\n\t\t'|>',\n\t\t'<|',\n\t\t';',\n\t\t'$',\n\t\t'if',\n\t\t'length',\n\t\t'head',\n\t\t'tail',\n\t\t'map',\n\t\t'filter',\n\t\t'reduce',\n\t\t'isEmpty',\n\t\t'append',\n\t\t'concat',\n\t\t'toString',\n\t\t'abs',\n\t\t'max',\n\t\t'min',\n\t\t'print',\n\t\t'println',\n\t\t'readFile',\n\t\t'writeFile',\n\t\t'log',\n\t\t'random',\n\t\t'randomRange',\n\t\t'mutSet',\n\t\t'mutGet',\n\t\t'hasKey',\n\t\t'hasValue',\n\t\t'set',\n\t\t'tupleLength',\n\t\t'tupleIsEmpty',\n\t\t'list_get',\n\t\t'True',\n\t\t'False',\n\t\t'None',\n\t\t'Some',\n\t\t'Ok',\n\t\t'Err',\n\t\t'Bool',\n\t\t'Option',\n\t\t'Result',\n\t];\n\tfor (const essential of essentials) {\n\t\tif (state.environment.has(essential)) {\n\t\t\tfunctionEnv.set(essential, state.environment.get(essential)!);\n\t\t}\n\t}\n\t\n\t// Include only the free variables actually used\n\tfor (const freeVar of freeVars) {\n\t\tif (state.environment.has(freeVar)) {\n\t\t\tfunctionEnv.set(freeVar, state.environment.get(freeVar)!);\n\t\t}\n\t}\n\t\n\t// Closure optimization: using minimal environment\n\t\n\tlet currentState = { ...state, environment: functionEnv };\n\n\tconst paramTypes: Type[] = [];\n\tfor (const param of expr.params) {\n\t\tconst [paramType, nextState] = freshTypeVariable(currentState);\n\t\tfunctionEnv.set(param, { type: paramType, quantifiedVars: [] });\n\t\tparamTypes.push(paramType);\n\t\tcurrentState = { ...nextState, environment: functionEnv };\n\t}\n\n\t// Type the function body with the function-local environment\n\tconst bodyResult = typeExpression(expr.body, currentState);\n\tcurrentState = bodyResult.state;\n\n\t// Decorate the function body with its inferred type\n\texpr.body.type = bodyResult.type;\n\n\t// Restore the original environment for the outer scope\n\tcurrentState = { ...currentState, environment: state.environment };\n\n\t// Special handling for constrained function bodies\n\tlet funcType: Type;\n\n\tif (expr.body.kind === 'constrained') {\n\t\tconst constrainedBody = expr.body as ConstrainedExpression;\n\t\tconst constraints = flattenConstraintExpr(constrainedBody.constraint);\n\n\t\t// If the constrained body has an explicit function type, use it as the innermost type\n\t\tif (constrainedBody.type.kind === 'function') {\n\t\t\tfuncType = constrainedBody.type;\n\n\t\t\t// Apply constraints to this function type\n\t\t\tif (constraints.length > 0) {\n\t\t\t\tfuncType.constraints = constraints;\n\t\t\t\t// Store the original constraint expression for display purposes\n\t\t\t\t(funcType as any).originalConstraint = constrainedBody.constraint;\n\n\t\t\t\t// CRITICAL: Also propagate constraints to type variables in parameters\n\t\t\t\t// This ensures constraint validation works during function application\n\t\t\t\tfor (const constraint of constraints) {\n\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\tpropagateConstraintToTypeVariable(funcType, constraint);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we have more parameters than the explicit type accounts for, wrap it\n\t\t\tconst explicitParamCount = countFunctionParams(constrainedBody.type);\n\t\t\tconst actualParamCount = paramTypes.length;\n\t\t\tif (actualParamCount > explicitParamCount) {\n\t\t\t\t// Wrap the explicit function type with additional parameter layers\n\t\t\t\tfor (let i = actualParamCount - explicitParamCount - 1; i >= 0; i--) {\n\t\t\t\t\tfuncType = functionType([paramTypes[i]], funcType);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Build function type normally and apply constraints\n\t\t\tfuncType = bodyResult.type;\n\t\t\tfor (let i = paramTypes.length - 1; i >= 0; i--) {\n\t\t\t\tfuncType = functionType([paramTypes[i]], funcType);\n\t\t\t}\n\t\t\tif (constraints.length > 0 && funcType.kind === 'function') {\n\t\t\t\tfuncType.constraints = constraints;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Build the function type normally\n\t\tfuncType = bodyResult.type;\n\t\tfor (let i = paramTypes.length - 1; i >= 0; i--) {\n\t\t\tfuncType = functionType([paramTypes[i]], funcType);\n\t\t}\n\t}\n\n\treturn createTypeResult(funcType, bodyResult.effects, currentState);\n};\n\n// Type inference for definitions\nexport const typeDefinition = (\n\texpr: DefinitionExpression,\n\tstate: TypeState\n): TypeResult => {\n\tlet currentState = state;\n\n\t// Add placeholder for recursion before inferring the value\n\tconst [placeholderType, newState] = freshTypeVariable(currentState);\n\tcurrentState = newState;\n\n\tconst tempEnv = mapSet(currentState.environment, expr.name, {\n\t\ttype: placeholderType,\n\t\tquantifiedVars: [],\n\t});\n\tcurrentState = { ...currentState, environment: tempEnv };\n\n\t// Type the value\n\tconst valueResult = typeExpression(expr.value, currentState);\n\tcurrentState = valueResult.state;\n\n\t// Decorate the value with its inferred type\n\texpr.value.type = valueResult.type;\n\n\t// Unify placeholder with actual type for recursion\n\tcurrentState = unify(\n\t\tplaceholderType,\n\t\tvalueResult.type,\n\t\tcurrentState,\n\t\tgetExprLocation(expr)\n\t);\n\n\t// Remove the just-defined variable from the environment for generalization\n\tconst envForGen = new Map(currentState.environment);\n\tenvForGen.delete(expr.name);\n\n\t// Generalize the type before storing in the environment (apply substitution!)\n\tconst scheme = generalize(\n\t\tvalueResult.type,\n\t\tenvForGen,\n\t\tcurrentState.substitution\n\t);\n\n\t// Add to environment with generalized type\n\tconst finalEnv = mapSet(currentState.environment, expr.name, scheme);\n\tcurrentState = { ...currentState, environment: finalEnv };\n\n\t// Freshen type variables for the definition's value (thread state)\n\tconst [finalType, finalState] = freshenTypeVariables(\n\t\tvalueResult.type,\n\t\tnew Map(),\n\t\tcurrentState\n\t);\n\treturn createTypeResult(finalType, valueResult.effects, finalState);\n};\n\n// Type inference for if expressions\nexport const typeIf = (expr: IfExpression, state: TypeState): TypeResult => {\n\tlet currentState = state;\n\n\t// Type condition\n\tconst conditionResult = typeExpression(expr.condition, currentState);\n\tcurrentState = conditionResult.state;\n\n\t// Unify condition with boolean\n\tcurrentState = unify(\n\t\tconditionResult.type,\n\t\tboolType(),\n\t\tcurrentState,\n\t\tgetExprLocation(expr)\n\t);\n\n\t// Type then branch\n\tconst thenResult = typeExpression(expr.then, currentState);\n\tcurrentState = thenResult.state;\n\n\t// Type else branch\n\tconst elseResult = typeExpression(expr.else, currentState);\n\tcurrentState = elseResult.state;\n\n\t// Unify then and else types\n\tcurrentState = unify(\n\t\tthenResult.type,\n\t\telseResult.type,\n\t\tcurrentState,\n\t\tgetExprLocation(expr)\n\t);\n\n\t// Apply substitution to get final type\n\tconst finalType = substitute(thenResult.type, currentState.substitution);\n\n\treturn createTypeResult(finalType, unionEffects(conditionResult.effects, thenResult.effects, elseResult.effects), currentState);\n};\n\n// Type inference for binary expressions\nexport const typeBinary = (\n\texpr: BinaryExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// Special handling for semicolon operator (sequence) - flatten to avoid O(n²) re-evaluation\n\tif (expr.operator === ';') {\n\t\t// Flatten the semicolon sequence and process each statement exactly once\n\t\tconst statements = flattenStatements(expr);\n\t\tlet currentState = state;\n\t\tlet finalType = null;\n\t\tlet allEffects = emptyEffects();\n\n\t\tfor (const statement of statements) {\n\t\t\tconst result = typeExpression(statement, currentState);\n\t\t\tcurrentState = result.state;\n\t\t\tfinalType = result.type;\n\t\t\tallEffects = unionEffects(allEffects, result.effects);\n\t\t}\n\n\t\treturn createTypeResult(finalType || unitType(), allEffects, currentState);\n\t}\n\n\tlet currentState = state;\n\n\t// Type left operand\n\tconst leftResult = typeExpression(expr.left, currentState);\n\tcurrentState = leftResult.state;\n\n\t// Type right operand\n\tconst rightResult = typeExpression(expr.right, currentState);\n\tcurrentState = rightResult.state;\n\n\t// Special handling for thrush operator (|) - function application\n\tif (expr.operator === '|') {\n\t\t// Thrush: a | b means b(a) - apply right function to left value\n\t\tif (rightResult.type.kind !== 'function') {\n\t\t\tthrowTypeError(\n\t\t\t\tlocation => nonFunctionApplicationError(rightResult.type, location),\n\t\t\t\tgetExprLocation(expr)\n\t\t\t);\n\t\t}\n\n\t\t// Check that the function can take the left value as its first argument\n\t\tif (rightResult.type.params.length < 1) {\n\t\t\tthrow new Error(\n\t\t\t\t`Thrush operator requires function with at least one parameter, got ${rightResult.type.params.length}`\n\t\t\t);\n\t\t}\n\n\t\tcurrentState = unify(\n\t\t\trightResult.type.params[0],\n\t\t\tleftResult.type,\n\t\t\tcurrentState,\n\t\t\tgetExprLocation(expr)\n\t\t);\n\n\t\t// Return the function's return type (which may be a partially applied function)\n\t\treturn createTypeResult(\n\t\t\trightResult.type.return,\n\t\t\tunionEffects(leftResult.effects, rightResult.effects),\n\t\t\tcurrentState\n\t\t);\n\t}\n\n\t// Special handling for dollar operator ($) - low precedence function application\n\tif (expr.operator === '$') {\n\t\t// Dollar: a $ b means a(b) - apply left function to right value\n\t\t// Delegate to the same logic as regular function application\n\t\tconst { typeApplication } = require('./function-application');\n\t\t\n\t\t// Create a synthetic ApplicationExpression for a $ b\n\t\tconst syntheticApp: import('../ast').ApplicationExpression = {\n\t\t\tkind: 'application',\n\t\t\tfunc: expr.left,\n\t\t\targs: [expr.right],\n\t\t\tlocation: expr.location\n\t\t};\n\t\t\n\t\treturn typeApplication(syntheticApp, currentState);\n\t}\n\n\t// Get operator type from environment\n\tconst operatorScheme = currentState.environment.get(expr.operator);\n\tif (!operatorScheme) {\n\t\tthrow new Error(`Unknown operator: ${expr.operator}`);\n\t}\n\n\tconst [operatorType, newState] = instantiate(operatorScheme, currentState);\n\tcurrentState = newState;\n\n\t// Create fresh type variable for result\n\tconst [resultType, finalState] = freshTypeVariable(currentState);\n\tcurrentState = finalState;\n\n\t// Build expected function type\n\tconst expectedType = functionType(\n\t\t[leftResult.type, rightResult.type],\n\t\tresultType\n\t);\n\n\t// Unify operator type with expected type\n\tcurrentState = unify(\n\t\toperatorType,\n\t\texpectedType,\n\t\tcurrentState,\n\t\tgetExprLocation(expr),\n\t\t{\n\t\t\treason: 'operator_application',\n\t\t\toperation: `applying operator ${expr.operator}`,\n\t\t\thint: `The ${\n\t\t\t\texpr.operator\n\t\t\t} operator expects compatible operand types. Left operand: ${typeToString(\n\t\t\t\tleftResult.type,\n\t\t\t\tcurrentState.substitution\n\t\t\t)}, Right operand: ${typeToString(\n\t\t\t\trightResult.type,\n\t\t\t\tcurrentState.substitution\n\t\t\t)}.`,\n\t\t}\n\t);\n\n\t// Apply substitution to get final result type\n\tconst [finalResultType, finalResultState] = freshenTypeVariables(\n\t\tresultType,\n\t\tnew Map(),\n\t\tcurrentState\n\t);\n\n\treturn createTypeResult(\n\t\tfinalResultType,\n\t\tunionEffects(leftResult.effects, rightResult.effects),\n\t\tfinalResultState\n\t);\n};\n\n// Type inference for mutable definitions\nexport const typeMutableDefinition = (\n\texpr: MutableDefinitionExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// Handle mutable definitions similar to regular definitions\n\tconst valueResult = typeExpression(expr.value, state);\n\tconst newEnv = mapSet(state.environment, expr.name, {\n\t\ttype: valueResult.type,\n\t\tquantifiedVars: [],\n\t});\n\treturn createTypeResult(\n\t\tvalueResult.type, \n\t\tvalueResult.effects, \n\t\t{ ...valueResult.state, environment: newEnv }\n\t);\n};\n\n// Type inference for mutations\nexport const typeMutation = (\n\texpr: MutationExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// For mutations, we need to check that the target exists and the value type matches\n\tconst targetScheme = state.environment.get(expr.target);\n\tif (!targetScheme) {\n\t\tthrowTypeError(\n\t\t\tlocation => undefinedVariableError(expr.target, location),\n\t\t\tgetExprLocation(expr)\n\t\t);\n\t}\n\n\tconst valueResult = typeExpression(expr.value, state);\n\tconst newState = unify(\n\t\ttargetScheme.type,\n\t\tvalueResult.type,\n\t\tvalueResult.state,\n\t\tgetExprLocation(expr)\n\t);\n\n\treturn createTypeResult(unitType(), valueResult.effects, newState); // Mutations return unit\n};\n\n// Type inference for imports\nexport const typeImport = (\n\texpr: ImportExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// For now, assume imports return a record type\n\treturn createPureTypeResult(recordType({}), state);\n};\n\n// Type inference for records\nexport const typeRecord = (\n\texpr: RecordExpression,\n\tstate: TypeState\n): TypeResult => {\n\tconst fields: { [key: string]: Type } = {};\n\tlet currentState = state;\n\tlet allEffects = emptyEffects();\n\n\tfor (const field of expr.fields) {\n\t\tconst fieldResult = typeExpression(field.value, currentState);\n\t\tfields[field.name] = fieldResult.type;\n\t\tcurrentState = fieldResult.state;\n\t\tallEffects = unionEffects(allEffects, fieldResult.effects);\n\t}\n\n\treturn createTypeResult(recordType(fields), allEffects, currentState);\n};\n\n// Type inference for accessors\nexport const typeAccessor = (\n\texpr: AccessorExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// Check cache first\n\tconst fieldName = expr.field;\n\tconst cachedType = state.accessorCache.get(fieldName);\n\tif (cachedType) {\n\t\treturn createPureTypeResult(cachedType, state);\n\t}\n\n\t// Accessors return functions that take any record with the required field and return the field type\n\t// @bar should have type {bar: a, ...} -> a (allows extra fields)\n\t// Use a fresh type variable for the field type\n\tconst [fieldType, nextState] = freshTypeVariable(state);\n\t// Create a simple type variable for the record (no constraints on the variable itself)\n\tconst [recordVar, finalState] = freshTypeVariable(nextState);\n\t// Create a function type with constraints attached to the function type\n\tconst funcType = functionType([recordVar], fieldType);\n\t// Add the constraint directly to the parameter variable\n\tif (recordVar.kind === 'variable') {\n\t\trecordVar.constraints = [\n\t\t\thasFieldConstraint(recordVar.name, fieldName, fieldType),\n\t\t];\n\t}\n\n\t// Cache the result for future use\n\tconst resultState = {\n\t\t...finalState,\n\t\taccessorCache: new Map(finalState.accessorCache).set(fieldName, funcType),\n\t};\n\n\treturn createPureTypeResult(funcType, resultState);\n};\n\n// Type inference for tuples\nexport const typeTuple = (\n\texpr: TupleExpression,\n\tstate: TypeState\n): TypeResult => {\n\tconst elements: Type[] = [];\n\tlet currentState = state;\n\tlet allEffects = emptyEffects();\n\n\tfor (const element of expr.elements) {\n\t\tconst elementResult = typeExpression(element, currentState);\n\t\telements.push(elementResult.type);\n\t\tcurrentState = elementResult.state;\n\t\tallEffects = unionEffects(allEffects, elementResult.effects);\n\t}\n\n\treturn createTypeResult(tupleType(elements), allEffects, currentState);\n};\n\n// Type inference for lists\nexport const typeList = (\n\texpr: ListExpression,\n\tstate: TypeState\n): TypeResult => {\n\tif (expr.elements.length === 0) {\n\t\t// Empty list - we can't infer the element type\n\t\treturn createPureTypeResult(listTypeWithElement(typeVariable('a')), state);\n\t}\n\n\t// Infer the type from the first element\n\tlet currentState = state;\n\tconst firstElementResult = typeExpression(expr.elements[0], currentState);\n\tcurrentState = firstElementResult.state;\n\tconst firstElementType = firstElementResult.type;\n\tlet allEffects = firstElementResult.effects;\n\n\t// Check that all elements have the same type\n\tfor (let i = 1; i < expr.elements.length; i++) {\n\t\tconst elementResult = typeExpression(expr.elements[i], currentState);\n\t\tcurrentState = elementResult.state;\n\t\tallEffects = unionEffects(allEffects, elementResult.effects);\n\t\tcurrentState = unify(firstElementType, elementResult.type, currentState, {\n\t\t\tline: expr.location?.start.line || 1,\n\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t});\n\t}\n\n\t// Apply substitution to get the resolved element type\n\tconst resolvedElementType = substitute(\n\t\tfirstElementType,\n\t\tcurrentState.substitution\n\t);\n\treturn createTypeResult(\n\t\tlistTypeWithElement(resolvedElementType),\n\t\tallEffects,\n\t\tcurrentState\n\t);\n};\n\n// Type inference for where expressions\nexport const typeWhere = (\n\texpr: WhereExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// Create a new type environment with the where-clause definitions\n\tlet whereEnv = new Map(state.environment);\n\tlet currentState = { ...state, environment: whereEnv };\n\n\t// Type all definitions in the where clause\n\tfor (const def of expr.definitions) {\n\t\tif ((def as DefinitionExpression).kind === 'definition') {\n\t\t\tconst definitionDef = def as DefinitionExpression;\n\t\t\tconst valueResult = typeExpression(definitionDef.value, currentState);\n\t\t\tcurrentState = valueResult.state;\n\n\t\t\t// Generalize with respect to the current whereEnv (excluding the new binding)\n\t\t\tconst tempEnv = new Map(currentState.environment);\n\t\t\ttempEnv.delete(definitionDef.name);\n\t\t\tconst scheme = generalize(\n\t\t\t\tvalueResult.type,\n\t\t\t\ttempEnv,\n\t\t\t\tcurrentState.substitution\n\t\t\t);\n\n\t\t\twhereEnv = mapSet(currentState.environment, definitionDef.name, scheme);\n\t\t\tcurrentState = { ...currentState, environment: whereEnv };\n\t\t} else if (\n\t\t\t(def as MutableDefinitionExpression).kind === 'mutable-definition'\n\t\t) {\n\t\t\tconst mutableDef = def as MutableDefinitionExpression;\n\t\t\tconst valueResult = typeExpression(mutableDef.value, currentState);\n\t\t\tcurrentState = valueResult.state;\n\n\t\t\twhereEnv = mapSet(currentState.environment, mutableDef.name, {\n\t\t\t\ttype: valueResult.type,\n\t\t\t\tquantifiedVars: [],\n\t\t\t});\n\t\t\tcurrentState = { ...currentState, environment: whereEnv };\n\t\t}\n\t}\n\n\t// Type the main expression\n\tconst resultResult = typeExpression(expr.main, currentState);\n\n\treturn createTypeResult(resultResult.type, resultResult.effects, resultResult.state);\n};\n\n// Type inference for typed expressions\nexport const typeTyped = (\n\texpr: TypedExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// For typed expressions, validate that the explicit type matches the inferred type\n\tconst inferredResult = typeExpression(expr.expression, state);\n\tconst explicitType = expr.type;\n\n\tconst newState = unify(\n\t\tinferredResult.type,\n\t\texplicitType,\n\t\tinferredResult.state,\n\t\t{\n\t\t\tline: expr.location?.start.line || 1,\n\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t}\n\t);\n\n\treturn createTypeResult(explicitType, inferredResult.effects, newState); // Use the explicit type\n};\n\n// Type inference for constrained expressions\nexport const typeConstrained = (\n\texpr: ConstrainedExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// For constrained expressions, validate that the explicit type matches the inferred type\n\tconst inferredResult = typeExpression(expr.expression, state);\n\tconst explicitType = expr.type;\n\n\tlet currentState = unify(\n\t\tinferredResult.type,\n\t\texplicitType,\n\t\tinferredResult.state,\n\t\t{\n\t\t\tline: expr.location?.start.line || 1,\n\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t}\n\t);\n\n\t// Special case: if this constrained expression is inside a function body,\n\t// the constraint should apply to the function type, not to this expression\n\t// For now, we'll just return the explicit type without applying constraints here\n\t// The constraint will be handled at the function level\n\n\t// Return the explicit type without constraints applied\n\treturn createTypeResult(explicitType, inferredResult.effects, currentState);\n};\n\n// Type constraint definition\nexport const typeConstraintDefinition = (\n\texpr: ConstraintDefinitionExpression,\n\tstate: TypeState,\n): TypeResult => {\n\tconst { name, typeParam, functions } = expr;\n\t\n\t// Create constraint signature\n\tconst functionMap = new Map<string, Type>();\n\t\n\tfor (const func of functions) {\n\t\t// Type the function signature, substituting the constraint type parameter\n\t\tconst funcType = func.type;\n\t\tfunctionMap.set(func.name, funcType);\n\t}\n\t\n\tconst signature: ConstraintSignature = {\n\t\tname,\n\t\ttypeParam,\n\t\tfunctions: functionMap,\n\t};\n\t\n\t// Add to constraint registry\n\taddConstraintDefinition(state.constraintRegistry, name, signature);\n\t\n\t// Constraint definitions have unit type\n\treturn createPureTypeResult(unitType(), state);\n};\n\n// Type implement definition  \nexport const typeImplementDefinition = (\n\texpr: ImplementDefinitionExpression,\n\tstate: TypeState,\n): TypeResult => {\n\tconst { constraintName, typeName, implementations } = expr;\n\t\n\t// Check if constraint exists\n\tconst constraintSig = getConstraintSignature(state.constraintRegistry, constraintName);\n\tif (!constraintSig) {\n\t\tthrow new Error(`Constraint '${constraintName}' not defined`);\n\t}\n\t\n\t// Type each implementation\n\tconst implementationMap = new Map<string, TypeScheme>();\n\tlet currentState = state;\n\tlet allEffects = emptyEffects();\n\t\n\tfor (const impl of implementations) {\n\t\t// Check if function is required by constraint\n\t\tconst requiredType = constraintSig.functions.get(impl.name);\n\t\tif (!requiredType) {\n\t\t\tthrow new Error(`Function '${impl.name}' not required by constraint '${constraintName}'`);\n\t\t}\n\t\t\n\t\t// Type the implementation\n\t\tconst implResult = typeExpression(impl.value, currentState);\n\t\tcurrentState = implResult.state;\n\t\tallEffects = unionEffects(allEffects, implResult.effects);\n\t\t\n\t\t// TODO: Check that implementation type matches required type\n\t\t// For now, we'll trust the implementation\n\t\t\n\t\t// Store in implementation map\n\t\timplementationMap.set(impl.name, {\n\t\t\ttype: implResult.type,\n\t\t\tquantifiedVars: [], // TODO: compute quantified variables\n\t\t\teffects: implResult.effects,\n\t\t});\n\t}\n\t\n\t// Check that all required functions are implemented\n\tfor (const [funcName] of constraintSig.functions) {\n\t\tif (!implementationMap.has(funcName)) {\n\t\t\tthrow new Error(`Missing implementation for '${funcName}' in implementation of '${constraintName}' for '${typeName}'`);\n\t\t}\n\t}\n\t\n\t// Create constraint implementation\n\tconst implementation: ConstraintImplementation = {\n\t\tfunctions: implementationMap,\n\t};\n\t\n\t// Add to constraint registry\n\tconst success = addConstraintImplementation(\n\t\tcurrentState.constraintRegistry, \n\t\tconstraintName, \n\t\ttypeName, \n\t\timplementation\n\t);\n\t\n\tif (!success) {\n\t\tthrow new Error(`Failed to add implementation of '${constraintName}' for '${typeName}'`);\n\t}\n\t\n\t// Implement definitions have unit type\n\treturn createTypeResult(unitType(), allEffects, currentState);\n};"],"version":3}