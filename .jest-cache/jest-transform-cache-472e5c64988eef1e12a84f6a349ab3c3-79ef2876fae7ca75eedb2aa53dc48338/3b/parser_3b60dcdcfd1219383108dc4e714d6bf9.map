{"file":"/workspace/src/parser/parser.ts","mappings":"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","names":[],"sources":["/workspace/src/parser/parser.ts"],"sourcesContent":["import type { Token } from \"../lexer\";\nimport {\n\ttype Expression,\n\ttype Program,\n\ttype LiteralExpression,\n\ttype VariableExpression,\n\ttype FunctionExpression,\n\tcreateLocation,\n\ttype DefinitionExpression,\n\ttype MutableDefinitionExpression,\n\ttype ImportExpression,\n\ttype AccessorExpression,\n\ttype Type,\n\ttype Effect,\n\tintType,\n\tstringType,\n\tunitType,\n\tlistTypeWithElement,\n\tfunctionType,\n\ttypeVariable,\n\ttype TypedExpression,\n\ttype ConstrainedExpression,\n\ttype ListExpression,\n\ttype WhereExpression,\n\trecordType,\n\ttupleType,\n\ttupleTypeConstructor,\n\ttype ConstraintExpr,\n\ttype TypeDefinitionExpression,\n\ttype MatchExpression,\n\ttype ConstructorDefinition,\n\ttype Pattern,\n\ttype MatchCase,\n\ttype UnitExpression,\n\ttype RecordExpression,\n\ttype TupleExpression,\n\ttype ConstraintDefinitionExpression,\n\ttype ImplementDefinitionExpression,\n\ttype ConstraintFunction,\n\ttype ImplementationFunction,\n} from '../ast';\nimport * as C from \"./combinators\";\n\n// --- Helper: parse type name (IDENTIFIER or type-related KEYWORD) ---\nconst parseTypeName: C.Parser<Token> = (tokens: Token[]) => {\n  if (tokens.length === 0) {\n    return {\n      success: false,\n      error: \"Expected type name, but got end of input\",\n      position: 0,\n    };\n  }\n\n  const [first, ...rest] = tokens;\n  const typeKeywords = [\"Int\", \"Number\", \"String\", \"Unit\", \"List\"];\n\n  if (\n    first.type === \"IDENTIFIER\" ||\n    (first.type === \"KEYWORD\" && typeKeywords.includes(first.value))\n  ) {\n    return {\n      success: true,\n      value: first,\n      remaining: rest,\n    };\n  }\n\n  return {\n    success: false,\n    error: `Expected type name, but got ${first.type} '${first.value}'`,\n    position: first.location.start.line,\n  };\n};\n\n// --- Helper: parse a single type atom (primitive, variable, record, tuple, list) ---\nfunction parseTypeAtom(tokens: Token[]): C.ParseResult<Type> {\n  // Try primitive types first, but handle List as a parameterizable type constructor\n  const primitiveTypes = [\"Int\", \"Number\", \"String\", \"Unit\"];\n  for (const typeName of primitiveTypes) {\n    const result = C.keyword(typeName)(tokens);\n    if (result.success) {\n      switch (typeName) {\n        case \"Int\":\n        case \"Number\":\n          return {\n            success: true as const,\n            value: intType(),\n            remaining: result.remaining,\n          };\n        case \"String\":\n          return {\n            success: true as const,\n            value: stringType(),\n            remaining: result.remaining,\n          };\n        case \"Unit\":\n          return {\n            success: true as const,\n            value: unitType(),\n            remaining: result.remaining,\n          };\n      }\n    }\n  }\n\n  // Try List as a parameterizable type constructor\n  const listKeywordResult = C.keyword(\"List\")(tokens);\n  if (listKeywordResult.success) {\n    // Try to parse a type argument for List\n    const argResult = C.lazy(() => parseTypeAtom)(listKeywordResult.remaining);\n    if (argResult.success) {\n      // List with specific element type: List Number, List String, etc.\n      return {\n        success: true as const,\n        value: listTypeWithElement(argResult.value),\n        remaining: argResult.remaining,\n      };\n    } else {\n      // Just List (generic)\n      return {\n        success: true as const,\n        value: listTypeWithElement(typeVariable(\"a\")),\n        remaining: listKeywordResult.remaining,\n      };\n    }\n  }\n\n\n\n  // Try record type\n  const recordResult = C.seq(\n    C.punctuation(\"{\"),\n    C.optional(\n      C.sepBy(\n        C.map(\n          C.seq(\n            C.identifier(),\n            C.punctuation(\":\"),\n            C.lazy(() => parseTypeExpression)\n          ),\n          ([name, colon, type]) => [name.value, type] as [string, Type]\n        ),\n        C.punctuation(\",\")\n      )\n    ),\n    C.punctuation(\"}\")\n  )(tokens);\n  if (recordResult.success) {\n    const fields: Array<[string, Type]> = recordResult.value[1] || [];\n    const fieldObj: Record<string, Type> = {};\n    for (const [name, type] of fields) {\n      fieldObj[name] = type;\n    }\n    return {\n      success: true as const,\n      value: recordType(fieldObj),\n      remaining: recordResult.remaining,\n    };\n  }\n\n  // Try tuple type\n  const tupleResult = C.seq(\n    C.punctuation(\"{\"),\n    C.optional(\n      C.sepBy(\n        C.lazy(() => parseTypeExpression),\n        C.punctuation(\",\")\n      )\n    ),\n    C.punctuation(\"}\")\n  )(tokens);\n  if (tupleResult.success) {\n    const elements = tupleResult.value[1] || [];\n    return {\n      success: true as const,\n      value: tupleType(elements),\n      remaining: tupleResult.remaining,\n    };\n  }\n\n  // Try List type\n  const listResult = C.seq(\n    C.keyword(\"List\"),\n    C.lazy(() => parseTypeExpression)\n  )(tokens);\n  if (listResult.success) {\n    return {\n      success: true as const,\n      value: listTypeWithElement(listResult.value[1]),\n      remaining: listResult.remaining,\n    };\n  }\n\n  // Try Tuple type constructor: Tuple T1 T2 T3\n  if (\n    tokens.length > 0 &&\n    tokens[0].type === \"IDENTIFIER\" &&\n    tokens[0].value === \"Tuple\"\n  ) {\n    const tupleConstructorResult = C.seq(\n      C.identifier(),\n      C.many(C.lazy(() => parseTypeExpression))\n    )(tokens);\n    if (tupleConstructorResult.success) {\n      const elementTypes = tupleConstructorResult.value[1];\n      return {\n        success: true as const,\n        value: tupleTypeConstructor(elementTypes),\n        remaining: tupleConstructorResult.remaining,\n      };\n    }\n  }\n\n  // Try parenthesized type: (Type)\n  const parenResult = C.seq(\n    C.punctuation(\"(\"),\n    C.lazy(() => parseTypeExpression),\n    C.punctuation(\")\")\n  )(tokens);\n  if (parenResult.success) {\n    return {\n      success: true as const,\n      value: parenResult.value[1],\n      remaining: parenResult.remaining,\n    };\n  }\n\n\n\n  // Try uppercase type constructor: TypeName arg1 arg2 ... (preserve original logic)\n  if (\n    tokens.length > 0 &&\n    tokens[0].type === \"IDENTIFIER\" &&\n    /^[A-Z]/.test(tokens[0].value)\n  ) {\n    const typeNameResult = C.identifier()(tokens);\n    if (typeNameResult.success) {\n      // Try to parse type arguments\n      const argsResult = C.many(C.lazy(() => parseTypeAtom))(\n        typeNameResult.remaining\n      );\n      if (argsResult.success) {\n        return {\n          success: true as const,\n          value: {\n            kind: \"variant\",\n            name: typeNameResult.value.value,\n            args: argsResult.value,\n          } as Type,\n          remaining: argsResult.remaining,\n        };\n      }\n    }\n  }\n\n  // Try type variable or simple identifier\n  if (tokens.length > 0 && tokens[0].type === \"IDENTIFIER\") {\n    const identifierResult = C.identifier()(tokens);\n    if (identifierResult.success) {\n      return {\n        success: true as const,\n        value: typeVariable(identifierResult.value.value),\n        remaining: identifierResult.remaining,\n      };\n    }\n  }\n\n  return {\n    success: false,\n    error: \"Expected type atom\",\n    position: tokens[0]?.location.start.line || 0,\n  };\n}\n\n\n\n// --- Type Expression ---\n// Helper function to parse function types without top-level effects\nconst parseFunctionTypeWithoutEffects: C.Parser<Type> = (tokens) => {\n  let leftResult = parseTypeAtom(tokens);\n  if (!leftResult.success) return leftResult;\n  let left = leftResult.value;\n  let rest = leftResult.remaining;\n\n  while (\n    rest &&\n    rest.length > 0 &&\n    rest[0].type === \"OPERATOR\" &&\n    rest[0].value === \"->\"\n  ) {\n    rest = rest.slice(1);\n    const rightResult = parseFunctionTypeWithoutEffects(rest);\n    if (!rightResult.success) return rightResult;\n    if (!rightResult.value)\n      return {\n        success: false,\n        error: \"Expected type expression\",\n        position: tokens[0]?.location.start.line || 0,\n      };\n    \n    left = functionType([left], rightResult.value);\n    rest = rightResult.remaining;\n  }\n  \n  return { success: true as const, value: left, remaining: rest };\n};\n\nexport const parseTypeExpression: C.Parser<Type> = (tokens) => {\n  // Try function type (right-associative): a -> b -> c FIRST\n  const funcType = (() => {\n    let leftResult = parseTypeAtom(tokens);\n    if (!leftResult.success) return leftResult;\n    let left = leftResult.value;\n    let rest = leftResult.remaining;\n\n    while (\n      rest &&\n      rest.length > 0 &&\n      rest[0].type === \"OPERATOR\" &&\n      rest[0].value === \"->\"\n    ) {\n      rest = rest.slice(1);\n      const rightResult = parseFunctionTypeWithoutEffects(rest);\n      if (!rightResult.success) return rightResult;\n      if (!rightResult.value)\n        return {\n          success: false,\n          error: \"Expected type expression\",\n          position: tokens[0]?.location.start.line || 0,\n        };\n      \n      left = functionType([left], rightResult.value);\n      rest = rightResult.remaining;\n    }\n    \n    // Parse effects at the end of the entire function type chain\n    let effects = new Set<Effect>();\n    let effectRest = rest;\n    \n    // Parse effects: !effect1 !effect2 ...\n    while (\n      effectRest &&\n      effectRest.length > 0 &&\n      effectRest[0].type === \"OPERATOR\" &&\n      effectRest[0].value === \"!\"\n    ) {\n      effectRest = effectRest.slice(1); // consume !\n      \n      // Expect an effect name (identifier or keyword)\n      if (\n        !effectRest ||\n        effectRest.length === 0 ||\n        (effectRest[0].type !== \"IDENTIFIER\" && effectRest[0].type !== \"KEYWORD\")\n      ) {\n        return {\n          success: false,\n          error: \"Expected effect name after !\",\n          position: effectRest?.[0]?.location?.start?.line || 0,\n        };\n      }\n      \n      const effectName = effectRest[0].value;\n      \n      // Validate effect name\n      const validEffects: Effect[] = [\"log\", \"read\", \"write\", \"state\", \"time\", \"rand\", \"ffi\", \"async\"];\n      if (!validEffects.includes(effectName as Effect)) {\n        return {\n          success: false,\n          error: `Invalid effect: ${effectName}. Valid effects: ${validEffects.join(\", \")}`,\n          position: effectRest[0].location.start.line,\n        };\n      }\n      \n      effects.add(effectName as Effect);\n      effectRest = effectRest.slice(1); // consume effect name\n    }\n    \n    // Apply effects to the function type (including empty effects)\n    if (left.kind === 'function') {\n      left = { ...left, effects };\n    }\n    \n    return { success: true as const, value: left, remaining: effectRest };\n  })();\n\n  if (funcType.success && funcType.value) {\n    return funcType;\n  }\n  \n  // If function type parsing failed with a specific effect error, return that error\n  if (!funcType.success && (\n    funcType.error.includes(\"Invalid effect:\") || \n    funcType.error.includes(\"Expected effect name after !\")\n  )) {\n    return funcType as C.ParseError;\n  }\n\n  // Try type variable (lowercase identifier)\n  if (\n    tokens.length > 0 &&\n    tokens[0].type === \"IDENTIFIER\" &&\n    /^[a-z]/.test(tokens[0].value)\n  ) {\n    const varResult = C.identifier()(tokens);\n    if (varResult.success) {\n      return {\n        success: true as const,\n        value: typeVariable(varResult.value.value),\n        remaining: varResult.remaining,\n      };\n    }\n  }\n\n  // Try record type: { name: String, age: Number }\n  const recordResult = C.seq(\n    C.punctuation(\"{\"),\n    C.optional(\n      C.sepBy(\n        C.map(\n          C.seq(\n            C.identifier(),\n            C.punctuation(\":\"),\n            C.lazy(() => parseTypeExpression)\n          ),\n          ([name, colon, type]) => [name.value, type] as [string, Type]\n        ),\n        C.punctuation(\",\")\n      )\n    ),\n    C.punctuation(\"}\")\n  )(tokens);\n  if (recordResult.success) {\n    const fields: Array<[string, Type]> = recordResult.value[1] || [];\n    const fieldObj: Record<string, Type> = {};\n    for (const [name, type] of fields) {\n      fieldObj[name] = type;\n    }\n    return {\n      success: true as const,\n      value: recordType(fieldObj),\n      remaining: recordResult.remaining,\n    };\n  }\n\n  // Try tuple type: { Number, String }\n  const tupleResult = C.seq(\n    C.punctuation(\"{\"),\n    C.optional(\n      C.sepBy(\n        C.lazy(() => parseTypeExpression),\n        C.punctuation(\",\")\n      )\n    ),\n    C.punctuation(\"}\")\n  )(tokens);\n  if (tupleResult.success) {\n    const elements = tupleResult.value[1] || [];\n    return {\n      success: true as const,\n      value: tupleType(elements),\n      remaining: tupleResult.remaining,\n    };\n  }\n\n  // Try List type\n  const listResult = C.seq(\n    C.keyword(\"List\"),\n    C.lazy(() => parseTypeExpression)\n  )(tokens);\n  if (listResult.success) {\n    return {\n      success: true as const,\n      value: listTypeWithElement(listResult.value[1]),\n      remaining: listResult.remaining,\n    };\n  }\n\n  return {\n    success: false,\n    error: \"Expected type expression\",\n    position: tokens[0]?.location.start.line || 0,\n  };\n};\n// --- Basic Parsers ---\nconst parseIdentifier = C.map(\n  C.identifier(),\n  (token): VariableExpression => ({\n    kind: \"variable\",\n    name: token.value,\n    location: token.location,\n  })\n);\n\nconst parseNumber = C.map(\n  C.number(),\n  (token): LiteralExpression => ({\n    kind: \"literal\",\n    value: parseFloat(token.value),\n    location: token.location,\n  })\n);\n\nconst parseString = C.map(\n  C.string(),\n  (token): LiteralExpression => ({\n    kind: \"literal\",\n    value: token.value,\n    location: token.location,\n  })\n);\n\nconst parseAccessor = C.map(\n  C.accessor(),\n  (token): AccessorExpression => ({\n    kind: \"accessor\",\n    field: token.value,\n    location: token.location,\n  })\n);\n\n// --- Record Parsing ---\nconst parseRecordFieldName = C.map(\n  C.accessor(),\n  (token) => token.value // Just get the field name without @\n);\n\n// Parse an expression that stops at @ (accessor tokens) or semicolon\nconst parseRecordFieldValue = (tokens: Token[]): C.ParseResult<Expression> => {\n  // Use the full expression parser to parse the complete expression\n  // This includes records, so we can parse nested records\n  const result = C.lazy(() => parseSequence)(tokens);\n  if (!result.success) {\n    return result;\n  }\n\n  // The expression parser should have consumed all the tokens it needs\n  // and left us with the remaining tokens that come after the expression\n  return {\n    success: true,\n    value: result.value,\n    remaining: result.remaining,\n  };\n};\n\nconst parseRecordField = C.map(\n  C.seq(parseRecordFieldName, parseRecordFieldValue),\n  ([fieldName, value]) => ({\n    name: fieldName,\n    value,\n    isNamed: true,\n  })\n);\n\n// Parse a single record field (named or positional)\nconst parseRecordFieldOrPositional =\n  (\n    index: number\n  ): C.Parser<{ name: string; value: Expression; isNamed: boolean }> =>\n  (tokens) => {\n    // Try to parse as named field first (with accessor)\n    const namedFieldResult = parseRecordField(tokens);\n    if (namedFieldResult.success) {\n      return {\n        ...namedFieldResult,\n        value: { ...namedFieldResult.value, isNamed: true },\n      };\n    }\n    // If that fails, try to parse as positional field (expression without accessor)\n    const positionalFieldResult = parseRecordFieldValue(tokens);\n    if (positionalFieldResult.success) {\n      return {\n        success: true,\n        value: {\n          name: `@${index}`,\n          value: positionalFieldResult.value,\n          isNamed: false,\n        },\n        remaining: positionalFieldResult.remaining,\n      };\n    }\n    return {\n      success: false,\n      error: \"Expected record field (named or positional)\",\n      position: tokens[0]?.location.start.line || 0,\n    };\n  };\n\n// Custom parser for a sequence of fields separated by semicolons\nconst parseRecordFields: C.Parser<{ name: string; value: Expression }[]> = (\n  tokens\n) => {\n  let fields: { name: string; value: Expression; isNamed: boolean }[] = [];\n  let rest = tokens;\n  // Parse first field\n  const firstFieldResult = parseRecordFieldOrPositional(0)(rest);\n  if (!firstFieldResult.success) {\n    return {\n      success: false,\n      error: \"Expected at least one record field\",\n      position: tokens[0]?.location.start.line || 0,\n    };\n  }\n  fields.push(firstFieldResult.value);\n  rest = firstFieldResult.remaining;\n  const isNamed = firstFieldResult.value.isNamed;\n  // Parse additional fields, each preceded by a comma\n  while (rest.length > 0) {\n    const commaResult = C.punctuation(\",\")(rest);\n    if (!commaResult.success) {\n      break; // No more commas, we're done\n    }\n    rest = commaResult.remaining;\n    const fieldResult = parseRecordFieldOrPositional(fields.length)(rest);\n    if (!fieldResult.success) {\n      // Check if this is a trailing comma (no more fields after comma)\n      // Look ahead to see if the next token is a closing brace\n      if (\n        rest.length > 0 &&\n        rest[0].type === \"PUNCTUATION\" &&\n        rest[0].value === \"}\"\n      ) {\n        // This is a trailing comma, which is allowed\n        break;\n      }\n      return {\n        success: false,\n        error: \"Expected field after comma\",\n        position: rest[0]?.location.start.line || 0,\n      };\n    }\n    if (fieldResult.value.isNamed !== isNamed) {\n      return {\n        success: false,\n        error:\n          \"Cannot mix named and positional fields in the same record/tuple\",\n        position: rest[0]?.location.start.line || 0,\n      };\n    }\n    fields.push(fieldResult.value);\n    rest = fieldResult.remaining;\n  }\n  // Remove isNamed before returning\n  return {\n    success: true,\n    value: fields.map(({ isNamed, ...rest }) => rest),\n    remaining: rest,\n  };\n};\n\n// --- Record/Tuple Parsing ---\nconst parseRecord = C.map(\n  C.seq(C.punctuation(\"{\"), C.optional(parseRecordFields), C.punctuation(\"}\")),\n  ([open, fields, close]): Expression => {\n    const fieldsList = fields || [];\n    if (fieldsList.length === 0) {\n      // Empty braces: unit\n      return {\n        kind: \"unit\",\n        location: open.location,\n      } as UnitExpression;\n    }\n    const allNamed = fieldsList.every((f) => f.name[0] !== \"@\");\n    const allPositional = fieldsList.every((f, i) => f.name === `@${i}`);\n    if (allNamed) {\n      // All named fields: record\n      return {\n        kind: \"record\",\n        fields: fieldsList,\n        location: open.location,\n      } as RecordExpression;\n    } else if (allPositional) {\n      // All positional fields: tuple\n      return {\n        kind: \"tuple\",\n        elements: fieldsList.map((f) => f.value),\n        location: open.location,\n      } as TupleExpression;\n    } else {\n      // Mixed fields: error\n      throw new Error(\n        \"Cannot mix named and positional fields in the same record/tuple\"\n      );\n    }\n  }\n);\n\n// --- Parenthesized Expressions ---\nconst parseParenExpr: C.Parser<Expression> = C.map(\n  C.seq(\n    C.punctuation(\"(\"),\n    C.lazy(() => parseSequence), // Use parseSequence to allow full semicolon-separated sequences\n    C.punctuation(\")\")\n  ),\n  ([open, expr, close]) => expr\n);\n\n// --- Lambda Expression ---\nconst parseLambdaExpression: C.Parser<FunctionExpression> = (tokens) => {\n  // Try to parse fn keyword first\n  const fnResult = C.keyword(\"fn\")(tokens);\n  if (!fnResult.success) {\n    return fnResult;\n  }\n\n  // Try unit parameter patterns first\n  let paramNames: string[] = [];\n  let remaining = fnResult.remaining;\n\n  const parenResult = C.seq(C.punctuation(\"(\"), C.punctuation(\")\"))(remaining);\n  if (parenResult.success) {\n    // No parameters (should not be used in Noolang, but keep for syntax completeness)\n    paramNames = [];\n    remaining = parenResult.remaining;\n  } else {\n    const braceResult = C.seq(\n      C.punctuation(\"{\"),\n      C.punctuation(\"}\")\n    )(remaining);\n    if (braceResult.success) {\n      // Unit parameter\n      paramNames = [\"_unit\"];\n      remaining = braceResult.remaining;\n    } else {\n      // Try multiple identifiers last\n      const idResult = C.many(C.identifier())(remaining);\n      if (idResult.success) {\n        paramNames = idResult.value.map((p) => p.value);\n        remaining = idResult.remaining;\n      } else {\n        return {\n          success: false,\n          error: \"Expected parameter list, parentheses, or braces\",\n          position: remaining[0]?.location.start.line || 0,\n        };\n      }\n    }\n  }\n\n  // Parse the arrow\n  const arrowResult = C.operator(\"=>\")(remaining);\n  if (!arrowResult.success) {\n    return arrowResult;\n  }\n\n  // Parse the body (use parseSequenceTermWithIf to allow full expressions)\n  const bodyResult = C.lazy(() => parseSequenceTermWithIf)(\n    arrowResult.remaining\n  );\n  if (!bodyResult.success) {\n    return bodyResult;\n  }\n\n  return {\n    success: true,\n    value: {\n      kind: \"function\",\n      params: paramNames,\n      body: bodyResult.value,\n      location: fnResult.value.location,\n    },\n    remaining: bodyResult.remaining,\n  };\n};\n\n// --- List Parsing ---\n// Custom parser for a sequence of expressions separated by semicolons\nconst parseListElements: C.Parser<Expression[]> = (tokens) => {\n  let elements: Expression[] = [];\n  let rest = tokens;\n\n  // Parse first element\n  const firstElementResult = C.lazy(() => parseThrush)(rest);\n  if (!firstElementResult.success) {\n    return {\n      success: false,\n      error: \"Expected at least one list element\",\n      position: tokens[0]?.location.start.line || 0,\n    };\n  }\n  elements.push(firstElementResult.value);\n  rest = firstElementResult.remaining;\n\n  // Parse additional elements, each preceded by a comma\n  while (rest.length > 0) {\n    const commaResult = C.punctuation(\",\")(rest);\n    if (!commaResult.success) {\n      break; // No more commas, we're done\n    }\n    rest = commaResult.remaining;\n\n    const elementResult = C.lazy(() => parseThrush)(rest);\n    if (!elementResult.success) {\n      // Check if this is a trailing comma (no more elements after comma)\n      // Look ahead to see if the next token is a closing bracket\n      if (\n        rest.length > 0 &&\n        rest[0].type === \"PUNCTUATION\" &&\n        rest[0].value === \"]\"\n      ) {\n        // This is a trailing comma, which is allowed\n        break;\n      }\n      return {\n        success: false,\n        error: \"Expected element after comma\",\n        position: rest[0]?.location.start.line || 0,\n      };\n    }\n    elements.push(elementResult.value);\n    rest = elementResult.remaining;\n  }\n\n  return {\n    success: true,\n    value: elements,\n    remaining: rest,\n  };\n};\n\nconst parseList: C.Parser<ListExpression> = C.map(\n  C.seq(C.punctuation(\"[\"), C.optional(parseListElements), C.punctuation(\"]\")),\n  ([open, elements, close]) => {\n    const elementsList: Expression[] = elements || [];\n    return {\n      kind: \"list\",\n      elements: elementsList,\n      location: open.location,\n    };\n  }\n);\n\n// --- Import Expression ---\nconst parseImportExpression: C.Parser<ImportExpression> = C.map(\n  C.seq(C.keyword(\"import\"), C.string()),\n  ([importKw, path]): ImportExpression => ({\n    kind: \"import\",\n    path: path.value,\n    location: importKw.location,\n  })\n);\n\n// --- If Expression (special: do not allow semicolon in branches) ---\nconst parseIfExpression: C.Parser<Expression> = C.map(\n  C.seq(\n    C.keyword(\"if\"),\n    C.lazy(() => parseSequenceTerm),\n    C.keyword(\"then\"),\n    C.lazy(() => parseSequenceTerm),\n    C.keyword(\"else\"),\n    C.lazy(() => parseSequenceTerm)\n  ),\n  ([ifKw, condition, thenKw, thenExpr, elseKw, elseExpr]) => {\n    return {\n      kind: \"if\",\n      condition,\n      then: thenExpr,\n      else: elseExpr,\n      location: ifKw.location,\n    };\n  }\n);\n\n// --- Primary Expressions (no unary minus) ---\nconst parsePrimary: C.Parser<Expression> = (tokens) => {\n  // DEBUG: Log tokens at entry\n  if (process.env.NOO_DEBUG_PARSE) {\n    console.log(\"parsePrimary tokens:\", tokens.map((t) => t.value).join(\" \"));\n  }\n  \n  // Fast token-based dispatch instead of sequential choice attempts\n  if (tokens.length === 0) {\n    return { success: false, error: \"Unexpected end of input\", position: 0 };\n  }\n  \n  const firstToken = tokens[0];\n  let result: C.ParseResult<Expression>;\n  \n  // Dispatch based on token type and value for O(1) selection\n  switch (firstToken.type) {\n    case \"NUMBER\":\n      result = parseNumber(tokens);\n      break;\n    case \"STRING\": \n      result = parseString(tokens);\n      break;\n    case \"IDENTIFIER\":\n      result = parseIdentifier(tokens);\n      break;\n    case \"ACCESSOR\":\n      result = parseAccessor(tokens);\n      break;\n    case \"PUNCTUATION\":\n      if (firstToken.value === \"[\") {\n        result = parseList(tokens);\n      } else if (firstToken.value === \"{\") {\n        result = parseRecord(tokens);\n      } else if (firstToken.value === \"(\") {\n        result = parseParenExpr(tokens);\n      } else {\n        result = { success: false, error: `Unexpected punctuation: ${firstToken.value}`, position: firstToken.location.start.line };\n      }\n      break;\n    case \"KEYWORD\":\n      if (firstToken.value === \"fn\") {\n        result = parseLambdaExpression(tokens);\n      } else if (firstToken.value === \"let\") {\n        result = C.lazy(() => parseDefinitionWithType)(tokens);\n      } else if (firstToken.value === \"import\") {\n        result = parseImportExpression(tokens);\n      } else {\n        result = { success: false, error: `Unexpected keyword: ${firstToken.value}`, position: firstToken.location.start.line };\n      }\n      break;\n    default:\n      result = { success: false, error: `Unexpected token type: ${firstToken.type}`, position: firstToken.location.start.line };\n      break;\n  }\n  \n  // DEBUG: Log result\n  if (process.env.NOO_DEBUG_PARSE) {\n    console.log(\n      \"parsePrimary result:\",\n      result.success ? result.value : result.error\n    );\n  }\n  return result;\n};\n\n// --- Primary with Postfix (type annotations) ---\nconst parsePrimaryWithPostfix: C.Parser<Expression> = (tokens) => {\n  if (process.env.NOO_DEBUG_PARSE) {\n    console.log(\n      \"parsePrimaryWithPostfix tokens:\",\n      tokens.map((t) => t.value).join(\" \")\n    );\n  }\n  const primaryResult = parsePrimary(tokens);\n  if (!primaryResult.success) return primaryResult;\n  const postfixResult = parsePostfixFromResult(\n    primaryResult.value,\n    primaryResult.remaining\n  );\n  if (process.env.NOO_DEBUG_PARSE) {\n    console.log(\n      \"parsePrimaryWithPostfix result:\",\n      postfixResult.success ? postfixResult.value : postfixResult.error\n    );\n  }\n  return postfixResult;\n};\n\n// --- Unary Operators (negation, only if '-' is adjacent to the next token) ---\nconst parseUnary: C.Parser<Expression> = (tokens) => {\n  if (process.env.NOO_DEBUG_PARSE) {\n    console.log(\"parseUnary tokens:\", tokens.map((t) => t.value).join(\" \"));\n  }\n  if (\n    tokens.length >= 2 &&\n    tokens[0].type === \"OPERATOR\" &&\n    tokens[0].value === \"-\"\n  ) {\n    const minusToken = tokens[0];\n    const nextToken = tokens[1];\n    // Check if minus is directly adjacent to the next token (no space)\n    if (\n      minusToken.location.end.line === nextToken.location.start.line &&\n      minusToken.location.end.column === nextToken.location.start.column\n    ) {\n      // Parse as unary minus\n      const operandResult = parsePrimaryWithPostfix(tokens.slice(1));\n      if (!operandResult.success) return operandResult;\n      const result = {\n        success: true as const,\n        value: {\n          kind: \"binary\" as const,\n          operator: \"*\" as const,\n          left: {\n            kind: \"literal\" as const,\n            value: -1,\n            location: minusToken.location,\n          },\n          right: operandResult.value,\n          location: minusToken.location,\n        },\n        remaining: operandResult.remaining,\n      };\n      if (process.env.NOO_DEBUG_PARSE) {\n        console.log(\"parseUnary result (negation):\", result.value);\n      }\n      return result;\n    }\n  }\n  // Otherwise, fall through to parsePrimaryWithPostfix\n  const result = parsePrimaryWithPostfix(tokens);\n  if (process.env.NOO_DEBUG_PARSE) {\n    console.log(\n      \"parseUnary result:\",\n      result.success ? result.value : result.error\n    );\n  }\n  return result;\n};\n\n// --- Function Application (left-associative, tightest binding) ---\nconst parseApplication: C.Parser<Expression> = (tokens) => {\n  const appResult = C.map(\n    C.seq(parseUnary, C.many(parseUnary)),\n    ([func, args]) => {\n      let result = func;\n      for (const arg of args) {\n        result = {\n          kind: \"application\",\n          func: result,\n          args: [arg],\n          location: result.location,\n        };\n      }\n      return result;\n    }\n  )(tokens);\n\n  if (!appResult.success) return appResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(appResult.value, appResult.remaining);\n};\n\n// --- Multiplicative (*, /) ---\nconst parseMultiplicative: C.Parser<Expression> = (tokens) => {\n  const multResult = C.map(\n    C.seq(\n      parseApplication,\n      C.many(\n        C.seq(C.choice(C.operator(\"*\"), C.operator(\"/\")), parseApplication)\n      )\n    ),\n    ([left, rest]) => {\n      let result = left;\n      for (const [op, right] of rest) {\n        result = {\n          kind: \"binary\",\n          operator: op.value as \"*\" | \"/\",\n          left: result,\n          right,\n          location: result.location,\n        };\n      }\n      return result;\n    }\n  )(tokens);\n\n  if (!multResult.success) return multResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(multResult.value, multResult.remaining);\n};\n\n// --- Additive (+, -) ---\nconst parseAdditive: C.Parser<Expression> = (tokens) => {\n  const addResult = C.map(\n    C.seq(\n      parseMultiplicative,\n      C.many(\n        C.seq(C.choice(C.operator(\"+\"), C.operator(\"-\")), parseMultiplicative)\n      )\n    ),\n    ([left, rest]) => {\n      let result = left;\n      for (const [op, right] of rest) {\n        result = {\n          kind: \"binary\",\n          operator: op.value as \"+\" | \"-\",\n          left: result,\n          right,\n          location: result.location,\n        };\n      }\n      return result;\n    }\n  )(tokens);\n\n  if (!addResult.success) return addResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(addResult.value, addResult.remaining);\n};\n\n// --- Comparison (<, >, <=, >=, ==, !=) ---\nconst parseComparison: C.Parser<Expression> = (tokens) => {\n  const compResult = C.map(\n    C.seq(\n      parseAdditive,\n      C.many(\n        C.seq(\n          C.choice(\n            C.operator(\"<\"),\n            C.operator(\">\"),\n            C.operator(\"<=\"),\n            C.operator(\">=\"),\n            C.operator(\"==\"),\n            C.operator(\"!=\")\n          ),\n          parseAdditive\n        )\n      )\n    ),\n    ([left, rest]) => {\n      let result = left;\n      for (const [op, right] of rest) {\n        result = {\n          kind: \"binary\",\n          operator: op.value as \"<\" | \">\" | \"<=\" | \">=\" | \"==\" | \"!=\",\n          left: result,\n          right,\n          location: result.location,\n        };\n      }\n      return result;\n    }\n  )(tokens);\n\n  if (!compResult.success) return compResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(compResult.value, compResult.remaining);\n};\n\n// --- Composition (|>, <|) ---\nconst parseCompose: C.Parser<Expression> = (tokens) => {\n  const compResult = C.map(\n    C.seq(\n      parseComparison,\n      C.many(\n        C.seq(C.choice(C.operator(\"|>\"), C.operator(\"<|\")), parseComparison)\n      )\n    ),\n    ([left, rest]) => {\n      // Build steps array for pipeline expression\n      const steps = [left];\n      for (const [op, right] of rest) {\n        steps.push(right);\n      }\n\n      // If we have multiple steps, create a pipeline expression\n      if (steps.length > 1) {\n        return {\n          kind: \"pipeline\",\n          steps,\n          location: left.location,\n        } as import(\"../ast\").PipelineExpression;\n      }\n\n      // Otherwise just return the single expression\n      return left;\n    }\n  )(tokens);\n\n  if (!compResult.success) return compResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(compResult.value, compResult.remaining);\n};\n\n// --- Thrush (|) ---\nconst parseThrush: C.Parser<Expression> = (tokens) => {\n  const thrushResult = C.map(\n    C.seq(parseDollar, C.many(C.seq(C.operator(\"|\"), parseDollar))),\n    ([left, rest]) => {\n      let result = left;\n      for (const [op, right] of rest) {\n        result = {\n          kind: \"binary\",\n          operator: \"|\",\n          left: result,\n          right,\n          location: result.location,\n        };\n      }\n      return result;\n    }\n  )(tokens);\n\n  if (!thrushResult.success) return thrushResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(thrushResult.value, thrushResult.remaining);\n};\n\n// --- Dollar ($) - Low precedence function application (right-associative) ---\nconst parseDollar: C.Parser<Expression> = (tokens) => {\n  const leftResult = parseCompose(tokens);\n  if (!leftResult.success) return leftResult;\n  \n  // Check for $ operator\n  if (leftResult.remaining.length > 0 && \n      leftResult.remaining[0].type === \"OPERATOR\" && \n      leftResult.remaining[0].value === \"$\") {\n    \n    // Consume the $ token\n    const remaining = leftResult.remaining.slice(1);\n    \n    // Recursively parse the right side (this creates right-associativity)\n    const rightResult = parseDollar(remaining);\n    if (!rightResult.success) return rightResult;\n    \n    const result = {\n      kind: \"binary\" as const,\n      operator: \"$\" as const,\n      left: leftResult.value,\n      right: rightResult.value,\n      location: leftResult.value.location,\n    };\n    \n    return parsePostfixFromResult(result, rightResult.remaining);\n  }\n  \n  // No $ operator found, just return the left expression\n  return parsePostfixFromResult(leftResult.value, leftResult.remaining);\n};\n\n// --- If Expression (after dollar, before sequence) ---\nconst parseIfAfterDollar: C.Parser<Expression> = (tokens) => {\n  const ifResult = parseIfExpression(tokens);\n  if (!ifResult.success) return ifResult;\n\n  // Apply postfix operators (type annotations) to the result\n  return parsePostfixFromResult(ifResult.value, ifResult.remaining);\n};\n\n// Helper function to apply postfix operators to an expression\nconst parsePostfixFromResult = (\n  expr: Expression,\n  tokens: Token[]\n): C.ParseResult<Expression> => {\n  let result = expr;\n  let remaining = tokens;\n\n  // Try to parse postfix type annotations\n  while (remaining.length > 0) {\n    // Try to parse : type given constraint\n    if (\n      remaining.length >= 2 &&\n      remaining[0].type === \"PUNCTUATION\" &&\n      remaining[0].value === \":\"\n    ) {\n      const typeResult = parseTypeExpression(remaining.slice(1));\n      if (!typeResult.success) break;\n\n      // Check if there's a \"given\" constraint after the type\n      if (\n        typeResult.remaining.length > 0 &&\n        typeResult.remaining[0].type === \"KEYWORD\" &&\n        typeResult.remaining[0].value === \"given\"\n      ) {\n        const constraintResult = parseConstraintExpr(\n          typeResult.remaining.slice(1)\n        );\n        if (!constraintResult.success) break;\n\n        result = {\n          kind: \"constrained\",\n          expression: result,\n          type: typeResult.value,\n          constraint: constraintResult.value,\n          location: result.location,\n        };\n        remaining = constraintResult.remaining;\n        continue;\n      } else {\n        // Just a type annotation without constraints\n        result = {\n          kind: \"typed\",\n          expression: result,\n          type: typeResult.value,\n          location: result.location,\n        };\n        remaining = typeResult.remaining;\n        continue;\n      }\n    }\n\n    // No more postfix operators\n    break;\n  }\n\n  return {\n    success: true,\n    value: result,\n    remaining,\n  };\n};\n\n// --- Definition ---\nconst parseDefinition: C.Parser<DefinitionExpression> = C.map(\n  C.seq(\n    C.identifier(),\n    C.operator(\"=\"),\n    C.lazy(() => parseSequenceTermWithIf)\n  ),\n  ([name, equals, value]): DefinitionExpression => {\n    return {\n      kind: \"definition\",\n      name: name.value,\n      value,\n      location: name.location,\n    };\n  }\n);\n\n// --- Definition with typed expression (now just a regular definition) ---\nconst parseDefinitionWithType: C.Parser<DefinitionExpression> = parseDefinition;\n\n// --- Mutable Definition ---\nconst parseMutableDefinition: C.Parser<\n  import(\"../ast\").MutableDefinitionExpression\n> = C.map(\n  C.seq(\n    C.keyword(\"mut\"),\n    C.identifier(),\n    C.operator(\"=\"),\n    C.lazy(() => parseSequenceTermWithIf)\n  ),\n  ([\n    mut,\n    name,\n    equals,\n    value,\n  ]): import(\"../ast\").MutableDefinitionExpression => {\n    return {\n      kind: \"mutable-definition\",\n      name: name.value,\n      value,\n      location: mut.location,\n    };\n  }\n);\n\n// --- Mutation ---\nconst parseMutation: C.Parser<import(\"../ast\").MutationExpression> = C.map(\n  C.seq(\n    C.keyword(\"mut!\"),\n    C.identifier(),\n    C.operator(\"=\"),\n    C.lazy(() => parseSequenceTermWithIf)\n  ),\n  ([mut, name, equals, value]): import(\"../ast\").MutationExpression => {\n    return {\n      kind: \"mutation\",\n      target: name.value,\n      value,\n      location: mut.location,\n    };\n  }\n);\n\n// Custom parser for where clause definitions (both regular and mutable)\nconst parseWhereDefinition: C.Parser<\n  DefinitionExpression | MutableDefinitionExpression\n> = (tokens) => {\n  // Try mutable definition first\n  const mutableResult = parseMutableDefinition(tokens);\n  if (mutableResult.success) {\n    return mutableResult;\n  }\n  // Try regular definition\n  const regularResult = parseDefinition(tokens);\n  if (regularResult.success) {\n    return regularResult;\n  }\n  return {\n    success: false,\n    error: \"Expected definition in where clause\",\n    position: tokens[0]?.location.start.line || 0,\n  };\n};\n\n// --- ADT Constructor ---\nconst parseConstructor: C.Parser<ConstructorDefinition> = C.map(\n  C.seq(parseTypeName, C.many(C.lazy(() => parseTypeExpression))),\n  ([name, args]): ConstructorDefinition => ({\n    name: name.value,\n    args,\n    location: createLocation(name.location.start, name.location.end),\n  })\n);\n\n// --- Type Definition ---\nconst parseTypeDefinition: C.Parser<TypeDefinitionExpression> = C.map(\n  C.seq(\n    C.keyword(\"type\"),\n    parseTypeName,\n    C.many(C.identifier()),\n    C.operator(\"=\"),\n    C.sepBy(parseConstructor, C.operator(\"|\"))\n  ),\n  ([\n    type,\n    name,\n    typeParams,\n    equals,\n    constructors,\n  ]): TypeDefinitionExpression => ({\n    kind: \"type-definition\",\n    name: name.value,\n    typeParams: typeParams.map((p: any) => p.value),\n    constructors,\n    location: createLocation(\n      type.location.start,\n      constructors[constructors.length - 1]?.location.end || equals.location.end\n    ),\n  })\n);\n\n// --- Constraint Function ---\nconst parseConstraintFunction: C.Parser<ConstraintFunction> = C.map(\n  C.seq(\n    C.identifier(),\n    C.many(C.identifier()), // type parameters like \"a b\" in \"bind a b\"\n    C.punctuation(\":\"),\n    C.lazy(() => parseTypeExpression)\n  ),\n  ([name, typeParams, colon, type]): ConstraintFunction => ({\n    name: name.value,\n    typeParams: typeParams.map((p: any) => p.value),\n    type,\n    location: createLocation(name.location.start, colon.location.end),\n  })\n);\n\n// --- Constraint Definition ---\nconst parseConstraintDefinition: C.Parser<ConstraintDefinitionExpression> = C.map(\n  C.seq(\n    C.keyword(\"constraint\"),\n    C.identifier(), // constraint name like \"Monad\"\n    C.identifier(), // type parameter like \"m\"\n    C.punctuation(\"(\"),\n    C.sepBy(parseConstraintFunction, C.punctuation(\";\")),\n    C.punctuation(\")\")\n  ),\n  ([constraintKeyword, name, typeParam, openParen, functions, closeParen]): ConstraintDefinitionExpression => ({\n    kind: \"constraint-definition\",\n    name: name.value,\n    typeParam: typeParam.value,\n    functions,\n    location: createLocation(constraintKeyword.location.start, closeParen.location.end),\n  })\n);\n\n// --- Implementation Function ---\nconst parseImplementationFunction: C.Parser<ImplementationFunction> = C.map(\n  C.seq(\n    C.identifier(),\n    C.operator(\"=\"),\n    C.lazy(() => parseSequenceTerm)\n  ),\n  ([name, equals, value]): ImplementationFunction => ({\n    name: name.value,\n    value,\n    location: createLocation(name.location.start, value.location.end),\n  })\n);\n\n// --- Implement Definition ---\nconst parseImplementDefinition: C.Parser<ImplementDefinitionExpression> = C.map(\n  C.seq(\n    C.keyword(\"implement\"),\n    C.identifier(), // constraint name like \"Monad\"\n    parseTypeName, // type name like \"List\" or \"Int\"\n    C.punctuation(\"(\"),\n    C.sepBy(parseImplementationFunction, C.punctuation(\";\")),\n    C.punctuation(\")\")\n  ),\n  ([implementKeyword, constraintName, typeName, openParen, implementations, closeParen]): ImplementDefinitionExpression => ({\n    kind: \"implement-definition\",\n    constraintName: constraintName.value,\n    typeName: typeName.value,\n    implementations,\n    location: createLocation(implementKeyword.location.start, closeParen.location.end),\n  })\n);\n\n// --- Pattern Parsing ---\n// Basic pattern parsing for constructor arguments (no nested constructors with args)\nconst parseBasicPattern: C.Parser<Pattern> = C.choice(\n  // Wildcard pattern: _\n  C.map(\n    C.punctuation(\"_\"),\n    (underscore): Pattern => ({\n      kind: \"wildcard\",\n      location: underscore.location,\n    })\n  ),\n  // Literal pattern: number or string\n  C.map(\n    C.number(),\n    (num): Pattern => ({\n      kind: \"literal\",\n      value: parseInt(num.value),\n      location: num.location,\n    })\n  ),\n  C.map(\n    C.string(),\n    (str): Pattern => ({\n      kind: \"literal\",\n      value: str.value,\n      location: str.location,\n    })\n  ),\n  // Constructor or variable pattern: identifier (decide based on capitalization)\n  C.map(C.identifier(), (name): Pattern => {\n    // If identifier starts with uppercase, treat as constructor pattern (zero args)\n    if (name.value.length > 0 && name.value[0] >= \"A\" && name.value[0] <= \"Z\") {\n      return {\n        kind: \"constructor\",\n        name: name.value,\n        args: [],\n        location: name.location,\n      };\n    } else {\n      // Otherwise, treat as variable pattern\n      return {\n        kind: \"variable\",\n        name: name.value,\n        location: name.location,\n      };\n    }\n  })\n);\n\nconst parsePattern: C.Parser<Pattern> = C.choice(\n  // Wildcard pattern: _\n  C.map(\n    C.punctuation(\"_\"),\n    (underscore): Pattern => ({\n      kind: \"wildcard\",\n      location: underscore.location,\n    })\n  ),\n  // Constructor pattern with arguments: Some x y\n  C.map(\n    C.seq(C.identifier(), C.many1(parseBasicPattern)),\n    ([name, args]): Pattern => ({\n      kind: \"constructor\",\n      name: name.value,\n      args,\n      location: createLocation(\n        name.location.start,\n        args[args.length - 1].location.end\n      ),\n    })\n  ),\n  // Constructor pattern with parenthesized arguments: Wrap (Value n)\n  C.map(\n    C.seq(\n      C.identifier(),\n      C.punctuation(\"(\"),\n      C.lazy(() => parsePattern),\n      C.punctuation(\")\")\n    ),\n    ([name, openParen, arg, closeParen]): Pattern => ({\n      kind: \"constructor\",\n      name: name.value,\n      args: [arg],\n      location: createLocation(name.location.start, closeParen.location.end),\n    })\n  ),\n  // Constructor or variable pattern: identifier (decide based on capitalization)\n  C.map(C.identifier(), (name): Pattern => {\n    // If identifier starts with uppercase, treat as constructor pattern\n    if (name.value.length > 0 && name.value[0] >= \"A\" && name.value[0] <= \"Z\") {\n      return {\n        kind: \"constructor\",\n        name: name.value,\n        args: [],\n        location: name.location,\n      };\n    } else {\n      // Otherwise, treat as variable pattern\n      return {\n        kind: \"variable\",\n        name: name.value,\n        location: name.location,\n      };\n    }\n  })\n);\n\n// --- Match Case Expression Parser ---\n// This parser supports expressions in match cases, including nested match expressions\nconst parseMatchCaseExpression: C.Parser<Expression> = C.choice(\n  C.lazy(() => parseMatchExpression), // Support nested match expressions\n  parseIfExpression, // Support if expressions  \n  C.lazy(() => parseExprWithType) // Support all other expressions including type annotations\n);\n\n// --- Match Case ---\nconst parseMatchCase: C.Parser<MatchCase> = C.map(\n  C.seq(\n    parsePattern,\n    C.operator(\"=>\"),\n    C.lazy(() => parseMatchCaseExpression) // Use dedicated parser for match case expressions\n  ),\n  ([pattern, arrow, expression]): MatchCase => ({\n    pattern,\n    expression,\n    location: createLocation(pattern.location.start, expression.location.end),\n  })\n);\n\n// --- Match Expression ---\nconst parseMatchExpression: C.Parser<MatchExpression> = C.map(\n  C.seq(\n    C.keyword(\"match\"),\n    C.lazy(() => parseThrush), // Use a simpler expression parser to avoid circular dependency\n    C.keyword(\"with\"),\n    C.punctuation(\"(\"),\n    C.sepBy(parseMatchCase, C.punctuation(\";\")),\n    C.punctuation(\")\")\n  ),\n  ([\n    match,\n    expression,\n    with_,\n    openParen,\n    cases,\n    closeParen,\n  ]): MatchExpression => ({\n    kind: \"match\",\n    expression,\n    cases,\n    location: createLocation(match.location.start, closeParen.location.end),\n  })\n);\n\n// --- Where Expression ---\nconst parseWhereExpression: C.Parser<WhereExpression> = C.map(\n  C.seq(\n    C.lazy(() => parseSequenceTermWithIfExceptRecord), // Main expression (no records to avoid circular dependency)\n    C.keyword(\"where\"),\n    C.punctuation(\"(\"),\n    C.sepBy(parseWhereDefinition, C.punctuation(\";\")),\n    C.punctuation(\")\")\n  ),\n  ([main, where, openParen, definitions, closeParen]): WhereExpression => {\n    return {\n      kind: \"where\",\n      main,\n      definitions,\n      location: main.location,\n    };\n  }\n);\n\n// --- Sequence term: everything else ---\nconst parseSequenceTerm: C.Parser<Expression> = C.choice(\n  // Parse keyword-based expressions first to avoid identifier conflicts\n  parseMatchExpression, // ADT pattern matching (starts with \"match\")\n  parseTypeDefinition, // ADT type definitions (starts with \"type\")\n  parseConstraintDefinition, // constraint definitions (starts with \"constraint\")\n  parseImplementDefinition, // implement definitions (starts with \"implement\")\n  parseMutableDefinition, // starts with \"mut\"\n  parseMutation, // starts with \"mut!\"\n  parseImportExpression, // starts with \"import\"\n  parseIfAfterDollar, // if expressions (starts with \"if\")\n  // Then parse identifier-based expressions\n  parseDefinitionWithType, // allow definitions with type annotations\n  parseDefinition, // fallback to regular definitions  \n  parseWhereExpression,\n  parseThrush, // full expression hierarchy (includes all primaries and type annotations)\n  parseRecord,\n  parseThrush,\n  parseLambdaExpression\n);\n\n// Version without records to avoid circular dependency\nconst parseSequenceTermExceptRecord: C.Parser<Expression> = C.choice(\n  // Parse keyword-based expressions first\n  parseMatchExpression, // ADT pattern matching\n  parseTypeDefinition, // ADT type definitions\n  parseConstraintDefinition, // constraint definitions\n  parseImplementDefinition, // implement definitions\n  parseMutableDefinition,\n  parseMutation,\n  parseImportExpression,\n  // Then identifier-based expressions\n  parseDefinition, // Regular definitions\n  parseThrush,\n  parseLambdaExpression,\n  parseNumber,\n  parseString,\n  parseIdentifier,\n  parseList,\n  parseAccessor,\n  parseParenExpr\n);\n\n// parseSequenceTerm now includes parseIfExpression\nconst parseSequenceTermWithIf: C.Parser<Expression> = parseSequenceTerm;\n\n// Version with if but without records to avoid circular dependency\nconst parseSequenceTermWithIfExceptRecord: C.Parser<Expression> = C.choice(\n  parseSequenceTermExceptRecord,\n  parseIfExpression\n);\n\n// --- Parse atomic constraint ---\nconst parseAtomicConstraint: C.Parser<ConstraintExpr> = C.choice(\n  // Parenthesized constraint\n  C.map(\n    C.seq(\n      C.punctuation(\"(\"),\n      C.lazy(() => parseConstraintExpr),\n      C.punctuation(\")\")\n    ),\n    ([open, expr, close]) => ({ kind: \"paren\", expr })\n  ),\n  // a is Collection\n  C.map(\n    C.seq(\n      C.identifier(),\n      C.keyword(\"is\"),\n      C.choice(\n        C.identifier()\n        // Removed meaningless constraint keywords\n      )\n    ),\n    ([typeVar, isKeyword, constraint]): ConstraintExpr => ({\n      kind: \"is\",\n      typeVar: typeVar.value,\n      constraint: constraint.value,\n    })\n  ),\n  // a has field \"name\" of type T\n  C.map(\n    C.seq(\n      C.identifier(),\n      C.keyword(\"has\"),\n      C.keyword(\"field\"),\n      C.string(),\n      C.keyword(\"of\"),\n      C.keyword(\"type\"),\n      C.lazy(() => parseTypeExpression)\n    ),\n    ([\n      typeVar,\n      has,\n      field,\n      fieldName,\n      of,\n      type,\n      fieldType,\n    ]): ConstraintExpr => ({\n      kind: \"hasField\",\n      typeVar: typeVar.value,\n      field: fieldName.value,\n      fieldType,\n    })\n  ),\n  // a implements Interface\n  C.map(\n    C.seq(C.identifier(), C.keyword(\"implements\"), C.identifier()),\n    ([typeVar, implementsKeyword, interfaceName]): ConstraintExpr => ({\n      kind: \"implements\",\n      typeVar: typeVar.value,\n      interfaceName: interfaceName.value,\n    })\n  )\n);\n\n// --- Parse constraint expression with precedence: and > or ---\nconst parseConstraintExpr: C.Parser<ConstraintExpr> = (tokens) => {\n  // Parse left side (and chains)\n  let leftResult = parseConstraintAnd(tokens);\n  if (!leftResult.success) return leftResult;\n  let left = leftResult.value;\n  let rest = leftResult.remaining;\n\n  // Parse or chains\n  while (\n    rest.length > 0 &&\n    rest[0].type === \"KEYWORD\" &&\n    rest[0].value === \"or\"\n  ) {\n    rest = rest.slice(1);\n    const rightResult = parseConstraintAnd(rest);\n    if (!rightResult.success) return rightResult;\n    left = { kind: \"or\", left, right: rightResult.value };\n    rest = rightResult.remaining;\n  }\n  return { success: true as const, value: left, remaining: rest };\n};\n\nconst parseConstraintAnd: C.Parser<ConstraintExpr> = (tokens) => {\n  let leftResult = parseAtomicConstraint(tokens);\n  if (!leftResult.success) return leftResult;\n  let left = leftResult.value;\n  let rest = leftResult.remaining;\n\n  while (\n    rest.length > 0 &&\n    rest[0].type === \"KEYWORD\" &&\n    rest[0].value === \"and\"\n  ) {\n    rest = rest.slice(1);\n    const rightResult = parseAtomicConstraint(rest);\n    if (!rightResult.success) return rightResult;\n    left = { kind: \"and\", left, right: rightResult.value };\n    rest = rightResult.remaining;\n  }\n  return { success: true as const, value: left, remaining: rest };\n};\n\n// --- Expression with type annotation (just above semicolon) ---\nconst parseExprWithType: C.Parser<Expression> = C.choice(\n  // Expression with type and constraints: expr : type given constraintExpr\n  C.map(\n    C.seq(\n      parseThrush, // Use parseThrush to support full expression hierarchy\n      C.punctuation(\":\"),\n      C.lazy(() => parseTypeExpression),\n      C.keyword(\"given\"),\n      parseConstraintExpr\n    ),\n    ([expr, colon, type, given, constraint]): ConstrainedExpression => ({\n      kind: \"constrained\",\n      expression: expr,\n      type,\n      constraint,\n      location: expr.location,\n    })\n  ),\n  // Expression with just type: expr : type\n  C.map(\n    C.seq(\n      parseThrush, // Use parseThrush to support full expression hierarchy\n      C.punctuation(\":\"),\n      C.lazy(() => parseTypeExpression)\n    ),\n    ([expr, colon, type]): TypedExpression => ({\n      kind: \"typed\",\n      expression: expr,\n      type,\n      location: expr.location,\n    })\n  ),\n  parseThrush // Fallback to regular expressions\n);\n\n// --- Sequence (semicolon) ---\n// Accepts a sequence of definitions and/or expressions, separated by semicolons\nconst parseSequence: C.Parser<Expression> = C.map(\n  C.seq(\n    C.lazy(() => parseSequenceTermWithIf),\n    C.many(\n      C.seq(\n        C.punctuation(\";\"),\n        C.lazy(() => parseSequenceTermWithIf)\n      )\n    )\n  ),\n  ([left, rest]) => {\n    let result = left;\n    for (const [op, right] of rest) {\n      result = {\n        kind: \"binary\",\n        operator: \";\",\n        left: result,\n        right,\n        location: result.location,\n      };\n    }\n    return result;\n  }\n);\n\n// --- Expression (top-level) ---\nconst parseExpr: C.Parser<Expression> = parseSequence;\n\n// --- Main Parse Function ---\nexport const parse = (tokens: Token[]): Program => {\n  // Filter out EOF tokens for parsing\n  const nonEOFTokens = tokens.filter((t) => t.type !== \"EOF\");\n\n  // Parse multiple top-level expressions separated by semicolons\n  let statements: Expression[] = [];\n  let rest = nonEOFTokens;\n  while (rest.length > 0) {\n    // Skip leading semicolons\n    while (\n      rest.length > 0 &&\n      rest[0].type === \"PUNCTUATION\" &&\n      rest[0].value === \";\"\n    ) {\n      rest = rest.slice(1);\n    }\n    if (rest.length === 0) break;\n    const result = parseExpr(rest);\n    if (!result.success) {\n      // Include line and column information in parse error\n      const errorLocation =\n        result.position > 0 ? ` at line ${result.position}` : \"\";\n      throw new Error(`Parse error: ${result.error}${errorLocation}`);\n    }\n    statements.push(result.value);\n    rest = result.remaining;\n    // Skip trailing semicolons after each statement\n    while (\n      rest.length > 0 &&\n      rest[0].type === \"PUNCTUATION\" &&\n      rest[0].value === \";\"\n    ) {\n      rest = rest.slice(1);\n    }\n  }\n  // If there are still leftover tokens that aren't semicolons or EOF, throw an error\n  if (rest.length > 0) {\n    const next = rest[0];\n    throw new Error(\n      `Unexpected token after expression: ${next.type} '${next.value}' at line ${next.location.start.line}, column ${next.location.start.column}`\n    );\n  }\n  return {\n    statements,\n    location: createLocation({ line: 1, column: 1 }, { line: 1, column: 1 }),\n  };\n};\n"],"version":3}