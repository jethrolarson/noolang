{"file":"/workspace/src/typer/constraint-resolution.ts","mappings":"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","names":[],"sources":["/workspace/src/typer/constraint-resolution.ts"],"sourcesContent":["// Constraint function resolution for trait system\nimport { \n  Type, \n  Expression, \n  VariableExpression, \n  ApplicationExpression,\n  typeVariable,\n  functionType\n} from '../ast';\nimport { \n  TypeState, \n  TypeResult, \n  TypeScheme,\n  resolveConstraintFunction,\n  createPureTypeResult,\n  createTypeResult\n} from './types';\nimport { substitute } from './substitute';\nimport { typeToString } from './helpers';\n\n/**\n * Check if a function call might be a constraint function and resolve it\n */\nexport function tryResolveConstraintFunction(\n  functionName: string,\n  args: Expression[],\n  argTypes: Type[],\n  state: TypeState\n): { resolved: boolean; specializedName?: string; typeScheme?: TypeScheme } {\n  \n  // Search through all constraints to see if this function name exists\n  for (const [constraintName, constraintInfo] of state.constraintRegistry) {\n    if (constraintInfo.signature.functions.has(functionName)) {\n      // This is potentially a constraint function call\n      \n      // Try to resolve based on the first argument's type (common pattern)\n      if (argTypes.length > 0) {\n        const firstArgType = substitute(argTypes[0], state.substitution);\n        \n        // Only resolve if we have a concrete type (not a type variable)\n        if (firstArgType.kind !== 'variable') {\n          const implementation = resolveConstraintFunction(\n            state.constraintRegistry,\n            constraintName,\n            functionName,\n            firstArgType\n          );\n          \n          if (implementation) {\n            // Generate specialized function name\n            const typeName = typeToString(firstArgType);\n            const specializedName = `__${constraintName}_${functionName}_${typeName}`;\n            \n            return {\n              resolved: true,\n              specializedName,\n              typeScheme: implementation\n            };\n          }\n        }\n      }\n    }\n  }\n  \n  return { resolved: false };\n}\n\n/**\n * Decorate the environment with specialized constraint functions\n */\nexport function decorateEnvironmentWithConstraintFunctions(state: TypeState): TypeState {\n  const newEnvironment = new Map(state.environment);\n  \n  // Add all available constraint implementations to the environment\n  for (const [constraintName, constraintInfo] of state.constraintRegistry) {\n    for (const [functionName, functionType] of constraintInfo.signature.functions) {\n      for (const [typeName, implementation] of constraintInfo.implementations) {\n        const specializedName = `__${constraintName}_${functionName}_${typeName}`;\n        \n        // Add the specialized function to the environment\n        for (const [implName, implScheme] of implementation.functions) {\n          if (implName === functionName) {\n            newEnvironment.set(specializedName, implScheme);\n          }\n        }\n      }\n    }\n  }\n  \n  return {\n    ...state,\n    environment: newEnvironment\n  };\n}\n\n/**\n * Check if a variable reference is a constraint function and needs resolution\n */\nexport function resolveConstraintVariable(\n  name: string,\n  state: TypeState\n): { resolved: boolean; needsResolution?: boolean; constraintName?: string; functionName?: string } {\n  \n  // Check if this is a constraint function name\n  for (const [constraintName, constraintInfo] of state.constraintRegistry) {\n    if (constraintInfo.signature.functions.has(name)) {\n      return {\n        resolved: true,\n        needsResolution: true,\n        constraintName,\n        functionName: name\n      };\n    }\n  }\n  \n  return { resolved: false };\n}\n\n/**\n * Create a constraint function type that includes information about needed resolution\n */\nexport function createConstraintFunctionType(\n  constraintName: string,\n  functionName: string,\n  state: TypeState\n): Type {\n  const constraintInfo = state.constraintRegistry.get(constraintName);\n  if (!constraintInfo) {\n    throw new Error(`Constraint '${constraintName}' not found`);\n  }\n  \n  const functionType = constraintInfo.signature.functions.get(functionName);\n  if (!functionType) {\n    throw new Error(`Function '${functionName}' not found in constraint '${constraintName}'`);\n  }\n  \n  // Return the function type with constraint information\n  // We'll handle the actual resolution during application\n  return functionType;\n}\n\n/**\n * Generate constraint qualification error when resolution fails\n */\nexport function generateConstraintError(\n  constraintName: string,\n  functionName: string,\n  attemptedType: Type,\n  state: TypeState\n): string {\n  const typeName = typeToString(attemptedType);\n  const availableImpls = state.constraintRegistry.get(constraintName)?.implementations;\n  const availableTypes = availableImpls ? Array.from(availableImpls.keys()) : [];\n  \n  let message = `No implementation of constraint '${constraintName}' found for type '${typeName}' when calling '${functionName}'.`;\n  \n  if (availableTypes.length > 0) {\n    message += `\\nAvailable implementations: ${availableTypes.join(', ')}`;\n  } else {\n    message += `\\nNo implementations of '${constraintName}' have been defined.`;\n  }\n  \n  message += `\\n\\nTo fix this, add an implementation:\\nimplement ${constraintName} ${typeName} (\\n  ${functionName} = ...\\n);`;\n  \n  return message;\n}"],"version":3}