{"file":"/workspace/test/record_tuple_unit.test.ts","mappings":";;AAAA,wCAAqC;AACrC,iDAA6C;AAE7C,QAAQ,CAAC,2BAA2B,EAAE,GAAG,EAAE;IACzC,SAAS,QAAQ,CAAC,GAAW;QAC3B,MAAM,KAAK,GAAG,IAAI,aAAK,CAAC,GAAG,CAAC,CAAC;QAC7B,MAAM,MAAM,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC;QAChC,OAAO,IAAA,cAAK,EAAC,MAAM,CAAC,CAAC;IACvB,CAAC;IAED,IAAI,CAAC,qBAAqB,EAAE,GAAG,EAAE;QAC/B,MAAM,OAAO,GAAG,QAAQ,CAAC,gBAAgB,CAAC,CAAC;QAC3C,MAAM,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QACrC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACnC,IAAI,MAAM,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;YAC7B,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC;gBAC5B,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,CAAC,QAAQ,EAAE,EAAE;gBACvC,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,CAAC,QAAQ,EAAE,EAAE;aACxC,CAAC,CAAC;QACL,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,gCAAgC,EAAE,GAAG,EAAE;QAC1C,MAAM,OAAO,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC;QACrC,MAAM,KAAK,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QACpC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACjC,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;YAC3B,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACtC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;YACrD,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;QACvD,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,4BAA4B,EAAE,GAAG,EAAE;QACtC,MAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;QAChC,MAAM,IAAI,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QACnC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACjC,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,6CAA6C,EAAE,GAAG,EAAE;QACvD,MAAM,CAAC,GAAG,EAAE,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;QAChD,MAAM,CAAC,GAAG,EAAE,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;IAClD,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","names":[],"sources":["/workspace/test/record_tuple_unit.test.ts"],"sourcesContent":["import { Lexer } from \"../src/lexer\";\nimport { parse } from \"../src/parser/parser\";\n\ndescribe(\"Records, Tuples, and Unit\", () => {\n  function parseNoo(src: string) {\n    const lexer = new Lexer(src);\n    const tokens = lexer.tokenize();\n    return parse(tokens);\n  }\n\n  test(\"parses named record\", () => {\n    const program = parseNoo(\"{ @a 1, @b 2 }\");\n    const record = program.statements[0];\n    expect(record.kind).toBe(\"record\");\n    if (record.kind === \"record\") {\n      expect(record.fields).toEqual([\n        { name: \"a\", value: expect.anything() },\n        { name: \"b\", value: expect.anything() },\n      ]);\n    }\n  });\n\n  test(\"parses tuple (nameless record)\", () => {\n    const program = parseNoo(\"{ 1, 2 }\");\n    const tuple = program.statements[0];\n    expect(tuple.kind).toBe(\"tuple\");\n    if (tuple.kind === \"tuple\") {\n      expect(tuple.elements.length).toBe(2);\n      expect(tuple.elements[0]).toEqual(expect.anything());\n      expect(tuple.elements[1]).toEqual(expect.anything());\n    }\n  });\n\n  test(\"parses unit (empty braces)\", () => {\n    const program = parseNoo(\"{ }\");\n    const unit = program.statements[0];\n    expect(unit.kind).toBe(\"unit\");\n  });\n\n  test(\"throws on mixed named and positional fields\", () => {\n    expect(() => parseNoo(\"{ 1, @a 2 }\")).toThrow();\n    expect(() => parseNoo(\"{ @a 2, 1 }\")).toThrow();\n  });\n});\n"],"version":3}