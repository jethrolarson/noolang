887ccb2448af9dafbdba7c751bc2ca13
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const lexer_1 = require("../../lexer");
const parser_1 = require("../../parser/parser");
const index_1 = require("../index");
const helpers_1 = require("../helpers");
// Helper function to parse a string into a program
const parseProgram = (source) => {
    const lexer = new lexer_1.Lexer(source);
    const tokens = lexer.tokenize();
    return (0, parser_1.parse)(tokens);
};
(0, globals_1.describe)('Functional Typer - Let-Polymorphism', () => {
    (0, globals_1.describe)('Core Let-Polymorphism', () => {
        (0, globals_1.it)('should generalize polymorphic identity function', () => {
            const program = parseProgram('id = fn x => x');
            const result = (0, index_1.typeProgram)(program);
            (0, globals_1.expect)((0, helpers_1.typeToString)(result.type, result.state.substitution)).toBe('(α) -> α');
        });
        (0, globals_1.it)('should allow polymorphic function to be used with different types', () => {
            const program = parseProgram(`
        id = fn x => x;
        num = id 42;
        str = id "hello";
        bool = id True
      `);
            const result = (0, index_1.typeProgram)(program);
            // The sequence returns the type of the rightmost expression
            (0, globals_1.expect)((0, helpers_1.typeToString)(result.type, result.state.substitution)).toBe('Bool');
        });
        (0, globals_1.it)('should handle higher-order functions with generalization', () => {
            const program = parseProgram(`
        apply = fn f x => f x;
        double = fn x => x * 2;
        result = apply double 5
      `);
            const result = (0, index_1.typeProgram)(program);
            // The sequence returns the type of the rightmost expression
            (0, globals_1.expect)((0, helpers_1.typeToString)(result.type, result.state.substitution)).toBe('Int');
        });
    });
    (0, globals_1.describe)('Let-Polymorphism Edge Cases', () => {
        (0, globals_1.it)('should handle nested function definitions', () => {
            const program = parseProgram(`
        outer = fn x => (
          inner = fn y => x;
          inner 42
        )
      `);
            const result = (0, index_1.typeProgram)(program);
            // This should work with proper generalization
            (0, globals_1.expect)((0, helpers_1.typeToString)(result.type, result.state.substitution)).toBe('(α) -> α');
        });
        (0, globals_1.it)('should handle curried polymorphic functions', () => {
            const program = parseProgram(`
        add = fn x y => x + y;
        addFive = add 5;
        result = addFive 3
      `);
            const result = (0, index_1.typeProgram)(program);
            (0, globals_1.expect)((0, helpers_1.typeToString)(result.type, result.state.substitution)).toBe('Int');
        });
        (0, globals_1.it)('should handle multiple polymorphic functions in sequence', () => {
            const program = parseProgram(`
        id = fn x => x;
        const = fn x y => x;
        result1 = id 42;
        result2 = const "hello" 123;
        result3 = id True
      `);
            const result = (0, index_1.typeProgram)(program);
            (0, globals_1.expect)((0, helpers_1.typeToString)(result.type, result.state.substitution)).toBe('Bool');
        });
    });
    (0, globals_1.describe)('Type Environment Consistency', () => {
        (0, globals_1.it)('should properly instantiate polymorphic functions in single program', () => {
            const program = parseProgram(`
        id = fn x => x;
        numResult = id 42;
        strResult = id "hello";
        boolResult = id True;
        numResult
      `);
            const result = (0, index_1.typeProgram)(program);
            (0, globals_1.expect)((0, helpers_1.typeToString)(result.type, result.state.substitution)).toBe('Int');
        });
        (0, globals_1.it)('should handle polymorphic function with multiple instantiations', () => {
            const program = parseProgram(`
        id = fn x => x;
        id 42;
        id "hello";
        id True
      `);
            const result = (0, index_1.typeProgram)(program);
            (0, globals_1.expect)((0, helpers_1.typeToString)(result.type, result.state.substitution)).toBe('Bool');
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL3dvcmtzcGFjZS9zcmMvdHlwZXIvX190ZXN0c19fL3R5cGVyX2Z1bmN0aW9uYWxfZ2VuZXJhbGl6YXRpb24udGVzdC50cyIsIm1hcHBpbmdzIjoiOztBQUFBLDJDQUFxRDtBQUNyRCx1Q0FBb0M7QUFDcEMsZ0RBQTRDO0FBQzVDLG9DQUF1QztBQUN2Qyx3Q0FBMEM7QUFFMUMsbURBQW1EO0FBQ25ELE1BQU0sWUFBWSxHQUFHLENBQUMsTUFBYyxFQUFFLEVBQUU7SUFDdkMsTUFBTSxLQUFLLEdBQUcsSUFBSSxhQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEMsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ2hDLE9BQU8sSUFBQSxjQUFLLEVBQUMsTUFBTSxDQUFDLENBQUM7QUFDdEIsQ0FBQyxDQUFDO0FBRUYsSUFBQSxrQkFBUSxFQUFDLHFDQUFxQyxFQUFFLEdBQUcsRUFBRTtJQUNwRCxJQUFBLGtCQUFRLEVBQUMsdUJBQXVCLEVBQUUsR0FBRyxFQUFFO1FBQ3RDLElBQUEsWUFBRSxFQUFDLGlEQUFpRCxFQUFFLEdBQUcsRUFBRTtZQUMxRCxNQUFNLE9BQU8sR0FBRyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUMvQyxNQUFNLE1BQU0sR0FBRyxJQUFBLG1CQUFXLEVBQUMsT0FBTyxDQUFDLENBQUM7WUFDcEMsSUFBQSxnQkFBTSxFQUFDLElBQUEsc0JBQVksRUFBQyxNQUFNLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQ2hFLFVBQVUsQ0FDVixDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFBLFlBQUUsRUFBQyxtRUFBbUUsRUFBRSxHQUFHLEVBQUU7WUFDNUUsTUFBTSxPQUFPLEdBQUcsWUFBWSxDQUFDOzs7OztPQUt6QixDQUFDLENBQUM7WUFDTixNQUFNLE1BQU0sR0FBRyxJQUFBLG1CQUFXLEVBQUMsT0FBTyxDQUFDLENBQUM7WUFDcEMsNERBQTREO1lB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QUFZLENBQUM7Ozs7O09BS3pCLENBQUMsQ0FBQztZQUNOLE1BQU0sTUFBTSxHQUFHLElBQUEsbUJBQVcsRUFBQyxPQUFPLENBQUMsQ0FBQztZQUNwQyxJQUFBLGdCQUFNLEVBQUMsSUFBQSxzQkFBWSxFQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMzRSxDQUFDLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ0osQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL3dvcmtzcGFjZS9zcmMvdHlwZXIvX190ZXN0c19fL3R5cGVyX2Z1bmN0aW9uYWxfZ2VuZXJhbGl6YXRpb24udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXNjcmliZSwgaXQsIGV4cGVjdCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tICcuLi8uLi9sZXhlcic7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJy4uLy4uL3BhcnNlci9wYXJzZXInO1xuaW1wb3J0IHsgdHlwZVByb2dyYW0gfSBmcm9tICcuLi9pbmRleCc7XG5pbXBvcnQgeyB0eXBlVG9TdHJpbmcgfSBmcm9tICcuLi9oZWxwZXJzJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHBhcnNlIGEgc3RyaW5nIGludG8gYSBwcm9ncmFtXG5jb25zdCBwYXJzZVByb2dyYW0gPSAoc291cmNlOiBzdHJpbmcpID0+IHtcblx0Y29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoc291cmNlKTtcblx0Y29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcblx0cmV0dXJuIHBhcnNlKHRva2Vucyk7XG59O1xuXG5kZXNjcmliZSgnRnVuY3Rpb25hbCBUeXBlciAtIExldC1Qb2x5bW9ycGhpc20nLCAoKSA9PiB7XG5cdGRlc2NyaWJlKCdDb3JlIExldC1Qb2x5bW9ycGhpc20nLCAoKSA9PiB7XG5cdFx0aXQoJ3Nob3VsZCBnZW5lcmFsaXplIHBvbHltb3JwaGljIGlkZW50aXR5IGZ1bmN0aW9uJywgKCkgPT4ge1xuXHRcdFx0Y29uc3QgcHJvZ3JhbSA9IHBhcnNlUHJvZ3JhbSgnaWQgPSBmbiB4ID0+IHgnKTtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IHR5cGVQcm9ncmFtKHByb2dyYW0pO1xuXHRcdFx0ZXhwZWN0KHR5cGVUb1N0cmluZyhyZXN1bHQudHlwZSwgcmVzdWx0LnN0YXRlLnN1YnN0aXR1dGlvbikpLnRvQmUoXG5cdFx0XHRcdCcozrEpIC0+IM6xJ1xuXHRcdFx0KTtcblx0XHR9KTtcblxuXHRcdGl0KCdzaG91bGQgYWxsb3cgcG9seW1vcnBoaWMgZnVuY3Rpb24gdG8gYmUgdXNlZCB3aXRoIGRpZmZlcmVudCB0eXBlcycsICgpID0+IHtcblx0XHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZVByb2dyYW0oYFxuICAgICAgICBpZCA9IGZuIHggPT4geDtcbiAgICAgICAgbnVtID0gaWQgNDI7XG4gICAgICAgIHN0ciA9IGlkIFwiaGVsbG9cIjtcbiAgICAgICAgYm9vbCA9IGlkIFRydWVcbiAgICAgIGApO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdHlwZVByb2dyYW0ocHJvZ3JhbSk7XG5cdFx0XHQvLyBUaGUgc2VxdWVuY2UgcmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgcmlnaHRtb3N0IGV4cHJlc3Npb25cblx0XHRcdGV4cGVjdCh0eXBlVG9TdHJpbmcocmVzdWx0LnR5cGUsIHJlc3VsdC5zdGF0ZS5zdWJzdGl0dXRpb24pKS50b0JlKCdCb29sJyk7XG5cdFx0fSk7XG5cblx0XHRpdCgnc2hvdWxkIGhhbmRsZSBoaWdoZXItb3JkZXIgZnVuY3Rpb25zIHdpdGggZ2VuZXJhbGl6YXRpb24nLCAoKSA9PiB7XG5cdFx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2VQcm9ncmFtKGBcbiAgICAgICAgYXBwbHkgPSBmbiBmIHggPT4gZiB4O1xuICAgICAgICBkb3VibGUgPSBmbiB4ID0+IHggKiAyO1xuICAgICAgICByZXN1bHQgPSBhcHBseSBkb3VibGUgNVxuICAgICAgYCk7XG5cdFx0XHRjb25zdCByZXN1bHQgPSB0eXBlUHJvZ3JhbShwcm9ncmFtKTtcblx0XHRcdC8vIFRoZSBzZXF1ZW5jZSByZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSByaWdodG1vc3QgZXhwcmVzc2lvblxuXHRcdFx0ZXhwZWN0KHR5cGVUb1N0cmluZyhyZXN1bHQudHlwZSwgcmVzdWx0LnN0YXRlLnN1YnN0aXR1dGlvbikpLnRvQmUoJ0ludCcpO1xuXHRcdH0pO1xuXHR9KTtcblxuXHRkZXNjcmliZSgnTGV0LVBvbHltb3JwaGlzbSBFZGdlIENhc2VzJywgKCkgPT4ge1xuXHRcdGl0KCdzaG91bGQgaGFuZGxlIG5lc3RlZCBmdW5jdGlvbiBkZWZpbml0aW9ucycsICgpID0+IHtcblx0XHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZVByb2dyYW0oYFxuICAgICAgICBvdXRlciA9IGZuIHggPT4gKFxuICAgICAgICAgIGlubmVyID0gZm4geSA9PiB4O1xuICAgICAgICAgIGlubmVyIDQyXG4gICAgICAgIClcbiAgICAgIGApO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdHlwZVByb2dyYW0ocHJvZ3JhbSk7XG5cdFx0XHQvLyBUaGlzIHNob3VsZCB3b3JrIHdpdGggcHJvcGVyIGdlbmVyYWxpemF0aW9uXG5cdFx0XHRleHBlY3QodHlwZVRvU3RyaW5nKHJlc3VsdC50eXBlLCByZXN1bHQuc3RhdGUuc3Vic3RpdHV0aW9uKSkudG9CZShcblx0XHRcdFx0JyjOsSkgLT4gzrEnXG5cdFx0XHQpO1xuXHRcdH0pO1xuXG5cdFx0aXQoJ3Nob3VsZCBoYW5kbGUgY3VycmllZCBwb2x5bW9ycGhpYyBmdW5jdGlvbnMnLCAoKSA9PiB7XG5cdFx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2VQcm9ncmFtKGBcbiAgICAgICAgYWRkID0gZm4geCB5ID0+IHggKyB5O1xuICAgICAgICBhZGRGaXZlID0gYWRkIDU7XG4gICAgICAgIHJlc3VsdCA9IGFkZEZpdmUgM1xuICAgICAgYCk7XG5cdFx0XHRjb25zdCByZXN1bHQgPSB0eXBlUHJvZ3JhbShwcm9ncmFtKTtcblx0XHRcdGV4cGVjdCh0eXBlVG9TdHJpbmcocmVzdWx0LnR5cGUsIHJlc3VsdC5zdGF0ZS5zdWJzdGl0dXRpb24pKS50b0JlKCdJbnQnKTtcblx0XHR9KTtcblxuXHRcdGl0KCdzaG91bGQgaGFuZGxlIG11bHRpcGxlIHBvbHltb3JwaGljIGZ1bmN0aW9ucyBpbiBzZXF1ZW5jZScsICgpID0+IHtcblx0XHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZVByb2dyYW0oYFxuICAgICAgICBpZCA9IGZuIHggPT4geDtcbiAgICAgICAgY29uc3QgPSBmbiB4IHkgPT4geDtcbiAgICAgICAgcmVzdWx0MSA9IGlkIDQyO1xuICAgICAgICByZXN1bHQyID0gY29uc3QgXCJoZWxsb1wiIDEyMztcbiAgICAgICAgcmVzdWx0MyA9IGlkIFRydWVcbiAgICAgIGApO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdHlwZVByb2dyYW0ocHJvZ3JhbSk7XG5cdFx0XHRleHBlY3QodHlwZVRvU3RyaW5nKHJlc3VsdC50eXBlLCByZXN1bHQuc3RhdGUuc3Vic3RpdHV0aW9uKSkudG9CZSgnQm9vbCcpO1xuXHRcdH0pO1xuXHR9KTtcblxuXHRkZXNjcmliZSgnVHlwZSBFbnZpcm9ubWVudCBDb25zaXN0ZW5jeScsICgpID0+IHtcblx0XHRpdCgnc2hvdWxkIHByb3Blcmx5IGluc3RhbnRpYXRlIHBvbHltb3JwaGljIGZ1bmN0aW9ucyBpbiBzaW5nbGUgcHJvZ3JhbScsICgpID0+IHtcblx0XHRcdGNvbnN0IHByb2dyYW0gPSBwYXJzZVByb2dyYW0oYFxuICAgICAgICBpZCA9IGZuIHggPT4geDtcbiAgICAgICAgbnVtUmVzdWx0ID0gaWQgNDI7XG4gICAgICAgIHN0clJlc3VsdCA9IGlkIFwiaGVsbG9cIjtcbiAgICAgICAgYm9vbFJlc3VsdCA9IGlkIFRydWU7XG4gICAgICAgIG51bVJlc3VsdFxuICAgICAgYCk7XG5cdFx0XHRjb25zdCByZXN1bHQgPSB0eXBlUHJvZ3JhbShwcm9ncmFtKTtcblx0XHRcdGV4cGVjdCh0eXBlVG9TdHJpbmcocmVzdWx0LnR5cGUsIHJlc3VsdC5zdGF0ZS5zdWJzdGl0dXRpb24pKS50b0JlKCdJbnQnKTtcblx0XHR9KTtcblxuXHRcdGl0KCdzaG91bGQgaGFuZGxlIHBvbHltb3JwaGljIGZ1bmN0aW9uIHdpdGggbXVsdGlwbGUgaW5zdGFudGlhdGlvbnMnLCAoKSA9PiB7XG5cdFx0XHRjb25zdCBwcm9ncmFtID0gcGFyc2VQcm9ncmFtKGBcbiAgICAgICAgaWQgPSBmbiB4ID0+IHg7XG4gICAgICAgIGlkIDQyO1xuICAgICAgICBpZCBcImhlbGxvXCI7XG4gICAgICAgIGlkIFRydWVcbiAgICAgIGApO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gdHlwZVByb2dyYW0ocHJvZ3JhbSk7XG5cdFx0XHRleHBlY3QodHlwZVRvU3RyaW5nKHJlc3VsdC50eXBlLCByZXN1bHQuc3RhdGUuc3Vic3RpdHV0aW9uKSkudG9CZSgnQm9vbCcpO1xuXHRcdH0pO1xuXHR9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9