{"file":"/workspace/src/typer/type-operations.ts","mappings":"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","names":[],"sources":["/workspace/src/typer/type-operations.ts"],"sourcesContent":["import * as fs from \"node:fs\";\nimport * as path from \"node:path\";\nimport {\n\ttype Type,\n\ttype Expression,\n\ttype Program,\n\ttypeVariable,\n\tunitType,\n} from '../ast';\nimport { parse } from '../parser/parser';\nimport { Lexer } from '../lexer';\nimport { type TypeState, type TypeEnvironment, type TypeScheme, createConstraintRegistry } from './types';\nimport { substitute } from './substitute';\nimport { typeExpression } from './expression-dispatcher';\nimport { constraintsEqual } from './helpers';\n\n// Fresh type variable generation - optimized to avoid string concatenation\nexport const freshTypeVariable = (state: TypeState): [Type, TypeState] => {\n\tconst newCounter = state.counter + 1;\n\tconst newType = typeVariable(`Î±${newCounter}`);\n\t// Avoid spreading the entire state object for better performance\n\treturn [newType, { \n\t\t...state, \n\t\tcounter: newCounter \n\t}];\n};\n\n// Collect all free type variables in a type\nexport const freeTypeVars = (\n\ttype: Type,\n\tacc: Set<string> = new Set()\n): Set<string> => {\n\tswitch (type.kind) {\n\t\tcase 'variable':\n\t\t\tacc.add(type.name);\n\t\t\tbreak;\n\t\tcase 'function':\n\t\t\tfor (const param of type.params) freeTypeVars(param, acc);\n\t\t\tfreeTypeVars(type.return, acc);\n\t\t\tbreak;\n\t\tcase 'list':\n\t\t\tfreeTypeVars(type.element, acc);\n\t\t\tbreak;\n\t\tcase 'tuple':\n\t\t\tfor (const el of type.elements) freeTypeVars(el, acc);\n\t\t\tbreak;\n\t\tcase 'record':\n\t\t\tObject.values(type.fields).forEach(v => freeTypeVars(v, acc));\n\t\t\tbreak;\n\t\tcase 'union':\n\t\t\ttype.types.forEach(t => freeTypeVars(t, acc));\n\t\t\tbreak;\n\t\tcase 'variant':\n\t\t\ttype.args.forEach(arg => freeTypeVars(arg, acc));\n\t\t\tbreak;\n\t}\n\treturn acc;\n};\n\n// Collect all free type variables in the environment\nexport const freeTypeVarsEnv = (env: TypeEnvironment): Set<string> => {\n\tconst acc = new Set<string>();\n\tfor (const scheme of env.values()) {\n\t\tfreeTypeVars(scheme.type, acc);\n\t}\n\treturn acc;\n};\n\n// Generalize a type with respect to the environment\nexport const generalize = (\n\ttype: Type,\n\tenv: TypeEnvironment,\n\tsubstitution: Map<string, Type>\n): TypeScheme => {\n\t// Apply current substitution to the type before generalizing\n\tconst substitutedType = substitute(type, substitution);\n\tconst typeVars = freeTypeVars(substitutedType);\n\tconst envVars = freeTypeVarsEnv(env);\n\tconst quantifiedVars: string[] = [];\n\n\tfor (const varName of typeVars) {\n\t\tif (!envVars.has(varName)) {\n\t\t\tquantifiedVars.push(varName);\n\t\t}\n\t}\n\treturn { type: substitutedType, quantifiedVars };\n};\n\n// Instantiate a type scheme by freshening all quantified variables (threading state)\nexport const instantiate = (\n\tscheme: TypeScheme,\n\tstate: TypeState\n): [Type, TypeState] => {\n\tconst mapping = new Map<string, Type>();\n\tlet currentState = state;\n\tfor (const varName of scheme.quantifiedVars) {\n\t\tconst [freshVar, newState] = freshTypeVariable(currentState);\n\t\tmapping.set(varName, freshVar);\n\t\tcurrentState = newState;\n\t}\n\n\tconst [instantiatedType, finalState] = freshenTypeVariables(\n\t\tscheme.type,\n\t\tmapping,\n\t\tcurrentState\n\t);\n\n\treturn [instantiatedType, finalState];\n};\n\n// Replace type variables with fresh ones, threading state\nexport const freshenTypeVariables = (\n\ttype: Type,\n\tmapping: Map<string, Type> = new Map(),\n\tstate: TypeState\n): [Type, TypeState] => {\n\tswitch (type.kind) {\n\t\tcase 'variable': {\n\t\t\tconst freshVar = mapping.get(type.name);\n\t\t\tif (freshVar) {\n\t\t\t\t// Copy constraints from the original variable to the fresh one\n\t\t\t\tif (freshVar.kind === 'variable') {\n\t\t\t\t\tfreshVar.constraints = freshVar.constraints || [];\n\t\t\t\t\tif (type.constraints) {\n\t\t\t\t\t\tfor (const c of type.constraints) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!freshVar.constraints.some(\n\t\t\t\t\t\t\t\t\texisting => constraintsEqual(existing, c)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tfreshVar.constraints.push(c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [freshVar, state];\n\t\t\t}\n\t\t\treturn [type, state];\n\t\t}\n\t\tcase 'function': {\n\t\t\tlet currentState = state;\n\t\t\tconst newParams: Type[] = [];\n\t\t\tfor (const param of type.params) {\n\t\t\t\tconst [newParam, nextState] = freshenTypeVariables(\n\t\t\t\t\tparam,\n\t\t\t\t\tmapping,\n\t\t\t\t\tcurrentState\n\t\t\t\t);\n\t\t\t\tnewParams.push(newParam);\n\t\t\t\tcurrentState = nextState;\n\t\t\t}\n\t\t\tconst [newReturn, finalState] = freshenTypeVariables(\n\t\t\t\ttype.return,\n\t\t\t\tmapping,\n\t\t\t\tcurrentState\n\t\t\t);\n\t\t\treturn [{ ...type, params: newParams, return: newReturn }, finalState];\n\t\t}\n\t\tcase 'list': {\n\t\t\tconst [newElem, nextState] = freshenTypeVariables(\n\t\t\t\ttype.element,\n\t\t\t\tmapping,\n\t\t\t\tstate\n\t\t\t);\n\t\t\treturn [{ ...type, element: newElem }, nextState];\n\t\t}\n\t\tcase 'tuple': {\n\t\t\tlet currentState = state;\n\t\t\tconst newElems: Type[] = [];\n\t\t\tfor (const el of type.elements) {\n\t\t\t\tconst [newEl, nextState] = freshenTypeVariables(\n\t\t\t\t\tel,\n\t\t\t\t\tmapping,\n\t\t\t\t\tcurrentState\n\t\t\t\t);\n\t\t\t\tnewElems.push(newEl);\n\t\t\t\tcurrentState = nextState;\n\t\t\t}\n\t\t\treturn [{ ...type, elements: newElems }, currentState];\n\t\t}\n\t\tcase 'record': {\n\t\t\tlet currentState = state;\n\t\t\tconst newFields: { [key: string]: Type } = {};\n\t\t\tfor (const [key, fieldType] of Object.entries(type.fields)) {\n\t\t\t\tconst [newField, nextState] = freshenTypeVariables(\n\t\t\t\t\tfieldType,\n\t\t\t\t\tmapping,\n\t\t\t\t\tcurrentState\n\t\t\t\t);\n\t\t\t\tnewFields[key] = newField;\n\t\t\t\tcurrentState = nextState;\n\t\t\t}\n\t\t\treturn [{ ...type, fields: newFields }, currentState];\n\t\t}\n\t\tcase 'union': {\n\t\t\tlet currentState = state;\n\t\t\tconst newTypes: Type[] = [];\n\t\t\tfor (const t of type.types) {\n\t\t\t\tconst [newType, nextState] = freshenTypeVariables(\n\t\t\t\t\tt,\n\t\t\t\t\tmapping,\n\t\t\t\t\tcurrentState\n\t\t\t\t);\n\t\t\t\tnewTypes.push(newType);\n\t\t\t\tcurrentState = nextState;\n\t\t\t}\n\t\t\treturn [{ ...type, types: newTypes }, currentState];\n\t\t}\n\t\tcase 'variant': {\n\t\t\tlet currentState = state;\n\t\t\tconst newArgs: Type[] = [];\n\t\t\tfor (const arg of type.args) {\n\t\t\t\tconst [newArg, nextState] = freshenTypeVariables(\n\t\t\t\t\targ,\n\t\t\t\t\tmapping,\n\t\t\t\t\tcurrentState\n\t\t\t\t);\n\t\t\t\tnewArgs.push(newArg);\n\t\t\t\tcurrentState = nextState;\n\t\t\t}\n\t\t\treturn [{ ...type, args: newArgs }, currentState];\n\t\t}\n\t\tdefault:\n\t\t\treturn [type, state];\n\t}\n};\n\n// Helper to flatten semicolon-separated binary expressions into individual statements\nexport const flattenStatements = (expr: Expression): Expression[] => {\n\tif (expr.kind === 'binary' && expr.operator === ';') {\n\t\treturn [...flattenStatements(expr.left), ...flattenStatements(expr.right)];\n\t}\n\treturn [expr];\n};\n\n// Load standard library from stdlib.noo\nexport const loadStdlib = (state: TypeState): TypeState => {\n\ttry {\n\t\t// Find stdlib.noo relative to this file\n\t\tconst stdlibPath = path.join(__dirname, '..', '..', 'stdlib.noo');\n\n\t\tif (!fs.existsSync(stdlibPath)) {\n\t\t\tconsole.warn(`Warning: stdlib.noo not found at ${stdlibPath}`);\n\t\t\treturn state;\n\t\t}\n\n\t\tconst stdlibContent = fs.readFileSync(stdlibPath, 'utf-8');\n\t\tconst lexer = new Lexer(stdlibContent);\n\t\tconst tokens = lexer.tokenize();\n\t\tconst stdlibProgram = parse(tokens);\n\n\t\t// Flatten any semicolon-separated statements\n\t\tconst allStatements: Expression[] = [];\n\t\tfor (const statement of stdlibProgram.statements) {\n\t\t\tallStatements.push(...flattenStatements(statement));\n\t\t}\n\n\t\tlet currentState = state;\n\t\tfor (const statement of allStatements) {\n\t\t\tconst result = typeExpression(statement, currentState);\n\t\t\tcurrentState = result.state;\n\t\t}\n\n\t\treturn currentState;\n\t} catch (error) {\n\t\tconsole.warn(`Warning: Failed to load stdlib.noo:`, error);\n\t\treturn state;\n\t}\n};\n\n// Initialize type state\nexport const createTypeState = (): TypeState => ({\n\tenvironment: new Map(),\n\tsubstitution: new Map(),\n\tcounter: 0,\n\tconstraints: [],\n\tadtRegistry: new Map(),\n\taccessorCache: new Map(),\n\tconstraintRegistry: createConstraintRegistry(),\n});\n\n// Clean substitutions from type state while preserving environment and other state\n// This is used in REPL to prevent type pollution between evaluations\nexport const cleanSubstitutions = (state: TypeState): TypeState => ({\n\t...state,\n\tsubstitution: new Map(), // Clear substitutions but keep environment\n\tconstraints: [], // Clear constraints as well\n});"],"version":3}