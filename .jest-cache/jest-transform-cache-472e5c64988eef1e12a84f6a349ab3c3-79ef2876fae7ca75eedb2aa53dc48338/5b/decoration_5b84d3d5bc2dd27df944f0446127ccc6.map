{"file":"/workspace/src/typer/decoration.ts","mappings":";;;AAAA,gCAMgB;AAEhB,uDAAgE;AAChE,yCAAgD;AAChD,mEAAyD;AAEzD,uEAAuE;AAChE,MAAM,eAAe,GAAG,CAAC,OAAgB,EAAE,YAAwB,EAAE,EAAE;IAC7E,IAAI,KAAK,GAAG,YAAY,IAAI,IAAA,iCAAe,GAAE,CAAC;IAC9C,IAAI,CAAC,YAAY,EAAE,CAAC;QACnB,KAAK,GAAG,IAAA,6BAAkB,EAAC,KAAK,CAAC,CAAC;QAClC,KAAK,GAAG,IAAA,4BAAU,EAAC,KAAK,CAAC,CAAC;IAC3B,CAAC;IAED,oEAAoE;IACpE,IAAI,YAAY,GAAG,KAAK,CAAC;IACzB,IAAI,SAAS,GAAG,IAAI,CAAC;IAErB,KAAK,MAAM,SAAS,IAAI,OAAO,CAAC,UAAU,EAAE,CAAC;QAC5C,8CAA8C;QAC9C,MAAM,MAAM,GAAG,IAAA,sCAAc,EAAC,SAAS,EAAE,YAAY,CAAC,CAAC;QACvD,YAAY,GAAG,MAAM,CAAC,KAAK,CAAC;QAC5B,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC;QAExB,0EAA0E;QAC1E,SAAS,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;IAC9B,CAAC;IAED,IAAI,CAAC,SAAS,EAAE,CAAC;QAChB,SAAS,GAAG,IAAA,cAAQ,GAAE,CAAC;IACxB,CAAC;IAED,OAAO;QACN,OAAO,EAAE,EAAE,GAAG,OAAO,EAAE;QACvB,KAAK,EAAE,YAAY;KACnB,CAAC;AACH,CAAC,CAAC;AA7BW,QAAA,eAAe,mBA6B1B","names":[],"sources":["/workspace/src/typer/decoration.ts"],"sourcesContent":["import {\n\ttype Expression,\n\ttype Program,\n\ttype DefinitionExpression,\n\ttype MutableDefinitionExpression,\n\tunitType,\n} from '../ast';\nimport { type TypeState } from './types';\nimport { createTypeState, loadStdlib } from './type-operations';\nimport { initializeBuiltins } from './builtins';\nimport { typeExpression } from './expression-dispatcher';\n\n// Decorate AST nodes with inferred types - now uses single-pass typing\nexport const typeAndDecorate = (program: Program, initialState?: TypeState) => {\n\tlet state = initialState || createTypeState();\n\tif (!initialState) {\n\t\tstate = initializeBuiltins(state);\n\t\tstate = loadStdlib(state);\n\t}\n\n\t// Process all statements with typeExpression, then decorate the AST\n\tlet currentState = state;\n\tlet finalType = null;\n\t\n\tfor (const statement of program.statements) {\n\t\t// Type the statement (this does all the work)\n\t\tconst result = typeExpression(statement, currentState);\n\t\tcurrentState = result.state;\n\t\tfinalType = result.type;\n\t\t\n\t\t// Now just add the computed type to the AST node (lightweight decoration)\n\t\tstatement.type = result.type;\n\t}\n\t\n\tif (!finalType) {\n\t\tfinalType = unitType();\n\t}\n\t\n\treturn { \n\t\tprogram: { ...program }, \n\t\tstate: currentState \n\t};\n};"],"version":3}