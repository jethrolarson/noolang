{"file":"/workspace/src/typer/function-application.ts","mappings":"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","names":[],"sources":["/workspace/src/typer/function-application.ts"],"sourcesContent":["import {\n\ttype ApplicationExpression,\n\ttype PipelineExpression,\n\ttype Type,\n\ttype Constraint,\n\tfunctionType,\n\tisConstraint,\n} from '../ast';\nimport {\n\tfunctionApplicationError,\n\tnonFunctionApplicationError,\n\tformatTypeError,\n\tcreateTypeError,\n} from './type-errors';\nimport {\n\tgetExprLocation,\n\tthrowTypeError,\n\ttypeToString,\n\tpropagateConstraintToTypeVariable,\n} from './helpers';\nimport { \n\ttype TypeState, \n\ttype TypeResult, \n\tcreateTypeResult, \n\tunionEffects \n} from './types';\nimport { \n\tvalidateFunctionCall, \n\tareEffectsCompatible,\n\tmergeEffects \n} from './effect-validation';\nimport { satisfiesConstraint } from './constraints';\nimport { substitute } from './substitute';\nimport { unify } from './unify';\nimport { freshTypeVariable, instantiate } from './type-operations';\nimport { typeExpression } from './expression-dispatcher';\nimport { \n\ttryResolveConstraintFunction, \n\tgenerateConstraintError,\n\tdecorateEnvironmentWithConstraintFunctions \n} from './constraint-resolution';\n\n// Helper function to continue function application with a specialized constraint function\nfunction continueWithSpecializedFunction(\n\texpr: ApplicationExpression,\n\tspecializedFuncType: Type,\n\targTypes: Type[],\n\tallEffects: Set<import('../ast').Effect>,\n\tstate: TypeState\n): TypeResult {\n\tlet currentState = state;\n\t\n\tif (specializedFuncType.kind !== 'function') {\n\t\tthrowTypeError(\n\t\t\tlocation => nonFunctionApplicationError(specializedFuncType, location),\n\t\t\tgetExprLocation(expr)\n\t\t);\n\t}\n\n\tconst funcType = specializedFuncType;\n\n\t// Check argument count\n\tif (argTypes.length > funcType.params.length) {\n\t\tthrowTypeError(\n\t\t\tlocation =>\n\t\t\t\tfunctionApplicationError(\n\t\t\t\t\tfuncType.params[funcType.params.length - 1],\n\t\t\t\t\targTypes[funcType.params.length - 1],\n\t\t\t\t\tfuncType.params.length - 1,\n\t\t\t\t\tundefined,\n\t\t\t\t\tlocation\n\t\t\t\t),\n\t\t\tgetExprLocation(expr)\n\t\t);\n\t}\n\n\t// Unify each argument with the corresponding parameter type\n\tfor (let i = 0; i < argTypes.length; i++) {\n\t\tcurrentState = unify(\n\t\t\tfuncType.params[i],\n\t\t\targTypes[i],\n\t\t\tcurrentState,\n\t\t\tgetExprLocation(expr),\n\t\t\t{\n\t\t\t\treason: 'constraint_function_application',\n\t\t\t\toperation: `applying argument ${i + 1}`,\n\t\t\t\thint: `Argument ${i + 1} has type ${typeToString(\n\t\t\t\t\targTypes[i],\n\t\t\t\t\tcurrentState.substitution\n\t\t\t\t)} but the constraint function expects ${typeToString(\n\t\t\t\t\tfuncType.params[i],\n\t\t\t\t\tcurrentState.substitution\n\t\t\t\t)}.`,\n\t\t\t}\n\t\t);\n\t}\n\n\t// Determine the result type\n\tlet resultType = funcType.return;\n\t\n\t// If not all arguments were provided, create a partial application\n\tif (argTypes.length < funcType.params.length) {\n\t\tconst remainingParams = funcType.params.slice(argTypes.length);\n\t\tresultType = functionType(remainingParams, funcType.return, funcType.effects);\n\t}\n\n\t// Merge effects from function type and arguments\n\tconst finalEffects = unionEffects(allEffects, funcType.effects);\n\n\treturn createTypeResult(resultType, finalEffects, currentState);\n}\n\n// Comprehensive constraint validation\nexport const validateConstraints = (\n\ttype: Type,\n\tstate: TypeState,\n\tlocation?: { line: number; column: number }\n): TypeState => {\n\tlet currentState = state;\n\n\t// Apply substitution to get the concrete type\n\tconst substitutedType = substitute(type, state.substitution);\n\n\t// If it's a type variable with constraints, check them\n\tif (substitutedType.kind === 'variable' && substitutedType.constraints) {\n\t\tfor (const constraint of substitutedType.constraints) {\n\t\t\t// currentState = solveConstraint(constraint, currentState, location);\n\t\t}\n\t}\n\n\t// If it's a function type, check constraints on parameters and return type\n\tif (substitutedType.kind === 'function') {\n\t\t// Check constraints on parameters\n\t\tfor (const param of substitutedType.params) {\n\t\t\tcurrentState = validateConstraints(param, currentState, location);\n\t\t}\n\n\t\t// Check constraints on return type\n\t\tcurrentState = validateConstraints(\n\t\t\tsubstitutedType.return,\n\t\t\tcurrentState,\n\t\t\tlocation\n\t\t);\n\n\t\t// Check function-level constraints\n\t\tif (substitutedType.constraints) {\n\t\t\t// currentState = solveConstraints(\n\t\t\t// \tsubstitutedType.constraints,\n\t\t\t// \tcurrentState,\n\t\t\t// \tlocation\n\t\t\t// );\n\t\t}\n\t}\n\n\t// If it's a list type, check constraints on element type\n\tif (substitutedType.kind === 'list') {\n\t\tcurrentState = validateConstraints(\n\t\t\tsubstitutedType.element,\n\t\t\tcurrentState,\n\t\t\tlocation\n\t\t);\n\t}\n\n\t// If it's a record type, check constraints on field types\n\tif (substitutedType.kind === 'record') {\n\t\tfor (const fieldType of Object.values(substitutedType.fields)) {\n\t\t\tcurrentState = validateConstraints(fieldType, currentState, location);\n\t\t}\n\t}\n\n\treturn currentState;\n};\n\n// Update typeApplication to thread state through freshenTypeVariables\nexport const typeApplication = (\n\texpr: ApplicationExpression,\n\tstate: TypeState\n): TypeResult => {\n\tlet currentState = state;\n\n\t// Type the function\n\tconst funcResult = typeExpression(expr.func, currentState);\n\tcurrentState = funcResult.state;\n\tconst funcType = funcResult.type;\n\n\t// Type each argument and collect effects\n\tconst argTypes: Type[] = [];\n\tlet allEffects = funcResult.effects;\n\tfor (const arg of expr.args) {\n\t\tconst argResult = typeExpression(arg, currentState);\n\t\targTypes.push(argResult.type);\n\t\tcurrentState = argResult.state;\n\t\tallEffects = unionEffects(allEffects, argResult.effects);\n\t}\n\n\t// Check if this is a constraint function call that needs resolution\n\t// ONLY apply to functions that are explicitly defined in constraints\n\tif (expr.func.kind === 'variable' && currentState.constraintRegistry.size > 0) {\n\t\t// Only check constraint resolution if the function is explicitly in a constraint\n\t\tlet isDefinedInConstraint = false;\n\t\tfor (const [, constraintInfo] of currentState.constraintRegistry) {\n\t\t\tif (constraintInfo.signature.functions.has(expr.func.name)) {\n\t\t\t\tisDefinedInConstraint = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// ONLY apply constraint resolution to explicitly defined constraint functions\n\t\t// This excludes ADT constructors like Point, Rectangle, etc.\n\t\tif (isDefinedInConstraint) {\n\t\t\tconst constraintResolution = tryResolveConstraintFunction(\n\t\t\t\texpr.func.name,\n\t\t\t\texpr.args,\n\t\t\t\targTypes,\n\t\t\t\tcurrentState\n\t\t\t);\n\t\t\t\n\t\t\tif (constraintResolution.resolved && constraintResolution.specializedName) {\n\t\t\t\t// This is a constraint function call with a concrete resolution\n\t\t\t\t// Look up the specialized function in the environment\n\t\t\t\tconst decoratedState = decorateEnvironmentWithConstraintFunctions(currentState);\n\t\t\t\tconst specializedScheme = decoratedState.environment.get(constraintResolution.specializedName);\n\t\t\t\t\n\t\t\t\tif (specializedScheme) {\n\t\t\t\t\t// Use the specialized implementation\n\t\t\t\t\tconst [instantiatedType, newState] = instantiate(specializedScheme, decoratedState);\n\t\t\t\t\t\n\t\t\t\t\t// The specialized function should match the call pattern\n\t\t\t\t\tif (instantiatedType.kind === 'function') {\n\t\t\t\t\t\t// Continue with normal function application using the specialized type\n\t\t\t\t\t\tconst specializedFuncType = instantiatedType;\n\t\t\t\t\t\t// Replace funcType with specializedFuncType for the rest of the function\n\t\t\t\t\t\treturn continueWithSpecializedFunction(\n\t\t\t\t\t\t\texpr, \n\t\t\t\t\t\t\tspecializedFuncType, \n\t\t\t\t\t\t\targTypes, \n\t\t\t\t\t\t\tallEffects, \n\t\t\t\t\t\t\tnewState\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Could not resolve - generate helpful error\n\t\t\t\t\tconst firstArgType = argTypes.length > 0 ? substitute(argTypes[0], currentState.substitution) : null;\n\t\t\t\t\tif (firstArgType && firstArgType.kind !== 'variable') {\n\t\t\t\t\t\t// We have a concrete type but no implementation\n\t\t\t\t\t\tconst errorMessage = generateConstraintError(\n\t\t\t\t\t\t\texpr.func.name, // This should be parsed differently, but for now using function name\n\t\t\t\t\t\t\texpr.func.name,\n\t\t\t\t\t\t\tfirstArgType,\n\t\t\t\t\t\t\tcurrentState\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthrow new Error(errorMessage);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Handle function application by checking if funcType is a function\n\tif (funcType.kind === 'function') {\n\t\tif (argTypes.length > funcType.params.length) {\n\t\t\tthrowTypeError(\n\t\t\t\tlocation =>\n\t\t\t\t\tfunctionApplicationError(\n\t\t\t\t\t\tfuncType.params[funcType.params.length - 1],\n\t\t\t\t\t\targTypes[funcType.params.length - 1],\n\t\t\t\t\t\tfuncType.params.length - 1,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tlocation\n\t\t\t\t\t),\n\t\t\t\tgetExprLocation(expr)\n\t\t\t);\n\t\t}\n\n\t\t// Unify each argument with the corresponding parameter type\n\t\tfor (let i = 0; i < argTypes.length; i++) {\n\t\t\tcurrentState = unify(\n\t\t\t\tfuncType.params[i],\n\t\t\t\targTypes[i],\n\t\t\t\tcurrentState,\n\t\t\t\tgetExprLocation(expr),\n\t\t\t\t{\n\t\t\t\t\treason: 'function_application',\n\t\t\t\t\toperation: `applying argument ${i + 1}`,\n\t\t\t\t\thint: `Argument ${i + 1} has type ${typeToString(\n\t\t\t\t\t\targTypes[i],\n\t\t\t\t\t\tcurrentState.substitution\n\t\t\t\t\t)} but the function parameter expects ${typeToString(\n\t\t\t\t\t\tfuncType.params[i],\n\t\t\t\t\t\tcurrentState.substitution\n\t\t\t\t\t)}.`,\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// After unification, validate constraints on the parameter\n\t\t\tconst substitutedParam = substitute(\n\t\t\t\tfuncType.params[i],\n\t\t\t\tcurrentState.substitution\n\t\t\t);\n\n\t\t\t// Check if the parameter has constraints that need to be validated\n\t\t\tif (\n\t\t\t\tsubstitutedParam.kind === 'variable' &&\n\t\t\t\tsubstitutedParam.constraints\n\t\t\t) {\n\t\t\t\t// Validate each constraint\n\t\t\t\tfor (const constraint of substitutedParam.constraints) {\n\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t// Check if the type variable has been unified to a concrete type\n\t\t\t\t\t\tconst concreteType = currentState.substitution.get(\n\t\t\t\t\t\t\tconstraint.typeVar\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (concreteType && concreteType.kind !== 'variable') {\n\t\t\t\t\t\t\t// The type variable has been unified to a concrete type, validate the constraint\n\t\t\t\t\t\t\tif (!satisfiesConstraint(concreteType, constraint.constraint)) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\tformatTypeError(\n\t\t\t\t\t\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t\t\t\t\t\t`Type ${typeToString(\n\t\t\t\t\t\t\t\t\t\t\t\tconcreteType,\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentState.substitution\n\t\t\t\t\t\t\t\t\t\t\t)} does not satisfy constraint '${\n\t\t\t\t\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t\t\t\t\t}'`,\n\t\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tline: expr.location?.start.line || 1,\n\t\t\t\t\t\t\t\t\t\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Also validate constraints on the argument type\n\t\t\tconst substitutedArg = substitute(argTypes[i], currentState.substitution);\n\t\t\tif (substitutedArg.kind === 'variable' && substitutedArg.constraints) {\n\t\t\t\tfor (const constraint of substitutedArg.constraints) {\n\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\tconst concreteType = currentState.substitution.get(\n\t\t\t\t\t\t\tconstraint.typeVar\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (concreteType && concreteType.kind !== 'variable') {\n\t\t\t\t\t\t\tif (!satisfiesConstraint(concreteType, constraint.constraint)) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\tformatTypeError(\n\t\t\t\t\t\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t\t\t\t\t\t`Type ${typeToString(\n\t\t\t\t\t\t\t\t\t\t\t\tconcreteType,\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentState.substitution\n\t\t\t\t\t\t\t\t\t\t\t)} does not satisfy constraint '${\n\t\t\t\t\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t\t\t\t\t}'`,\n\t\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tline: expr.location?.start.line || 1,\n\t\t\t\t\t\t\t\t\t\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// CRITICAL: Also check if the argument type itself satisfies constraints\n\t\t\t// This is needed for cases where the argument is a concrete type that should satisfy constraints\n\t\t\tif (substitutedArg.kind !== 'variable') {\n\t\t\t\t// Check if the parameter has constraints that the argument should satisfy\n\t\t\t\tif (\n\t\t\t\t\tsubstitutedParam.kind === 'variable' &&\n\t\t\t\t\tsubstitutedParam.constraints\n\t\t\t\t) {\n\t\t\t\t\tfor (const constraint of substitutedParam.constraints) {\n\t\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t\tif (!satisfiesConstraint(substitutedArg, constraint.constraint)) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\tformatTypeError(\n\t\t\t\t\t\t\t\t\t\tcreateTypeError(\n\t\t\t\t\t\t\t\t\t\t\t`Type ${typeToString(\n\t\t\t\t\t\t\t\t\t\t\t\tsubstitutedArg,\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentState.substitution\n\t\t\t\t\t\t\t\t\t\t\t)} does not satisfy constraint '${\n\t\t\t\t\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t\t\t\t\t}'`,\n\t\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tline: expr.location?.start.line || 1,\n\t\t\t\t\t\t\t\t\t\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Apply substitution to get the return type\n\t\tconst returnType = substitute(funcType.return, currentState.substitution);\n\n\t\t// Validate constraints on the return type\n\t\tcurrentState = validateConstraints(returnType, currentState, {\n\t\t\tline: expr.location?.start.line || 1,\n\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t});\n\n\t\t// Phase 3: Add effect validation for function calls\n\t\t// Add function's effects to the collected effects\n\t\tallEffects = unionEffects(allEffects, funcType.effects);\n\n\t\tif (argTypes.length === funcType.params.length) {\n\t\t\t// Full application - return the return type\n\n\t\t\t// CRITICAL FIX: Handle function composition constraint propagation\n\t\t\tlet finalReturnType = returnType;\n\n\t\t\t// Case 1: Direct compose function call\n\t\t\tif (\n\t\t\t\texpr.func.kind === 'variable' &&\n\t\t\t\texpr.func.name === 'compose' &&\n\t\t\t\texpr.args.length >= 1\n\t\t\t) {\n\t\t\t\tconst fArg = expr.args[0]; // First function (f in \"compose f g\")\n\t\t\t\tconst fResult = typeExpression(fArg, currentState);\n\n\t\t\t\t// If f has constraints and returnType is a function, propagate the constraints\n\t\t\t\tif (\n\t\t\t\t\tfResult.type.kind === 'function' &&\n\t\t\t\t\tfResult.type.constraints &&\n\t\t\t\t\treturnType.kind === 'function'\n\t\t\t\t) {\n\t\t\t\t\tconst enhancedReturnType = { ...returnType };\n\n\t\t\t\t\t// Map constraint variables from f's type to the new function's type variables\n\t\t\t\t\tconst updatedConstraints: Constraint[] = [];\n\t\t\t\t\tfor (const constraint of fResult.type.constraints) {\n\t\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t\t// Find the corresponding parameter in the new function\n\t\t\t\t\t\t\t// The first parameter of the composed function should inherit f's parameter constraints\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tenhancedReturnType.params.length > 0 &&\n\t\t\t\t\t\t\t\tenhancedReturnType.params[0].kind === 'variable'\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst newConstraint = isConstraint(\n\t\t\t\t\t\t\t\t\tenhancedReturnType.params[0].name,\n\t\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tupdatedConstraints.push(newConstraint);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For non-\"is\" constraints, copy as-is for now\n\t\t\t\t\t\t\tupdatedConstraints.push(constraint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tenhancedReturnType.constraints = (\n\t\t\t\t\t\tenhancedReturnType.constraints || []\n\t\t\t\t\t).concat(updatedConstraints);\n\n\t\t\t\t\t// Also propagate constraints to parameter type variables in the result function\n\t\t\t\t\tfor (const constraint of updatedConstraints) {\n\t\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t\tpropagateConstraintToTypeVariable(enhancedReturnType, constraint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfinalReturnType = enhancedReturnType;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Case 2: Application to result of compose (e.g., (compose head) id)\n\t\t\telse if (\n\t\t\t\texpr.func.kind === 'application' &&\n\t\t\t\texpr.func.func.kind === 'variable' &&\n\t\t\t\texpr.func.func.name === 'compose' &&\n\t\t\t\texpr.func.args.length >= 1\n\t\t\t) {\n\t\t\t\t// This is applying the second argument to a partial compose result\n\t\t\t\tconst fArg = expr.func.args[0]; // First function from the compose\n\t\t\t\tconst fResult = typeExpression(fArg, currentState);\n\n\t\t\t\tif (\n\t\t\t\t\tfResult.type.kind === 'function' &&\n\t\t\t\t\tfResult.type.constraints &&\n\t\t\t\t\treturnType.kind === 'function'\n\t\t\t\t) {\n\t\t\t\t\tconst enhancedReturnType = { ...returnType };\n\n\t\t\t\t\t// Map constraint variables from f's type to the new function's type variables\n\t\t\t\t\tconst updatedConstraints: Constraint[] = [];\n\t\t\t\t\tfor (const constraint of fResult.type.constraints) {\n\t\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t\t// Find the corresponding parameter in the new function\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tenhancedReturnType.params.length > 0 &&\n\t\t\t\t\t\t\t\tenhancedReturnType.params[0].kind === 'variable'\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst newConstraint = isConstraint(\n\t\t\t\t\t\t\t\t\tenhancedReturnType.params[0].name,\n\t\t\t\t\t\t\t\t\tconstraint.constraint\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tupdatedConstraints.push(newConstraint);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdatedConstraints.push(constraint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tenhancedReturnType.constraints = (\n\t\t\t\t\t\tenhancedReturnType.constraints || []\n\t\t\t\t\t).concat(updatedConstraints);\n\n\t\t\t\t\tfor (const constraint of updatedConstraints) {\n\t\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t\tpropagateConstraintToTypeVariable(enhancedReturnType, constraint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfinalReturnType = enhancedReturnType;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn createTypeResult(finalReturnType, allEffects, currentState);\n\t\t} else {\n\t\t\t// Partial application - return a function with remaining parameters\n\t\t\tconst remainingParams = funcType.params.slice(argTypes.length);\n\t\t\tconst partialFunctionType = functionType(remainingParams, returnType, funcType.effects);\n\n\t\t\t// CRITICAL FIX: Handle partial application of compose\n\t\t\tif (\n\t\t\t\texpr.func.kind === 'variable' &&\n\t\t\t\texpr.func.name === 'compose' &&\n\t\t\t\texpr.args.length >= 1\n\t\t\t) {\n\t\t\t\tconst fArg = expr.args[0]; // First function\n\t\t\t\tconst fResult = typeExpression(fArg, currentState);\n\n\t\t\t\t// If f has constraints, the partial result should eventually inherit them\n\t\t\t\tif (\n\t\t\t\t\tfResult.type.kind === 'function' &&\n\t\t\t\t\tfResult.type.constraints &&\n\t\t\t\t\tpartialFunctionType.kind === 'function'\n\t\t\t\t) {\n\t\t\t\t\tpartialFunctionType.constraints = (\n\t\t\t\t\t\tpartialFunctionType.constraints || []\n\t\t\t\t\t).concat(fResult.type.constraints);\n\n\t\t\t\t\tfor (const constraint of fResult.type.constraints) {\n\t\t\t\t\t\tif (constraint.kind === 'is') {\n\t\t\t\t\t\t\tpropagateConstraintToTypeVariable(\n\t\t\t\t\t\t\t\tpartialFunctionType,\n\t\t\t\t\t\t\t\tconstraint\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn createTypeResult(partialFunctionType, allEffects, currentState);\n\t\t}\n\t} else if (funcType.kind === 'variable') {\n\t\t// If it's a type variable, create a function type and unify\n\t\tif (argTypes.length === 0) {\n\t\t\treturn createTypeResult(funcType, allEffects, currentState);\n\t\t}\n\n\t\tconst [paramType, newState] = freshTypeVariable(currentState);\n\t\tcurrentState = newState;\n\t\tconst [returnType, finalState] = freshTypeVariable(currentState);\n\t\tcurrentState = finalState;\n\n\t\tconst freshFunctionType = functionType([paramType], returnType);\n\t\tcurrentState = unify(funcType, freshFunctionType, currentState, {\n\t\t\tline: expr.location?.start.line || 1,\n\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t});\n\t\tcurrentState = unify(paramType, argTypes[0], currentState, {\n\t\t\tline: expr.location?.start.line || 1,\n\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t});\n\n\t\treturn createTypeResult(\n\t\t\tsubstitute(returnType, currentState.substitution),\n\t\t\tallEffects,\n\t\t\tcurrentState\n\t\t);\n\t} else {\n\t\tthrow new Error(\n\t\t\tformatTypeError(\n\t\t\t\tnonFunctionApplicationError(funcType, {\n\t\t\t\t\tline: expr.location?.start.line || 1,\n\t\t\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t\t\t})\n\t\t\t)\n\t\t);\n\t}\n};\n\n// Type inference for pipeline expressions\nexport const typePipeline = (\n\texpr: PipelineExpression,\n\tstate: TypeState\n): TypeResult => {\n\t// Pipeline should be function composition, not function application\n\t// For a pipeline like f |> g |> h, we want to compose them as h(g(f(x)))\n\n\tif (expr.steps.length === 1) {\n\t\treturn typeExpression(expr.steps[0], state);\n\t}\n\n\t// Start with the first function type\n\tlet currentState = state;\n\tlet composedType = typeExpression(expr.steps[0], currentState);\n\tcurrentState = composedType.state;\n\tlet allEffects = composedType.effects;\n\n\t// Compose with each subsequent function type\n\tfor (let i = 1; i < expr.steps.length; i++) {\n\t\tconst nextFuncType = typeExpression(expr.steps[i], currentState);\n\t\tcurrentState = nextFuncType.state;\n\t\tallEffects = unionEffects(allEffects, nextFuncType.effects);\n\n\t\tif (\n\t\t\tcomposedType.type.kind === 'function' &&\n\t\t\tnextFuncType.type.kind === 'function'\n\t\t) {\n\t\t\t// Check that the output of composedType matches the input of nextFuncType\n\t\t\tif (nextFuncType.type.params.length !== 1) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tformatTypeError(\n\t\t\t\t\t\tfunctionApplicationError(\n\t\t\t\t\t\t\tnextFuncType.type.params[0],\n\t\t\t\t\t\t\tnextFuncType.type,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tline: expr.location?.start.line || 1,\n\t\t\t\t\t\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcurrentState = unify(\n\t\t\t\tcomposedType.type.return,\n\t\t\t\tnextFuncType.type.params[0],\n\t\t\t\tcurrentState,\n\t\t\t\t{\n\t\t\t\t\tline: expr.location?.start.line || 1,\n\t\t\t\t\tcolumn: expr.location?.start.column || 1,\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t// The composed function takes the input of the first function and returns the output of the last function\n\t\t\tcomposedType = createTypeResult(\n\t\t\t\tfunctionType(\n\t\t\t\t\t[composedType.type.params[0]],\n\t\t\t\t\tnextFuncType.type.return\n\t\t\t\t),\n\t\t\t\tallEffects,\n\t\t\t\tcurrentState\n\t\t\t);\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot compose non-function types in pipeline: ${typeToString(\n\t\t\t\t\tcomposedType.type\n\t\t\t\t)} and ${typeToString(nextFuncType.type)}`\n\t\t\t);\n\t\t}\n\t}\n\n\treturn createTypeResult(\n\t\tsubstitute(composedType.type, currentState.substitution),\n\t\tallEffects,\n\t\tcurrentState\n\t);\n};"],"version":3}