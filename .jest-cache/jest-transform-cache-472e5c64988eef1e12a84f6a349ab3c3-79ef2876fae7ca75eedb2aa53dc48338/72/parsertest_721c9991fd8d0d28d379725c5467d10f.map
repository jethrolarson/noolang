{"file":"/workspace/src/parser/__tests__/parser.test.ts","mappings":"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","names":[],"sources":["/workspace/src/parser/__tests__/parser.test.ts"],"sourcesContent":["import { Lexer } from \"../../lexer\";\nimport { parse, parseTypeExpression } from \"../parser\";\nimport type {\n\tExpression,\n\tLiteralExpression,\n\tVariableExpression,\n\tFunctionExpression,\n\tApplicationExpression,\n\tBinaryExpression,\n\tIfExpression,\n\tRecordExpression,\n\tAccessorExpression,\n\tType,\n\tRecordType,\n\tTupleType,\n\tListType,\n\tFunctionType,\n\tVariableType,\n\tDefinitionExpression,\n\tTypedExpression,\n\tMatchExpression,\n\tTypeDefinitionExpression,\n\tWhereExpression,\n\tMutableDefinitionExpression,\n\tMutationExpression,\n\tConstraintDefinitionExpression,\n\tImplementDefinitionExpression,\n\tUnitExpression,\n\tConstrainedExpression,\n} from \"../../ast\";\nimport type { ParseError, ParseResult, ParseSuccess } from \"../combinators\";\n\n// Helper functions for type-safe testing\nfunction assertLiteralExpression(expr: Expression): LiteralExpression {\n\tif (expr.kind !== \"literal\") {\n\t\tthrow new Error(`Expected literal expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertVariableExpression(expr: Expression): VariableExpression {\n\tif (expr.kind !== \"variable\") {\n\t\tthrow new Error(`Expected variable expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertFunctionExpression(expr: Expression): FunctionExpression {\n\tif (expr.kind !== \"function\") {\n\t\tthrow new Error(`Expected function expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertApplicationExpression(expr: Expression): ApplicationExpression {\n\tif (expr.kind !== \"application\") {\n\t\tthrow new Error(`Expected application expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertBinaryExpression(expr: Expression): BinaryExpression {\n\tif (expr.kind !== \"binary\") {\n\t\tthrow new Error(`Expected binary expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertIfExpression(expr: Expression): IfExpression {\n\tif (expr.kind !== \"if\") {\n\t\tthrow new Error(`Expected if expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertRecordExpression(expr: Expression): RecordExpression {\n\tif (expr.kind !== \"record\") {\n\t\tthrow new Error(`Expected record expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertAccessorExpression(expr: Expression): AccessorExpression {\n\tif (expr.kind !== \"accessor\") {\n\t\tthrow new Error(`Expected accessor expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertUnitExpression(expr: Expression): UnitExpression {\n\tif (expr.kind !== \"unit\") {\n\t\tthrow new Error(`Expected unit expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertTypeDefinitionExpression(expr: Expression): TypeDefinitionExpression {\n\tif (expr.kind !== \"type-definition\") {\n\t\tthrow new Error(`Expected type definition expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertWhereExpression(expr: Expression): WhereExpression {\n\tif (expr.kind !== \"where\") {\n\t\tthrow new Error(`Expected where expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertMutableDefinitionExpression(expr: Expression): MutableDefinitionExpression {\n\tif (expr.kind !== \"mutable-definition\") {\n\t\tthrow new Error(`Expected mutable definition expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertMutationExpression(expr: Expression): MutationExpression {\n\tif (expr.kind !== \"mutation\") {\n\t\tthrow new Error(`Expected mutation expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertConstraintDefinitionExpression(expr: Expression): ConstraintDefinitionExpression {\n\tif (expr.kind !== \"constraint-definition\") {\n\t\tthrow new Error(`Expected constraint definition expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertImplementDefinitionExpression(expr: Expression): ImplementDefinitionExpression {\n\tif (expr.kind !== \"implement-definition\") {\n\t\tthrow new Error(`Expected implement definition expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertConstrainedExpression(expr: Expression): ConstrainedExpression {\n\tif (expr.kind !== \"constrained\") {\n\t\tthrow new Error(`Expected constrained expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertRecordType(type: Type): asserts type is RecordType {\n\tif (type.kind !== \"record\") {\n\t\tthrow new Error(`Expected record type, got ${type.kind}`);\n\t}\n}\n\nfunction assertTupleType(type: Type): asserts type is TupleType {\n\tif (type.kind !== \"tuple\") {\n\t\tthrow new Error(`Expected tuple type, got ${type.kind}`);\n\t}\n}\n\nfunction assertListType(type: Type): asserts type is ListType {\n\tif (type.kind !== \"list\") {\n\t\tthrow new Error(`Expected list type, got ${type.kind}`);\n\t}\n}\n\nfunction assertFunctionType(type: Type): asserts type is FunctionType {\n\tif (type.kind !== \"function\") {\n\t\tthrow new Error(`Expected function type, got ${type.kind}`);\n\t}\n}\n\nfunction assertVariableType(type: Type): asserts type is VariableType {\n\tif (type.kind !== \"variable\") {\n\t\tthrow new Error(`Expected variable type, got ${type.kind}`);\n\t}\n}\n\nfunction assertDefinitionExpression(expr: Expression): DefinitionExpression {\n\tif (expr.kind !== \"definition\") {\n\t\tthrow new Error(`Expected definition expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertTypedExpression(expr: Expression): TypedExpression {\n\tif (expr.kind !== \"typed\") {\n\t\tthrow new Error(`Expected typed expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertMatchExpression(expr: Expression): MatchExpression {\n\tif (expr.kind !== \"match\") {\n\t\tthrow new Error(`Expected match expression, got ${expr.kind}`);\n\t}\n\treturn expr;\n}\n\nfunction assertParseSuccess<T>(\n\tresult: ParseResult<T>,\n): asserts result is ParseSuccess<T> {\n\tif (!result.success) {\n\t\tthrow new Error(`Expected parse success, got ${result.error}`);\n\t}\n}\n\nfunction assertParseError<T>(\n\tresult: ParseResult<T>,\n): asserts result is ParseError {\n\tif (result.success) {\n\t\tthrow new Error(\n\t\t\t`Expected parse error, got success: (${JSON.stringify(result)})`,\n\t\t);\n\t}\n}\n\ndescribe(\"Parser\", () => {\n\ttest(\"should parse simple literals\", () => {\n\t\tconst lexer = new Lexer(\"42\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst literal = assertLiteralExpression(program.statements[0]);\n\t\texpect(literal.value).toBe(42);\n\t});\n\n\ttest(\"should parse string literals\", () => {\n\t\tconst lexer = new Lexer('\"hello\"');\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst literal = assertLiteralExpression(program.statements[0]);\n\t\texpect(literal.value).toBe(\"hello\");\n\t});\n\n\ttest(\"should parse boolean literals\", () => {\n\t\tconst lexer = new Lexer(\"True\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"variable\");\n\t\texpect((program.statements[0] as any).name).toBe(\"True\");\n\t});\n\n\ttest(\"should parse variable references\", () => {\n\t\tconst lexer = new Lexer(\"x\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst variable = assertVariableExpression(program.statements[0]);\n\t\texpect(variable.name).toBe(\"x\");\n\t});\n\n\ttest(\"should parse function definitions\", () => {\n\t\tconst lexer = new Lexer(\"fn x => x + 1\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst func = assertFunctionExpression(program.statements[0]);\n\t\texpect(func.params).toEqual([\"x\"]);\n\t\texpect(func.body.kind).toBe(\"binary\");\n\t});\n\n\ttest(\"should parse function applications\", () => {\n\t\tconst lexer = new Lexer(\"(fn x => x + 1) 2\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst app = assertApplicationExpression(program.statements[0]);\n\t\texpect(app.func.kind).toBe(\"function\");\n\t\texpect(app.args).toHaveLength(1);\n\t\tconst arg = assertLiteralExpression(app.args[0]);\n\t\texpect(arg.value).toBe(2);\n\t});\n\n\ttest(\"should parse binary expressions\", () => {\n\t\tconst lexer = new Lexer(\"2 + 3\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst binary = assertBinaryExpression(program.statements[0]);\n\t\texpect(binary.operator).toBe(\"+\");\n\t});\n\n\ttest(\"should parse lists\", () => {\n\t\tconst lexer = new Lexer(\"[1, 2, 3]\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"list\");\n\t\tconst elements = (program.statements[0] as any).elements;\n\t\texpect(Array.isArray(elements)).toBe(true);\n\t\texpect(elements).toHaveLength(3);\n\t\texpect(elements[0].kind).toBe(\"literal\");\n\t\texpect(elements[0].value).toBe(1);\n\t\texpect(elements[1].kind).toBe(\"literal\");\n\t\texpect(elements[1].value).toBe(2);\n\t\texpect(elements[2].kind).toBe(\"literal\");\n\t\texpect(elements[2].value).toBe(3);\n\t});\n\n\ttest(\"should parse if expressions\", () => {\n\t\tconst lexer = new Lexer(\"if True then 1 else 2\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"if\");\n\t\tconst ifExpr = program.statements[0] as any;\n\t\texpect(ifExpr.condition.name).toBe(\"True\");\n\t\texpect(ifExpr.then.value).toBe(1);\n\t\texpect(ifExpr.else.value).toBe(2);\n\t});\n\n\ttest(\"should parse pipeline expressions\", () => {\n\t\tconst lexer = new Lexer(\"[1, 2, 3] |> map\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst pipeline = program.statements[0] as any;\n\t\texpect(pipeline.kind).toBe(\"pipeline\");\n\t\texpect(pipeline.steps[0].kind).toBe(\"list\");\n\t\texpect(pipeline.steps[1].kind).toBe(\"variable\");\n\t});\n\n\ttest(\"should parse single-field record\", () => {\n\t\tconst lexer = new Lexer('{ @name \"Alice\", @age 30 }');\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"record\");\n\t\tconst record = program.statements[0] as any;\n\t\texpect(record.fields).toHaveLength(2);\n\t\texpect(record.fields[0].name).toBe(\"name\");\n\t\texpect(record.fields[0].value.value).toBe(\"Alice\");\n\t\texpect(record.fields[1].name).toBe(\"age\");\n\t\texpect(record.fields[1].value.value).toBe(30);\n\t});\n\n\ttest(\"should parse multi-field record (semicolon separated)\", () => {\n\t\tconst lexer = new Lexer('{ @name \"Alice\", @age 30 }');\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"record\");\n\t\tconst record = program.statements[0] as any;\n\t\texpect(record.fields).toHaveLength(2);\n\t\texpect(record.fields[0].name).toBe(\"name\");\n\t\texpect(record.fields[0].value.value).toBe(\"Alice\");\n\t\texpect(record.fields[1].name).toBe(\"age\");\n\t\texpect(record.fields[1].value.value).toBe(30);\n\t});\n\n\ttest(\"should parse multi-field record (semicolon separated)\", () => {\n\t\tconst lexer = new Lexer('{ @name \"Alice\", @age 30 }');\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"record\");\n\t\tconst record = program.statements[0] as any;\n\t\texpect(record.fields).toHaveLength(2);\n\t\texpect(record.fields[0].name).toBe(\"name\");\n\t\texpect(record.fields[0].value.value).toBe(\"Alice\");\n\t\texpect(record.fields[1].name).toBe(\"age\");\n\t\texpect(record.fields[1].value.value).toBe(30);\n\t});\n\n\ttest(\"should parse accessor\", () => {\n\t\tconst lexer = new Lexer(\"@name\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"accessor\");\n\t\tconst accessor = program.statements[0] as any;\n\t\texpect(accessor.field).toBe(\"name\");\n\t});\n\n\ttest(\"should parse function with unit parameter\", () => {\n\t\tconst lexer = new Lexer(\"fn {} => 42\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst func = assertFunctionExpression(program.statements[0]);\n\t\texpect(func.params).toEqual([\"_unit\"]); // Unit parameter\n\t\texpect(func.body.kind).toBe(\"literal\");\n\t\texpect((func.body as LiteralExpression).value).toBe(42);\n\t});\n\n\ttest(\"should parse deeply nested tuples in records\", () => {\n\t\tconst lexer = new Lexer(\"{ @key [1, {{{1}}}] }\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\t// Check the outermost record\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst outer = program.statements[0];\n\t\texpect(outer.kind).toBe(\"record\");\n\t\tconst keyField = (outer as any).fields[0];\n\t\texpect(keyField.name).toBe(\"key\");\n\t\t// Check that keyField.value is a list with two elements\n\t\texpect(keyField.value.kind).toBe(\"list\");\n\t\texpect(keyField.value.elements).toHaveLength(2);\n\t\t// First element should be a literal\n\t\texpect(keyField.value.elements[0].kind).toBe(\"literal\");\n\t\texpect(keyField.value.elements[0].value).toBe(1);\n\t\t// Second element should be a nested tuple structure\n\t\tlet nestedTuple = keyField.value.elements[1];\n\t\texpect(nestedTuple.kind).toBe(\"tuple\");\n\t\t// Check the nested structure: tuple -> tuple -> tuple -> literal\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\texpect(nestedTuple.kind).toBe(\"tuple\");\n\t\t\texpect(nestedTuple.elements).toHaveLength(1);\n\t\t\tnestedTuple = nestedTuple.elements[0];\n\t\t}\n\t\texpect(nestedTuple.kind).toBe(\"literal\");\n\t\texpect(nestedTuple.value).toBe(1);\n\t});\n\n\ttest(\"should parse records with nested lists and records\", () => {\n\t\tconst lexer = new Lexer(\"{ @key [1, { @inner [2, 3] }] }\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst outer = program.statements[0];\n\t\texpect(outer.kind).toBe(\"record\");\n\t\tconst keyField = (outer as any).fields[0];\n\t\texpect(keyField.name).toBe(\"key\");\n\t\tconst list = keyField.value as any;\n\t\texpect(list.kind).toBe(\"list\");\n\t\texpect(list.elements[0].kind).toBe(\"literal\");\n\t\texpect(list.elements[0].value).toBe(1);\n\t\tconst nestedRecord = list.elements[1];\n\t\texpect(nestedRecord.kind).toBe(\"record\");\n\t\tconst innerField = nestedRecord.fields[0];\n\t\texpect(innerField.name).toBe(\"inner\");\n\t\tconst innerList = innerField.value as any;\n\t\texpect(innerList.kind).toBe(\"list\");\n\t\texpect(innerList.elements.map((e: any) => e.value)).toEqual([2, 3]);\n\t});\n\n\ttest(\"should parse lists of records\", () => {\n\t\tconst lexer = new Lexer(\"[{ @a 1 }, { @b 2 }]\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst list = program.statements[0] as any;\n\t\texpect(list.kind).toBe(\"list\");\n\t\texpect(list.elements[0].kind).toBe(\"record\");\n\t\texpect(list.elements[1].kind).toBe(\"record\");\n\t\texpect(list.elements[0].fields[0].name).toBe(\"a\");\n\t\texpect(list.elements[0].fields[0].value.value).toBe(1);\n\t\texpect(list.elements[1].fields[0].name).toBe(\"b\");\n\t\texpect(list.elements[1].fields[0].value.value).toBe(2);\n\t});\n\n\ttest(\"should parse a single tuple\", () => {\n\t\tconst lexer = new Lexer(\"{1}\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst tuple = program.statements[0] as any;\n\t\texpect(tuple.kind).toBe(\"tuple\");\n\t\texpect(tuple.elements[0].kind).toBe(\"literal\");\n\t\texpect(tuple.elements[0].value).toBe(1);\n\t});\n\n\ttest(\"should parse a single record\", () => {\n\t\tconst lexer = new Lexer(\"{ @foo 1 }\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst record = program.statements[0] as any;\n\t\texpect(record.kind).toBe(\"record\");\n\t\texpect(record.fields[0].name).toBe(\"foo\");\n\t\texpect(record.fields[0].value.value).toBe(1);\n\t});\n\n\ttest(\"should parse a list of literals\", () => {\n\t\tconst lexer = new Lexer(\"[1, 2]\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst list = program.statements[0] as any;\n\t\texpect(list.kind).toBe(\"list\");\n\t\texpect(list.elements[0].kind).toBe(\"literal\");\n\t\texpect(list.elements[0].value).toBe(1);\n\t\texpect(list.elements[1].kind).toBe(\"literal\");\n\t\texpect(list.elements[1].value).toBe(2);\n\t});\n\n\ttest(\"should parse a list of tuples\", () => {\n\t\tconst lexer = new Lexer(\"[{1}, {2}]\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst list = program.statements[0] as any;\n\t\texpect(list.kind).toBe(\"list\");\n\t\texpect(list.elements[0].kind).toBe(\"tuple\");\n\t\texpect(list.elements[0].elements[0].value).toBe(1);\n\t\texpect(list.elements[1].kind).toBe(\"tuple\");\n\t\texpect(list.elements[1].elements[0].value).toBe(2);\n\t});\n\n\ttest(\"should parse a list of records\", () => {\n\t\tconst lexer = new Lexer(\"[{ @foo 1 }, { @bar 2 }]\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst list = program.statements[0] as any;\n\t\texpect(list.kind).toBe(\"list\");\n\t\texpect(list.elements[0].kind).toBe(\"record\");\n\t\texpect(list.elements[0].fields[0].name).toBe(\"foo\");\n\t\texpect(list.elements[0].fields[0].value.value).toBe(1);\n\t\texpect(list.elements[1].kind).toBe(\"record\");\n\t\texpect(list.elements[1].fields[0].name).toBe(\"bar\");\n\t\texpect(list.elements[1].fields[0].value.value).toBe(2);\n\t});\n\n\ttest(\"should parse thrush operator\", () => {\n\t\tconst lexer = new Lexer(\"10 | (fn x => x + 1)\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst thrush = program.statements[0] as any;\n\t\texpect(thrush.kind).toBe(\"binary\");\n\t\texpect(thrush.operator).toBe(\"|\");\n\t\texpect(thrush.left.kind).toBe(\"literal\");\n\t\texpect(thrush.right.kind).toBe(\"function\");\n\t});\n\n\ttest(\"should parse chained thrush operators as left-associative\", () => {\n\t\tconst lexer = new Lexer(\"a | b | c\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst chain = program.statements[0] as any;\n\t\texpect(chain.kind).toBe(\"binary\");\n\t\texpect(chain.operator).toBe(\"|\");\n\t\texpect(chain.left.kind).toBe(\"binary\");\n\t\texpect(chain.left.operator).toBe(\"|\");\n\t\texpect(chain.left.left.kind).toBe(\"variable\");\n\t\texpect(chain.left.left.name).toBe(\"a\");\n\t\texpect(chain.left.right.kind).toBe(\"variable\");\n\t\texpect(chain.left.right.name).toBe(\"b\");\n\t\texpect(chain.right.kind).toBe(\"variable\");\n\t\texpect(chain.right.name).toBe(\"c\");\n\t});\n\n\ttest(\"should parse thrush operator after record\", () => {\n\t\tconst lexer = new Lexer(\"{@key 1, @key2 False} | @key\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\n\t\t// Verify it's a binary expression with thrush operator\n\t\tconst expr = program.statements[0] as BinaryExpression;\n\t\texpect(expr.kind).toBe(\"binary\");\n\t\texpect(expr.operator).toBe(\"|\");\n\t\texpect(expr.left.kind).toBe(\"record\");\n\t\texpect(expr.right.kind).toBe(\"accessor\");\n\t});\n\n\t// Add tests for empty unit expression\n\ttest(\"should parse empty braces as unit\", () => {\n\t\tconst lexer = new Lexer(\"{}\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst unit = assertUnitExpression(program.statements[0]);\n\t\texpect(unit.kind).toBe(\"unit\");\n\t});\n\n\t// Add tests for function with empty parentheses\n\ttest(\"should parse function with empty parentheses\", () => {\n\t\tconst lexer = new Lexer(\"fn () => 42\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst func = assertFunctionExpression(program.statements[0]);\n\t\texpect(func.params).toEqual([]);\n\t\texpect(func.body.kind).toBe(\"literal\");\n\t});\n\n\t// Add tests for function with multiple parameters\n\ttest(\"should parse function with multiple parameters\", () => {\n\t\tconst lexer = new Lexer(\"fn x y z => x + y + z\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst func = assertFunctionExpression(program.statements[0]);\n\t\texpect(func.params).toEqual([\"x\", \"y\", \"z\"]);\n\t\texpect(func.body.kind).toBe(\"binary\");\n\t});\n\n\t// Add tests for empty lists\n\ttest(\"should parse empty list\", () => {\n\t\tconst lexer = new Lexer(\"[]\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"list\");\n\t\tconst list = program.statements[0] as any;\n\t\texpect(list.elements).toHaveLength(0);\n\t});\n\n\t// Add tests for lists with trailing commas\n\ttest(\"should parse list with trailing comma\", () => {\n\t\tconst lexer = new Lexer(\"[1, 2, 3,]\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"list\");\n\t\tconst list = program.statements[0] as any;\n\t\texpect(list.elements).toHaveLength(3);\n\t});\n\n\t// Add tests for records with trailing commas\n\ttest(\"should parse record with trailing comma\", () => {\n\t\tconst lexer = new Lexer(\"{ @name \\\"Alice\\\", @age 30, }\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"record\");\n\t\tconst record = program.statements[0] as any;\n\t\texpect(record.fields).toHaveLength(2);\n\t});\n\n\t// Add tests for unary minus (adjacent)\n\ttest(\"should parse unary minus (adjacent)\", () => {\n\t\tconst lexer = new Lexer(\"-42\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"binary\");\n\t\tconst binary = program.statements[0] as any;\n\t\texpect(binary.operator).toBe(\"*\");\n\t\texpect(binary.left.kind).toBe(\"literal\");\n\t\texpect(binary.left.value).toBe(-1);\n\t\texpect(binary.right.kind).toBe(\"literal\");\n\t\texpect(binary.right.value).toBe(42);\n\t});\n\n\t// Add tests for minus operator (non-adjacent)\n\ttest(\"should parse minus operator (non-adjacent)\", () => {\n\t\tconst lexer = new Lexer(\"10 - 5\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"binary\");\n\t\tconst binary = program.statements[0] as any;\n\t\texpect(binary.operator).toBe(\"-\");\n\t\texpect(binary.left.kind).toBe(\"literal\");\n\t\texpect(binary.left.value).toBe(10);\n\t\texpect(binary.right.kind).toBe(\"literal\");\n\t\texpect(binary.right.value).toBe(5);\n\t});\n});\n\n// Add new test suite for Type Definitions (ADTs)\ndescribe(\"Type Definitions (ADTs)\", () => {\n\ttest(\"should parse simple type definition\", () => {\n\t\tconst lexer = new Lexer(\"type Bool = True | False\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst typeDef = assertTypeDefinitionExpression(program.statements[0]);\n\t\texpect(typeDef.name).toBe(\"Bool\");\n\t\texpect(typeDef.typeParams).toEqual([]);\n\t\texpect(typeDef.constructors).toHaveLength(2);\n\t\texpect(typeDef.constructors[0].name).toBe(\"True\");\n\t\texpect(typeDef.constructors[0].args).toEqual([]);\n\t\texpect(typeDef.constructors[1].name).toBe(\"False\");\n\t\texpect(typeDef.constructors[1].args).toEqual([]);\n\t});\n\n\ttest(\"should parse type definition with parameters\", () => {\n\t\tconst lexer = new Lexer(\"type Option a = None | Some a\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst typeDef = assertTypeDefinitionExpression(program.statements[0]);\n\t\texpect(typeDef.name).toBe(\"Option\");\n\t\texpect(typeDef.typeParams).toEqual([\"a\"]);\n\t\texpect(typeDef.constructors).toHaveLength(2);\n\t\texpect(typeDef.constructors[0].name).toBe(\"None\");\n\t\texpect(typeDef.constructors[0].args).toEqual([]);\n\t\texpect(typeDef.constructors[1].name).toBe(\"Some\");\n\t\texpect(typeDef.constructors[1].args).toHaveLength(1);\n\t});\n\n\ttest(\"should parse type definition with complex constructors\", () => {\n\t\tconst lexer = new Lexer(\"type Either a b = Left a | Right b\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst typeDef = assertTypeDefinitionExpression(program.statements[0]);\n\t\texpect(typeDef.name).toBe(\"Either\");\n\t\texpect(typeDef.typeParams).toEqual([\"a\", \"b\"]);\n\t\texpect(typeDef.constructors).toHaveLength(2);\n\t\texpect(typeDef.constructors[0].name).toBe(\"Left\");\n\t\texpect(typeDef.constructors[1].name).toBe(\"Right\");\n\t});\n\n\ttest(\"should parse type definition with multiple constructor arguments\", () => {\n\t\tconst lexer = new Lexer(\"type Person = Person String Number\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst typeDef = assertTypeDefinitionExpression(program.statements[0]);\n\t\texpect(typeDef.name).toBe(\"Person\");\n\t\texpect(typeDef.constructors).toHaveLength(1);\n\t\texpect(typeDef.constructors[0].name).toBe(\"Person\");\n\t\texpect(typeDef.constructors[0].args).toHaveLength(2);\n\t});\n});\n\n// Add new test suite for Pattern Matching\ndescribe(\"Pattern Matching\", () => {\n\ttest(\"should parse simple match expression\", () => {\n\t\tconst lexer = new Lexer(\"match x with ( True => 1; False => 0 )\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst matchExpr = assertMatchExpression(program.statements[0]);\n\t\texpect(matchExpr.expression.kind).toBe(\"variable\");\n\t\texpect(matchExpr.cases).toHaveLength(2);\n\t\texpect(matchExpr.cases[0].pattern.kind).toBe(\"constructor\");\n\t\texpect((matchExpr.cases[0].pattern as any).name).toBe(\"True\");\n\t\texpect(matchExpr.cases[0].expression.kind).toBe(\"literal\");\n\t\texpect((matchExpr.cases[0].expression as any).value).toBe(1);\n\t});\n\n\ttest(\"should parse match with variable patterns\", () => {\n\t\tconst lexer = new Lexer(\"match x with ( Some y => y; None => 0 )\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst matchExpr = assertMatchExpression(program.statements[0]);\n\t\texpect(matchExpr.cases).toHaveLength(2);\n\t\texpect(matchExpr.cases[0].pattern.kind).toBe(\"constructor\");\n\t\texpect((matchExpr.cases[0].pattern as any).name).toBe(\"Some\");\n\t\texpect((matchExpr.cases[0].pattern as any).args).toHaveLength(1);\n\t\texpect((matchExpr.cases[0].pattern as any).args[0].kind).toBe(\"variable\");\n\t});\n\n\ttest(\"should parse match with wildcard patterns\", () => {\n\t\tconst lexer = new Lexer(\"match x with ( Some _ => 1; _ => 0 )\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst matchExpr = assertMatchExpression(program.statements[0]);\n\t\texpect(matchExpr.cases).toHaveLength(2);\n\t\texpect(matchExpr.cases[0].pattern.kind).toBe(\"constructor\");\n\t\t// Note: _ is parsed as a variable pattern because it's an identifier in the lexer\n\t\texpect(matchExpr.cases[1].pattern.kind).toBe(\"variable\");\n\t\texpect((matchExpr.cases[1].pattern as any).name).toBe(\"_\");\n\t});\n\n\ttest.skip(\"should parse match with literal patterns\", () => {\n\t\t// TODO: This test is skipped due to parser precedence issues with top-level match expressions.\n\t\t// The parser choice ordering causes parseMatchExpression to conflict with other parsers\n\t\t// when parsing at the top level. This needs parser architecture improvements to resolve.\n\t\tconst lexer = new Lexer('match x with ( 1 => \"one\"; \"hello\" => \"world\"; _ => \"other\" )');\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst matchExpr = assertMatchExpression(program.statements[0]);\n\t\texpect(matchExpr.cases).toHaveLength(3);\n\t\texpect(matchExpr.cases[0].pattern.kind).toBe(\"literal\");\n\t\texpect((matchExpr.cases[0].pattern as any).value).toBe(1);\n\t\texpect(matchExpr.cases[1].pattern.kind).toBe(\"literal\");\n\t\texpect((matchExpr.cases[1].pattern as any).value).toBe(\"hello\");\n\t});\n\n\ttest(\"should parse match with nested constructor patterns\", () => {\n\t\tconst lexer = new Lexer(\"match x with ( Wrap (Value n) => n; _ => 0 )\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst matchExpr = assertMatchExpression(program.statements[0]);\n\t\texpect(matchExpr.cases).toHaveLength(2);\n\t\texpect(matchExpr.cases[0].pattern.kind).toBe(\"constructor\");\n\t\texpect((matchExpr.cases[0].pattern as any).name).toBe(\"Wrap\");\n\t\texpect((matchExpr.cases[0].pattern as any).args).toHaveLength(1);\n\t\tconst nestedPattern = (matchExpr.cases[0].pattern as any).args[0];\n\t\texpect(nestedPattern.kind).toBe(\"constructor\");\n\t\texpect(nestedPattern.name).toBe(\"Value\");\n\t});\n});\n\n// Add new test suite for Where Expressions\ndescribe(\"Where Expressions\", () => {\n\ttest(\"should parse where expression with single definition\", () => {\n\t\tconst lexer = new Lexer(\"x + y where ( x = 1 )\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst whereExpr = assertWhereExpression(program.statements[0]);\n\t\texpect(whereExpr.main.kind).toBe(\"binary\");\n\t\texpect(whereExpr.definitions).toHaveLength(1);\n\t\texpect(whereExpr.definitions[0].kind).toBe(\"definition\");\n\t\texpect((whereExpr.definitions[0] as any).name).toBe(\"x\");\n\t});\n\n\ttest(\"should parse where expression with multiple definitions\", () => {\n\t\tconst lexer = new Lexer(\"x + y where ( x = 1; y = 2 )\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst whereExpr = assertWhereExpression(program.statements[0]);\n\t\texpect(whereExpr.definitions).toHaveLength(2);\n\t\texpect((whereExpr.definitions[0] as any).name).toBe(\"x\");\n\t\texpect((whereExpr.definitions[1] as any).name).toBe(\"y\");\n\t});\n\n\ttest(\"should parse where expression with mutable definition\", () => {\n\t\tconst lexer = new Lexer(\"x + y where ( mut x = 1; y = 2 )\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst whereExpr = assertWhereExpression(program.statements[0]);\n\t\texpect(whereExpr.definitions).toHaveLength(2);\n\t\texpect(whereExpr.definitions[0].kind).toBe(\"mutable-definition\");\n\t\texpect(whereExpr.definitions[1].kind).toBe(\"definition\");\n\t});\n});\n\n// Add new test suite for Mutable Definitions and Mutations\ndescribe(\"Mutable Definitions and Mutations\", () => {\n\ttest(\"should parse mutable definition\", () => {\n\t\tconst lexer = new Lexer(\"mut x = 42\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst mutDef = assertMutableDefinitionExpression(program.statements[0]);\n\t\texpect(mutDef.name).toBe(\"x\");\n\t\texpect(mutDef.value.kind).toBe(\"literal\");\n\t\texpect((mutDef.value as any).value).toBe(42);\n\t});\n\n\ttest(\"should parse mutation\", () => {\n\t\tconst lexer = new Lexer(\"mut! x = 100\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst mutation = assertMutationExpression(program.statements[0]);\n\t\texpect(mutation.target).toBe(\"x\");\n\t\texpect(mutation.value.kind).toBe(\"literal\");\n\t\texpect((mutation.value as any).value).toBe(100);\n\t});\n\n\ttest(\"should parse mutable definition with complex expression\", () => {\n\t\tconst lexer = new Lexer(\"mut result = fn x => x * 2\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst mutDef = assertMutableDefinitionExpression(program.statements[0]);\n\t\texpect(mutDef.name).toBe(\"result\");\n\t\texpect(mutDef.value.kind).toBe(\"function\");\n\t});\n});\n\n// Add new test suite for Constraint Definitions and Implementations\ndescribe(\"Constraint Definitions and Implementations\", () => {\n\ttest.skip(\"should parse constraint definition\", () => {\n\t\t// TODO: This test is skipped due to parser precedence issues with top-level constraint definitions.\n\t\t// The parser choice ordering causes parseConstraintDefinition to conflict with other parsers\n\t\t// when parsing at the top level. This needs parser architecture improvements to resolve.\n\t\tconst lexer = new Lexer(\"constraint Monad m ( return a : a -> m a; bind a b : m a -> (a -> m b) -> m b )\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst constraintDef = assertConstraintDefinitionExpression(program.statements[0]);\n\t\texpect(constraintDef.name).toBe(\"Monad\");\n\t\texpect(constraintDef.typeParam).toBe(\"m\");\n\t\texpect(constraintDef.functions).toHaveLength(2);\n\t\texpect(constraintDef.functions[0].name).toBe(\"return\");\n\t\texpect(constraintDef.functions[1].name).toBe(\"bind\");\n\t});\n\n\ttest(\"should parse implement definition\", () => {\n\t\tconst lexer = new Lexer(\"implement Monad Option ( return = Some; bind = fn opt f => match opt with ( Some x => f x; None => None ) )\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst implDef = assertImplementDefinitionExpression(program.statements[0]);\n\t\texpect(implDef.constraintName).toBe(\"Monad\");\n\t\texpect(implDef.typeName).toBe(\"Option\");\n\t\texpect(implDef.implementations).toHaveLength(2);\n\t\texpect(implDef.implementations[0].name).toBe(\"return\");\n\t\texpect(implDef.implementations[1].name).toBe(\"bind\");\n\t});\n\n\ttest(\"should parse constraint with simple functions\", () => {\n\t\tconst lexer = new Lexer(\"constraint Eq a ( eq a : a -> a -> Bool )\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst constraintDef = assertConstraintDefinitionExpression(program.statements[0]);\n\t\texpect(constraintDef.name).toBe(\"Eq\");\n\t\texpect(constraintDef.typeParam).toBe(\"a\");\n\t\texpect(constraintDef.functions).toHaveLength(1);\n\t\texpect(constraintDef.functions[0].name).toBe(\"eq\");\n\t\texpect(constraintDef.functions[0].typeParams).toEqual([\"a\"]);\n\t});\n});\n\n// Add new test suite for Advanced Type Expressions\ndescribe(\"Advanced Type Expressions\", () => {\n\ttest(\"should parse Tuple type constructor\", () => {\n\t\tconst lexer = new Lexer(\"Tuple Int String Bool\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseSuccess(result);\n\t\texpect(result.value.kind).toBe(\"tuple\");\n\t\tconst tupleConstructor = result.value as any;\n\t\texpect(tupleConstructor.elements).toHaveLength(3);\n\t});\n\n\ttest(\"should parse parenthesized type expression\", () => {\n\t\tconst lexer = new Lexer(\"(Int -> String)\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseSuccess(result);\n\t\tassertFunctionType(result.value);\n\t});\n\n\ttest(\"should parse List type with generic parameter\", () => {\n\t\tconst lexer = new Lexer(\"List\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseSuccess(result);\n\t\tassertListType(result.value);\n\t\tconst listType = result.value;\n\t\texpect(listType.element.kind).toBe(\"variable\");\n\t\texpect((listType.element as any).name).toBe(\"a\");\n\t});\n\n\ttest(\"should parse variant type with args\", () => {\n\t\tconst lexer = new Lexer(\"Maybe String\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseSuccess(result);\n\t\texpect(result.value.kind).toBe(\"variant\");\n\t\tconst variantType = result.value as any;\n\t\texpect(variantType.name).toBe(\"Maybe\");\n\t\texpect(variantType.args).toHaveLength(1);\n\t});\n});\n\n// Add new test suite for Constraint Expressions\ndescribe(\"Constraint Expressions\", () => {\n\ttest(\"should parse simple constraint expression\", () => {\n\t\tconst lexer = new Lexer(\"x : Int given a is Eq\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst constrained = assertConstrainedExpression(program.statements[0]);\n\t\texpect(constrained.expression.kind).toBe(\"variable\");\n\t\texpect(constrained.type.kind).toBe(\"primitive\");\n\t\texpect(constrained.constraint.kind).toBe(\"is\");\n\t\texpect((constrained.constraint as any).typeVar).toBe(\"a\");\n\t\texpect((constrained.constraint as any).constraint).toBe(\"Eq\");\n\t});\n\n\ttest(\"should parse constraint with and operator\", () => {\n\t\tconst lexer = new Lexer(\"x : a given a is Eq and a is Ord\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst constrained = assertConstrainedExpression(program.statements[0]);\n\t\texpect(constrained.constraint.kind).toBe(\"and\");\n\t\tconst andConstraint = constrained.constraint as any;\n\t\texpect(andConstraint.left.kind).toBe(\"is\");\n\t\texpect(andConstraint.right.kind).toBe(\"is\");\n\t});\n\n\ttest(\"should parse constraint with or operator\", () => {\n\t\tconst lexer = new Lexer(\"x : a given a is Eq or a is Ord\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst constrained = assertConstrainedExpression(program.statements[0]);\n\t\texpect(constrained.constraint.kind).toBe(\"or\");\n\t});\n\n\ttest.skip(\"should parse constraint with hasField\", () => {\n\t\t// TODO: This test is skipped due to parser precedence issues with top-level constrained expressions.\n\t\t// The parser choice ordering causes constraint parsing to conflict with other parsers\n\t\t// when parsing at the top level. This needs parser architecture improvements to resolve.\n\t\tconst lexer = new Lexer('x : a given a has field \"name\" of type String');\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst constrained = assertConstrainedExpression(program.statements[0]);\n\t\texpect(constrained.constraint.kind).toBe(\"hasField\");\n\t\tconst hasFieldConstraint = constrained.constraint as any;\n\t\texpect(hasFieldConstraint.typeVar).toBe(\"a\");\n\t\texpect(hasFieldConstraint.field).toBe(\"name\");\n\t\texpect(hasFieldConstraint.fieldType.kind).toBe(\"primitive\");\n\t});\n\n\ttest(\"should parse constraint with implements\", () => {\n\t\tconst lexer = new Lexer(\"x : a given a implements Iterable\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst constrained = assertConstrainedExpression(program.statements[0]);\n\t\texpect(constrained.constraint.kind).toBe(\"implements\");\n\t\tconst implementsConstraint = constrained.constraint as any;\n\t\texpect(implementsConstraint.typeVar).toBe(\"a\");\n\t\texpect(implementsConstraint.interfaceName).toBe(\"Iterable\");\n\t});\n\n\ttest(\"should parse parenthesized constraint\", () => {\n\t\tconst lexer = new Lexer(\"x : a given (a is Eq and a is Ord) or a is Show\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst constrained = assertConstrainedExpression(program.statements[0]);\n\t\texpect(constrained.constraint.kind).toBe(\"or\");\n\t\tconst orConstraint = constrained.constraint as any;\n\t\texpect(orConstraint.left.kind).toBe(\"paren\");\n\t\texpect(orConstraint.right.kind).toBe(\"is\");\n\t});\n});\n\n// Add new test suite for Error Conditions\ndescribe(\"Error Conditions\", () => {\n\ttest(\"should throw error for unexpected token after expression\", () => {\n\t\tconst lexer = new Lexer(\"1 + +\"); // Invalid double operator\n\t\tconst tokens = lexer.tokenize();\n\t\texpect(() => parse(tokens)).toThrow(\"Parse error\");\n\t});\n\n\ttest(\"should throw error for parse error with line information\", () => {\n\t\tconst lexer = new Lexer(\"fn ==> 42\"); // invalid double arrow\n\t\tconst tokens = lexer.tokenize();\n\t\texpect(() => parse(tokens)).toThrow(\"Parse error\");\n\t});\n\n\ttest(\"should handle empty input\", () => {\n\t\tconst lexer = new Lexer(\"\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(0);\n\t});\n\n\ttest(\"should handle only semicolons\", () => {\n\t\tconst lexer = new Lexer(\";;;;\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(0);\n\t});\n\n\ttest(\"should handle mixed named and positional fields error\", () => {\n\t\texpect(() => {\n\t\t\tconst lexer = new Lexer(\"{ @name \\\"Alice\\\", 30 }\"); // mixed named and positional\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tparse(tokens);\n\t\t}).toThrow(\"Parse error\");\n\t});\n\n\ttest(\"should handle invalid field after comma in record\", () => {\n\t\texpect(() => {\n\t\t\tconst lexer = new Lexer(\"{ @name \\\"Alice\\\", }\"); // trailing comma with no field\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tparse(tokens);\n\t\t}).not.toThrow(); // should handle trailing comma gracefully\n\t});\n\n\ttest(\"should handle invalid element after comma in list\", () => {\n\t\texpect(() => {\n\t\t\tconst lexer = new Lexer(\"[1, 2, ]\"); // trailing comma with no element\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tparse(tokens);\n\t\t}).not.toThrow(); // should handle trailing comma gracefully\n\t});\n});\n\n// Add new test suite for Operator Precedence\ndescribe(\"Operator Precedence\", () => {\n\ttest(\"should parse operators with correct precedence\", () => {\n\t\tconst lexer = new Lexer(\"a + b * c\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst expr = assertBinaryExpression(program.statements[0]);\n\t\texpect(expr.operator).toBe(\"+\");\n\t\texpect(expr.left.kind).toBe(\"variable\");\n\t\texpect(expr.right.kind).toBe(\"binary\");\n\t\tconst rightExpr = assertBinaryExpression(expr.right);\n\t\texpect(rightExpr.operator).toBe(\"*\");\n\t});\n\n\ttest(\"should parse comparison operators\", () => {\n\t\tconst lexer = new Lexer(\"a < b == c > d\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\t// Due to left associativity, this parses as (((a < b) == c) > d)\n\t\tconst expr = assertBinaryExpression(program.statements[0]);\n\t\texpect(expr.operator).toBe(\">\");\n\t});\n\n\ttest(\"should parse composition operators\", () => {\n\t\tconst lexer = new Lexer(\"f |> g |> h\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst pipeline = program.statements[0] as any;\n\t\texpect(pipeline.kind).toBe(\"pipeline\");\n\t\texpect(pipeline.steps).toHaveLength(3);\n\t});\n\n\ttest(\"should parse dollar operator\", () => {\n\t\tconst lexer = new Lexer(\"f $ g $ h\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst expr = assertBinaryExpression(program.statements[0]);\n\t\texpect(expr.operator).toBe(\"$\");\n\t});\n});\n\ndescribe(\"Top-level sequence parsing\", () => {\n\ttest(\"multiple definitions and final expression\", () => {\n\t\tconst lexer = new Lexer(\"a = 1; b = 2; a + b\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst seq = program.statements[0];\n\t\texpect(seq.kind).toBe(\"binary\"); // semicolon sequence\n\t});\n\n\ttest(\"multiple definitions and final record\", () => {\n\t\tconst code = `\n      add = fn x y => x + y;\n      sub = fn x y => x - y;\n      math = { @add add, @sub sub };\n      math\n    `;\n\t\tconst lexer = new Lexer(code);\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst seq = program.statements[0];\n\t\texpect(seq.kind).toBe(\"binary\");\n\t});\n\n\ttest(\"sequence with trailing semicolon\", () => {\n\t\tconst lexer = new Lexer(\"a = 1; b = 2; a + b;\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst seq = program.statements[0];\n\t\texpect(seq.kind).toBe(\"binary\");\n\t});\n});\n\ndescribe(\"Type annotation parsing\", () => {\n\tfunction parseType(typeSrc: string) {\n\t\tconst lexer = new Lexer(typeSrc);\n\t\tconst tokens = lexer.tokenize();\n\t\treturn parseTypeExpression(tokens);\n\t}\n\n\ttest(\"parses record type annotation\", () => {\n\t\tconst result = parseType(\"{ name: String, age: Number }\");\n\t\tassertParseSuccess(result);\n\t\tassertRecordType(result.value);\n\t\texpect(result.value.kind).toBe(\"record\");\n\t\texpect(result.value.fields).toHaveProperty(\"name\");\n\t\texpect(result.value.fields).toHaveProperty(\"age\");\n\t\texpect(result.value.fields.name.kind).toBe(\"primitive\");\n\t\texpect(result.value.fields.age.kind).toBe(\"primitive\");\n\t});\n\n\ttest(\"parses tuple type annotation\", () => {\n\t\tconst result = parseType(\"{ Number, String }\");\n\t\tassertParseSuccess(result);\n\t\tassertTupleType(result.value);\n\t\texpect(result.value.elements[0].kind).toBe(\"primitive\");\n\t\texpect(result.value.elements[1].kind).toBe(\"primitive\");\n\t});\n\n\ttest(\"parses list type annotation\", () => {\n\t\tconst result = parseType(\"List Number\");\n\t\tassertParseSuccess(result);\n\t\tassertListType(result.value);\n\t\texpect(result.value.element.kind).toBe(\"primitive\");\n\t});\n\n\ttest(\"parses function type annotation\", () => {\n\t\tconst result = parseType(\"Number -> Number\");\n\t\tassertParseSuccess(result);\n\t\tassertFunctionType(result.value);\n\t\tconst funcType = result.value;\n\t\texpect(funcType.params[0].kind).toBe(\"primitive\");\n\t\texpect(funcType.return.kind).toBe(\"primitive\");\n\t});\n\n\ttest(\"parses type variable\", () => {\n\t\tconst result = parseType(\"a\");\n\t\tassertParseSuccess(result);\n\t\tassertVariableType(result.value);\n\t\texpect(result.value.kind).toBe(\"variable\");\n\t\texpect(result.value.name).toBe(\"a\");\n\t});\n\n\t// Add comprehensive tests for type constructor application\n\ttest(\"parses simple type constructor application\", () => {\n\t\tconst result = parseType(\"Option Int\");\n\t\tassertParseSuccess(result);\n\t\texpect(result.value.kind).toBe(\"variant\");\n\t\tconst variantType = result.value as any;\n\t\texpect(variantType.name).toBe(\"Option\");\n\t\texpect(variantType.args).toHaveLength(1);\n\t\texpect(variantType.args[0].kind).toBe(\"primitive\");\n\t\texpect(variantType.args[0].name).toBe(\"Int\");\n\t});\n\n\ttest(\"parses type constructor with type variable\", () => {\n\t\tconst result = parseType(\"Option a\");\n\t\tassertParseSuccess(result);\n\t\texpect(result.value.kind).toBe(\"variant\");\n\t\tconst variantType = result.value as any;\n\t\texpect(variantType.name).toBe(\"Option\");\n\t\texpect(variantType.args).toHaveLength(1);\n\t\texpect(variantType.args[0].kind).toBe(\"variable\");\n\t\texpect(variantType.args[0].name).toBe(\"a\");\n\t});\n\n\ttest(\"parses type constructor with multiple arguments\", () => {\n\t\tconst result = parseType(\"Either String Int\");\n\t\tassertParseSuccess(result);\n\t\texpect(result.value.kind).toBe(\"variant\");\n\t\tconst variantType = result.value as any;\n\t\texpect(variantType.name).toBe(\"Either\");\n\t\texpect(variantType.args).toHaveLength(2);\n\t\texpect(variantType.args[0].kind).toBe(\"primitive\");\n\t\texpect(variantType.args[0].name).toBe(\"String\");\n\t\texpect(variantType.args[1].kind).toBe(\"primitive\");\n\t\texpect(variantType.args[1].name).toBe(\"Int\");\n\t});\n\n\ttest(\"parses type constructor with mixed type arguments\", () => {\n\t\tconst result = parseType(\"Map String a\");\n\t\tassertParseSuccess(result);\n\t\texpect(result.value.kind).toBe(\"variant\");\n\t\tconst variantType = result.value as any;\n\t\texpect(variantType.name).toBe(\"Map\");\n\t\texpect(variantType.args).toHaveLength(2);\n\t\texpect(variantType.args[0].kind).toBe(\"primitive\");\n\t\texpect(variantType.args[0].name).toBe(\"String\");\n\t\texpect(variantType.args[1].kind).toBe(\"variable\");\n\t\texpect(variantType.args[1].name).toBe(\"a\");\n\t});\n\n\ttest(\"parses nested type constructor application\", () => {\n\t\tconst result = parseType(\"Option (Either String Int)\");\n\t\tassertParseSuccess(result);\n\t\texpect(result.value.kind).toBe(\"variant\");\n\t\tconst variantType = result.value as any;\n\t\texpect(variantType.name).toBe(\"Option\");\n\t\texpect(variantType.args).toHaveLength(1);\n\t\texpect(variantType.args[0].kind).toBe(\"variant\");\n\t\texpect(variantType.args[0].name).toBe(\"Either\");\n\t\texpect(variantType.args[0].args).toHaveLength(2);\n\t});\n\n\ttest(\"parses single letter type constructor for constraints\", () => {\n\t\t// While the advanced `m a` syntax isn't currently supported,\n\t\t// we should still be able to parse simple type variables for constraints\n\t\tconst result = parseType(\"m\");\n\t\tassertParseSuccess(result);\n\t\texpect(result.value.kind).toBe(\"variable\");\n\t\tconst varType = result.value as any;\n\t\texpect(varType.name).toBe(\"m\");\n\t\t\n\t\t// TODO: In the future, we should support `m a` syntax:\n\t\t// const advancedResult = parseType(\"m a\");\n\t\t// expect(advancedResult.value.kind).toBe(\"variant\");\n\t\t// expect(advancedResult.value.name).toBe(\"m\");\n\t\t// expect(advancedResult.value.args).toHaveLength(1);\n\t});\n\n\ttest(\"parses type constructor in function type\", () => {\n\t\tconst result = parseType(\"Option a -> Bool\");\n\t\tassertParseSuccess(result);\n\t\texpect(result.value.kind).toBe(\"function\");\n\t\tconst funcType = result.value as any;\n\t\texpect(funcType.params[0].kind).toBe(\"variant\");\n\t\texpect(funcType.params[0].name).toBe(\"Option\");\n\t\texpect(funcType.params[0].args).toHaveLength(1);\n\t\texpect(funcType.return.kind).toBe(\"variant\");\n\t\texpect(funcType.return.name).toBe(\"Bool\");\n\t});\n\n\ttest(\"parses constraint function types\", () => {\n\t\t// Test simple constraint function\n\t\tconst result = parseType(\"a -> a\");\n\t\tassertParseSuccess(result);\n\t\texpect(result.value.kind).toBe(\"function\");\n\t\tconst funcType = result.value as any;\n\t\texpect(funcType.params[0].kind).toBe(\"variable\");\n\t\texpect(funcType.params[0].name).toBe(\"a\");\n\t\texpect(funcType.return.kind).toBe(\"variable\");\n\t\texpect(funcType.return.name).toBe(\"a\");\n\t\t\n\t\t// TODO: In the future, we should support more complex constraint functions:\n\t\t// const complexResult = parseType(\"m a -> (a -> m b) -> m b\");\n\t\t// expect(complexResult.value.kind).toBe(\"function\");\n\t\t// This would be the monadic bind signature\n\t});\n\n\ttest(\"parses nested record type\", () => {\n\t\tconst result = parseType(\n\t\t\t\"{ person: { name: String, age: Number }, active: Bool }\",\n\t\t);\n\t\tassertParseSuccess(result);\n\t\tassertRecordType(result.value);\n\t\texpect(result.value.fields).toHaveProperty(\"person\");\n\t\texpect(result.value.fields).toHaveProperty(\"active\");\n\t\texpect(result.value.fields.person.kind).toBe(\"record\");\n\t\texpect(result.value.fields.active.kind).toBe(\"variant\");\n\t});\n});\n\ndescribe(\"Top-level definitions with type annotations\", () => {\n\tfunction parseDefinition(defSrc: string) {\n\t\tconst lexer = new Lexer(defSrc);\n\t\tconst tokens = lexer.tokenize();\n\t\treturn parse(tokens);\n\t}\n\n\ttest(\"parses definition with function type annotation\", () => {\n\t\tconst result = parseDefinition(\n\t\t\t\"add = fn x y => x + y : Number -> Number -> Number;\",\n\t\t);\n\t\texpect(result.statements).toHaveLength(1);\n\t\texpect(result.statements[0].kind).toBe(\"definition\");\n\t\tconst def = assertDefinitionExpression(result.statements[0]);\n\t\texpect(def.name).toBe(\"add\");\n\t\texpect(def.value.kind).toBe(\"function\");\n\t\t// Function expressions with type annotations may not wrap in \"typed\" nodes\n\t\t// The type information might be stored directly on the function\n\t});\n\n\ttest(\"parses definition with primitive type annotation\", () => {\n\t\tconst result = parseDefinition(\"answer = 42 : Number;\");\n\t\texpect(result.statements).toHaveLength(1);\n\t\texpect(result.statements[0].kind).toBe(\"definition\");\n\t\tconst def = assertDefinitionExpression(result.statements[0]);\n\t\texpect(def.name).toBe(\"answer\");\n\t\tconst typed = assertTypedExpression(def.value);\n\t\texpect(typed.expression.kind).toBe(\"literal\");\n\t\texpect(typed.type.kind).toBe(\"primitive\");\n\t});\n\n\ttest(\"parses definition with list type annotation\", () => {\n\t\tconst result = parseDefinition(\"numbers = [1, 2, 3] : List Number;\");\n\t\texpect(result.statements).toHaveLength(1);\n\t\tconst def = assertDefinitionExpression(result.statements[0]);\n\t\texpect(def.name).toBe(\"numbers\");\n\t\tconst typed = assertTypedExpression(def.value);\n\t\texpect(typed.expression.kind).toBe(\"list\");\n\t\texpect(typed.type.kind).toBe(\"list\"); // List types have kind \"list\"\n\t\texpect((typed.type as any).element.kind).toBe(\"primitive\"); // Number is a primitive type  \n\t\texpect((typed.type as any).element.name).toBe(\"Int\"); // Number maps to Int internally\n\t});\n\n\ttest(\"parses multiple definitions with type annotations\", () => {\n\t\tconst result = parseDefinition(`\n      add = fn x y => x + y : Number -> Number -> Number;\n      answer = 42 : Number;\n      numbers = [1, 2, 3] : List Number;\n    `);\n\t\texpect(result.statements).toHaveLength(1);\n\t\tconst seq = assertBinaryExpression(result.statements[0]);\n\t\texpect(seq.kind).toBe(\"binary\"); // semicolon sequence\n\t\texpect(seq.operator).toBe(\";\");\n\t});\n\n\t// Phase 1: Effect parsing tests\n\tdescribe(\"Effect parsing\", () => {\n\t\ttest(\"should parse function type with single effect\", () => {\n\t\t\tconst lexer = new Lexer(\"Int -> Int !write\");\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tconst result = parseTypeExpression(tokens);\n\t\t\t\n\t\t\tassertParseSuccess(result);\n\t\t\tassertFunctionType(result.value);\n\t\tconst funcType = result.value;\n\t\t\texpect([...funcType.effects]).toEqual([\"write\"]);\n\t\t\texpect(funcType.params).toHaveLength(1);\n\t\t\texpect(funcType.params[0].kind).toBe(\"primitive\");\n\t\t\texpect(funcType.return.kind).toBe(\"primitive\");\n\t\t});\n\n\t\ttest(\"should parse function type with multiple effects\", () => {\n\t\t\tconst lexer = new Lexer(\"Int -> String !write !log\");\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tconst result = parseTypeExpression(tokens);\n\t\t\t\n\t\t\tassertParseSuccess(result);\n\t\t\tassertFunctionType(result.value);\n\t\tconst funcType = result.value;\n\t\t\texpect([...funcType.effects].sort()).toEqual([\"log\", \"write\"]);\n\t\t});\n\n\t\ttest(\"should parse function type with all valid effects\", () => {\n\t\t\tconst lexer = new Lexer(\"Int -> Int !log !read !write !state !time !rand !ffi !async\");\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tconst result = parseTypeExpression(tokens);\n\t\t\t\n\t\t\tassertParseSuccess(result);\n\t\t\tassertFunctionType(result.value);\n\t\tconst funcType = result.value;\n\t\t\texpect([...funcType.effects].sort()).toEqual([\"async\", \"ffi\", \"log\", \"rand\", \"read\", \"state\", \"time\", \"write\"]);\n\t\t});\n\n\t\ttest(\"should parse function type with no effects\", () => {\n\t\t\tconst lexer = new Lexer(\"Int -> Int\");\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tconst result = parseTypeExpression(tokens);\n\t\t\t\n\t\t\tassertParseSuccess(result);\n\t\t\tassertFunctionType(result.value);\n\t\tconst funcType = result.value;\n\t\t\texpect([...funcType.effects]).toEqual([]);\n\t\t});\n\n\t\ttest(\"should parse multi-parameter function with effects\", () => {\n\t\t\tconst lexer = new Lexer(\"Int -> String -> Bool !read\");\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tconst result = parseTypeExpression(tokens);\n\t\t\t\n\t\t\tassertParseSuccess(result);\n\t\t\tassertFunctionType(result.value);\n\t\tconst funcType = result.value;\n\t\t\texpect([...funcType.effects]).toEqual([\"read\"]);\n\t\t\texpect(funcType.params).toHaveLength(1);\n\t\t\texpect(funcType.return.kind).toBe(\"function\");\n\t\t});\n\n\t\ttest(\"should reject invalid effect names\", () => {\n\t\t\tconst lexer = new Lexer(\"Int -> Int !invalid\");\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tconst result = parseTypeExpression(tokens);\n\t\t\t\n\t\t\tassertParseError(result);\n\t\t\texpect(result.error).toContain(\"Invalid effect: invalid\");\n\t\t});\n\n\t\ttest(\"should require effect name after exclamation mark\", () => {\n\t\t\tconst lexer = new Lexer(\"Int -> Int !\");\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tconst result = parseTypeExpression(tokens);\n\t\t\t\n\t\t\tassertParseError(result);\n\t\t\texpect(result.error).toContain(\"Expected effect name after !\");\n\t\t});\n\n\t\ttest(\"should parse typed expression with effects\", () => {\n\t\t\tconst result = parseDefinition(\"x : Int -> Int !state\");\n\t\t\texpect(result.statements).toHaveLength(1);\n\t\t\tconst typed = assertTypedExpression(result.statements[0]);\n\t\t\tassertFunctionType(typed.type);\n\t\tconst funcType = typed.type;\n\t\t\texpect([...funcType.effects]).toEqual([\"state\"]);\n\t\t});\n\n\t\ttest(\"should parse function definition with effect annotation\", () => {\n\t\t\tconst result = parseDefinition(\"fn x => x : Int -> Int !log\");\n\t\t\texpect(result.statements).toHaveLength(1);\n\t\t\tconst func = assertFunctionExpression(result.statements[0]);\n\t\t\tconst typed = assertTypedExpression(func.body);\n\t\t\tassertFunctionType(typed.type);\n\t\tconst funcType = typed.type;\n\t\t\texpect([...funcType.effects]).toEqual([\"log\"]);\n\t\t});\n\n\t\ttest(\"should automatically deduplicate effects\", () => {\n\t\t\tconst lexer = new Lexer(\"Int -> Int !write !log !write\");\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tconst result = parseTypeExpression(tokens);\n\t\t\t\n\t\t\tassertParseSuccess(result);\n\t\t\tassertFunctionType(result.value);\n\t\tconst funcType = result.value;\n\t\t\t// Set automatically deduplicates, so !write !log !write becomes {log, write}\n\t\t\texpect([...funcType.effects].sort()).toEqual([\"log\", \"write\"]);\n\t\t\texpect(funcType.effects.size).toBe(2);\n\t\t});\n\t});\n});\n\n// Add new test suite for Edge Cases and Error Conditions to improve coverage\ndescribe(\"Edge Cases and Error Conditions\", () => {\n\ttest(\"should handle empty input for type expressions\", () => {\n\t\tconst tokens: any[] = [];\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseError(result);\n\t\texpect(result.error).toContain(\"Expected type expression\");\n\t});\n\n\ttest(\"should handle invalid tokens for type expressions\", () => {\n\t\tconst lexer = new Lexer(\"@invalid\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseError(result);\n\t\texpect(result.error).toContain(\"Expected type expression\");\n\t});\n\n\ttest(\"should parse Unit type correctly\", () => {\n\t\tconst lexer = new Lexer(\"Unit\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseSuccess(result);\n\t\texpect(result.value.kind).toBe(\"unit\");\n\t});\n\n\ttest(\"should parse Number type correctly\", () => {\n\t\tconst lexer = new Lexer(\"Number\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseSuccess(result);\n\t\texpect(result.value.kind).toBe(\"primitive\");\n\t\texpect((result.value as any).name).toBe(\"Int\");\n\t});\n\n\ttest(\"should handle incomplete function type\", () => {\n\t\tconst lexer = new Lexer(\"Int ->\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseError(result);\n\t});\n\n\ttest(\"should handle invalid effect name\", () => {\n\t\tconst lexer = new Lexer(\"Int -> Int !invalideffect\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseError(result);\n\t\texpect(result.error).toContain(\"Invalid effect: invalideffect\");\n\t});\n\n\ttest(\"should handle missing effect name after exclamation\", () => {\n\t\tconst lexer = new Lexer(\"Int -> Int !\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseError(result);\n\t\texpect(result.error).toContain(\"Expected effect name after !\");\n\t});\n\n\ttest(\"should handle generic List type\", () => {\n\t\tconst lexer = new Lexer(\"List\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseSuccess(result);\n\t\tassertListType(result.value);\n\t\texpect(result.value.element.kind).toBe(\"variable\");\n\t\texpect((result.value.element as any).name).toBe(\"a\");\n\t});\n\n\ttest(\"should handle List type with argument\", () => {\n\t\tconst lexer = new Lexer(\"List String\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseSuccess(result);\n\t\tassertListType(result.value);\n\t\texpect(result.value.element.kind).toBe(\"primitive\");\n\t});\n\n\ttest(\"should handle empty record fields\", () => {\n\t\tconst lexer = new Lexer(\"{ }\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst unit = assertUnitExpression(program.statements[0]);\n\t\texpect(unit.kind).toBe(\"unit\");\n\t});\n\n\ttest.skip(\"should handle record field parsing edge cases\", () => {\n\t\t// TODO: This test is skipped because the input \"{ @name @value }\" is actually valid syntax\n\t\t// that parses as a record with positional fields. Need to find a truly invalid syntax\n\t\t// to test error conditions, or adjust the test expectation.\n\t\tconst lexer = new Lexer(\"{ @name @value }\"); // Invalid syntax - two accessors\n\t\tconst tokens = lexer.tokenize();\n\t\texpect(() => parse(tokens)).toThrow(\"Parse error\");\n\t});\n\n\ttest(\"should handle empty list elements\", () => {\n\t\tconst lexer = new Lexer(\"[]\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"list\");\n\t\tconst list = program.statements[0] as any;\n\t\texpect(list.elements).toHaveLength(0);\n\t});\n\n\ttest(\"should handle adjacent minus for unary operator\", () => {\n\t\tconst lexer = new Lexer(\"-123\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"binary\");\n\t\tconst binary = program.statements[0] as any;\n\t\texpect(binary.operator).toBe(\"*\");\n\t\texpect(binary.left.value).toBe(-1);\n\t\texpect(binary.right.value).toBe(123);\n\t});\n\n\ttest(\"should handle non-adjacent minus for binary operator\", () => {\n\t\tconst lexer = new Lexer(\"a - b\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\texpect(program.statements[0].kind).toBe(\"binary\");\n\t\tconst binary = program.statements[0] as any;\n\t\texpect(binary.operator).toBe(\"-\");\n\t});\n\n\ttest(\"should handle function type without effects fallback\", () => {\n\t\tconst lexer = new Lexer(\"String -> Int\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseSuccess(result);\n\t\tassertFunctionType(result.value);\n\t\texpect([...result.value.effects]).toEqual([]);\n\t});\n\n\ttest(\"should handle lowercase type variable\", () => {\n\t\tconst lexer = new Lexer(\"a\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseSuccess(result);\n\t\tassertVariableType(result.value);\n\t\texpect(result.value.name).toBe(\"a\");\n\t});\n\n\ttest(\"should handle record type edge case\", () => {\n\t\tconst lexer = new Lexer(\"{ name: String }\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseSuccess(result);\n\t\tassertRecordType(result.value);\n\t\texpect(result.value.fields).toHaveProperty(\"name\");\n\t});\n\n\ttest(\"should handle tuple type edge case\", () => {\n\t\tconst lexer = new Lexer(\"{ String, Int }\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst result = parseTypeExpression(tokens);\n\t\tassertParseSuccess(result);\n\t\tassertTupleType(result.value);\n\t\texpect(result.value.elements).toHaveLength(2);\n\t});\n\n\ttest.skip(\"should handle debug logging when enabled\", () => {\n\t\t// Set debug environment variable\n\t\tconst originalDebug = process.env.NOO_DEBUG_PARSE;\n\t\tprocess.env.NOO_DEBUG_PARSE = \"1\";\n\t\t\n\t\tconst lexer = new Lexer(\"42\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\t\n\t\t// Restore original environment\n\t\tif (originalDebug) {\n\t\t\tprocess.env.NOO_DEBUG_PARSE = originalDebug;\n\t\t} else {\n\t\t\tdelete process.env.NOO_DEBUG_PARSE;\n\t\t}\n\t});\n\n\ttest(\"should handle unexpected token types in primary parser\", () => {\n\t\t// Create a mock token with an unexpected type\n\t\tconst tokens = [{\n\t\t\ttype: \"COMMENT\" as any,\n\t\t\tvalue: \"# comment\",\n\t\t\tlocation: { start: { line: 1, column: 1 }, end: { line: 1, column: 9 } }\n\t\t}];\n\t\texpect(() => parse(tokens)).toThrow(\"Parse error\");\n\t});\n\n\ttest(\"should handle various punctuation cases\", () => {\n\t\tconst testCases = [\n\t\t\t\"(\",\n\t\t\t\"[\",\n\t\t\t\"{\",\n\t\t];\n\t\t\n\t\tfor (const testCase of testCases) {\n\t\t\tconst lexer = new Lexer(testCase);\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\texpect(() => parse(tokens)).toThrow(\"Parse error\");\n\t\t}\n\t});\n\n\ttest(\"should handle type atom parsing edge cases\", () => {\n\t\t// Test various edge cases that might not be covered\n\t\tconst testCases = [\n\t\t\t\"(Int -> String)\",\n\t\t\t\"Maybe Int\",\n\t\t\t\"Either String Int\",\n\t\t];\n\t\t\n\t\tfor (const testCase of testCases) {\n\t\t\tconst lexer = new Lexer(testCase);\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tconst result = parseTypeExpression(tokens);\n\t\t\tassertParseSuccess(result);\n\t\t}\n\t});\n\n\ttest(\"should handle constraint expression edge cases\", () => {\n\t\tconst lexer = new Lexer(\"x : a given (a is Eq)\");\n\t\tconst tokens = lexer.tokenize();\n\t\tconst program = parse(tokens);\n\t\texpect(program.statements).toHaveLength(1);\n\t\tconst constrained = assertConstrainedExpression(program.statements[0]);\n\t\texpect(constrained.constraint.kind).toBe(\"paren\");\n\t});\n\n\ttest(\"should handle complex parsing edge cases for coverage\", () => {\n\t\t// Test some complex parsing scenarios\n\t\tconst testCases = [\n\t\t\t\"fn x y z => x + y + z\",\n\t\t\t\"(fn x => x) 42\",\n\t\t\t\"[1, 2, 3] |> map |> filter\",\n\t\t\t\"{ @a 1, @b 2, @c 3 }\",\n\t\t\t\"match x with ( Some y => y + 1; None => 0 )\",\n\t\t];\n\n\t\tfor (const testCase of testCases) {\n\t\t\tconst lexer = new Lexer(testCase);\n\t\t\tconst tokens = lexer.tokenize();\n\t\t\tconst program = parse(tokens);\n\t\t\texpect(program.statements).toHaveLength(1);\n\t\t}\n\t});\n});\n"],"version":3}