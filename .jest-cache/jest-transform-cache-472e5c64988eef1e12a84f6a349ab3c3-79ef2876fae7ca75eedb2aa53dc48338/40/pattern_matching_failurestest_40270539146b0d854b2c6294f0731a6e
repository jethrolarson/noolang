714002565fc25833745426526873cdfa
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lexer_1 = require("../src/lexer");
const parser_1 = require("../src/parser/parser");
const typer_1 = require("../src/typer");
const evaluator_1 = require("../src/evaluator");
function unwrapValue(val) {
    if (val === null)
        return null;
    if (typeof val !== "object")
        return val;
    switch (val.tag) {
        case "number":
            return val.value;
        case "string":
            return val.value;
        case "constructor":
            if (val.name === "True")
                return true;
            if (val.name === "False")
                return false;
            return { name: val.name, args: val.args.map(unwrapValue) };
        case "list":
            return val.values.map(unwrapValue);
        case "tuple":
            return val.values.map(unwrapValue);
        case "record": {
            const obj = {};
            for (const k in val.fields)
                obj[k] = unwrapValue(val.fields[k]);
            return obj;
        }
        default:
            return val;
    }
}
describe("Pattern Matching Failure Tests", () => {
    let evaluator;
    beforeEach(() => {
        evaluator = new evaluator_1.Evaluator();
    });
    const runCode = (code) => {
        const lexer = new lexer_1.Lexer(code);
        const tokens = lexer.tokenize();
        const ast = (0, parser_1.parse)(tokens);
        const decoratedResult = (0, typer_1.typeAndDecorate)(ast);
        return evaluator.evaluateProgram(decoratedResult.program);
    };
    test.skip("should handle parametric ADT pattern matching", () => {
        // FIXME: Currently fails with "Pattern expects constructor but got α"
        const code = `
      type Point a = Point a a;
      get_x = fn point => match point with (Point x y => x);
      origin = Point 0 0;
      get_x origin
    `;
        const result = runCode(code);
        expect(unwrapValue(result.finalResult)).toBe(0);
    });
    test.skip("should handle Option pattern matching in functions", () => {
        // FIXME: Currently fails with "Pattern expects constructor but got α"
        const code = `
      handle_option = fn opt => match opt with (
        Some value => value * 2;
        None => 0
      );
      handle_option (Some 21)
    `;
        const result = runCode(code);
        expect(unwrapValue(result.finalResult)).toBe(42);
    });
    test.skip("should handle Result pattern matching", () => {
        // FIXME: Currently fails with "Pattern expects constructor but got α"
        const code = `
      handle_result = fn res => match res with (
        Ok value => value + 10;
        Err msg => 0
      );
      handle_result (Ok 32)
    `;
        const result = runCode(code);
        expect(unwrapValue(result.finalResult)).toBe(42);
    });
    test.skip("should handle complex Shape pattern matching", () => {
        // FIXME: Currently fails with "Pattern expects constructor but got α"
        const code = `
      type Shape = Circle Number | Rectangle Number Number;
      calculate_area = fn shape => match shape with (
        Circle radius => radius * radius * 3;
        Rectangle width height => width * height
      );
      calculate_area (Circle 5)
    `;
        const result = runCode(code);
        expect(unwrapValue(result.finalResult)).toBe(75);
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL3dvcmtzcGFjZS90ZXN0L3BhdHRlcm5fbWF0Y2hpbmdfZmFpbHVyZXMudGVzdC50cyIsIm1hcHBpbmdzIjoiOztBQUFBLHdDQUFxQztBQUNyQyxpREFBNkM7QUFDN0Msd0NBQStDO0FBQy9DLGdEQUFvRDtBQUVwRCxTQUFTLFdBQVcsQ0FBQyxHQUFVO0lBQzdCLElBQUksR0FBRyxLQUFLLElBQUk7UUFBRSxPQUFPLElBQUksQ0FBQztJQUM5QixJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVE7UUFBRSxPQUFPLEdBQUcsQ0FBQztJQUN4QyxRQUFRLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNoQixLQUFLLFFBQVE7WUFDWCxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUM7UUFDbkIsS0FBSyxRQUFRO1lBQ1gsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDO1FBQ25CLEtBQUssYUFBYTtZQUNoQixJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssTUFBTTtnQkFBRSxPQUFPLElBQUksQ0FBQztZQUNyQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssT0FBTztnQkFBRSxPQUFPLEtBQUssQ0FBQztZQUN2QyxPQUFPLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUM7UUFDN0QsS0FBSyxNQUFNO1lBQ1QsT0FBTyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNyQyxLQUFLLE9BQU87WUFDVixPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3JDLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNkLE1BQU0sR0FBRyxHQUFRLEVBQUUsQ0FBQztZQUNwQixLQUFLLE1BQU0sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNO2dCQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2hFLE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQztRQUNEO1lBQ0UsT0FBTyxHQUFHLENBQUM7SUFDZixDQUFDO0FBQ0gsQ0FBQztBQUVELFFBQVEsQ0FBQyxnQ0FBZ0MsRUFBRSxHQUFHLEVBQUU7SUFDOUMsSUFBSSxTQUFvQixDQUFDO0lBRXpCLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDZCxTQUFTLEdBQUcsSUFBSSxxQkFBUyxFQUFFLENBQUM7SUFDOUIsQ0FBQyxDQUFDLENBQUM7SUFFSCxNQUFNLE9BQU8sR0FBRyxDQUFDLElBQVksRUFBRSxFQUFFO1FBQy9CLE1BQU0sS0FBSyxHQUFHLElBQUksYUFBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzlCLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNoQyxNQUFNLEdBQUcsR0FBRyxJQUFBLGNBQUssRUFBQyxNQUFNLENBQUMsQ0FBQztRQUMxQixNQUFNLGVBQWUsR0FBRyxJQUFBLHVCQUFlLEVBQUMsR0FBRyxDQUFDLENBQUM7UUFDN0MsT0FBTyxTQUFTLENBQUMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM1RCxDQUFDLENBQUM7SUFFRixJQUFJLENBQUMsSUFBSSxDQUFDLCtDQUErQyxFQUFFLEdBQUcsRUFBRTtRQUM5RCxzRUFBc0U7UUFDdEUsTUFBTSxJQUFJLEdBQUc7Ozs7O0tBS1osQ0FBQztRQUNGLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QixNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsRCxDQUFDLENBQUMsQ0FBQztJQUVILElBQUksQ0FBQyxJQUFJLENBQUMsb0RBQW9ELEVBQUUsR0FBRyxFQUFFO1FBQ25FLHNFQUFzRTtRQUN0RSxNQUFNLElBQUksR0FBRzs7Ozs7O0tBTVosQ0FBQztRQUNGLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QixNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNuRCxDQUFDLENBQUMsQ0FBQztJQUVILElBQUksQ0FBQyxJQUFJLENBQUMsdUNBQXVDLEVBQUUsR0FBRyxFQUFFO1FBQ3RELHNFQUFzRTtRQUN0RSxNQUFNLElBQUksR0FBRzs7Ozs7O0tBTVosQ0FBQztRQUNGLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QixNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNuRCxDQUFDLENBQUMsQ0FBQztJQUVILElBQUksQ0FBQyxJQUFJLENBQUMsOENBQThDLEVBQUUsR0FBRyxFQUFFO1FBQzdELHNFQUFzRTtRQUN0RSxNQUFNLElBQUksR0FBRzs7Ozs7OztLQU9aLENBQUM7UUFDRixNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDN0IsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDbkQsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvd29ya3NwYWNlL3Rlc3QvcGF0dGVybl9tYXRjaGluZ19mYWlsdXJlcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uL3NyYy9sZXhlclwiO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tIFwiLi4vc3JjL3BhcnNlci9wYXJzZXJcIjtcbmltcG9ydCB7IHR5cGVBbmREZWNvcmF0ZSB9IGZyb20gXCIuLi9zcmMvdHlwZXJcIjtcbmltcG9ydCB7IEV2YWx1YXRvciwgVmFsdWUgfSBmcm9tIFwiLi4vc3JjL2V2YWx1YXRvclwiO1xuXG5mdW5jdGlvbiB1bndyYXBWYWx1ZSh2YWw6IFZhbHVlKTogYW55IHtcbiAgaWYgKHZhbCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIGlmICh0eXBlb2YgdmFsICE9PSBcIm9iamVjdFwiKSByZXR1cm4gdmFsO1xuICBzd2l0Y2ggKHZhbC50YWcpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gdmFsLnZhbHVlO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiB2YWwudmFsdWU7XG4gICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6XG4gICAgICBpZiAodmFsLm5hbWUgPT09IFwiVHJ1ZVwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh2YWwubmFtZSA9PT0gXCJGYWxzZVwiKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4geyBuYW1lOiB2YWwubmFtZSwgYXJnczogdmFsLmFyZ3MubWFwKHVud3JhcFZhbHVlKSB9O1xuICAgIGNhc2UgXCJsaXN0XCI6XG4gICAgICByZXR1cm4gdmFsLnZhbHVlcy5tYXAodW53cmFwVmFsdWUpO1xuICAgIGNhc2UgXCJ0dXBsZVwiOlxuICAgICAgcmV0dXJuIHZhbC52YWx1ZXMubWFwKHVud3JhcFZhbHVlKTtcbiAgICBjYXNlIFwicmVjb3JkXCI6IHtcbiAgICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGsgaW4gdmFsLmZpZWxkcykgb2JqW2tdID0gdW53cmFwVmFsdWUodmFsLmZpZWxkc1trXSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbDtcbiAgfVxufVxuXG5kZXNjcmliZShcIlBhdHRlcm4gTWF0Y2hpbmcgRmFpbHVyZSBUZXN0c1wiLCAoKSA9PiB7XG4gIGxldCBldmFsdWF0b3I6IEV2YWx1YXRvcjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBldmFsdWF0b3IgPSBuZXcgRXZhbHVhdG9yKCk7XG4gIH0pO1xuXG4gIGNvbnN0IHJ1bkNvZGUgPSAoY29kZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoY29kZSk7XG4gICAgY29uc3QgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoKTtcbiAgICBjb25zdCBhc3QgPSBwYXJzZSh0b2tlbnMpO1xuICAgIGNvbnN0IGRlY29yYXRlZFJlc3VsdCA9IHR5cGVBbmREZWNvcmF0ZShhc3QpO1xuICAgIHJldHVybiBldmFsdWF0b3IuZXZhbHVhdGVQcm9ncmFtKGRlY29yYXRlZFJlc3VsdC5wcm9ncmFtKTtcbiAgfTtcblxuICB0ZXN0LnNraXAoXCJzaG91bGQgaGFuZGxlIHBhcmFtZXRyaWMgQURUIHBhdHRlcm4gbWF0Y2hpbmdcIiwgKCkgPT4ge1xuICAgIC8vIEZJWE1FOiBDdXJyZW50bHkgZmFpbHMgd2l0aCBcIlBhdHRlcm4gZXhwZWN0cyBjb25zdHJ1Y3RvciBidXQgZ290IM6xXCJcbiAgICBjb25zdCBjb2RlID0gYFxuICAgICAgdHlwZSBQb2ludCBhID0gUG9pbnQgYSBhO1xuICAgICAgZ2V0X3ggPSBmbiBwb2ludCA9PiBtYXRjaCBwb2ludCB3aXRoIChQb2ludCB4IHkgPT4geCk7XG4gICAgICBvcmlnaW4gPSBQb2ludCAwIDA7XG4gICAgICBnZXRfeCBvcmlnaW5cbiAgICBgO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJ1bkNvZGUoY29kZSk7XG4gICAgZXhwZWN0KHVud3JhcFZhbHVlKHJlc3VsdC5maW5hbFJlc3VsdCkpLnRvQmUoMCk7XG4gIH0pO1xuXG4gIHRlc3Quc2tpcChcInNob3VsZCBoYW5kbGUgT3B0aW9uIHBhdHRlcm4gbWF0Y2hpbmcgaW4gZnVuY3Rpb25zXCIsICgpID0+IHtcbiAgICAvLyBGSVhNRTogQ3VycmVudGx5IGZhaWxzIHdpdGggXCJQYXR0ZXJuIGV4cGVjdHMgY29uc3RydWN0b3IgYnV0IGdvdCDOsVwiXG4gICAgY29uc3QgY29kZSA9IGBcbiAgICAgIGhhbmRsZV9vcHRpb24gPSBmbiBvcHQgPT4gbWF0Y2ggb3B0IHdpdGggKFxuICAgICAgICBTb21lIHZhbHVlID0+IHZhbHVlICogMjtcbiAgICAgICAgTm9uZSA9PiAwXG4gICAgICApO1xuICAgICAgaGFuZGxlX29wdGlvbiAoU29tZSAyMSlcbiAgICBgO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJ1bkNvZGUoY29kZSk7XG4gICAgZXhwZWN0KHVud3JhcFZhbHVlKHJlc3VsdC5maW5hbFJlc3VsdCkpLnRvQmUoNDIpO1xuICB9KTtcblxuICB0ZXN0LnNraXAoXCJzaG91bGQgaGFuZGxlIFJlc3VsdCBwYXR0ZXJuIG1hdGNoaW5nXCIsICgpID0+IHtcbiAgICAvLyBGSVhNRTogQ3VycmVudGx5IGZhaWxzIHdpdGggXCJQYXR0ZXJuIGV4cGVjdHMgY29uc3RydWN0b3IgYnV0IGdvdCDOsVwiXG4gICAgY29uc3QgY29kZSA9IGBcbiAgICAgIGhhbmRsZV9yZXN1bHQgPSBmbiByZXMgPT4gbWF0Y2ggcmVzIHdpdGggKFxuICAgICAgICBPayB2YWx1ZSA9PiB2YWx1ZSArIDEwO1xuICAgICAgICBFcnIgbXNnID0+IDBcbiAgICAgICk7XG4gICAgICBoYW5kbGVfcmVzdWx0IChPayAzMilcbiAgICBgO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJ1bkNvZGUoY29kZSk7XG4gICAgZXhwZWN0KHVud3JhcFZhbHVlKHJlc3VsdC5maW5hbFJlc3VsdCkpLnRvQmUoNDIpO1xuICB9KTtcblxuICB0ZXN0LnNraXAoXCJzaG91bGQgaGFuZGxlIGNvbXBsZXggU2hhcGUgcGF0dGVybiBtYXRjaGluZ1wiLCAoKSA9PiB7XG4gICAgLy8gRklYTUU6IEN1cnJlbnRseSBmYWlscyB3aXRoIFwiUGF0dGVybiBleHBlY3RzIGNvbnN0cnVjdG9yIGJ1dCBnb3QgzrFcIlxuICAgIGNvbnN0IGNvZGUgPSBgXG4gICAgICB0eXBlIFNoYXBlID0gQ2lyY2xlIE51bWJlciB8IFJlY3RhbmdsZSBOdW1iZXIgTnVtYmVyO1xuICAgICAgY2FsY3VsYXRlX2FyZWEgPSBmbiBzaGFwZSA9PiBtYXRjaCBzaGFwZSB3aXRoIChcbiAgICAgICAgQ2lyY2xlIHJhZGl1cyA9PiByYWRpdXMgKiByYWRpdXMgKiAzO1xuICAgICAgICBSZWN0YW5nbGUgd2lkdGggaGVpZ2h0ID0+IHdpZHRoICogaGVpZ2h0XG4gICAgICApO1xuICAgICAgY2FsY3VsYXRlX2FyZWEgKENpcmNsZSA1KVxuICAgIGA7XG4gICAgY29uc3QgcmVzdWx0ID0gcnVuQ29kZShjb2RlKTtcbiAgICBleHBlY3QodW53cmFwVmFsdWUocmVzdWx0LmZpbmFsUmVzdWx0KSkudG9CZSg3NSk7XG4gIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=