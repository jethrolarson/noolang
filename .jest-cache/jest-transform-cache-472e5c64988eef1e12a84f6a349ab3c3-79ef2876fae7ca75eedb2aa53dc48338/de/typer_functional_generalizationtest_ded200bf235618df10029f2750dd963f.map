{"file":"/workspace/src/typer/__tests__/typer_functional_generalization.test.ts","mappings":"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","names":[],"sources":["/workspace/src/typer/__tests__/typer_functional_generalization.test.ts"],"sourcesContent":["import { describe, it, expect } from '@jest/globals';\nimport { Lexer } from '../../lexer';\nimport { parse } from '../../parser/parser';\nimport { typeProgram } from '../index';\nimport { typeToString } from '../helpers';\n\n// Helper function to parse a string into a program\nconst parseProgram = (source: string) => {\n\tconst lexer = new Lexer(source);\n\tconst tokens = lexer.tokenize();\n\treturn parse(tokens);\n};\n\ndescribe('Functional Typer - Let-Polymorphism', () => {\n\tdescribe('Core Let-Polymorphism', () => {\n\t\tit('should generalize polymorphic identity function', () => {\n\t\t\tconst program = parseProgram('id = fn x => x');\n\t\t\tconst result = typeProgram(program);\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe(\n\t\t\t\t'(α) -> α'\n\t\t\t);\n\t\t});\n\n\t\tit('should allow polymorphic function to be used with different types', () => {\n\t\t\tconst program = parseProgram(`\n        id = fn x => x;\n        num = id 42;\n        str = id \"hello\";\n        bool = id True\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\t// The sequence returns the type of the rightmost expression\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe('Bool');\n\t\t});\n\n\t\tit('should handle higher-order functions with generalization', () => {\n\t\t\tconst program = parseProgram(`\n        apply = fn f x => f x;\n        double = fn x => x * 2;\n        result = apply double 5\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\t// The sequence returns the type of the rightmost expression\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe('Int');\n\t\t});\n\t});\n\n\tdescribe('Let-Polymorphism Edge Cases', () => {\n\t\tit('should handle nested function definitions', () => {\n\t\t\tconst program = parseProgram(`\n        outer = fn x => (\n          inner = fn y => x;\n          inner 42\n        )\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\t// This should work with proper generalization\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe(\n\t\t\t\t'(α) -> α'\n\t\t\t);\n\t\t});\n\n\t\tit('should handle curried polymorphic functions', () => {\n\t\t\tconst program = parseProgram(`\n        add = fn x y => x + y;\n        addFive = add 5;\n        result = addFive 3\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe('Int');\n\t\t});\n\n\t\tit('should handle multiple polymorphic functions in sequence', () => {\n\t\t\tconst program = parseProgram(`\n        id = fn x => x;\n        const = fn x y => x;\n        result1 = id 42;\n        result2 = const \"hello\" 123;\n        result3 = id True\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe('Bool');\n\t\t});\n\t});\n\n\tdescribe('Type Environment Consistency', () => {\n\t\tit('should properly instantiate polymorphic functions in single program', () => {\n\t\t\tconst program = parseProgram(`\n        id = fn x => x;\n        numResult = id 42;\n        strResult = id \"hello\";\n        boolResult = id True;\n        numResult\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe('Int');\n\t\t});\n\n\t\tit('should handle polymorphic function with multiple instantiations', () => {\n\t\t\tconst program = parseProgram(`\n        id = fn x => x;\n        id 42;\n        id \"hello\";\n        id True\n      `);\n\t\t\tconst result = typeProgram(program);\n\t\t\texpect(typeToString(result.type, result.state.substitution)).toBe('Bool');\n\t\t});\n\t});\n});\n"],"version":3}