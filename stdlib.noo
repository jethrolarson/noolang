# Noolang Standard Library
# This file defines the global default environment that's automatically loaded

# ========================================
# TYPE CONSTRAINTS
# ========================================

# Constraint for showing a type
constraint Show a (
  show : a -> String
);

# Constraint for monads
constraint Monad m ( 
  bind a b : m a -> (a -> m b) -> m b; 
  pure a : a -> m a 
);

# Constraint for functors
constraint Functor f ( 
  fmap a b : (a -> b) -> f a -> f b 
);

constraint Eq a ( 
  equals : a -> a -> Bool 
);

constraint Applicative f ( 
  apply : f (a -> b) -> f a -> f b 
);

# ========================================
# UTILITY FUNCTIONS
# ========================================

# Identity function
id = fn x => x;

# ========================================
# CORE ALGEBRAIC DATA TYPES
# ========================================

# ========================================
# BOOLEAN TYPE
# ========================================

type Bool = True | False;

implement Show Bool (
  show = fn b => match b with (
    True => "True";
    False => "False"
  )
);

implement Eq Bool (
  equals = fn a b => match a with (
    True => match b with (True => True; False => False);
    False => match b with (True => False; False => True)
  )
);

# Boolean negation
not = fn b => match b with (True => False; False => True);

# ========================================
# OPTION TYPE
# ========================================

type Option a = Some a | None;

implement Show Option (
  show = fn showElement opt => match opt with (
    Some x => concat "Some(" (concat (showElement x) ")");
    None => "None"
  )
);

option_get_or = fn default opt => match opt with (
  Some value => value;
  None => default
);

# Map over Option (using Monad constraint)
implement Monad Option (
  bind = fn f opt => match opt with (
    Some x => f x;
    None => None
  );
  pure = fn x => Some x
);

implement Functor Option (
  fmap = fn f opt => match opt with (
    Some x => Some (f x);
    None => None
  )
);

implement Eq Option (
  equals = fn opt1 opt2 => match opt1 with (
    Some x => match opt2 with (
      Some y => equals x y;
      None => False
    );
    None => match opt2 with (   
      Some y => False;
      None => True
    )
  )
);

implement Applicative Option (
  apply = fn f opt => match opt with (
    Some x => f x;
    None => None
  )
);

# ========================================
# RESULT TYPE
# ========================================

# Result type for error handling  
type Result a b = Ok a | Err b;

implement Show Result (
  show = fn showOk showErr res => match res with (
    Ok x => concat "Ok(" (concat (showOk x) ")");
    Err e => concat "Err(" (concat (showErr e) ")")
  )
);

# Extract value from Result with default for errors
result_get_or = fn default res => match res with (
  Ok value => value;
  Err error => default
);

# Map over Result value (using Monad constraint) 
implement Monad Result (
  bind = fn f res => match res with (
    Ok x => f x;
    Err e => Err e
  );
  pure = fn x => Ok x
);

implement Functor Result (
  fmap = fn f res => match res with (
    Ok x => Ok (f x);
    Err e => Err e
  )
);

implement Eq Result (
  equals = fn res1 res2 => match res1 with (
    Ok x => match res2 with (
      Ok y => equals x y;
      Err e => False
    );

    Err e => match res2 with (
      Ok y => False;
      Err e => equals e e
    )
  )
);

implement Applicative Result (
  apply = fn f res => match res with (
    Ok x => f x;
    Err e => Err e
  )
);


# ========================================
# LIST OPERATIONS
# ========================================

# Safe head function - returns Option instead of throwing
head = fn list => if (length list) == 0 
  then None 
  else list_get 0 list;

# Join list elements with a separator
# Example: join ", " [1, 2, 3] -> "1, 2, 3"
join = fn separator list =>
  reduce (fn acc x => if acc == "" then x else concat acc (concat separator x)) "" list;

implement Functor List (
  map = fn f list => reduce (fn acc x => append acc [f x]) [] list
);

implement Monad List (
  bind = fn f list => reduce (fn acc x => append acc (f x)) [] list;
  pure = fn x => [x]
);

# ========================================
# Constrint implementations for basic types
# ========================================

implement Show Int (
  show = fn i => toString i
);

implement Show String (
  show = id
);

# Eq-like functions for basic types
implement Eq Int (
  equals = primitive_int_eq
);

implement Eq String (
  equals = primitive_string_eq
);
