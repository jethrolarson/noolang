# Noolang Comprehensive Demo: Core Language Features

# ========================================
# 1. LITERALS AND BASIC TYPES
# ========================================
number_literal = 42;
string_literal = "Hello, Noolang!";
boolean_literal = true;
unit_literal = {};

# ========================================
# 2. FUNCTIONS AND CURRYING
# ========================================
# Basic function
identity = fn x => x;

# Curried function (Haskell-style)
add = fn a => fn b => a + b;
add_ten = add 10;
result = add_ten 5;

# Function with multiple parameters
multiply = fn a b => a * b;
product = multiply 6 7;

# ========================================
# 3. RECURSION (NEW FEATURE!)
# ========================================
# Factorial function
factorial = fn n => if n == 0 then 1 else n * (factorial (n - 1));
fact_5 = factorial 5;

# Fibonacci function
fibonacci = fn n => if n <= 1 then n else (fibonacci (n - 1)) + (fibonacci (n - 2));
fib_10 = fibonacci 10;

# ========================================
# 4. DATA STRUCTURES
# ========================================
# Lists
empty_list = [];
number_list = [1, 2, 3, 4, 5];

# Records (named fields)
person = { @name "Alice", @age 30, @city "Wonderland" };

# Accessor usage
person_name = @name person;    # Get the name field
person_age = person | @age;    # Get the age field using pipe operator

# Tuples (positional fields)
point = {10, 20};

# ========================================
# 5. CONTROL FLOW
# ========================================
# If expressions
is_even = fn n => if (n / 2) * 2 == n then true else false;
even_check = is_even 10;

# ========================================
# 6. OPERATORS AND EXPRESSIONS
# ========================================
# Arithmetic operators
arithmetic_result = 10 + 5 * 2;

# Comparison operators
comparison_result = 5 < 10;

# ========================================
# 7. PIPELINE, THRUSH, AND DOLLAR OPERATORS
# ========================================
# Thrush operator (|) - function application
thrush_result = [1, 2, 3, 4, 5] | map (fn x => x * 2);

# Pipeline operator (|>) - function composition
add_one = fn x => x + 1;
square = fn x => x * x;
composed = add_one |> square;
pipeline_result = 10 | composed;

# Dollar operator ($) - low-precedence function application
# Useful for avoiding parentheses in complex expressions
# Without $ - lots of parentheses needed
complex_without_dollar = map (fn x => x * 2) (filter (fn x => x > 5) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

# With $ - much cleaner and more readable
complex_with_dollar = map (fn x => x * 2) $ filter (fn x => x > 5) $ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

# ========================================
# 8. MUTATION (LOCAL MUTATION)
# ========================================
# Mutable variables
mutation_demo = (
  mut counter = 0;
  mut! counter = counter + 1;
  counter
);

# ========================================
# 9. BUILT-IN FUNCTIONS
# ========================================
# List operations
head_result = head [1, 2, 3, 4, 5];
length_result = length [1, 2, 3, 4, 5];

# Higher-order functions
mapped = map (fn x => x * x) [1, 2, 3, 4, 5];
filtered = filter (fn x => x > 10) mapped;

# ========================================
# 10. TYPE CONSTRAINT SYSTEM (NEW FEATURE!)
# ========================================

# ========================================
# 10.1 BASIC CONSTRAINT SYSTEM
# ========================================

# Built-in functions carry automatic constraints
# head function: (List a) -> a given a is Collection
head_with_constraint = head [1, 2, 3, 4, 5];

# tail function: (List a) -> List a given a is Collection
tail_with_constraint = tail [1, 2, 3, 4, 5];

# length function: (List a) -> Int given a is Collection
length_with_constraint = length [1, 2, 3, 4, 5];

# ========================================
# 10.2 CONSTRAINT PROPAGATION
# ========================================

# Function composition preserves constraints
compose = fn f g => fn x => f (g x);

# head has constraint: a is Collection
# compose preserves this constraint automatically
safeHead = compose head;

# This works because list satisfies Collection constraint
safe_head_result = safeHead [1, 2, 3, 4, 5];

# ========================================
# 10.3 CONSTRAINT VALIDATION
# ========================================

# Records also satisfy Collection constraint
record_person = { @name "Bob", @age 25, @city "Metropolis" };

# Accessors work with any record having the required field
record_name = @name record_person;
record_age = record_person | @age;

# ========================================
# 10.4 LIST OPERATIONS WITH CONSTRAINTS
# ========================================

# All list operations require Collection constraint
numbers_for_constraints = [10, 20, 30, 40, 50];

# These work because Int satisfies Collection constraint
first_number = head numbers_for_constraints;
rest_numbers = tail numbers_for_constraints;
count_numbers = length numbers_for_constraints;

# ========================================
# 10.5 FUNCTION COMPOSITION WITH CONSTRAINTS
# ========================================

# Create safe list operations that preserve constraints
safeTail = compose tail;
safeLength = compose length;

# These work because constraints are preserved through composition
composed_first = safeHead numbers_for_constraints;
composed_rest = safeTail numbers_for_constraints;
composed_count = safeLength numbers_for_constraints;

# ========================================
# 10.6 CONSTRAINT EXAMPLES WITH DIFFERENT TYPES
# ========================================

# String lists work (List String satisfies Collection constraint)
string_list = ["hello", "world", "noolang"];
first_string = head string_list;
string_count = length string_list;

# Record lists work too (Record satisfies Collection)
record_list = [
  { @name "Alice", @age 30 },
  { @name "Bob", @age 25 },
  { @name "Charlie", @age 35 }
];
first_record = head record_list;
record_count = length record_list;

# ========================================
# 11. FINAL DEMONSTRATION
# ========================================
# Showcase all features working together
final_demo = {
  @factorial factorial 5,
  @fibonacci fibonacci 10,
  @person person,
  @mapped mapped,
  @head head_result,
  @constraint_demo {
    @head_with_constraint head_with_constraint,
    @safe_head_result safe_head_result,
    @record_name record_name,
    @first_string first_string,
    @first_record first_record
  }
};

# Final expression to evaluate and return
final_demo 